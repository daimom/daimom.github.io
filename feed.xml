<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:base="https://daimom.vercel.app">
    <title>度估筆記本</title>
    <link href="https://daimom.vercel.app/feed.xml" rel="self" />
    <link href="https://daimom.vercel.app" />
    <updated>2024-02-13T10:18:11Z</updated>
    <id>https://daimom.vercel.app</id>
        <entry>
            <title>
                98. k8s中的command與dockerfile的 CMD
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/Yaml/98. k8s中的command與dockerfile的 CMD/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;忘記是什麼原因，&lt;/p&gt;
&lt;p&gt;讓我跑去查這兩個的差異&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;dockerfile中的指令&lt;/p&gt;
&lt;p&gt;CMD 、 ENTRYPOINT&lt;/p&gt;
&lt;p&gt;k8s 中的yaml 中也有&lt;/p&gt;
&lt;p&gt;command 、args&lt;/p&gt;
&lt;p&gt;先來分辨 CMD 與 ENTRYPOINT的差別&lt;/p&gt;
&lt;h3 id=&quot;cmd&quot; tabindex=&quot;-1&quot;&gt;CMD&lt;/h3&gt;
&lt;p&gt;先上個Dockerfile&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM golang:1.16-alpine AS build-env

CMD [&amp;quot;/bin/sh&amp;quot;,&amp;quot;-c&amp;quot;,&amp;quot;echo $HOME&amp;quot;]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這個build完後，直接執行會顯示 /root，如果用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run golang:1.16 /bin/sh -c &amp;quot;echo $SHELL&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;，會直接執行剛剛的指令。&lt;br /&gt;
原因是，CMD 跟 外面接受的指令會互相覆蓋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/98-fig-1.jpg&quot; alt=&quot;98-fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;entrypoint&quot; tabindex=&quot;-1&quot;&gt;ENTRYPOINT&lt;/h3&gt;
&lt;p&gt;Dockerfile&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM golang:1.16-alpine AS build-env

ENTRYPOINT [&amp;quot;/bin/sh&amp;quot;,&amp;quot;-c&amp;quot;,&amp;quot;echo $HOME&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同樣也直接執行會顯示 /root ，&lt;br /&gt;
如果用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run golang:1.17 /bin/sh -c &amp;quot;echo $SHELL&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;還是顯示 /root&lt;br /&gt;
原因是，使用entrypoint的話，指令不會互相覆蓋。&lt;/p&gt;
&lt;p&gt;反而是被當成參數加在後面。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://myapollo.com.tw/zh-tw/docker-cmd-vs-entrypoint/&quot; title=&quot;Docker CMD 與 ENTRYPOINT 說明詳解&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Docker CMD 與 ENTRYPOINT 說明詳解&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;兩者互動表&quot; tabindex=&quot;-1&quot;&gt;兩者互動表&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;No ENTRYPOINT&lt;/th&gt;
&lt;th&gt;ENTRYPOINT exec_entry p1_entry&lt;/th&gt;
&lt;th&gt;ENTRYPOINT [“exec_entry”, “p1_entry”]&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;No CMD&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;error, not allowed&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;/bin/sh -c exec_entry p1_entry&lt;/td&gt;
&lt;td&gt;exec_entry p1_entry&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;CMD [“exec_cmd”, “p1_cmd”]&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;exec_cmd p1_cmd&lt;/td&gt;
&lt;td&gt;/bin/sh -c exec_entry p1_entry&lt;/td&gt;
&lt;td&gt;exec_entry p1_entry exec_cmd p1_cmd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;CMD exec_cmd p1_cmd&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;/bin/sh -c exec_cmd p1_cmd&lt;/td&gt;
&lt;td&gt;/bin/sh -c exec_entry p1_entry&lt;/td&gt;
&lt;td&gt;exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Understand how CMD and ENTRYPOINT interact&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://myapollo.com.tw/blog/docker-cmd-vs-entrypoint/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Docker CMD 與 ENTRYPOINT 說明詳解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;k8-s-yaml-command&quot; tabindex=&quot;-1&quot;&gt;K8S yaml  command&lt;/h3&gt;
&lt;p&gt;佈署個cronJob來測試&lt;/p&gt;
&lt;p&gt;這次掛載的映像檔是使用 dockerfile『command』的映像檔&lt;br /&gt;
跟上面測試方法一樣，先不加command看結果是什麼&lt;br /&gt;
加了後結果又會是什麼。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;  spec:
    containers:
    - command:
      - /bin/sh
      - -c
      - echo $PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/98-fig.2.jpg&quot; alt=&quot;98-fig.2.jpg&quot; /&gt;&lt;br /&gt;
11:57 那個沒有加command，所以會看到顯示root&lt;br /&gt;
12:03 加了上面的command，指令覆蓋，所以顯示$PATH的內容&lt;/p&gt;
&lt;p&gt;p.s 如果不用command改用args，指令覆蓋。&lt;/p&gt;
&lt;h3 id=&quot;k8-s-yaml-args&quot; tabindex=&quot;-1&quot;&gt;K8S yaml args&lt;/h3&gt;
&lt;p&gt;這次掛載的映像檔是使用 dockerfile『ENTRYPOINT』的映像檔&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;  spec:
    containers:
    - args:
      - /bin/sh
      - -c
      - echo $PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/98-fig.3.jpg&quot; alt=&quot;98-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;13:44 不加任何參數，顯示 /root&lt;br /&gt;
13:45 加了args，還是顯示/root，指令無覆蓋&lt;/p&gt;
&lt;p&gt;args的主要用途是，當dockerfile 為 ENTRYPOINT時，&lt;br /&gt;
使用args會將其視爲參數傳入到image內。&lt;/p&gt;
&lt;p&gt;ps. 如果改使用 command ，則覆蓋&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://kung-fu-master.github.io/2021/03/13/microService/kubernetes/k8s_command_args_entrypoint_cmd%E5%8C%BA%E5%88%AB/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;k8s command, args, entrypoint, cmd 區別&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h3&gt;
&lt;p&gt;Docker&lt;/p&gt;
&lt;p&gt;ENTRYPOINT 主要是將整個container當做可執行檔來用。&lt;br /&gt;
CMD 則比較類似一台VM&lt;/p&gt;
&lt;p&gt;K8S&lt;/p&gt;
&lt;p&gt;command  ： 指令都是覆蓋&lt;br /&gt;
args ： 外加的參數，可與command一起使用，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;  spec:
    containers:
    - args:
      - -a
      command:
      - /bin/sh
      - -c
      - uname
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/Yaml/98. k8s中的command與dockerfile的 CMD/" />
        </entry>
        <entry>
            <title>
                94. k8s 細節補充
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/Yaml/94. k8s 細節補充/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近幫其他組的同事看問題時，&lt;/p&gt;
&lt;p&gt;發現有些東西是我沒看過的，&lt;/p&gt;
&lt;p&gt;就整合再一起，寫起來當備忘拉。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;deployment 的 lifecycle&lt;/p&gt;
&lt;p&gt;postStart 在container創建後，立即發送postStart事件。&lt;br /&gt;
preStop 在 container結束前，立即發送preStop事件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: Pod
metadata:
  name: lifecycle-demo
spec:
  containers:
  - name: lifecycle-demo-container
    image: nginx
    lifecycle:
      postStart:
        exec:
          command: [&amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;echo Hello from the postStart handler &amp;gt; /usr/share/message&amp;quot;]
      preStop:
        exec:
          command: [&amp;quot;/bin/sh&amp;quot;,&amp;quot;-c&amp;quot;,&amp;quot;nginx -s quit; while killall -0 nginx; do sleep 1; done&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://kubernetes.io/zh/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;為容器的生命週期事件設置處理函數&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;pod的終止&lt;br /&gt;
通常情況下，container會發送TERM信號到每個container中，&lt;br /&gt;
當超出了正常終止期限，則會向其他的processor發送KILL信號&lt;br /&gt;
ref. &lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Pod 的終止&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;探針&lt;br /&gt;
livenessProbe ：判斷container是否正常&lt;br /&gt;
readinessProbe：判斷服務是否正常&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;查詢kubectl resouce 簡寫&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubectl api-resources
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;類似下列資源都可用縮寫&lt;br /&gt;
configmap = cm&lt;br /&gt;
deployment=deploy&lt;br /&gt;
pod = po&lt;br /&gt;
persistentvolumeclaims = pvc&lt;/p&gt;
&lt;p&gt;ref .&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10236404&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;【從題目中學習k8s】-【Day8】K8s常用指令 (Cheat Sheet)&amp;amp;解題技巧&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;k8s的 command ，bash -c 意思&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;        command: [&amp;quot;/bin/bash&amp;quot;,&amp;quot;-c&amp;quot;]
        args: [ &amp;quot;service cron start; while true; do sleep 30; done;&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很常看到 bash -c ，這個表示從後面的字串中 讀取命令來使用。&lt;/p&gt;
&lt;p&gt;ps. bash 跟 sh 不一樣，sh通常是指dash。&lt;br /&gt;
可用下列指令，查看目前使用的shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo $SHELL
or
ls -l /bin/sh

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;ref-br-a-href-https-www-computerhope-com-unix-ubash-htm-target-blank-class-external-link-the-bash-shell-a-br-a-href-https-www-wongwonggoods-com-linux-bin-bash-bin-sh-target-blank-class-external-link-bash-bin-bash-bin-sh-script-sh-bash-a&quot; tabindex=&quot;-1&quot;&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://www.computerhope.com/unix/ubash.htm&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;The bash shell&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://www.wongwonggoods.com/linux/bin-bash-bin-sh/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;【Bash】什麼是 #!/bin/bash, #!/bin/sh，為什麼要加在 script 前面 (問題解決：sh, bash 的不同)&lt;/a&gt;&lt;/h2&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;使用指令建立基本的 yaml&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubectl run nginx-kusc00101 --image=nginx --restart=Never --dry-run=client -o yaml&amp;gt; q1.pod
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有基本指令後再去裡面修修改改。&lt;/p&gt;
&lt;p&gt;如果要直接取得現有的yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   kubectl get deploy  yiyuan-landingpage-qa -n istio-yiyuan -o yaml &amp;gt; yiyuan.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/Yaml/94. k8s 細節補充/" />
        </entry>
        <entry>
            <title>
                87.kustomize 共用label(optional）
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/Yaml/87.kustomize 共用label(optional）/</id>
            <content type="html">
                &lt;h2 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;要把別人寫的yaml拆開，然後整併到自己的image，&lt;br /&gt;
才發現service的 base 怎麼沒寫selector ，&lt;br /&gt;
但佈署時卻有mapping到。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;原因在kustomize的 共用屬性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;commonLabels:
  app: token-proxy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這個會自動在各個resource上面增加label，&lt;br /&gt;
如果這邊拔掉的話，&lt;br /&gt;
需要在Deployment以及service上面增加label。&lt;/p&gt;
&lt;p&gt;但在一些文章也有人討論到這個問題，&lt;br /&gt;
如果我不要讓他強制增加的話，&lt;br /&gt;
該怎麼做？&lt;/p&gt;
&lt;p&gt;kustomize有新的參數可供設定(1)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;commonLabels:
- path: metadata/labels
  create: true

- path: spec/selector
  create: true
  version: v1
  kind: Service

- path: spec/selector/matchLabels
  create: true
  kind: Deployment
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，還有 下列新增的可供參考。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;annotations&lt;/li&gt;
&lt;li&gt;images&lt;/li&gt;
&lt;li&gt;labels&lt;/li&gt;
&lt;li&gt;name reference&lt;/li&gt;
&lt;li&gt;namespace&lt;/li&gt;
&lt;li&gt;prefix/suffix&lt;/li&gt;
&lt;li&gt;variable reference&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;br /&gt;
1 .&lt;a href=&quot;https://github.com/kubernetes-sigs/kustomize/tree/master/examples/transformerconfigs#labels-transformer&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;transformerconfigs&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/Yaml/87.kustomize 共用label(optional）/" />
        </entry>
        <entry>
            <title>
                85. gke-cronjob筆記
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/Yaml/85. gke-cronjob筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;之前同事是直接自己土炮用golang寫timer，&lt;br /&gt;
不過如果碰到執行時間過長，重複執行的話，&lt;br /&gt;
就要判斷一堆狀態，決定要不要做，&lt;br /&gt;
那就改用k8s的cronJob了吧。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;文件看一看(1) (2)，好像就差不多了。&lt;br /&gt;
下面是測試，每兩分鐘執行一次，&lt;br /&gt;
但如果執行時間過長，是不是會在執行。&lt;br /&gt;
這邊關掉的是併發以及 暫停後續執行，&lt;br /&gt;
另外注意，gcp的cronjob是每10秒檢查一次狀態。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: batch/v1beta1     # k8s after version 1.21 ,apiVersion: batch/v1
kind: CronJob
metadata:
  name: hello
spec:
  schedule: &amp;quot;*/2 * * * *&amp;quot;             # min hour day Mon week
  concurrencyPolicy: Forbid           # 並發政策 
  startingDeadlineSeconds: 60        # 截止時限
  suspend: true                       # 暫停後續執行
  successfulJobsHistoryLimit: 3       # 歷史限制: 保存成功的數量
  failedJobsHistoryLimit: 1           # 歷史限制： 保存失敗的數量
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: hello
            image: busybox
            args:
            - /bin/sh
            - -c
            - echo &amp;quot;start&amp;quot;; date; echo &amp;quot;Hello, World! Sleep 150s&amp;quot;; sleep 150s; date;
          restartPolicy: OnFailure
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
1.  &lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/cronjobs&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GCP-CronJob&lt;/a&gt;&lt;br /&gt;
2. &lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/workloads/controllers/cron-jobs/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;k8s-CronJob&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/Yaml/85. gke-cronjob筆記/" />
        </entry>
        <entry>
            <title>
                74. kubernetes 批次檢查yaml特定字元
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/Yaml/74. kubernetes 批次檢查yaml特定字元/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;因為dockershim的問題，&lt;br /&gt;
這次要搬cluster的node了。&lt;br /&gt;
但我根本忘記有哪個yaml有寫到 nodeSelector了，&lt;br /&gt;
一個一個看又好懶...怎麼辦？&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;想起來之前在檢查  docker.sock的時候，有用指令檢查過這個yaml (1)裡面，&lt;br /&gt;
有沒有 /docker.sock&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get pods --all-namespaces &#92;
-o=jsonpath=&#39;{range .items[*]}{&amp;quot;&#92;n&amp;quot;}{.metadata.namespace}{&amp;quot;:&#92;t&amp;quot;}{.metadata.name}{&amp;quot;:&#92;t&amp;quot;}{range .spec.volumes[*]}{.hostPath.path}{&amp;quot;, &amp;quot;}{end}{end}&#39; &#92;
| sort &#92;
| grep &#39;/var/run/docker.sock&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這段最後面兩個就不用看了，sort 跟 grep 是 linux的指令。&lt;/p&gt;
&lt;p&gt;主要針對 -o jsonpath 來看，詳細指令　 參考(2)&lt;/p&gt;
&lt;p&gt;當要取得複數資料時，用 range 來取資料。&lt;br /&gt;
然後...參考 pod的yaml看要取得哪些欄位來用吧。&lt;/p&gt;
&lt;p&gt;下面範例為取得 全部的 nodeSelectord&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get pods -A　 &#92;
-o=jsonpath=&#39;{range .items[*]}{&amp;quot;&#92;n&amp;quot;}{.metadata.namespace}{&amp;quot;:&#92;t&amp;quot;}{.metadata.name}{&amp;quot;:&#92;t&amp;quot;}{.spec.nodeSelector}{end}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/Yaml/74-fig.1.jpg&quot; alt=&quot;74-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;再排序一下，就可以很快的知道有哪些yaml有用到 nodeSelector了。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
1. &lt;a href=&quot;https://kubernetes.io/zh/docs/tasks/administer-cluster/migrating-from-dockershim/migrating-telemetry-and-security-agents/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;從 dockershim 遷移遙測和安全代理&lt;/a&gt;&lt;br /&gt;
2. &lt;a href=&quot;http://kubernetes.kansea.com/docs/user-guide/jsonpath/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;JSONpath 幫助&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/Yaml/74. kubernetes 批次檢查yaml特定字元/" />
        </entry>
        <entry>
            <title>
                2. k8s yaml撰寫 volume 踩坑篇
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/Yaml/2. k8s yaml撰寫 volume 踩坑篇/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;昨天接到一個任務，要把一個純html，放到nginx上面。&lt;br /&gt;
然後就開始踩坑之旅了&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;這邊寫的都是GKE 的佈署方式，&lt;br /&gt;
關於GKE  文章實在太多了，我也不知道何年何月何日才有那個技術存量可以把它寫成文章。&lt;/p&gt;
&lt;p&gt;目前使用的是 kustomize的方式佈署網站，&lt;br /&gt;
目前也在架設drone，日後走的是自動佈署，&lt;br /&gt;
但是第一次佈署還是要自己來的。&lt;/p&gt;
&lt;p&gt;基本的流程是，將網頁包成一個 docker image，&lt;br /&gt;
(不論是php 或是 html， Go 則是本身有服務可以掛載，比較簡單點。)&lt;br /&gt;
再將此image設定成 initContainers ，&lt;br /&gt;
將此image的資料夾，掛載成volume，讓nginx可以直接掛載此資料夾。&lt;/p&gt;
&lt;p&gt;這次踩的坑有兩個，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;網站程式，是別人傳給我的，所以檔案權限，everyone都是 無法存取。&lt;br /&gt;
所以要把裡面的所有檔案改成 755 rwxr-xr-x ，nginx圖片才能夠讀取。&lt;br /&gt;
我懶的一個一個改，所以下指令一次把整個資料夾內容都改掉，當初安全點是設定777&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;chmod -R 755 resource
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(ref. &lt;a href=&quot;https://www.jianshu.com/p/6c52260b1ff3&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://www.jianshu.com/p/6c52260b1ff3&lt;/a&gt;)&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;在寫yaml的時候，沒有搞清楚 volume的用途&lt;br /&gt;
導致一直出現rsync的錯誤。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;initContainers:
- command:
  - sh
  - -c
  - |
    rsync -avrh --delete /source/* /app
  image: gcr.io/project/busybox-web:v2.7
  imagePullPolicy: Always
  name: source
  volumeMounts:
  - mountPath: /app
    name: source
volumes:
- emptyDir: {}
  name: source
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;volumeMounts: 這段的意思是 定義一個叫 soure的新磁區，掛載在 busybox-web容器裡的 /app 的path上面。&lt;br /&gt;
volumes: 的意思是定義磁碟區，emptyDir是伴隨著pod的生命，當pod消失資料也會跟著消失&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;nginx.conf 改完後，要重啟pod ，因為nginx.conf 是寫在 k8s的 configMapGenerator，&lt;br /&gt;
所以更改裡面的設定後，不會重啟pod ，裡面的服務就不會重新抓取conf。&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/Yaml/2. k8s yaml撰寫 volume 踩坑篇/" />
        </entry>
        <entry>
            <title>
                136. 一步步篩選k8s的deploy內容
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/Yaml/136. 一步步篩選k8s的deploy內容/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;要抓一下，目前ingress裏面的所有白名單資訊，&lt;br /&gt;
但一個一個開起來看又很麻煩，&lt;br /&gt;
就寫code filter吧&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;先取得json，先指定一個服務，不然會太亂&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubectl get ingress websocketclient -o json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/Yaml/136-fig.1.jpg&quot; alt=&quot;136-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;然後開始看json 格式開始拆解，這次目的是要取得&lt;br /&gt;
&lt;code&gt;nginx.ingress.kubernetes.io/whitelist-source-range&lt;/code&gt;的值，&lt;br /&gt;
這邊會碰到一個問題，因為有特殊符號 . 跟 / ，所以要用 &#92; ，將它視爲一個整體。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubectl get ingress -n default -o=jsonpath=&#39;{range .items[*]}{&amp;quot;&#92;n&amp;quot;}{.metadata.name}{&amp;quot;&#92;t&amp;quot;}{.metadata.annotations.nginx&#92;.ingress&#92;.kubernetes&#92;.io&#92;/whitelist-source-range}{end}&#39; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/Yaml/136-fig.2.jpg&quot; alt=&quot;136-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/reference/kubectl/jsonpath/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;JSONPath Support&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/64014047/extract-information-of-kubernetes-annotations-with-jsonpath&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Extract information of kubernetes annotations with jsonpath&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/Yaml/136. 一步步篩選k8s的deploy內容/" />
        </entry>
        <entry>
            <title>
                12. k8s YAML 小細節
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/Yaml/12. k8s YAML 小細節/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近寫yaml，有時常會忘記這個的功能是什麼，就記一下吧&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Service 的Port功能&lt;br /&gt;
Port exposes the Kubernetes service on the specified port within the cluster. Other pods within the cluster can communicate with this server on the specified port.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;TargetPort is the port on which the service will send requests to, that your pod will be listening on. Your application in the container will need to be listening on this port also.&lt;/p&gt;
&lt;p&gt;NodePort exposes a service externally to the cluster by means of the target nodes IP address and the NodePort. NodePort is the default setting if the port field is not specified.&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;探針檢查&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;livenessProbe:
  initialDelaySeconds: 10
  periodSeconds: 10
  successThreshold: 1
  failureThreshold: 3
  tcpSocket:
    port: 80
readinessProbe:
  initialDelaySeconds: 30
  periodSeconds: 10
  successThreshold: 1
  failureThreshold: 3
  tcpSocket:
    port: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;pull image 認證&lt;br /&gt;
如果要佈署的image是屬於 私密的，&lt;br /&gt;
需要加上&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;imagePullSecrets:
  - name: regcred
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要先注入Secred&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl create secret generic regcred --from-file=./username.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Service 服務類型&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ClusterIP
&lt;ul&gt;
&lt;li&gt;一個集群內的服務，集群內的其它應用都可以訪問該服務。集群外部無法訪問它。 這也是默認的 ServiceType。&lt;/li&gt;
&lt;li&gt;可以使用proxy 的本機 port轉移，來訪問服務。像 (Fig.1)&lt;br /&gt;
[[12.fig-1.jpg]]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NodePort
&lt;ul&gt;
&lt;li&gt;在所有節點（虛擬機）上開放一個特定端口，任何發送到該端口的流量都被轉發到對應服務。&lt;/li&gt;
&lt;li&gt;在 1 的service port，就是指這個部分。&lt;/li&gt;
&lt;li&gt;需使用K8s的叢集主機加上port，去訪問服務。 (Fig.2)&lt;br /&gt;
[[12.fig-2.jpg]]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LoadBalancer
&lt;ul&gt;
&lt;li&gt;LoadBalancer 服務是暴露服務到 internet 的標準方式。在 GKE 上，這種方式會啟動一個 Network Load Balancer，它將給你一個單獨的 IP 地址，轉發所有流量到你的服務。&lt;/li&gt;
&lt;li&gt;一個外部ip，直接訪問即可，有時需注意防火牆有沒有擋住。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;http://dockone.io/article/4884&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes的三種外部訪問方式：NodePort、LoadBalancer 和 Ingress&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/services-networking/service/#nodeport&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes 服務&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;kube dns&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;pod-dns-record&quot; tabindex=&quot;-1&quot;&gt;Pod DNS record&lt;/h3&gt;
&lt;p&gt;[[12.fig-3.jpg]]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  172-17-0-6.default.pod.cluster.local
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;172-17-0-6: Pod IP&lt;/li&gt;
&lt;li&gt;default: Namespace Name&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;service-dns-record&quot; tabindex=&quot;-1&quot;&gt;Service DNS record&lt;/h3&gt;
&lt;p&gt;[[12.fig-4.jpg]]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  nginx.default.svc.cluster.local
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;nginx: Service Name&lt;/li&gt;
&lt;li&gt;default:  Namespace Name&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;service-discovery&quot; tabindex=&quot;-1&quot;&gt;Service Discovery&lt;/h3&gt;
&lt;p&gt;[[12.fig-5.jpg]]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  web-0.nginx.default.svc.cluster.local
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;web-0: Pod Name&lt;/li&gt;
&lt;li&gt;nginx: Service Name&lt;/li&gt;
&lt;li&gt;default: Namespace Name&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Auto Scaling（自動擴展）&lt;br /&gt;
在Auto Scaling 裡面，有一個設定是根據cpu的使用量大小去增加Pod，&lt;br /&gt;
假設&lt;br /&gt;
targetCPUUtilizationPercentage:10&lt;br /&gt;
在deploy 裡的request CPU 設定 200m&lt;br /&gt;
表示，當cpu的使用率在 20m(200m * 10% = 20m )時，會自動擴展&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果要使用其他的指標，api 需改用 autoscaling/v2beta2&lt;br /&gt;
這邊還沒測試過，有需要的可至相關網頁查詢&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://medium.com/andy-blog/kubernetes-%E9%82%A3%E4%BA%9B%E4%BA%8B-auto-scaling-7b887f61fdec&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes 那些事 — Auto Scaling&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.mdeditor.tw/pl/p7hU/zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes--k8s--進階--全面瞭解HPA--部署HPA實現高可用和成本控制&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.openshift.com/blog/kubernetes-1-8-now-custom-metrics&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes 1.8: Now with 100% Daily Value of Custom Metrics&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/Yaml/12. k8s YAML 小細節/" />
        </entry>
        <entry>
            <title>
                82. Terraform vs Ansible
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/Terraform/82. Terraform vs Ansible/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;本來想直接用表格闡述兩邊不同的地方，&lt;br /&gt;
但發現我不知道從何下手。&lt;br /&gt;
只好先用條列代替了，&lt;br /&gt;
這兩套我都沒用過，因為...我直接從GKE開始XD。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;Terraform&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;聲明性代碼：程式碼的結果就是最終狀態&lt;/li&gt;
&lt;li&gt;協作(Orchestration)：確保環境持續處於『理想狀態』，當服務不能用時，會砍掉重建。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ansible&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程式性代碼：每一次的狀態都是獨立的&lt;/li&gt;
&lt;li&gt;配置管理工具(Configuration Management)： 是一套流程和程序，執行時不會重置系統，會在機器上修復問題或升級服務。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h2&gt;
&lt;p&gt;目前看起來，&lt;/p&gt;
&lt;p&gt;Ansible主要偏向自動化管理工具但同時具備一定程度上的環境　建立。&lt;/p&gt;
&lt;p&gt;Terraform 就是單純的  環境建立工具&lt;/p&gt;
&lt;p&gt;如果走向k8s服務的話，學TerraForm就好了。&lt;br /&gt;
用來建立cluster、loadbalancer...。&lt;br /&gt;
由於 k8s的服務都已經容器化了，使用Ansible也沒什麼意義，&lt;br /&gt;
重開服務又消失了。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://linuxhandbook.com/terraform-vs-ansible/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Terraform vs Ansible: What&#39;s the difference and which one you should use?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.lsbin.com/13252.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Ansible vs Terraform vs Puppet差異比較：有什麼區別？選擇哪個？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/gemini-open-cloud/%E6%9E%B6%E6%A7%8B%E7%A8%8B%E5%BC%8F%E7%A2%BC-iii-devops-%E5%AF%A6%E6%96%BD%E5%B7%A5%E5%85%B7-873301f662e7&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;架構程式碼的實施工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/6844903908213522445&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [DevOps系列] 為什麼我們使用Terraform 而不使用Puppet, Ansible&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://spacelift.io/blog/ansible-vs-terraform&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Terraform vs. Ansible : Key Differences and Comparison of Tools&lt;/a&gt;，感覺這篇寫的最好，但結論就...&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/Terraform/82. Terraform vs Ansible/" />
        </entry>
        <entry>
            <title>
                183. Terrafrom 建立private cluster
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/Terraform/183. Terrafrom 建立private cluster/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;要重建一個新的project，然後把舊的服務搬過去。&lt;br /&gt;
初步估計就一堆東西，正好拿來練一下terraform了&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;服務列表&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Create Project&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Create Cluster&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Create VPC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Create CLoudSQL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Create Memorystore&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Create CloudStorage&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Copy file to CloudStorage&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;後端修改config&amp;amp;publish&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Creaet RabbitMQ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Create Nginx ingress&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;前端服務部署&amp;amp;測試&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;後端服務部署&amp;amp;測試&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Network policy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Obserbility service&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EFK logs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;前後端 CI/CD 修改 &amp;amp; IAM權限&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Project沒辦法用terraform，因爲那不是我操作的。&lt;br /&gt;
也不知道那個能不能用terraform 。&lt;/p&gt;
&lt;p&gt;這篇會建立一個bucket、vpc 、private cluster以及cloud NAT。&lt;br /&gt;
下面會用tf 來稱呼terraform&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立bucket&lt;br /&gt;
因爲狀態關係，就乾脆用gcs統一狀態了，可參考&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Terraform/148.%20Terraform%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/&quot;&gt;148. Terraform的基本概念&lt;/a&gt;&lt;br /&gt;
&lt;code&gt;new&#92;gcs&#92;main.tf&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;terraform {
  required_providers {
    google = {
      source = &amp;quot;hashicorp/google&amp;quot;
      version = &amp;quot;4.63.1&amp;quot;
    }
  }
}

provider &amp;quot;google&amp;quot; {
  project = &amp;quot;ezio-sms-o&amp;quot;
}


resource &amp;quot;random_id&amp;quot; &amp;quot;bucket_prefix&amp;quot; {
  byte_length = 3
}

resource &amp;quot;google_storage_bucket&amp;quot; &amp;quot;tfstate_bucket&amp;quot; {
  name          = &amp;quot;${random_id.bucket_prefix.hex}-terraform-devops&amp;quot;
  force_destroy = false
  location      = &amp;quot;asia-east1&amp;quot;
  storage_class = &amp;quot;Nearline&amp;quot;
  
  //物件版本管理
  versioning {  
    enabled = false
  }
}

output &amp;quot;bucket_name&amp;quot;{
  description = &amp;quot;get bucket name&amp;quot;
  value = google_storage_bucket.tfstate_bucket.name
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;記下bucket name與預計要用的前綴，然後寫在backend.hcl，&lt;br /&gt;
等等下面會用到。&lt;br /&gt;
&lt;code&gt;new&#92;backend.hcl&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   bucket  = &amp;quot;cb0392-terraform-devops&amp;quot;
   prefix  = &amp;quot;terraform/state&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;建vpc 與cloudNAT&lt;br /&gt;
&lt;code&gt;new&#92;gke&#92;main.tf&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;terraform {
  required_providers {
    google = {
      source  = &amp;quot;hashicorp/google&amp;quot;
      version = &amp;quot;5.4.0&amp;quot;
    }
  }
  backend &amp;quot;gcs&amp;quot; {

  }
}

provider &amp;quot;google&amp;quot; {
  project = &amp;quot;ezio-sms-o&amp;quot;
  zone    = &amp;quot;asia-east1-b&amp;quot;
}

# VPC
resource &amp;quot;google_compute_network&amp;quot; &amp;quot;basic&amp;quot; {
  name                            = &amp;quot;basic&amp;quot;
  auto_create_subnetworks         = false
  # delete_default_routes_on_create = false
  routing_mode                    = &amp;quot;REGIONAL&amp;quot;
}

resource &amp;quot;google_compute_subnetwork&amp;quot; &amp;quot;basic&amp;quot; {
  name                     = &amp;quot;basic-subnet&amp;quot;
  ip_cidr_range            = var.subnet_cidr
  region                   = var.gcp_region
  network                  = google_compute_network.basic.id
  private_ip_google_access = true

  secondary_ip_range {
    range_name    = &amp;quot;gke-pod-range&amp;quot;
    ip_cidr_range = var.pod_cidr
  }
  secondary_ip_range {
    range_name    = &amp;quot;gke-service-range&amp;quot;
    ip_cidr_range = var.service_cidr
  }
}

# Cloud NAT
resource &amp;quot;google_compute_router&amp;quot; &amp;quot;default_cloudnat&amp;quot; {
  name    = &amp;quot;default-nat&amp;quot;
  region  = var.gcp_region
  network = google_compute_network.basic.id
}

resource &amp;quot;google_compute_router_nat&amp;quot; &amp;quot;default_cloudnat&amp;quot; {
  name   = &amp;quot;nat&amp;quot;
  router = google_compute_router.default_cloudnat.name
  region = var.gcp_region

  source_subnetwork_ip_ranges_to_nat = &amp;quot;LIST_OF_SUBNETWORKS&amp;quot;
  nat_ip_allocate_option             = &amp;quot;MANUAL_ONLY&amp;quot;

  subnetwork {
    name                    = google_compute_subnetwork.basic.id
    source_ip_ranges_to_nat = [&amp;quot;ALL_IP_RANGES&amp;quot;]
  }

  nat_ips = [google_compute_address.nat.self_link]
}

resource &amp;quot;google_compute_address&amp;quot; &amp;quot;nat&amp;quot; {
  name         = &amp;quot;nat&amp;quot;
  address_type = &amp;quot;EXTERNAL&amp;quot;
  network_tier = &amp;quot;PREMIUM&amp;quot;
  region       = var.gcp_region

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;變數的設定，也請參考&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Terraform/148.%20Terraform%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/&quot;&gt;148. Terraform的基本概念&lt;/a&gt;&lt;br /&gt;
&lt;code&gt;new&#92;gke&#92;terraform.tf&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;variable &amp;quot;project_id&amp;quot; {
  default = &amp;quot;ezio-sms-o&amp;quot;
}
variable &amp;quot;gcp_region&amp;quot; {
  default = &amp;quot;asia-east1&amp;quot;
}
variable &amp;quot;gcp_zone&amp;quot; {
  type    = list(string)
  default = [&amp;quot;asia-east1-b&amp;quot;]
}
variable &amp;quot;gke_name&amp;quot; {
  default = &amp;quot;fixed&amp;quot;
}

variable &amp;quot;subnet_cidr&amp;quot; {
  default = &amp;quot;10.10.0.0/16&amp;quot;
}

variable &amp;quot;pod_cidr&amp;quot; {
  default = &amp;quot;192.168.8.0/21&amp;quot;
}

variable &amp;quot;service_cidr&amp;quot; {
  default = &amp;quot;192.168.16.0/21&amp;quot;
}

variable &amp;quot;master_cidr&amp;quot; {
  default = &amp;quot;10.0.2.0/28&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://alanzhan.dev/post/2023-03-12-terraform-private-gke/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;透過 Terraform 建立私有 GKE Cluster&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cloudskillsboost.google/focuses/15842?locale=zh_TW&amp;amp;parent=catalog&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;# 使用基礎架構即程式碼工具 Terraform&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_network&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;google_compute_network&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;建立GKE&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這部分算是查最久的，用到了terraform的module概念。&lt;br /&gt;
可以先看這篇 &lt;a href=&quot;https://godleon.github.io/blog/DevOps/terraform-getting-started/#%E4%BD%BF%E7%94%A8-module&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Terraform] 入門學習筆記&lt;/a&gt;，瞭解一下什麼是module。&lt;/p&gt;
&lt;p&gt;然後再來就是看官方文件了。&lt;br /&gt;
&lt;code&gt;new&#92;gke&#92;main.tf&lt;/code&gt;&lt;br /&gt;
沒錯跟上面vpc的檔案一樣，因爲是同一份文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# GKE
module &amp;quot;gke&amp;quot; {
  source  = &amp;quot;terraform-google-modules/kubernetes-engine/google//modules/private-cluster&amp;quot;
  version = &amp;quot;29.0.0&amp;quot;
  project_id                 = var.project_id
  name                       = var.gke_name
  # 區域性
  regional                   = false
  region                     = var.gcp_region
  zones                      = var.gcp_zone
  network                    = google_compute_network.basic.name
  subnetwork                 = google_compute_subnetwork.basic.name
  ip_range_pods              = google_compute_subnetwork.basic.secondary_ip_range[0].range_name
  ip_range_services          = google_compute_subnetwork.basic.secondary_ip_range[1].range_name
  http_load_balancing        = true
  network_policy             = false
  horizontal_pod_autoscaling = true
  filestore_csi_driver       = false
  # private cluster
  enable_private_endpoint    = false
  enable_private_nodes       = true
  master_global_access_enabled  = false
  master_ipv4_cidr_block     = &amp;quot;10.0.0.0/28&amp;quot;
  # gke version
  release_channel            = &amp;quot;UNSPECIFIED&amp;quot;
  remove_default_node_pool   = true
  # log record
  logging_enabled_components = [&amp;quot;SYSTEM_COMPONENTS&amp;quot;]
  create_service_account     = false

  node_pools = [
    {
      autoscaling               = false
      node_count                = 2
      name                      = &amp;quot;default-node-pool&amp;quot;
      machine_type              = &amp;quot;e2-custom-4-12288&amp;quot;
      local_ssd_count           = 0
      spot                      = false
      disk_size_gb              = 100
      disk_type                 = &amp;quot;pd-standard&amp;quot;
      image_type                = &amp;quot;COS_CONTAINERD&amp;quot;
      enable_gcfs               = false
      enable_gvnic              = false
      logging_variant           = &amp;quot;DEFAULT&amp;quot;
      auto_repair               = true
      auto_upgrade              = false
      preemptible               = false
      initial_node_count        = 80
    },
  ]

  node_pools_oauth_scopes = {
    all = [
		&amp;quot;https://www.googleapis.com/auth/logging.write&amp;quot;,
		&amp;quot;https://www.googleapis.com/auth/monitoring&amp;quot;,
		&amp;quot;https://www.googleapis.com/auth/devstorage.read_only&amp;quot;,
		&amp;quot;https://www.googleapis.com/auth/service.management.readonly&amp;quot;,
		&amp;quot;https://www.googleapis.com/auth/servicecontrol&amp;quot;,
		&amp;quot;https://www.googleapis.com/auth/trace.append&amp;quot;
    ]
  }

  node_pools_labels = {
    all = {}

    default-node-pool = {
      default-node-pool = true
    }
  }

  node_pools_metadata = {
    all = {}

    default-node-pool = {
      node-pool-metadata-custom-value = &amp;quot;fixed-node-pool&amp;quot;
    }
  }

  node_pools_taints = {
    all = []

    default-node-pool = [
      {
        key    = &amp;quot;default-node-pool&amp;quot;
        value  = true
        effect = &amp;quot;PREFER_NO_SCHEDULE&amp;quot;
      },
    ]
  }

  node_pools_tags = {
    all = []

    default-node-pool = [
      &amp;quot;default-node-pool&amp;quot;,
    ]
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;簡單說一下module的用法，&lt;br /&gt;
當第一次用module時，需要初始化，加上指定gcs儲存tfstat&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tf init -backend-config=../backend.hcl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之後要使用submodule的話，不用再初始化，只要get&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tf get
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要建立private cluster的話，需要使用submodule，&lt;br /&gt;
可從&lt;a href=&quot;https://registry.terraform.io/modules/terraform-google-modules/kubernetes-engine/google/latest?tab=inputs&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kubernetes-engine&lt;/a&gt; 到 submodule的 &lt;a href=&quot;https://registry.terraform.io/modules/terraform-google-modules/kubernetes-engine/google/latest/submodules/private-cluster?tab=inputs&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;private-cluster&lt;/a&gt;，&lt;/p&gt;
&lt;p&gt;有些參數不知道是建立GKE的哪個設定，&lt;br /&gt;
可以多利用&lt;code&gt;tf validate&lt;/code&gt; 驗證，&lt;br /&gt;
但有時是部署時才會發生錯誤。&lt;br /&gt;
我後來是直接手動把cluster砍掉，再&lt;code&gt;tf apply&lt;/code&gt;比較快。&lt;/p&gt;
&lt;p&gt;本來也有想過不要用module，直接實作。&lt;br /&gt;
但看了官方文件&lt;a href=&quot;https://registry.terraform.io/providers/hashicorp/google/latest/docs/guides/using_gke_with_terraform&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; Using GKE with Terraform&lt;/a&gt;，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Additionally, you may consider using Google&#39;s &lt;a href=&quot;https://registry.terraform.io/modules/terraform-google-modules/kubernetes-engine/google&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;&lt;code&gt;kubernetes-engine&lt;/code&gt;&lt;/a&gt; module, which implements many of these practices for you&lt;br /&gt;
就試試看了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意，submodule與主要module的source不一樣，有些參數在主module是沒有的。&lt;/p&gt;
&lt;h4 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h4&gt;
&lt;p&gt;部署GKE時，發現我沒辦法從Google Artifact Registry 下載image。&lt;br /&gt;
最後發現是 沒有設定 存取權範圍，&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/access-scopes&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Access scopes in GKE&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/Terraform/183-fig.1.jpg&quot; alt=&quot;183-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;這個需要在 &lt;code&gt;node_pools_oauth_scopes&lt;/code&gt; 裏面補上允許的api網址。&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/Terraform/183. Terrafrom 建立private cluster/" />
        </entry>
        <entry>
            <title>
                149. terraform 部署VM，啓動docker安裝metadata_startup_script
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/Terraform/149. terraform 部署VM，啓動docker安裝metadata_startup_script/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;由於前人弄向Let&#39;s encrypt 申請的ssl憑證，偶爾會出問題，&lt;br /&gt;
步驟繁瑣，常常改了這個，忘記要重啓那個，那就重新做一套吧。&lt;br /&gt;
為了我想偷懶..(^__^)&lt;br /&gt;
但在那之前，先生個機器來測試看看。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;第一次用terraform部署vm機器，&lt;br /&gt;
這邊要注意的是 backend &amp;quot;gcs&amp;quot;，&lt;br /&gt;
我直接將tfstate傳到gcs上面了，可以參考上一篇&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Terraform/148.%20Terraform%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/&quot;&gt;148. Terraform的基本概念&lt;/a&gt;。&lt;br /&gt;
底下的metadata_startup_script，&lt;br /&gt;
指令很長，導致我不想放在同一行，&lt;br /&gt;
跑去問了下chatGPT，能使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;&amp;lt;-EOT
 EOT
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這種方式將程式碼包在一起，就比較方便閱讀了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    terraform {
      required_providers {
        google = {
          source = &amp;quot;hashicorp/google&amp;quot;
          version = &amp;quot;4.63.1&amp;quot;
        }
      }
      backend &amp;quot;gcs&amp;quot; {

      }
    }
    
    provider &amp;quot;google&amp;quot; {
      project = &amp;quot;abc&amp;quot;
    }

    resource &amp;quot;google_compute_instance&amp;quot; &amp;quot;certificate-vm&amp;quot; {
      name         = &amp;quot;ca-service&amp;quot;
      machine_type = &amp;quot;f1-micro&amp;quot;
      zone         = &amp;quot;asia-east1-b&amp;quot;
      tags         = [&amp;quot;allow-admin-ip&amp;quot;]

      boot_disk {
        initialize_params {
          image = &amp;quot;debian-cloud/debian-11&amp;quot;
        }
      }

      # Install Docker
      metadata_startup_script = &amp;lt;&amp;lt;-EOT
        sudo apt-get update; sudo apt-get install ca-certificates curl gnupg; 
        sudo install -m 0755 -d /etc/apt/keyrings; 
        curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg; 
        sudo chmod a+r /etc/apt/keyrings/docker.gpg; 
        echo &amp;quot;deb [arch=&amp;quot;$(dpkg --print-architecture)&amp;quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian &#92;
        &amp;quot;$(. /etc/os-release &amp;amp;&amp;amp; echo &amp;quot;$VERSION_CODENAME&amp;quot;)&amp;quot; stable&amp;quot; | &#92;
        sudo tee /etc/apt/sources.list.d/docker.list &amp;gt; /dev/null ; 
        sudo apt-get update;
        sudo apt-get -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin;
      EOT

      network_interface {
        # subnetwork = google_compute_subnetwork.default.id
        subnetwork = &amp;quot;default&amp;quot;
        access_config {
          # Include this section to give the VM an external IP address
        }
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;troubleshooting&lt;/h1&gt;
&lt;p&gt;如果執行了startup-script，但沒跑，該怎麼除錯？&lt;br /&gt;
到vm裏面執行下面指令，就可以查log了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo journalctl -u google-startup-scripts.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://docs.docker.com/engine/install/debian/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Install Docker Engine on Debian&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/Terraform/149. terraform 部署VM，啓動docker安裝metadata_startup_script/" />
        </entry>
        <entry>
            <title>
                148. Terraform的基本概念
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/Terraform/148. Terraform的基本概念/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;經歷上一篇的失敗，&lt;br /&gt;
還是先從基本觀念開始吧。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h4 id=&quot;tf&quot; tabindex=&quot;-1&quot;&gt;tf基本組成&lt;/h4&gt;
&lt;p&gt;下面指令輸入時，會用tf取代terraform&lt;/p&gt;
&lt;h6 id=&quot;宣告&quot; tabindex=&quot;-1&quot;&gt;宣告&lt;/h6&gt;
&lt;ol&gt;
&lt;li&gt;terraform&lt;br /&gt;
宣告terraform以及環境的版本&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;terraform {
  required_version = &amp;quot;~&amp;gt;0.13.5&amp;quot;
  required_providers {
    ucloud = {
      source  = &amp;quot;ucloud/ucloud&amp;quot;
      version = &amp;quot;~&amp;gt;1.22.0&amp;quot;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;provider&lt;br /&gt;
呼叫該環境api時需要的參數&lt;br /&gt;
k8s&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;provider &amp;quot;kubernetes&amp;quot; {
  config_path = &amp;quot;~/.kube/config&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ucloud&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;provider &amp;quot;ucloud&amp;quot; {
  public_key  = &amp;quot;JInqRnkSY8eAmxKFRxW9kVANYThg1pcvjD2Aw5f5p&amp;quot;
  private_key = &amp;quot;IlJn6GlmanYI1iDVEtrPyt5R9noAGz41B8q5TML7abqD8e4YjVdylwaKWdY61J5TcA&amp;quot;
  project_id  = &amp;quot;org-tgqbvi&amp;quot;
  region      = &amp;quot;cn-bj2&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h6 id=&quot;定義&quot; tabindex=&quot;-1&quot;&gt;定義&lt;/h6&gt;
&lt;ol&gt;
&lt;li&gt;data&lt;br /&gt;
取得terraform以外的資訊，不同的proivder提供不同的data sources。&lt;br /&gt;
&lt;a href=&quot;https://registry.terraform.io/browse/providers&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;provider 列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;data &amp;quot;ucloud_security_groups&amp;quot; &amp;quot;default&amp;quot; {
  type = &amp;quot;recommend_web&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;resource&lt;br /&gt;
要建立的資源&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	resource &amp;quot;ucloud_eip&amp;quot; &amp;quot;web-eip&amp;quot; {
	  internet_type = &amp;quot;bgp&amp;quot;
	  charge_mode   = &amp;quot;bandwidth&amp;quot;
	  charge_type   = &amp;quot;dynamic&amp;quot;
	  name          = &amp;quot;web-eip&amp;quot;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;output&lt;br /&gt;
輸出&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;		output &amp;quot;eip&amp;quot; {
		  value = ucloud_eip.web-eip.public_ip
		} 
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;tfstate&quot; tabindex=&quot;-1&quot;&gt;狀態檔案(tfstate)&lt;/h4&gt;
&lt;p&gt;當terrform要執行變更時，會產生tfstate的檔案，&lt;br /&gt;
上面記載了目前雲上的資源狀態，此檔案不建議編輯，&lt;br /&gt;
當有任何資源變更時，會同步判斷目前雲上的資源狀態是否一致。&lt;br /&gt;
可使用以下指令，匯入目前雲端上的資源狀態&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; terraform import kubernetes_deployment.websocketclient default/websocketclient
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;kubernetes_deployment.websocketclient 為tf的資源名稱&lt;br /&gt;
default/websocketclient 是雲上的資源&lt;/p&gt;
&lt;p&gt;此tfstate的檔案是明碼，且多人使用會造成簽入時發生衝突，&lt;br /&gt;
所以要透過backend來解決這個問題&lt;/p&gt;
&lt;p&gt;檔案裏面會看到一些狀態，代表的意思如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; 代表新增的資源 (Resource added)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt; 代表刪除的資源 (Resource deleted)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt; 代表修改的資源 (Resource modified)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt; 代表資源參數的值沒有改變，只是調整了排序 (Resource parameter unchanged, only ordering changed)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-/+&lt;/code&gt; 同時出現，表示毀壞性變更，先刪除後建立&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/Terraform/148-fig.2.jpg&quot; alt=&quot;148-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.cloudskillsboost.google/focuses/15842?locale=zh_TW&amp;amp;parent=catalog&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用基礎架構即程式碼工具 Terraform&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;backend&quot; tabindex=&quot;-1&quot;&gt;遠端狀態儲存機制(Backend)&lt;/h4&gt;
&lt;p&gt;Terraform Remote Backend分為兩種：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;標準：支援遠端狀態儲存與狀態鎖
&lt;blockquote&gt;
&lt;p&gt;狀態鎖是指，當針對一個tfstate進行變更操作時，可以針對該狀態檔案新增一把全域鎖，確保同一時間只能有一個變更被執行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;增強：在標準的基礎上支援遠端操作(在遠端伺服器上執行plan、apply等操作)
&lt;blockquote&gt;
&lt;p&gt;只存在於Terraform Cloud&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前支援的backend list&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/Terraform/148-fig.1.jpg&quot; alt=&quot;148-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;要共用 backend的話，&lt;br /&gt;
先建立一個 backend.hcl&lt;br /&gt;
裏面輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   bucket  = &amp;quot;98c2c8-terraform-backend&amp;quot;
   prefix  = &amp;quot;terraform/state&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的prefix代表的意思為&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GCS prefix inside the bucket. Named states for workspaces are stored in an object called &lt;code&gt;&amp;lt;prefix&amp;gt;/&amp;lt;name&amp;gt;.tfstate&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在main.tf的required_providers後面填上 backend &amp;quot;gcs&amp;quot; { }，&lt;br /&gt;
格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;terraform {
  required_providers {
    google = {
      source = &amp;quot;hashicorp/google&amp;quot;
      version = &amp;quot;4.63.1&amp;quot;
    }
  }
  backend &amp;quot;gcs&amp;quot; {

  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後在初始化的時候，輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;terraform init -backend-config=backend.hcl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://lonegunmanb.github.io/introduction-terraform/2.2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html#backend%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8A%A8%E6%80%81%E8%B5%8B%E5%80%BC&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Backend組態的動態賦值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.hashicorp.com/terraform/language/settings/backends/gcs&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;tf-gcs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;workspace&quot; tabindex=&quot;-1&quot;&gt;建立workspace&lt;/h4&gt;
&lt;p&gt;相比起多資料夾隔離的方式來說，基於Workspace的隔離更加簡單，只需要保存一份程式碼，在程式碼中不需要為Workspace編寫額外程式碼，用命令列就可以在不同工作區之間來回切換。&lt;/p&gt;
&lt;p&gt;下列指令分別爲，建立、列表、選擇及顯示目前的workspace&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;terraform workspace new qa
terraform workspace list
terraform workspace select qa
terraform worspace show

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://lonegunmanb.github.io/introduction-terraform/2.2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;狀態管理&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;terraform&quot; tabindex=&quot;-1&quot;&gt;檢查terraform 的計劃&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;terraform plan -out=out.tfplan
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-out的指定計畫的輸出檔，確保您所檢閱的方案就是所套用的方案。&lt;br /&gt;
之後使用apply執行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;terraform apply out.tfplan
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立完成後，使用show看目前狀態&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;terraform show
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;count&quot; tabindex=&quot;-1&quot;&gt;count&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;舉例來說, 兩個VM是一隻狗一隻貓，&lt;a href=&quot;http://xn--dog-ww0f445bb75d.tf/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;那就是dog.tf&lt;/a&gt; &lt;a href=&quot;http://cat.tf/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;cat.tf&lt;/a&gt;&lt;br /&gt;
如果是兩隻狗 就可以寫一個 &lt;a href=&quot;http://dog.tf/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;dog.tf&lt;/a&gt;&lt;br /&gt;
裡面用&lt;br /&gt;
resources ec2&lt;br /&gt;
Count = 2&lt;br /&gt;
這樣&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;console&quot; tabindex=&quot;-1&quot;&gt;console&lt;/h3&gt;
&lt;p&gt;執行 console ，看程式執行結果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;terraform console 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cidrsubnet 後面的第二個參數表示二進位要位移多少，第三個參數表示，要設定位移的數字為多少。&lt;/p&gt;
&lt;p&gt;例如 10  =  1010&lt;br /&gt;
位移4bit，所以是 1010 0000  = 160&lt;br /&gt;
6 =  0110&lt;br /&gt;
位移4bit ，所以是 0110 0000 = 96&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tf console
&amp;gt; cidrsubnet(&amp;quot;10.1.0.0/24&amp;quot;,4,0)
&amp;quot;10.1.0.0/28&amp;quot;
&amp;gt; cidrsubnet(&amp;quot;10.1.0.0/24&amp;quot;,4,10)
&amp;quot;10.1.0.160/28&amp;quot;
&amp;gt; cidrsubnet(&amp;quot;10.1.0.0/24&amp;quot;,4,6)
&amp;quot;10.1.0.96/28&amp;quot;
&amp;gt; cidrsubnet(&amp;quot;10.1.0.0/24&amp;quot;,4,12)
&amp;quot;10.1.0.192/28&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://ntwobike.medium.com/how-cidrsubnet-works-in-terraform-f6ccd8e1838f&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How cidrsubnet works in Terraform&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;variable&quot; tabindex=&quot;-1&quot;&gt;variable變數宣告&lt;/h3&gt;
&lt;p&gt;先知道變數的繼承順序，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;種類&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;範例&lt;/th&gt;
&lt;th&gt;優先&lt;/th&gt;
&lt;th&gt;建議使用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;命令列參數&lt;/td&gt;
&lt;td&gt;輸入命令時，指定變數&lt;/td&gt;
&lt;td&gt;&lt;code&gt; tf apply -var=&amp;quot;gcp_region=asia-east&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;特殊情況&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;環境變數&lt;/td&gt;
&lt;td&gt;使用 TF_VAR_ 環境變數定義&lt;/td&gt;
&lt;td&gt;&lt;code&gt;TF_VAR_gcp_region=asia_east2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;變數文件&lt;/td&gt;
&lt;td&gt;使用tfvars變數文件定義&lt;/td&gt;
&lt;td&gt;&lt;code&gt;gcp_region=asia_east2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;開發者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;設定文件&lt;/td&gt;
&lt;td&gt;使用variables區塊定義&lt;/td&gt;
&lt;td&gt;&lt;code&gt;variable &amp;quot;gcp_region&amp;quot; {default = &amp;quot;asia-east1&amp;quot;}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;程式碼&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;tf的變數要先宣告，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-variable.tf&quot;&gt;variable &amp;quot;gcp_region&amp;quot; {
  default = &amp;quot;asia-east1&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果後續要改值，可以改成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-terraform.tfvars&quot;&gt;gcp_region = &amp;quot;asia-east2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;變數文件載入方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;檔案名稱為 &lt;code&gt;terraform.tfvars&lt;/code&gt; or &lt;code&gt;terraform.tfvars.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;副檔名為 &lt;code&gt;.auto.tfvars&lt;/code&gt; or &lt;code&gt;.auto.tfvars&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;必須在同一個&lt;code&gt;tf init&lt;/code&gt;的資料夾內。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/Terraform/148-fig.4.jpg&quot; alt=&quot;148-fig.4.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;還有其他載入方式，在apply 時載入變數檔，或是環境變數載入。&lt;br /&gt;
詳細參考&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://godleon.github.io/blog/DevOps/terraform-input-variables/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Terraform] Input Variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.oracle.com/zh-TW/learn/technical-articles/4-variables&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Terraform 變數&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Fn3M8ll5sC4&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;(Youtube)Terraform 從零開始 基礎 | 9-Variables（變數）的種類與使用順序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;常用指令&quot; tabindex=&quot;-1&quot;&gt;常用指令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tf console&lt;/code&gt; 可以經由這邊去驗證變數&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/Terraform/148-fig.3.jpg&quot; alt=&quot;148-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tf fmt&lt;/code&gt; &lt;a href=&quot;http://xn--main-kk0g674d1vo.tf/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;格式化main.tf&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tf validate&lt;/code&gt; 驗證terraform&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/Terraform/148. Terraform的基本概念/" />
        </entry>
        <entry>
            <title>
                147. 用chatGPT學Terraform
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/Terraform/147. 用chatGPT學Terraform/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;終於要來試試看terraorm了，&lt;br /&gt;
現在公司好像很少全部k8s，&lt;br /&gt;
大部分還是用虛擬機，這樣變成還是要把terraform學一下。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h4 id=&quot;terraform-ansible&quot; tabindex=&quot;-1&quot;&gt;Terraform跟ansible的差異&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;差異點&lt;/th&gt;
&lt;th&gt;Terraform&lt;/th&gt;
&lt;th&gt;Ansible&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;組態檔案管理 vs 組態&lt;/td&gt;
&lt;td&gt;Terraform使用組態檔案管理基礎設施，描述其狀態，而不是配置。&lt;/td&gt;
&lt;td&gt;Ansible基於主機的管理，直接配置基礎設施。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可變基礎設施 vs 不可變基礎設施&lt;/td&gt;
&lt;td&gt;Terraform以可變的方式管理基礎設施，可以對基礎設施進行更改。&lt;/td&gt;
&lt;td&gt;Ansible通常將基礎設施視為不可變的，一旦配置，它們就不再更改。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;過程式的 vs 聲明式的&lt;/td&gt;
&lt;td&gt;Terraform是過程式的，會循序漸進地執行創建、修改和刪除操作。&lt;/td&gt;
&lt;td&gt;Ansible是聲明式的，描述了期望的最終狀態，而不是執行一系列步驟來實現它。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Master vs Masterless&lt;/td&gt;
&lt;td&gt;Terraform通常使用單一主節點管理基礎設施狀態。&lt;/td&gt;
&lt;td&gt;Ansible可以在主節點和無主節點（即agentless）模式下運行。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Agent vs Agentless&lt;/td&gt;
&lt;td&gt;Terraform不需要在目標基礎設施上安裝任何代理。&lt;/td&gt;
&lt;td&gt;Ansible需要在目標基礎設施上安裝一個代理。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;成熟 vs 前沿&lt;/td&gt;
&lt;td&gt;Terraform是成熟的基礎設施自動化工具，已被廣泛使用。&lt;/td&gt;
&lt;td&gt;Ansible是一個新興的基礎設施自動化工具，並且正在積極發展。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;綜合使用多種工具&lt;/td&gt;
&lt;td&gt;Terraform與其他工具集成，如Packer、Docker和AWS CloudFormation等。&lt;/td&gt;
&lt;td&gt;Ansible與其他工具集成，如Jenkins、Docker和Kubernetes等。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;安裝&quot; tabindex=&quot;-1&quot;&gt;安裝&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.hashicorp.com/terraform/downloads&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;官網&lt;/a&gt;安裝最快了，上面有各個平臺的安裝方式。&lt;/p&gt;
&lt;h4 id=&quot;詠唱&quot; tabindex=&quot;-1&quot;&gt;詠唱&lt;/h4&gt;
&lt;p&gt;我先問了一下chatGPT怎麼學Terraform，然後給了我很標準的答案。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;閱讀Terraform官方文檔，熟悉其基礎結構、功能和概念。&lt;/li&gt;
&lt;li&gt;安裝Terraform，並學習如何使用它來創建基礎設施。&lt;/li&gt;
&lt;li&gt;開始使用Terraform的示例項目，並嘗試使用它們創建簡單的基礎設施。&lt;/li&gt;
&lt;li&gt;學習如何使用Terraform管理不同的基礎設施提供者，如AWS、Azure、Google Cloud等。&lt;/li&gt;
&lt;li&gt;閱讀Terraform的模塊化文檔，並學習如何使用模塊化設計來管理複雜的基礎設施。&lt;/li&gt;
&lt;li&gt;學習如何使用Terraform命令列工具來測試和調試基礎設施代碼。&lt;/li&gt;
&lt;li&gt;研究Terraform的最佳實踐，包括如何管理機密、編寫可重用的代碼和設計可擴展的基礎設施。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我還是直接從實際案例來看好了，&lt;/p&gt;
&lt;p&gt;Q: 幫我建立一個部署deployment的terrform程式碼&lt;br /&gt;
A:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 定義Kubernetes provider
provider &amp;quot;kubernetes&amp;quot; {
  config_context_cluster = &amp;quot;my-cluster&amp;quot;
}

# 定義deployment
resource &amp;quot;kubernetes_deployment&amp;quot; &amp;quot;my_deployment&amp;quot; {
  metadata {
    name = &amp;quot;my-deployment&amp;quot;
    labels = {
      app = &amp;quot;my-app&amp;quot;
    }
  }

  spec {
    replicas = 3

    selector {
      match_labels = {
        app = &amp;quot;my-app&amp;quot;
      }
    }

    template {
      metadata {
        labels = {
          app = &amp;quot;my-app&amp;quot;
        }
      }

      spec {
        container {
          image = &amp;quot;my-image:latest&amp;quot;
          name  = &amp;quot;my-container&amp;quot;
        }
      }
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看了一下他提供的程式碼，有點問題，然後接着問&lt;br /&gt;
Q：resouce 宣告 kubernetes_deployment my_deployment 是要跟deployment的name一樣嗎&lt;br /&gt;
A:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;是的，&lt;code&gt;kubernetes_deployment&lt;/code&gt;的&lt;code&gt;metadata&lt;/code&gt;區塊中的&lt;code&gt;name&lt;/code&gt;屬性會定義Kubernetes deployment的名稱，您需要將其設定為與實際的deployment名稱相同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然後在後續的對談過程中，發現另一個指令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;terraform import 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再緊接着問，這個的功用是什麼。&lt;/p&gt;
&lt;p&gt;A:&lt;br /&gt;
&lt;code&gt;terraform import&lt;/code&gt;是Terraform提供的一個命令，用於將現有的資源引入Terraform管理的狀態中。使用&lt;code&gt;terraform import&lt;/code&gt;可以讓Terraform瞭解現有資源的狀態，並允許你使用Terraform管理這些資源，並在需要時進行更改。&lt;/p&gt;
&lt;p&gt;通常情況下，Terraform會從頭開始創建和管理所有資源。然而，在實際環境中，有時候會存在一些已經存在的資源，這些資源可能是手動創建的，或者是由其他工具創建的。這些資源可能包括Kubernetes deployment、AWS EC2實例、GCP虛擬機等等。在這種情況下，使用&lt;code&gt;terraform import&lt;/code&gt;命令可以將這些現有資源引入到Terraform管理的狀態中，以便Terraform能夠管理它們。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;terraform import&lt;/code&gt;命令時，需要指定要引入的資源的類型和ID，以及要對應到Terraform的哪個資源。Terraform將使用提供的資源類型和ID尋找現有資源的狀態，並將其對應到Terraform組態檔案中的相應資源。一旦資源成功被引入，Terraform就可以開始管理它們，並將它們的狀態保存到狀態檔案中，這樣就可以使用&lt;code&gt;terraform plan&lt;/code&gt;、&lt;code&gt;terraform apply&lt;/code&gt;等命令進行更改。&lt;/p&gt;
&lt;p&gt;如果不知道怎麼用沒關係，&lt;br /&gt;
再問一下，&lt;br /&gt;
Q：該怎麼使用terraform import&lt;br /&gt;
A：&lt;br /&gt;
使用&lt;code&gt;terraform import&lt;/code&gt;命令引入現有資源到Terraform管理的狀態中，通常需要以下步驟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在Terraform組態檔案中定義資源的組態，例如使用&lt;code&gt;kubernetes_deployment&lt;/code&gt;定義Kubernetes deployment的組態。&lt;/li&gt;
&lt;li&gt;執行&lt;code&gt;terraform init&lt;/code&gt;初始化Terraform，以設置Terraform的工作目錄和相關外掛。&lt;/li&gt;
&lt;li&gt;執行&lt;code&gt;terraform import&lt;/code&gt;命令引入現有資源。例如，要引入Kubernetes deployment，可以使用以下命令：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;terraform import kubernetes_deployment.systemservice deployment2k7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這裡的&lt;code&gt;kubernetes_deployment.systemservice&lt;/code&gt;指的是在Terraform組態檔案中定義的Kubernetes deployment資源，&lt;code&gt;deployment2k7&lt;/code&gt;則是現有Kubernetes deployment的名稱或ID。通過這樣的方式，Terraform就會將現有的Kubernetes deployment引入到Terraform管理的狀態中。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;檢查Terraform的狀態，使用&lt;code&gt;terraform state list&lt;/code&gt;命令可以列出Terraform目前管理的所有資源，可以確認引入的資源是否已經被成功管理。&lt;/li&gt;
&lt;li&gt;更新Terraform組態檔案，通過&lt;code&gt;terraform plan&lt;/code&gt;和&lt;code&gt;terraform apply&lt;/code&gt;命令對資源進行更改。當Terraform管理現有資源時，它會比較Terraform組態檔案和現有資源的狀態，並生成一個計劃，顯示要將資源帶到Terraform所需的更改。通過執行&lt;code&gt;terraform apply&lt;/code&gt;命令，Terraform就可以將這些更改應用到現有的資源中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h4&gt;
&lt;p&gt;光看沒有用，最重要的還是實作，&lt;br /&gt;
一開始沒碰terraform是不知道寫壞了，會不會影響線上的服務，&lt;br /&gt;
現在我能夠先import，看目前服務建設的程式後，再來修改。&lt;/p&gt;
&lt;h3 id=&quot;感想&quot; tabindex=&quot;-1&quot;&gt;感想&lt;/h3&gt;
&lt;p&gt;實作後完全崩掉，有很多東西還是要從頭開始看一下。&lt;br /&gt;
像是， terraform 的backend ，跟tfstate 這些觀念。&lt;br /&gt;
上面也有提到引入資源，但實際上可能跟你想得不太一樣，&lt;br /&gt;
引入後是變成一個tfstate，而不是tf，&lt;br /&gt;
那tf 跟 tfstate又有什麼不同呢？&lt;/p&gt;
&lt;p&gt;我們還是看下一篇，從頭來過吧。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kknews.cc/zh-tw/code/amvkzax.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;為什麼我們使用Terraform 而不使用Puppet, Ansible &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/Terraform/147. 用chatGPT學Terraform/" />
        </entry>
        <entry>
            <title>
                71.gitlab on GKE 災害還原筆記
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/GKE/71.gitlab on GKE 災害還原筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;之前一直沒寫的gitlab yaml，再文章的最下方。&lt;br /&gt;
本片文章都是使用這個yaml做建立及佈署。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;Step 0.&lt;/p&gt;
&lt;p&gt;之前一直沒寫的gitlab yaml，再文章的最下方。&lt;br /&gt;
本片文章都是使用這個yaml做建立及佈署。&lt;/p&gt;
&lt;p&gt;Step 1.&lt;/p&gt;
&lt;p&gt;先參考上篇 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/GKE/70.%20GKE%20pvc%E9%82%84%E5%8E%9F/&quot;&gt;70. GKE pvc還原&lt;/a&gt;，建立好PVC。&lt;/p&gt;
&lt;p&gt;主要複製Gitlab的位置為&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: config
  mountPath: /etc/gitlab
- name: gitlab-data
  mountPath: /var/opt/gitlab/git-data
- name: postgres-data
  mountPath: /var/opt/gitlab/postgresql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由於我之前建立的image為 last版本（應該是快一年前的事），&lt;br /&gt;
這次我用last版本的話，版本超前太多，導致一直重開機。&lt;/p&gt;
&lt;p&gt;後來查我的gitlab版本為 14.0.1，&lt;br /&gt;
但裝上去後一直碰到這個錯誤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;relation &amp;quot;services&amp;quot; does not exist after upgrade to 14.2.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解決方式：&lt;br /&gt;
後來將版本升級到 14.1.1 後就好了。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gitlab.com/gitlab-org/omnibus-gitlab/-/issues/6352&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ERROR: relation &amp;quot;services&amp;quot; does not exist after upgrade to 14.2.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Step 2.&lt;/p&gt;
&lt;p&gt;用本來的帳號密碼能登入，沒問題。&lt;br /&gt;
增加新的git remote 位置，&lt;br /&gt;
然後試著推一個版本上去時，又出現錯誤了。這次比較好理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;remote: HTTP Basic: Access denied&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解決方式：&lt;br /&gt;
跑去另一個空目錄，git clone ，會要輸入帳號密碼，輸入後就好了。&lt;/p&gt;
&lt;p&gt;Step 3.&lt;/p&gt;
&lt;p&gt;如果看過之前的文章，可能知道我有在用istio，&lt;br /&gt;
會碰到要用一個ip暴露不同的服務。&lt;/p&gt;
&lt;p&gt;解決方式：&lt;br /&gt;
external_url &amp;quot;http://{ip}/gitlab&amp;quot;&lt;br /&gt;
virtualservice直接改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spec:
  hosts: []
  http:
    - match:
        - uri:
            prefix: /gitlab
      name: gitlab
      route:
        - destination:
            host: gitlab-svc.default.svc.cluster.local
            port:
              number: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.gitlab.com/omnibus/settings/configuration.html#configure-a-relative-url-for-gitlab&quot; title=&quot;Permalink&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Configure a relative URL for GitLab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;gitlab-yaml&quot; tabindex=&quot;-1&quot;&gt;Gitlab yaml&lt;/h3&gt;
&lt;p&gt;現在也有&lt;a href=&quot;https://docs.gitlab.com/charts/installation/operator.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gitlab operator&lt;/a&gt;跟 &lt;a href=&quot;https://docs.gitlab.com/charts/installation/deployment.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;helm&lt;/a&gt; 可以做，有興趣的可以參考一下官方文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: gitlab-svc
spec:
  ports:
  - name: &amp;quot;web&amp;quot;
    port: 80
    targetPort: 80
  - name: &amp;quot;ssh&amp;quot;
    port: 22
    targetPort: 22
  - name: &amp;quot;ssl&amp;quot;
    port: 443
    targetPort: 443
  selector:
    io.kompose.service: web
    drone: gitlab
  type: LoadBalancer
  loadBalancerIP: 123.123.123.123
  loadBalancerSourceRanges:
  - 192.168.0.0/16
  - 172.16.0.0/12
  - 10.0.0.0/8


---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: gitlab
  labels:
    io.kompose.service: web
spec:
  replicas: 1
  selector:
    matchLabels:      
      io.kompose.service: web
  template:
    metadata:
      labels:
        io.kompose.service: web
    spec:
      containers:
      - env:
        - name: GITLAB_TIMEZONE
          value: Taipei
        - name: GITLAB_OMNIBUS_CONFIG
          value: |            
            external_url &amp;quot;http://123.123.123.123/gitlab&amp;quot;
            gitlab_rails[&#39;gitlab_default_projects_features_builds&#39;] = false
        image: gitlab/gitlab-ce:14.1.1-ce.0
        name: web
        ports:
        - containerPort: 80
        resources: {}
        volumeMounts:
        - name: config
          mountPath: /etc/gitlab
        - name: gitlab-data
          mountPath: /var/opt/gitlab/git-data
        - name: postgres-data
          mountPath: /var/opt/gitlab/postgresql
      restartPolicy: Always
      serviceAccountName: &amp;quot;&amp;quot;
      volumes:
      - name: config
        persistentVolumeClaim:
          claimName: gke-drone-web-claim0
      - name: gitlab-data
        persistentVolumeClaim:
          claimName: gke-drone-repository-data
      - name: postgres-data
        persistentVolumeClaim:
          claimName: gke-drone-gitlab-postgresql
      
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PVC的建立，請參考&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/GKE/70.%20GKE%20pvc%E9%82%84%E5%8E%9F/&quot;&gt;70. GKE pvc還原&lt;/a&gt;，如要建立空的，&lt;br /&gt;
參考下方yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  creationTimestamp: null
  labels:
    io.kompose.service: web-claim0
  name: gke-drone-web-claim0
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
status: {}
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  labels:
    gitlab-data: gitlab
  name: gke-drone-repository-data
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 100Gi
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  labels:
    gitlab-data: postgresql
  name: gke-drone-gitlab-postgresql
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 100Gi  
 
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/GKE/71.gitlab on GKE 災害還原筆記/" />
        </entry>
        <entry>
            <title>
                70. GKE pvc還原
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/GKE/70. GKE pvc還原/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;之前的Gitlab建在GKE的公開叢集上，&lt;/p&gt;
&lt;p&gt;雖然有限定IP訪問，一直要改到私有叢集上，&lt;/p&gt;
&lt;p&gt;但一直沒時間動，現在終於有空弄了，首先要解決的是資料還原的問題。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;首先在GCE上面複製一個磁碟，&lt;br /&gt;
可以先從GKE上面的pod找到當初建立的pvc名稱，&lt;br /&gt;
再根據這個名稱去找。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/70-fig.1.jpg&quot; alt=&quot;70-fig.1.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/70-fig.2.jpg&quot; alt=&quot;70-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;再來就建立pv 跟 pvc了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: test-pv
  namespace: default
spec:
  # persistentVolumeReclaimPolicy: Delete
  storageClassName: &amp;quot;standard&amp;quot;
  capacity:
    storage: 300G
  accessModes:
    - ReadWriteOnce
  claimRef:
    namespace: default
    name: test-upload
  gcePersistentDisk:
    pdName: test-upload
    fsType: ext4
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: test-upload
  namespace: default
spec:
  storageClassName: &amp;quot;standard&amp;quot;
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 300G

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pv的 gcePersistentDisk ，是剛剛複製的硬碟名稱。&lt;/p&gt;
&lt;p&gt;將裡面的參數改一改，&lt;br /&gt;
要建立的 name,namespace,storage, claimRef ，&lt;br /&gt;
結束。&lt;/p&gt;
&lt;p&gt;deployment使用正常方式直接掛載即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  template:
    metadata:
      creationTimestamp: null
      labels:
        app: video-admin
        version: v1
    spec:
      containers:
      - name: video
        ...
        volumeMounts:
        - mountPath: /upload
          name: source
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      terminationGracePeriodSeconds: 30
      volumes:
      - name: source
        persistentVolumeClaim:
          claimName: test-upload
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是statefuleSet的話，&lt;br /&gt;
pv的名稱需要改成 statefulSet的命名規則。&lt;br /&gt;
statefulSet不會用到pvc。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;VC_TEMPLATE_NAME-STATEFULSET_NAME-REPLICA_INDEX
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;VC_TEMPLATE_NAME&lt;/code&gt;：新 PersistentVolumeClaim 模板的名稱。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;STATEFULSET_NAME&lt;/code&gt;：新 StatefulSet 的名稱。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;REPLICA_INDEX&lt;/code&gt;：StatefulSet 副本的索引。此示例使用的是 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;pvc-pv&quot; tabindex=&quot;-1&quot;&gt;注意，刪除pvc時，最好將pv也刪除，避免發生未知情況。&lt;/h3&gt;
&lt;p&gt;如碰到下圖情況，表示pv有問題，請刪除重建。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/70-fig.3.jpg&quot; alt=&quot;70-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/persistent-volumes/preexisting-pd&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;將原有永久性磁盤用作 PersistentVolume&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/concepts/persistent-volumes&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;永久性卷和動態預配&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/GKE/70. GKE pvc還原/" />
        </entry>
        <entry>
            <title>
                56. GKE記錄 nginx log
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/GKE/56. GKE記錄 nginx log/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;因前陣子被人用DDOS攻擊，&lt;/p&gt;
&lt;p&gt;然後公司有一個單位就跑出來了，說他們要nginx的log，&lt;/p&gt;
&lt;p&gt;發生當下才能作為分析用途。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;nginx 版本  1.21.4&lt;/p&gt;
&lt;p&gt;更改nginx config ，&lt;br /&gt;
將&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;       access_log  /dev/stdout   main;
        error_log /dev/stderr;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;放在  http 底下的 service內。&lt;/p&gt;
&lt;p&gt;這樣就會把log 訊息，使用標準輸出的方式列印到機器上。&lt;br /&gt;
GKE就能抓到記錄了。&lt;/p&gt;
&lt;p&gt;然後使用 ECK的filebeat ，預設是會去抓各個log的資料。&lt;br /&gt;
但前提是要有標準輸出，所以這邊就不用設定了。&lt;/p&gt;
&lt;p&gt;完整config 如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#user&quot;&gt;#user&lt;/a&gt;  nobody;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  &#39;$remote_addr - $remote_user [$time_local] , &#39;
                      &#39;http-host: &amp;quot;$http_host&amp;quot; , URL: &amp;quot;$request&amp;quot;  , request-status : &amp;quot;$status&amp;quot;  ,   &#39;
                      &#39;body-byte: $body_bytes_sent  ,http-referer: &amp;quot;$http_referer&amp;quot;  ,&#39;
                      &#39;user-agent: &amp;quot;$http_user_agent&amp;quot; , X-Forwarded-For : &amp;quot;$http_x_forwarded_for&amp;quot; ,  &#39;
                      &#39; request-time: &amp;quot;$request_time&amp;quot;  , response_time : &amp;quot;$upstream_response_time&amp;quot;  &#39;;




    sendfile        on;
    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#tcp_nopush&quot;&gt;#tcp_nopush&lt;/a&gt;     on;

    keepalive_timeout  65;

    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#gzip&quot;&gt;#gzip&lt;/a&gt;  on;
    
    server {
        listen 80;
        listen [::]:80;
        root   /app;
        listen 443 ssl;
        listen [::]:443 ssl;
        
        server_name _;

        ssl off;
        ssl_certificate /etc/nginx/nginxssl.crt;
        ssl_certificate_key /etc/nginx/nginxssl.key;

        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        ssl_prefer_server_ciphers on;

        access_log  /dev/stdout   main;
        error_log /dev/stderr;
       

        location / {
            try_files $uri /index.php$is_args$query_string;
        }
    
        location ~ &#92;.php$ {
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi_params;
        }
    }

}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_36750623/article/details/85008043&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Nginx配置中的log_format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://benjr.tw/22380&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux – Nginx log 格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/weifeng1463/p/10277178.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;docker運行nginx為什麼要使用 daemon off&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/22541333/have-nginx-access-log-and-error-log-log-to-stdout-and-stderr-of-master-process&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Have nginx access_log and error_log log to STDOUT and STDERR of master process&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/GKE/56. GKE記錄 nginx log/" />
        </entry>
        <entry>
            <title>
                50.GKE workload Identity 實地演練
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/GKE/50.GKE workload Identity 實地演練/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;某位大神說，GKE使用 IAM的角色認證安全性不太夠，&lt;/p&gt;
&lt;p&gt;所以希望未來都改用這種，workload Ideneity，&lt;/p&gt;
&lt;p&gt;就開始了採坑之旅，是說這個坑沒想像中的深。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;查詢cluster是否有 workload Identity&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud container clusters describe yaboxxx-test -z asia-east1-b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/50-fig.1.jpg&quot; alt=&quot;50-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;建議最好直接加上地區，不然看錯誤訊息也是可以。&lt;br /&gt;
會說在某個地區找不到此cluster&lt;/p&gt;
&lt;p&gt;修改cluster ，啟用 Workload Identity&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud container clusters update istio-test -z asia-east1-b &#92;    --workload-pool=rd7-project.svc.id.goog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改 node-pool&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud container node-pools update defaultpool -z asia-east1-b &#92;    --cluster=istio-test &#92;    --workload-metadata=GKE_METADATA
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果成功的話，會看到&lt;br /&gt;
GKE 中繼資料伺服器 ： 已啟用&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/50-fig.2.jpg&quot; alt=&quot;50-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;建立ns&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl create ns token-proxy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立kubernetes 帳號&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; kubectl create serviceaccount -n token-proxy proxy-user
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;申請 Google service accout的 IAM 服務帳號，&lt;br /&gt;
然後綁定 kubernetes service account 與 Google service account 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud iam service-accounts add-iam-policy-binding &#92;    --role roles/iam.workloadIdentityUser &#92;    --member &amp;quot;serviceAccount: project.svc.id.goog[token-proxy/proxy-user]&amp;quot; &#92;    token-proxy@rd7-project.iam.gserviceaccount.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/50-fig.3.jpg&quot; alt=&quot;50-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在 kubernet service account上面，增加註釋&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl annotate serviceaccount &#92;    --namespace token-proxy proxy-user &#92;    iam.gke.io/gcp-service-account=token-proxy@rd7-project.iam.gserviceaccount.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 Workload Identity&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/GKE/50.GKE workload Identity 實地演練/" />
        </entry>
        <entry>
            <title>
                44.srs 影音串流 on GKE
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/GKE/44.srs 影音串流 on GKE/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;首先介紹一下srs，這個就是一個影音串流，&lt;br /&gt;
本來是乖乖再用EFK on GKE，然後說網路有問題，&lt;br /&gt;
就又被抓去協助了，想裝死還不行 T_T  ，&lt;br /&gt;
我的東西還不夠多嗎  (╯‵□′)╯︵┴─┴&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;這次主要是協助除錯，&lt;br /&gt;
所以下面就直接列出碰到的問題點。&lt;br /&gt;
由於我沒玩過直撥，有些概念是後來才知道的。&lt;br /&gt;
也會順便列在下面。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;webrtc推流時，出現 getUserMedia  error&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要到chrome上面修改設定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.clarence.tw/wp-content/uploads/2020/10/%E6%88%AA%E5%9C%96-2020-10-29-%E4%B8%8B%E5%8D%8812.50.41-1024x653.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://blog.clarence.tw/2020/10/29/solve-the-undefined-problem-of-getusermedia/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;解決 ‘GETUSERMEDIA’ OF UNDEFINED 問題&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;rtmp 推拉&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;走TCP的協定&lt;br /&gt;
使用rtmp播放的話，所有的連線都會在伺服器上面留一份。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;webrtc播放&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要到srs 4.0.14以後的版本&lt;br /&gt;
有TCP跟 UDP的協定，&lt;br /&gt;
伺服器只負責對 直撥者跟觀看者做驗證，&lt;br /&gt;
webrtc，是直撥者跟觀看者直接連線，也就是點對點的連接方式。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.yasssssblog.com/2020/09/15/ithome-30-01-webrtc/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;何謂WebRTC&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;webrtc觀看方式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也是這一部分的網路架構，導致我不得不跳下去協助處理。&lt;br /&gt;
因為GKE的service 負載平衡目前還不支援混合的網路架構，&lt;br /&gt;
也就是TCP跟 UDP 混合使用。只能使用單一個協定。&lt;br /&gt;
所以沒辦法像傳統機器一樣，直接一個ip，同時開啟TCP跟UDP的網路協定。&lt;/p&gt;
&lt;p&gt;所以會變成 TCP 一個IP，UDP又是一個IP(fig.1)，&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/44-fig.1.jpg&quot; alt=&quot;44-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;此時在SRS上面的 Candidate ，必須要設定 *&lt;br /&gt;
然後再推流的時候，推流網址要更改成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;webrtc://35.2.3.1/live/ray123?eip=35.3.3.50
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;35.2.3.1 是 只開TCP的外網位置。&lt;br /&gt;
35.3.3.50 是 只開UDP的外網位置。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://github.com/ossrs/srs/wiki/v4_CN_WebRTC#config-candidate&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;v4_CN_WebRTC&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.cxymm.net/article/wltsysterm/119380486&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[SRS+docker]實現直播服務器 3 基於webRTC協議的srs低延遲直播研究_wltsysterm的博客-程序員秘密&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;其他參考文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;當然最好的方式，是把裡面的文件大約掃過一下。&lt;br /&gt;
但這資料有點多，我也只挑了幾個重點看。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ossrs/srs/wiki/v4_CN_K8s&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;v4_CN_K8S&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1588947&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;當SRS遇到K8s：如何實現高可用、回滾與灰度發布？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://shengyu7697.github.io/linux-nc/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 Linux nc 測試UDP有沒有通&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gitee.com/ossrs/srs/wikis/Home&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SRS全文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ossrs/srs/blob/4.0release/trunk/conf/full.conf&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SRS full.conf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/GKE/44.srs 影音串流 on GKE/" />
        </entry>
        <entry>
            <title>
                41.GKE節點無法自動縮小
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/GKE/41.GKE節點無法自動縮小/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;果然東西穩定之後，上面的都會想要costDown，&lt;br /&gt;
不過這也算是當初建立的人沒設定好，&lt;br /&gt;
會發生這個情況，後續也查明了，當初在每個節點上只允許放64個pod，&lt;br /&gt;
所以就算放滿，也吃不到那麼多。&lt;br /&gt;
但沒有自動縮小，這其實也是個問題，但要自動縮小，&lt;br /&gt;
還要看這個服務是否合適...。&lt;/p&gt;
&lt;p&gt;反正我之後反而沒在糾結這個狀況了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;最近發現一個東西，在GKE上面的節點，cpu分配很奇怪。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/41-fig.1.jpg&quot; alt=&quot;41-fig.1.jpg&quot; /&gt;&lt;br /&gt;
(fig.1)&lt;/p&gt;
&lt;p&gt;每個node的節點都只佔了一半的CPU就去開新的節點了。&lt;br /&gt;
本來懷疑是自動擴展有問題，&lt;br /&gt;
後來發現應該是自動縮小有問題。&lt;/p&gt;
&lt;p&gt;這個狀況在新建一個叢集，然後設定節點自動伸縮就會發生了。&lt;/p&gt;
&lt;p&gt;一般來說，節點只要沒有pod在裡面，大約只要十分鐘就會把多餘的節點移除了。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-autoscaler#how_cluster_autoscaler_works&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;集群自動擴縮程序的工作原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但新建了一個節點池，裡面都空的。他並沒有縮小到最小節點。&lt;/p&gt;
&lt;p&gt;詢問後得知，須先看一下log才能知道為什麼沒有自動縮小。&lt;/p&gt;
&lt;p&gt;首先開啟 GCP的日誌查看器，&lt;br /&gt;
a. 資源選擇 Kubernetes Cluster&lt;br /&gt;
b. 日誌類型列表選擇&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;container.googleapis.com/cluster-autoscaler-visibility
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;c. 再選擇要查看的cluster name&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/41-fig.2.jpg&quot; alt=&quot;41-fig.2.jpg&quot; /&gt;&lt;br /&gt;
(fig.2)&lt;/p&gt;
&lt;p&gt;d. 展開 noDecisionStatus&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/41-fig.3.jpg&quot; alt=&quot;41-fig.3.jpg&quot; /&gt;&lt;br /&gt;
(fig.3)&lt;/p&gt;
&lt;p&gt;看到錯誤了，就是這個害得pod無法自動縮減。&lt;br /&gt;
這邊的錯誤訊息是&lt;br /&gt;
node.pod.has.local.storage，&lt;br /&gt;
新建節點無法縮減會出現的錯誤訊息通常是&lt;br /&gt;
node.kube.system.unmovable&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/41-fig.4.jpg&quot; alt=&quot;41-fig.4.jpg&quot; /&gt;&lt;br /&gt;
(fig.4)&lt;/p&gt;
&lt;p&gt;碰到 node.pod.has.local.storage的解法是在deploy的yaml上面加上註釋，位置位於 metadata底下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;annotations:
	cluster-autoscaler.kubernetes.io/safe-to-evict: &amp;quot;true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/41-fig.5.jpg&quot; alt=&quot;41-fig.5.jpg&quot; /&gt;&lt;br /&gt;
(fig.5)&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/cluster-autoscaler-visibility#cluster-not-scalingdown&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;集群未縱向縮容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/63871413/how-to-make-sure-kubernetes-autoscaler-not-deleting-the-nodes-which-runs-specifi&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to make sure Kubernetes autoscaler not deleting the nodes which runs specific pod&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至於碰到 node.kube.system.unmovable 的解法，&lt;br /&gt;
需建立 PDB ，讓在 namespace 的 kube-system可以被驅逐。PDB是什麼可參考  &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/42.k8s%20PDB%EF%BC%88pod%E4%B8%AD%E6%96%B7%E9%A0%90%E7%AE%97%EF%BC%89/&quot;&gt;42.k8s PDB（pod中斷預算）&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl create poddisruptionbudget &amp;lt;pdb name&amp;gt; --namespace=kube-system --selector app=&amp;lt;app name&amp;gt; --max-unavailable 1

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要注意，selector的label不一定是app開頭，&lt;br /&gt;
要看各deploy裡面的設定。&lt;br /&gt;
最近碰到在GKE的kube-system裡面pod label，&lt;br /&gt;
反而是叫 k8s-app:kube-dns，selector可以隨意選擇，只要有辦法對到deploy即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/41-fig.6.jpg&quot; alt=&quot;41-fig.6.jpg&quot; /&gt;&lt;br /&gt;
(fig.6)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#how-to-set-pdbs-to-enable-ca-to-move-kube-system-pods&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to set PDBs to enable CA to move kube-system pods?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但後來有發現一個問題，當解了一個 node.kube.system.unmovable ，後續可能會出現 node.pod.has.local.storage的問題，&lt;br /&gt;
這樣會變成必須針對每個deploy都額外做設定。&lt;/p&gt;
&lt;p&gt;所以最後我選擇了，直接手動驅逐節點內的pod，&lt;br /&gt;
但pdb的設定要先看一下，&lt;br /&gt;
istio在安裝時，ingressgateway會同時設定pdb，&lt;br /&gt;
當pod只有1個的時候，是沒辦法驅逐的，&lt;br /&gt;
所以最好是預設ingressgateway 為 2個pod，這樣才能避免pdb的干擾，而導致無法驅逐。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl drain [node-name] --force --ignore-daemonsets --delete-local-data
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;drain的參數&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--force&lt;/code&gt;&lt;br /&gt;
當一些pod不是經 ReplicationController, ReplicaSet, Job, DaemonSet 或者 StatefulSet 管理時&lt;br /&gt;
就需要用&lt;code&gt;--force&lt;/code&gt;來強制執行 (例如:&lt;strong&gt;kube-proxy&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--ignore-daemonsets&lt;/code&gt;&lt;br /&gt;
無視DaemonSet管理下的Pod&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--delete-local-data&lt;/code&gt;&lt;br /&gt;
如果有mount local volumn的pod，會強制殺掉該pod並把資料清除掉&lt;br /&gt;
另外如果跟本身的配置訊息有衝突時，drain就不會執行&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.nandiheath.com/2018/09/19/k8s-drain-pod-inside-node/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes中清空一個node的所有pod&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/tutorials/migrating-node-pool&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;文件-遷移工作負載&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/GKE/41.GKE節點無法自動縮小/" />
        </entry>
        <entry>
            <title>
                4. GKE使用GPU
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/GKE/4. GKE使用GPU/</id>
            <content type="html">
                &lt;h2 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;接了一個工作，要幫人在GKE上面生一個能夠使用GPU的叢集，並且佈署。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;要使用Google上面的 GPU，GKE版本要到1.9以上，&lt;br /&gt;
節點池要到1.11.3以上。&lt;br /&gt;
另外，GPU只支援通用N1的機器支援，其他細項 請詳閱 &lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/gpus?_ga=2.80461332.-2097975552.1599111033#availability&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Google 運行 GPU&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可用性建議先用&lt;br /&gt;
gcloud compute accelerator-types list&lt;br /&gt;
看一下你的區域支援哪些顯卡，&lt;br /&gt;
像我這邊的是  asia-east1-a ，就只支援特定顯卡。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/4.%20fig-1.jpg&quot; alt=&quot;4. fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;到 &lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/gpus?_ga=2.80461332.-2097975552.1599111033#installing_drivers&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;安裝 NVIDIA GPU 設備驅動程序&lt;/a&gt;，這邊基本上都沒問題。&lt;/p&gt;
&lt;p&gt;kubectl apply -f &lt;a href=&quot;https://raw.githubusercontent.com/GoogleCloudPlatform/container-engine-accelerators/master/nvidia-driver-installer/cos/daemonset-preloaded.yaml&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://raw.githubusercontent.com/GoogleCloudPlatform/container-engine-accelerators/master/nvidia-driver-installer/cos/daemonset-preloaded.yaml&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這主要會裝在每個節點上的Daemonset，當pod起來後，會自動在pod上面安裝驅動程式。&lt;br /&gt;
所以必須檢查一下，看pod是否有起來。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/4.%20fig-2.jpg&quot; alt=&quot;4. fig-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;也可以執行&lt;br /&gt;
kubectl describe node -l &lt;a href=&quot;http://cloud.google.com/gke-accelerator&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;cloud.google.com/gke-accelerator&lt;/a&gt; | grep &lt;a href=&quot;http://nvidia.com/gpu&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;nvidia.com/gpu&lt;/a&gt;&lt;br /&gt;
看顯卡的使用情況&lt;/p&gt;
&lt;p&gt;當執行下一步驟&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/gpus?_ga=2.80461332.-2097975552.1599111033#pods_gpus&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;配置 Pod 以使用 GPU&lt;/a&gt;時，這邊就會有問題了。&lt;br /&gt;
他的image(nvidia/cuda:10.0-runtime-ubuntu18.04)會無法啟動，一直在crashLoopbackoff。&lt;/p&gt;
&lt;p&gt;更新&lt;br /&gt;
在12/24有開工單詢問，他們那邊給出了解法。後續應該會改他們的文件。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/4.%20fig-4.jpg&quot; alt=&quot;4. fig-4.jpg&quot; /&gt;&lt;br /&gt;
google的回覆如下&lt;/p&gt;
&lt;p&gt;按照文檔簡單使用“command: [&amp;quot;/bin/bash&amp;quot;]”測試。此時bash執行後立刻退出，故pod被重啟。&lt;br /&gt;
你們可以嘗試使用以下死循環避免這個問題：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        command: [ &amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;--&amp;quot; ]
        args: [ &amp;quot;while true; do sleep 600; done;&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以，可以改成下面的YAML，就能正常執行了。&lt;/p&gt;
&lt;p&gt;apiVersion: v1&lt;br /&gt;
kind: Pod&lt;br /&gt;
metadata:&lt;br /&gt;
name: gpu-pod&lt;br /&gt;
spec:&lt;br /&gt;
containers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name: digits-container&lt;br /&gt;
image: nvidia/cuda:10.0-runtime-ubuntu18.04&lt;br /&gt;
command: [ &amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;--&amp;quot; ]&lt;br /&gt;
args: [ &amp;quot;while true; do sleep 600; done;&amp;quot; ]&lt;br /&gt;
resources:&lt;br /&gt;
limits:&lt;br /&gt;
&lt;a href=&quot;http://nvidia.com/gpu:&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;nvidia.com/gpu:&lt;/a&gt; 1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下也可以使用&lt;br /&gt;
最後的解法是，不要用他的image。&lt;br /&gt;
完整 YAML&lt;/p&gt;
&lt;p&gt;apiVersion: v1&lt;br /&gt;
kind: Pod&lt;br /&gt;
metadata:&lt;br /&gt;
name: gpu-pod&lt;br /&gt;
spec:&lt;br /&gt;
containers:&lt;br /&gt;
- name: digits-container&lt;br /&gt;
image: nvidia/digits:6.0&lt;br /&gt;
resources:&lt;br /&gt;
limits:&lt;br /&gt;
&lt;a href=&quot;http://nvidia.com/gpu:&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;nvidia.com/gpu:&lt;/a&gt; 1&lt;/p&gt;
&lt;p&gt;佈署完後，執行&lt;br /&gt;
kubectl exec gpu-pod  -- nvidia-smi&lt;br /&gt;
這段話的意思是，在gpu-pod裡面執行 nvidia-smi的指令&lt;br /&gt;
正常的話，會顯示如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/4.%20fig-3.jpg&quot; alt=&quot;4. fig-3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;下面參考的文件，可以看看，但目前只需要做到上面那段『安裝 NVIDIA GPU 設備驅動程序』的指令即可&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://github.com/NVIDIA/k8s-device-plugin/issues/106&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;CrashLoopBackOff message wen running GPU Jobs example and others&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://gist.github.com/danisla/77afbb88f215d116f1905f723d3d879d&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GPU Sharing on GKE DaemonSet&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.hwchiu.com/gpu-gke.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Install GPU in GKE(Google Kubernetes Engine)（中）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查詢各有哪些VM使用GPU的指令&lt;br /&gt;
gcloud compute instances list --format=&amp;quot;table(guestAccelerators.acceleratorCount, name)&amp;quot;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/GKE/4. GKE使用GPU/" />
        </entry>
        <entry>
            <title>
                39.solrCloud的初體驗
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/GKE/39.solrCloud的初體驗/</id>
            <content type="html">
                &lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;傻瓜操作，都是在UI上面執行。&lt;br /&gt;
但solr都是使用api的方式做動作。&lt;br /&gt;
所以下面的操作改成api是也可行的。&lt;/p&gt;
&lt;h2 id=&quot;基本篇&quot; tabindex=&quot;-1&quot;&gt;基本篇&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;新增資料&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/39-fig.1.jpg&quot; alt=&quot;39-fig.1.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;查詢資料&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/39-fig.2.jpg&quot; alt=&quot;39-fig.2.jpg&quot; /&gt;&lt;br /&gt;
基本的查詢方式，&lt;br /&gt;
如果要查筆數的話，將rows 改成 0 ，就會列出所有筆數。&lt;br /&gt;
但不會顯示任何資料。&lt;/li&gt;
&lt;li&gt;刪除所有資料&lt;br /&gt;
如果要刪除單筆，只要修改條件即可&lt;br /&gt;
將 &lt;em&gt;:&lt;/em&gt; 改成要搜尋的條件，&lt;br /&gt;
(e.g. videoId: 28748)&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/39-fig.3.jpg&quot; alt=&quot;39-fig.3.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	&amp;lt;delete&amp;gt;&amp;lt;query&amp;gt;*:*&amp;lt;/query&amp;gt;&amp;lt;/delete&amp;gt;  
	&amp;lt;commit/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://www.itread01.com/content/1548988760.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;solr刪除資料的四種方法&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.w3cschool.cn/solr_doc&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Solr官方文檔&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;進階篇&quot; tabindex=&quot;-1&quot;&gt;進階篇&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查詢指令&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/39-fig.4.jpg&quot; alt=&quot;39-fig.4.jpg&quot; /&gt;&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/wbcg111/article/details/47863261&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Solr 查詢參數&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/496373/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;solr搜尋詳解&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.w3cschool.cn/solr_doc/solr_doc-kcas2fx9.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Solr查詢界面&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看collection的架構&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	http http://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/solr/&amp;lt;collectionName&amp;gt;/schema/fields
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://solr.apache.org/guide/6_6/schema-api.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Schema API&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;搜尋中文字，欄位結構 text_general vs string&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般我們搜尋中文要額外安裝中文分詞，這樣搜尋關鍵字的時候，才會正確。&lt;br /&gt;
沒裝的話，會有下面的情況。&lt;br /&gt;
例如，搜尋 『中文』 ，但這樣會將欄位裡面除了有『中文』的資料撈出來以外，還會將資料中有『中』的字取出。&lt;/p&gt;
&lt;p&gt;但後來同事有發現另一種解法，建立結構的時候，不能選擇 text_general，必須要選 string。&lt;/p&gt;
&lt;p&gt;如果使用string的話，要注意的是只接受完整的文字搜尋。也就是一串文字中，搜尋的關鍵字要完全符合才會顯示。&lt;/p&gt;
&lt;p&gt;而text_general，可接受部分的文字搜尋，但缺點就是搜尋中文時，會有上面的狀況。&lt;/p&gt;
&lt;p&gt;結構使用string的話，如果改使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	*中文*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這種搜尋方式，就只會搜尋資料中有『中文』關鍵字的資料，字串不會被拆開查詢。&lt;/p&gt;
&lt;p&gt;本來是要使用&lt;a href=&quot;https://wiki.shileizcc.com/confluence/pages/viewpage.action?pageId=40567076&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;中文分詞&lt;/a&gt;，但後來也不用了。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;solr的外掛套件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本來官方是提供&lt;a href=&quot;https://solr.apache.org/guide/6_6/adding-custom-plugins-in-solrcloud-mode.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;blob store API安裝套件&lt;/a&gt;，&lt;br /&gt;
但在 solrCloud 8.4 ，有多出了一個功能 package managr&lt;br /&gt;
可使用簡單且快速的方式安裝plugin。&lt;/p&gt;
&lt;p&gt;但因為上面的第三點，所以也不用研究這塊了。&lt;br /&gt;
留下一些參考網址，留着以後查詢。&lt;/p&gt;
&lt;p&gt;初步看都是在solr 啟動時要加一個指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-Denable.packages=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這個應該是在yaml佈署的時候，就要加上去了。&lt;br /&gt;
yaml佈署時，&lt;a href=&quot;https://kubernetes.io/zh/docs/tasks/inject-data-application/define-command-argument-container/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;為容器設置啟動時要執行的命令和參數&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也有在猜測，未來應該是可以直接使用 solr operator安裝的時候一並設定，但目前參數沒有看到，看未來會不會新增。&lt;a href=&quot;https://artifacthub.io/packages/helm/apache-solr/solr-operator/0.3.0&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Solr Operator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://solr.apache.org/guide/8_4/package-manager.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Package Management&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://solr.pl/en/2020/04/13/solr-8-4-0-plugin-management/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Solr 8.4.0 – Plugin Management&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sematext.com/blog/solr-plugins-system/#toc-solr-plugin-management-0&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Working with Solr Plugins System&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.w3cschool.cn/solr_doc/solr_doc-ez8q2i2v.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;在SolrCloud模式下添加自定義插件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/GKE/39.solrCloud的初體驗/" />
        </entry>
        <entry>
            <title>
                37.SolrCloud on GKE
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/GKE/37.SolrCloud on GKE/</id>
            <content type="html">
                &lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h2 id=&quot;solr&quot; tabindex=&quot;-1&quot;&gt;Solr的架構&lt;/h2&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.itread01.com/content/1550200885.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;淺談Solr叢集架構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;完整架構&lt;br /&gt;
&lt;img src=&quot;https://solr.apache.org/images/operator/k8s-primary-components.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
SolrCloud是基於 Solr 與 &lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.vercel.app/404&quot;&gt;blog.36.分佈式系統-Zookeeper&lt;/a&gt;搜尋方案。&lt;/p&gt;
&lt;p&gt;特色功能有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集中式的配置資訊&lt;/li&gt;
&lt;li&gt;自動容錯&lt;/li&gt;
&lt;li&gt;近實時搜尋&lt;/li&gt;
&lt;li&gt;查詢時自動負載平衡&lt;/li&gt;
&lt;li&gt;自動分發&lt;/li&gt;
&lt;li&gt;日誌跟蹤&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;solrCloud的架構，可以看看以下幾篇。&lt;br /&gt;
ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://solr.apache.org/operator/articles/explore-v030-gke.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Exploring the Apache Solr Operator v0.3.0 on GKE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/Hello_World_QWP/article/details/98726379&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SolrCloud分佈式企業搜索引擎架構原理解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itread01.com/content/1548041589.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;solrCloud架構&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_41030039/article/details/100539704&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SolrCloud集群架構&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這邊直接開始安裝吧。&lt;/p&gt;
&lt;p&gt;首先確定你的電腦有helm ，我試著找有沒有單純可以用 kubectl apply的方式安裝，但沒找到。所以，用helm吧。&lt;br /&gt;
ref.&lt;a href=&quot;https://artifacthub.io/packages/helm/apache-solr/solr-operator&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;solr-operator&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先增加solr的倉庫&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	helm repo add apache-solr https://solr.apache.org/charts

	helm repo update	
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;安裝 solr-operator，指定安裝在 solr的 namespace，避免istio的istio-proxy安裝進去&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;
	kubectl create -f https://solr.apache.org/operator/downloads/crds/v0.3.0/all-with-dependencies.yaml

	helm install solr-operator apache-solr/solr-operator &#92;
  --version 0.3.0 --namespace solr

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;operator 安裝完成 (fig.1)&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/37-fig.1.jpg&quot; alt=&quot;37-fig.1.jpg&quot; /&gt;&lt;br /&gt;
(fig.1)&lt;br /&gt;
3. solrCloud.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: solr.apache.org/v1beta1
kind: SolrCloud
metadata:
  name: video
  namespace: solr
spec:
  customSolrKubeOptions:
    podOptions:
      resources:
        limits:
          memory: 3Gi
        requests:
          cpu: 700m
          memory: 3Gi
  dataStorage:
    persistent:
      pvcTemplate:
        spec:
          resources:
            requests:
              storage: 2Gi
      reclaimPolicy: Delete
  replicas: 3
  solrImage:
    repository: solr
    tag: 8.8.2
  solrJavaMem: -Xms500M -Xmx500M
  updateStrategy:
    method: StatefulSet
  zookeeperRef:
    provided:
      chroot: /explore
      image:
        pullPolicy: IfNotPresent
        repository: pravega/zookeeper
        tag: 0.2.9
      persistence:
        reclaimPolicy: Delete
        spec:
          accessModes:
          - ReadWriteOnce
          resources:
            requests:
              storage: 2Gi
      replicas: 3
      zookeeperPodPolicy:
        resources:
          limits:
            memory: 500Mi
          requests:
            cpu: 250m
            memory: 500Mi
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;佈署 solrCloud.yaml，這邊的系統資源要求頗高，資源不夠請多開一些cpu 或 memory。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	kubectl apply -f solrCloud.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;由於我是直接佈署在istio上面，所以開啟網頁的話，我是直接新增 virtualService的設定。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kind: VirtualService
metadata:
  name: istio-virtualservice-tools
  namespace: tools
spec:
  hosts:
  - &amp;quot;*&amp;quot;
  gateways:
    - istio-gateway-tools.istio-system.svc.cluster.local
  http:
  - match:
        - uri:
            exact: /
        - uri:
            prefix: /solr
    name: solr
    route:
        - destination:
            host: video-solrcloud-common.solr.svc.cluster.local
            port:
              number: 80  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以直接在本機上使用port-forward轉發開啟網頁。如以下指令，開啟 網頁 &lt;a href=&quot;http://localhost:8080/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;http://localhost:8080&lt;/a&gt;   (fig.2)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	kubectl port-forward service/video-solrcloud-common -n solr 8080:80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/37-fig.2.jpg&quot; alt=&quot;37-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;solr-cloud&quot; tabindex=&quot;-1&quot;&gt;監控 solrCloud&lt;/h1&gt;
&lt;p&gt;本來的solrCloud舊有簡易的監控畫面了，&lt;br /&gt;
這部分是看記憶體的使用量。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/37-fig.3.jpg&quot; alt=&quot;37-fig.3.jpg&quot; /&gt;&lt;br /&gt;
但可有發現資料並不是非常得多。&lt;br /&gt;
之前在GKE的叢集上已經有架設prometheus了，&lt;br /&gt;
所以這次也要將資料丟進去prometheus裡面。&lt;/p&gt;
&lt;p&gt;這邊要先export solr的metric，&lt;br /&gt;
官方 github上面有建議的方法 ，但需安裝 prometheus operator。如果沒有安裝，prometheus 在探索metrics時，是找不到這個exporter的。&lt;br /&gt;
ref.&lt;a href=&quot;https://apache.github.io/solr-operator/docs/solr-prometheus-exporter/#deploy-prometheus-exporter-for-solr-metrics&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Deploy Prometheus Exporter for Solr Metrics&lt;/a&gt;，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: solr.apache.org/v1beta1
kind: SolrPrometheusExporter
metadata:
 labels:
   controller-tools.k8s.io: &amp;quot;1.0&amp;quot;
 name: explore-prom-exporter
 namespace: solr
spec:
 customKubeOptions:
   podOptions:
     resources:
       requests:
         cpu: 300m
         memory: 800Mi
 solrReference:
   cloud:
     name: &amp;quot;video&amp;quot;
 numThreads: 6
 image:
   repository: solr
   tag: 8.8.2
---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
 name: solr-metrics
 labels:
   release: prometheus-stack
spec:
 selector:
   matchLabels:
     solr-prometheus-exporter: explore-prom-exporter
 namespaceSelector:
   matchNames:
   - solr
 endpoints:
 - port: solr-metrics
   interval: 15s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因為我不想裝 prometheus operator，所以複製上面安裝的deploy yaml，自己產生一個solr exporter 的deploy跟 service給 prometheus抓資料。&lt;/p&gt;
&lt;p&gt;或許有人會問，為什麼不利用上面的部屬完後去修改service.yaml把&lt;br /&gt;
&lt;a href=&quot;http://prometheus.io/port:&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;prometheus.io/port:&lt;/a&gt; &amp;quot;80&amp;quot;&lt;br /&gt;
改成&lt;br /&gt;
&lt;a href=&quot;http://prometheus.io/port:&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;prometheus.io/port:&lt;/a&gt; &amp;quot;8080&amp;quot;&lt;br /&gt;
就好了。&lt;/p&gt;
&lt;p&gt;因為，改了後他會一直還原成舊的狀態。&lt;br /&gt;
這應該是 solrOperator的關係，會一直覆蓋手動修改的設定，因為我也找不到去修改增加solrOperator的設定，讓80改成8080，所以應該透過上面的  ServiceMonitor 來讓prometheus可以取得資料。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
 namespace: solr
 name: explore-prom-exporter
 annotations:
   deployment.kubernetes.io/revision: &amp;quot;1&amp;quot;
 # generation: 1
 labels:
   controller-tools.k8s.io: &amp;quot;1.0&amp;quot;
   solr-prometheus-exporter: explore-prom-exporter
   technology: solr-prometheus-exporter
spec:
 progressDeadlineSeconds: 600
 replicas: 1
 revisionHistoryLimit: 10
 selector:
   matchLabels:
     solr-prometheus-exporter: explore-prom-exporter
     technology: solr-prometheus-exporter
 strategy:
   rollingUpdate:
     maxSurge: 25%
     maxUnavailable: 25%
   type: RollingUpdate
 template:
   metadata:
     creationTimestamp: null
     labels:
       controller-tools.k8s.io: &amp;quot;1.0&amp;quot;
       solr-prometheus-exporter: explore-prom-exporter
       technology: solr-prometheus-exporter
   spec:
     containers:
     - args:
       - -p
       - &amp;quot;8080&amp;quot;
       - -n
       - &amp;quot;6&amp;quot;
       - -z
       - video-solrcloud-zookeeper-0.video-solrcloud-zookeeper-headless.solr.svc.cluster.local:2181,video-solrcloud-zookeeper-1.video-solrcloud-zookeeper-headless.solr.svc.cluster.local:2181,video-solrcloud-zookeeper-2.video-solrcloud-zookeeper-headless.solr.svc.cluster.local:2181/explore
       - -f
       - /opt/solr/contrib/prometheus-exporter/conf/solr-exporter-config.xml
       command:
       - /opt/solr/contrib/prometheus-exporter/bin/solr-exporter
       image: solr:8.8.2
       imagePullPolicy: IfNotPresent
       livenessProbe:
         failureThreshold: 3
         httpGet:
           path: /metrics
           port: 8080
           scheme: HTTP
         initialDelaySeconds: 20
         periodSeconds: 10
         successThreshold: 1
         timeoutSeconds: 1
       name: solr-prometheus-exporter
       ports:
       - containerPort: 8080
         name: solr-metrics
         protocol: TCP
       resources:
         requests:
           cpu: 300m
           memory: 800Mi
       terminationMessagePath: /dev/termination-log
       terminationMessagePolicy: File
     dnsPolicy: ClusterFirst
     restartPolicy: Always
     schedulerName: default-scheduler
     securityContext:
       fsGroup: 8080
     terminationGracePeriodSeconds: 10    

--- 

apiVersion: v1
kind: Service
metadata:
 namespace: solr
 name: explore-prom-exporter
 annotations:
   prometheus.io/path: /metrics
   prometheus.io/port: &amp;quot;8080&amp;quot;
   prometheus.io/scheme: http
   prometheus.io/scrape: &amp;quot;true&amp;quot;
 creationTimestamp: &amp;quot;2021-09-03T05:52:23Z&amp;quot;
 labels:
   controller-tools.k8s.io: &amp;quot;1.0&amp;quot;
   service-type: metrics
   solr-prometheus-exporter: explore-prom-exporter
spec:
 ports:
 - name: solr-metrics
   port: 80
   protocol: TCP
   targetPort: 8080
 selector:
   solr-prometheus-exporter: explore-prom-exporter
   technology: solr-prometheus-exporter
 sessionAffinity: None
 type: ClusterIP    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最後到prometheus看一下有沒有關於solr的資料(fig.4)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/GKE/37-fig.4.jpg&quot; alt=&quot;37-fig.4.jpg&quot; /&gt;&lt;br /&gt;
(fig.4)&lt;/p&gt;
&lt;p&gt;有資料了，但我們不知道要拿哪些metrics來作爲監控的資料，就先去grafana dashboard找找吧。&lt;br /&gt;
&lt;a href=&quot;https://grafana.com/grafana/dashboards/12456&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Solr Dashboard&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下載，匯入grafana收工。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://apache.github.io/solr-operator/docs/solr-prometheus-exporter/#deploy-prometheus-exporter-for-solr-metrics&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Solr Prometheus Exporter&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;結尾&quot; tabindex=&quot;-1&quot;&gt;結尾&lt;/h1&gt;
&lt;p&gt;再來就是，實際操作 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/GKE/39.solrCloud%E7%9A%84%E5%88%9D%E9%AB%94%E9%A9%97/&quot;&gt;39.solrCloud的初體驗&lt;/a&gt;了&lt;/p&gt;
&lt;p&gt;額外參考，雖然此連結已經不適用，但基本的安裝方式是可以參考。&lt;br /&gt;
&lt;a href=&quot;https://cloud.tencent.com/developer/article/1580031&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Running Solr on Kubernetes&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/GKE/37.SolrCloud on GKE/" />
        </entry>
        <entry>
            <title>
                76. k8s error,The node was low on resource..
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/76. k8s error,The node was low on resource../</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;之前發生過的，&lt;br /&gt;
prometheus會這樣、gitlab最近在弄新版的CI/CD也跑這個出來。&lt;br /&gt;
本來想要之後有空再解決，但最近被DDOS攻擊時，&lt;br /&gt;
發現監控的grafana會卡住，因為他的prometheus ram爆了~~&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/blog.76-fig.1.jpg&quot; alt=&quot;blog.76-fig.1.jpg&quot; /&gt;&lt;br /&gt;
從字面上看來，其實蠻好理解的，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The node was low on resource: memory. Container web was using 4236080Ki, which exceeds its request of 0.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;node的資源不夠了，container 使用量達到上限。&lt;/p&gt;
&lt;p&gt;最直覺的方式就是，資源不夠，那就加開資源阿。&lt;br /&gt;
但開資源前要先想一下，如果我開了，那未來資源就一定夠嗎？&lt;br /&gt;
開的資源又不一定是完全給prometheus用，他供應的是全體的pod。&lt;/p&gt;
&lt;p&gt;所以要先做的是，把 resources request 的加進去 pod裡面。&lt;br /&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;template:
  metadata:
    creationTimestamp: null
    labels:
      app: webhook
      version: v1
  spec:
    containers:
    - image: prom/prometheus:v2.28.0
      imagePullPolicy: Always
      name: prometheus
      ports:
      - containerPort: 80
        protocol: TCP
      resources:
        requests:
          cpu: 30m
          memory: 30Mi
        limits:
          memory: &amp;quot;128Mi&amp;quot;
          cpu: &amp;quot;500m&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊要特別注意 limit，當limit踩到上限時，這個pod就會被終止&lt;br /&gt;
，並引發記憶體不足(OOM)的錯誤。&lt;br /&gt;
所以 limit 要設嗎？？&lt;/p&gt;
&lt;p&gt;這邊要從掛載的服務去決定，&lt;br /&gt;
如果今天掛載的服務 ram的使用量通常不多，&lt;br /&gt;
那突然達到上限，是不是可以判斷這個服務有問題了，必須要重啟。&lt;/p&gt;
&lt;p&gt;但如果是使用prometheus，記憶體的量本來就會隨着metric的量而增加，&lt;br /&gt;
那就不適合加上去了，不然只會一直看到 記憶體不足的錯誤。&lt;/p&gt;
&lt;p&gt;後面的單位，可設定 Ki, Mi ,Gi...&lt;/p&gt;
&lt;p&gt;補充，&lt;/p&gt;
&lt;p&gt;當node資源不足時，刪除pod的先後順序為，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;沒有設定 request 跟 limit的 pod&lt;/li&gt;
&lt;li&gt;只要有pod設定 request 或 limit ，但使用的資源是比在資源上設置的請求還多。&lt;/li&gt;
&lt;li&gt;只要有pod設定 request 或 limit ，但使用的資源是比在資源上設置的請求還少。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h2&gt;
&lt;p&gt;先設定 request ，因node機器的擴展，是根據 request的值，&lt;br /&gt;
來判斷要不要增加node數量，如果沒設定request，&lt;br /&gt;
系統會認爲，沒有擴展的必要。就會導致前面的問題。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.padok.fr/en/blog/kubernetes-pods-evicted&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Why my pods are evicted on Kubernetes?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/scheduling-eviction/node-pressure-eviction/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;節點壓力驅逐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/configuration/manage-resources-containers/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;為容器管理資源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#how-does-scale-up-work&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How does scale-up work?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/76. k8s error,The node was low on resource../" />
        </entry>
        <entry>
            <title>
                42.k8s PDB（pod中斷預算）
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/42.k8s PDB（pod中斷預算）/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;K8S真是 TXD博大精深......，&lt;/p&gt;
&lt;p&gt;沒想到再追&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/GKE/41.GKE%E7%AF%80%E9%BB%9E%E7%84%A1%E6%B3%95%E8%87%AA%E5%8B%95%E7%B8%AE%E5%B0%8F/&quot;&gt;41.GKE節點無法自動縮小&lt;/a&gt;的時候，會到這邊來。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;簡單來說，這個設定是用來避免pod被無預警的刪除。&lt;br /&gt;
當發生自願中斷的時候，讓此pod不會因為pod的數量過少，&lt;br /&gt;
而導致服務中斷。&lt;/p&gt;
&lt;p&gt;這個跟 HPA有點像，但HPA是根據設定，來決定pod要不要增加或減少。&lt;/p&gt;
&lt;p&gt;自願中斷通常是下面三種：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排空（drain）節點進行修復或升級&lt;/li&gt;
&lt;li&gt;從集群中排空節點以縮小集群（瞭解集群自動擴縮）。&lt;/li&gt;
&lt;li&gt;從節點中移除一個 Pod，以允許其他 Pod 使用該節點。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我們一般直接下指令看有哪些pdb在系統內&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get pdb -A
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/42-fig.1.jpg&quot; alt=&quot;42-fig.1.jpg&quot; /&gt;&lt;br /&gt;
(fig.1)&lt;/p&gt;
&lt;p&gt;建立pdb，主要有兩個參數 看是要設定 minAvailable (最小可用)或 maxUnavailable(最大不可用)。&lt;/p&gt;
&lt;p&gt;建完後，可以看一下ALLOWED DISRUPTIONS 這個欄位，&lt;br /&gt;
這個欄位表示目前該pod可以被中斷的pod數量。&lt;/p&gt;
&lt;p&gt;所以如果為0的話，您的自願中斷那些操作，&lt;br /&gt;
是不會動作的，會一直waiting，直到這個值不為0。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/workloads/pods/disruptions/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;干擾(Disruptions)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh/docs/tasks/run-application/configure-pdb/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;為應用程序設置干擾預算(Disruption Budget)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/10987576.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kubernetes之PDB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itread01.com/content/1559872864.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kubernetes之PDB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/42.k8s PDB（pod中斷預算）/" />
        </entry>
        <entry>
            <title>
                27.K8s的節點選擇與污染
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/27.K8s的節點選擇與污染/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近碰到的問題，起因是單台的對外連線數過大，導致程式發生問題，無法再連線到外部網路。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;在 GCP網路對外的方式裡面有提到，對外連線時，如果是私有叢集會使用Cloud NAT，&lt;br /&gt;
本次的情形，是因為再該節點內，某一個deploy疑似將連線數吃滿，最近想通了，應該是節點數量的問題。&lt;/p&gt;
&lt;h2 id=&quot;node-selector&quot; tabindex=&quot;-1&quot;&gt;nodeSelector&lt;/h2&gt;
&lt;p&gt;所以要將某一個服務，獨立掛在單一的節點池上面。&lt;br /&gt;
最簡單的用法是  nodeSelector，在 spec.template.spec 的下一層。&lt;/p&gt;
&lt;p&gt;app : websocket  這個是label 在建立nodepool時，一併建立的。&lt;br /&gt;
也可在建立nodepool後，在手動新增label。當然也可以直接指定google賦予的label。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/27-fig.1.jpg&quot; alt=&quot;27-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  查詢label
  kubectl get nodes --show-label
  新增label
  kubectl label node &amp;lt;node name&amp;gt; &amp;lt;label&amp;gt;=&amp;lt;value&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tachingchen.com/tw/blog/kubernetes-assigning-pod-to-nodes/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes 分派 Pod 到指定節點&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;deploy的範例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: deployabc
spec:
  replicas: 10
  template:
    spec:
      .......
      nodeSelector:
        app: websocket
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/node-pools#deploy&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;將 Pod 部署到特定節點池&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/scheduling-eviction/assign-pod-node/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;將 Pod 分配給節點&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;節點污點&quot; tabindex=&quot;-1&quot;&gt;節點污點&lt;/h2&gt;
&lt;p&gt;剛上面有提到，deploy可以指定pod到特定的節點，但是當前面的節點滿了後，其他的deploy還是有可能會到特定的節點上。&lt;br /&gt;
k8s可以設定節點為 污點(Taint)，使此污染的節點，只能接受有容忍度的pod。&lt;/p&gt;
&lt;p&gt;污點的設定不能事後更新，所以要在一開始建立時就設定好。請注意(fig.2)的Taint。&lt;br /&gt;
另外建議統一由GKE的節點污點，從控制台建立或使用指令建立。&lt;br /&gt;
否則當node自動新增時，該節點並不會產生 Taits&lt;br /&gt;
設定時，要指定 key 與 value 以及 效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/27-fig.2.jpg&quot; alt=&quot;27-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;效果有以下三種：&lt;/p&gt;
&lt;p&gt;- NoSchedule：不能容忍此污點的 Pod 不會被調度到節點上；現有 Pod 不會從節點中逐出。&lt;br /&gt;
- PreferNoSchedule：Kubernetes 會避免將不能容忍此污點的 Pod 安排到節點上。&lt;br /&gt;
- NoExecute：如果 Pod 已在節點上運行，則會將該 Pod 從節點中逐出；如果尚未在節點上運行，則不會將其安排到節點上。&lt;/p&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/node-taints?hl=zh-cn#gcloud_1&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;用節點污點控制調度&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之後在deploy上面建立容忍(toleration)污點， 在 spec.template.spec 的下一層&lt;br /&gt;
其中 key 與 value 為自訂，效果請參考上面選擇。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: deployabc
spec:
  replicas: 10
  template:
    spec:
      .......
    tolerations:
    - key: &amp;quot;visible&amp;quot;
      operator: &amp;quot;Equal&amp;quot;
      value: &amp;quot;private&amp;quot;
      effect: &amp;quot;NoExecute&amp;quot;
      tolerationSeconds: 3600
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;補充，如果是舊的節點集區，在GKE上面，可以改使用這個label去選擇。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cloud.google.com/gke-nodepool: &amp;lt;節點池的名稱&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/scheduling-eviction/taint-and-toleration/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;污點和容忍度&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10221929&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;k8s進階篇（四）：Affinity and Anti-Affinity、Taints and Tolerations&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/27.K8s的節點選擇與污染/" />
        </entry>
        <entry>
            <title>
                193. pod debug方式
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/193. pod debug方式/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;這陣子建了一個新環境，&lt;br /&gt;
然後pod在第一次啓動時，都會重啓，&lt;br /&gt;
但一旦重啓就看不到之前的log。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;log&quot; tabindex=&quot;-1&quot;&gt;看上一次的log記錄&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;kubectl logs {PODNAME} --previous
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他用法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Return snapshot logs from pod nginx with only one container
kubectl logs nginx

# Return snapshot of previous terminated ruby container logs from pod web-1
kubectl logs -p -c ruby web-1

# Begin streaming the logs of the ruby container in pod web-1
kubectl logs -f -c ruby web-1

# Display only the most recent 20 lines of output in pod nginx
kubectl logs --tail=20 nginx

# Show all logs from pod nginx written in the last hour
kubectl logs --since=1h nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref .&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@tasslin/k8s%E5%A6%82%E4%BD%95%E6%96%B9%E4%BE%BF%E6%9F%A5%E6%89%BE%E4%BA%8B%E4%BB%B6%E7%99%BC%E7%94%9F%E6%88%96%E6%98%AF%E5%8F%96%E5%BE%97%E5%B7%B2%E6%B6%88%E9%80%9D%E7%9A%84log%E7%B4%80%E9%8C%84-8bb7ee2505f8&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;K8s如何方便尋找事件發生或是取得已消逝的LOG紀錄&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jamesdefabia.github.io/docs/user-guide/kubectl/kubectl_logs/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kubectl logs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;pod&quot; tabindex=&quot;-1&quot;&gt;連進去pod裏面監控&lt;/h3&gt;
&lt;p&gt;有時會碰到這個pod沒有權限可以安裝htop或 top等等，&lt;br /&gt;
這些看系統效能的東西，&lt;br /&gt;
此時可以透過這種方式，直接外掛一個debug的image，&lt;br /&gt;
就能隨便你亂搞了，還不怕會影響到正在執行的pod。&lt;/p&gt;
&lt;p&gt;下面指令的意思是，連去 filebeat的pod。&lt;br /&gt;
如果要指定container的話，增加 &lt;code&gt;--target=filebeat&lt;/code&gt;的指令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    kubectl debug -it &#92;
    --container=debug-container &#92;
    --image=alpine &#92;
    filebeat-beat-filebeat-bcb666b79-vm6dt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://medium.com/datamindedbe/debugging-running-pods-on-kubernetes-2ba160c47ef5&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Debugging Running Pods on Kubernetes&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/193. pod debug方式/" />
        </entry>
        <entry>
            <title>
                192. 自建的k8s拉取private registry
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/192. 自建的k8s拉取private registry/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;開發環境上，之前拉得都是另一個專案的registry，&lt;br /&gt;
現在有個全新的專案，理所當然image應該拉去另一個地方的GAR。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;首先到IAM裏面，申請一個ServiceAccount，&lt;br /&gt;
然後給權限，可以只給 &lt;code&gt;Artifact Registry讀取者&lt;/code&gt;就好。&lt;br /&gt;
然後產生金鑰，名稱為&lt;code&gt;gar-push-bms.json&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/192-fig.1.jpg&quot; alt=&quot;192-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;建立screct，名稱取名爲&lt;code&gt;gar-pull&lt;/code&gt;&lt;br /&gt;
stackoverflow的說明指出，該email是沒在用的，所以可以隨便打。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubectl create secret docker-registry gar-pull &#92;
  --docker-server &amp;quot;https://asia-east1-docker.pkg.dev&amp;quot; &#92;
  --docker-username _json_key &#92;
  --docker-email gar-pull@.iam.gserviceaccount.com &#92;
  --docker-password=&amp;quot;$(cat gar-push-bms.json)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;deployment的yaml設定&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;  imagePullSecrets:
  - name: gar-pull
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;記得，如果在不同的namespace，需重新建立新的secret。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/36283660/creating-image-pull-secret-for-google-container-registry-that-doesnt-expire&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Creating image pull secret for google container registry that doesn&#39;t expire?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/artifact-registry/docs/docker/authentication?hl=zh-cn#linux-macos&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;為 Docker 設定身份驗證&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/192. 自建的k8s拉取private registry/" />
        </entry>
        <entry>
            <title>
                172. 自建k8s版本升級
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/172. 自建k8s版本升級/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡唸&quot; tabindex=&quot;-1&quot;&gt;睡睡唸&lt;/h1&gt;
&lt;p&gt;有人說他要測試&lt;a href=&quot;https://airensoft.com/ome.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;OME(OverMediaEngine)&lt;/a&gt;，串流直播軟體，說比&lt;a href=&quot;https://github.com/ossrs/srs&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SRS&lt;/a&gt;好一些，但自建的k8s版本不夠，不能上gateway API，所以升級吧。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;更新前請先確認版本更新後，你的服務不會掛掉。&lt;br /&gt;
更新大版本時，會有API棄用的狀況， &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/162.%E6%9F%A5%E8%A9%A2%E5%B7%B2%E6%A3%84%E7%94%A8%E7%9A%84API/&quot;&gt;162.查詢已棄用的API&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;目標&quot; tabindex=&quot;-1&quot;&gt;目標&lt;/h2&gt;
&lt;p&gt;更新k8s的master一臺與node兩臺的版本&lt;/p&gt;
&lt;h2 id=&quot;步驟&quot; tabindex=&quot;-1&quot;&gt;步驟&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;查詢目前的版本&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kuberctl version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（這是目前版本，升級當時的版本為1.22.?)&lt;br /&gt;
server的版本為1.25.14&lt;/p&gt;
&lt;blockquote Major:1,=&quot;&quot; Minor:25,=&quot;&quot; GitVersion:v1.25.14,=&quot;&quot; GitCommit:a5967a3c4d0f33469b7e7798c9ee548f71455222,=&quot;&quot; GitTreeState:clean,=&quot;&quot; BuildDate:2023-09-13T09:04:55Z,=&quot;&quot; GoVersion:go1.20.8,=&quot;&quot; Compiler:gc,=&quot;&quot; Platform:linuxamd64=&quot;&quot;&gt;
&lt;p&gt;Server Version:  &lt;a href=&quot;http://version.info/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;version.Info&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;升級kubeadm&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# 查看所有可用的kubeadm的版本
yum list --showduplicates kubeadm --disableexcludes=kubernetes
# 然後升級kubeadm的版本到1.23.0
yum install -y kubeadm-1.23.0-0 --disableexcludes=kubernetes
# 查看kubeadm版本
kubeadm version
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;升級master控制&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kubeadm upgrade plan
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/172-fig.1.jpg&quot; alt=&quot;172-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;這邊碰到一個問題，我本來只想升級到1.23.0，&lt;br /&gt;
但上面這張圖，他要求直接到1.23.17，&lt;br /&gt;
不照做行不行，『不行』，升級會出錯。&lt;/p&gt;
&lt;p&gt;所以回到第二步，再度更新kubeadm到1.23.17&lt;/p&gt;
&lt;p&gt;再來一次&lt;code&gt;kubeam upgrade plan&lt;/code&gt;&lt;br /&gt;
這次沒出現警告了&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/172-fig.2.jpg&quot; alt=&quot;172-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;執行上面執行完&lt;code&gt;upgrade plan&lt;/code&gt;提供升級指令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kubeadm upgrade apply v1.23.17 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成後會看到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SUCCESS! Your cluster was upgraded to &amp;quot;v1.23.17&amp;quot;. Enjoy!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/172-fig.3.jpg&quot; alt=&quot;172-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;升級kubectl 與 kubelet&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;查看目前節點版本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kubectl get node -o wide
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;驅逐當下節點的pod（這段與參考來源的指令不一樣，這個比較暴力）&lt;br /&gt;
$master為節點的名稱&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kubectl drain --force --ignore-daemonsets --delete-local-data --grace-period=10 &amp;quot;$master&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等驅逐完後，確認node為&lt;code&gt;SchedulingDisabled&lt;/code&gt;狀態，就可已開始升級了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;yum install -y kubelet-1.23.17-0 kubectl-1.23.17-0 --disableexcludes=kubernetes
# 重啓服務
sudo systemctl daemon-reload
sudo systemctl restart kubelet

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查詢node版本是否已經更新，然後解除封鎖。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kubectl uncordon $node
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;升級node的版本&lt;br /&gt;
重複第四步驟，只有更新那一段&lt;code&gt;yum install....&lt;/code&gt;需要到目標的node機器上做。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以指令如下&lt;br /&gt;
$node為要更新的node主機&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# master主機
kubectl drain --force --ignore-daemonsets --delete-local-data --grace-period=10 &amp;quot;$node&amp;quot;
# node主機
yum install -y kubelet-1.23.17-0 kubectl-1.23.17-0 --disableexcludes=kubernetes
# 重啓服務
sudo systemctl daemon-reload
sudo systemctl restart kubelet
# master主機
kubectl uncordon $node
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://tinychen.com/20221224-k8s-12-kubeadm-upgrade-cluster/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;k8s系列12-kubeadm升級k8s叢集 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Upgrading kubeadm clusters&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/172. 自建k8s版本升級/" />
        </entry>
        <entry>
            <title>
                162.查詢已棄用的API
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/162.查詢已棄用的API/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;這件事說來突然，&lt;br /&gt;
某一天我就發現在GKE上面出現了警告訊息，&lt;br /&gt;
說我的GKE仍在使用已棄用的API，&lt;br /&gt;
但我搬到1.25版本已經是一個多月前的事情了，&lt;br /&gt;
也沒聽到有人在說服務掛掉，&lt;br /&gt;
百思不得其解。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/162-fig.1.jpg&quot; alt=&quot;162-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;再來使用了 &lt;a href=&quot;https://github.com/doitintl/kube-no-trouble&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kubent&lt;/a&gt; ，來尋找到底是哪一個服務卡住，&lt;br /&gt;
但很遺憾的都沒有搜尋到。&lt;/p&gt;
&lt;p&gt;過了幾天後，發現之前拿來測試的QA環境，&lt;br /&gt;
也跳出來了已棄用API警告通知。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/162-fig.2.jpg&quot; alt=&quot;162-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;發現GKE就有提示是什麼呼叫的了，&lt;br /&gt;
在QA環境很清楚的寫着kubent，&lt;br /&gt;
但本來的那個呢？&lt;br /&gt;
只有 v2.1.0 ，&lt;br /&gt;
於是根據這個關鍵字去找哪個image有這個版本號。&lt;/p&gt;
&lt;p&gt;在kube-state-metric上面找到了這個關鍵字，&lt;br /&gt;
這也符合為什麼出錯了沒人知道，&lt;br /&gt;
因爲沒人看（？）&lt;br /&gt;
但因爲metric來源有至少三套，所以不好發現。&lt;br /&gt;
不過這個前任建置的也有點奇怪，&lt;br /&gt;
我查了官方的&lt;a href=&quot;https://github.com/kubernetes/kube-state-metrics&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kube-state-metrics&lt;/a&gt;，&lt;br /&gt;
沒找到有用sts建立過的方式，&lt;br /&gt;
有點神奇。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/162-fig.3.jpg&quot; alt=&quot;162-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;先拿QA來驗證改改看了，&lt;br /&gt;
看後續會不會再跳出來警告&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/162.查詢已棄用的API/" />
        </entry>
        <entry>
            <title>
                151. kubeadm重新產生驗證
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/151. kubeadm重新產生驗證/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;事情發生在某一天，&lt;br /&gt;
突然有個人跑來跟我說，他該怎麼連樓上自建的k8s，&lt;br /&gt;
那時在處理其他東西，就說我等等給你。&lt;br /&gt;
再來，突然發現我自己連不上去，一直跳錯誤。&lt;br /&gt;
unable to connect to server: x509: certificate has expired or is not yet valid&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;使用openLen連線時，出現錯誤。當下認爲應該是金鑰有問題，&lt;br /&gt;
但那臺機器應該很久沒動了，當初k8s也不是我架起來的，&lt;br /&gt;
頭痛阿。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;proxy_server.go:147 Error while proxying request: x509: certificate has expired or is not yet valid&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;從這篇&lt;a href=&quot;https://blog.51cto.com/u_13963804/6055113&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;K8S自建叢集更換證書&lt;/a&gt;知道了一件事情&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通過kubeadm自建的叢集，初始化後會生成一年的證書，簽發的CA證書有效期默認是10年，簽發的apiserver證書有效期默認是1年&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再問一下其他單位的同事，那個環境是不是已經架一年了？&lt;br /&gt;
結果出來，差不多一年了，那可以判斷是金鑰過期，但還是必須到機器裏面檢查一下。&lt;/p&gt;
&lt;p&gt;用ssh或任意方式連到master主機上，&lt;br /&gt;
視權限變更使用者，&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;strong&gt;我在執行kubeadm的時候，全程使用root的帳號&lt;/strong&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;檢查憑證到期日&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;kubeadm certs check-expiration
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;發現真的過期了，重建吧。&lt;br /&gt;
參考下面連結發現有點問題，可能是因為版本有更新。&lt;br /&gt;
ref. &lt;a href=&quot;https://juejin.cn/post/7068909995701567501&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;解決kubernetes證書過期問題&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;kubeadm certs renew # 這樣有問題，會發生錯誤
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;kubeadm missing subcommand; &amp;quot;renew&amp;quot; is not meant to be run on its own&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查詢&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/kubeadm-certs/#cmd-certs-renew&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;官方文件&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;kubeadm certs renew all
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行完成後，在檢查一次到期日，是否已經變更。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;kubeadm certs check-expiration
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但此時還是沒辦法連線，需更新kube config，&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;strong&gt;這邊使用一般使用者帳號&lt;/strong&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mv config config.old cp -i /etc/kubernetes/admin.conf $HOME/.kube/config chown $(id -u):$(id -g) $HOME/.kube/config sudo chmod 644 $HOME/.kube/config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;p.s 上面的文章說要重啟kube-apiserver,kube-controller,kube-scheduler,etcd 這四個容器，但我沒重啓，因為我這台master主機根本沒找到docker，這部分我也很疑惑。&lt;br /&gt;
但一切都正常了，就先這樣吧。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;結尾&quot; tabindex=&quot;-1&quot;&gt;結尾&lt;/h3&gt;
&lt;p&gt;如果要從其他地方連到k8s master，檔案就在&lt;code&gt;/etc/kubernetes/admin.conf&lt;/code&gt;裏面了。&lt;br /&gt;
不過官方強烈建議，不要將admin.conf與其他人共享。&lt;br /&gt;
最好是另外開一個使用者，&lt;br /&gt;
這部分我研究下，改天在寫篇文章了吧&lt;/p&gt;
&lt;p&gt;相關資訊：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 kubeadm 進行憑證管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/setup/best-practices/certificates/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; PKI 證書和要求&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/151. kubeadm重新產生驗證/" />
        </entry>
        <entry>
            <title>
                144. k8s 的sercret複製
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/144. k8s 的sercret複製/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;本地的k8s機器，要去google artifact registry pull image ，發現沒權限。&lt;br /&gt;
以前的權限在namespace的 default上面，&lt;br /&gt;
default太肥了，實在不想再往那邊塞，&lt;br /&gt;
要麻自己創個SA再把json丟去驗證，&lt;br /&gt;
不然看能不能把舊的拿來用。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;複製&quot; tabindex=&quot;-1&quot;&gt;複製&lt;/h3&gt;
&lt;p&gt;參考  &lt;a href=&quot;https://fabianlee.org/2021/04/09/kubernetes-copying-a-secret-from-one-namespace-to-another/&quot; title=&quot;Kubernetes: copying a secret from one namespace to another&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes: copying a secret from one namespace to another&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get secret my-tlssecret --namespace=default -o yaml | sed &#39;s/namespace: .*/namespace: gameservice/&#39; | kubectl apply -f -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本來my-tlssecret 在 defaul上 ，要改到gamerservice&lt;/p&gt;
&lt;p&gt;這樣就不用再申請一個sa帳號搞認證了，&lt;br /&gt;
如果要從頭開始的話，&lt;br /&gt;
參考google官方文件&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/artifact-registry/docs/docker/authentication?hl=zh-cn#linux_1&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;為 Docker 設定身份驗證&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;解密&quot; tabindex=&quot;-1&quot;&gt;解密&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;kubectl get secret test-grafana -n monitoring -o jsonpath=&#39;{.data.admin-user}&#39; |base64 --decode; echo
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/144. k8s 的sercret複製/" />
        </entry>
        <entry>
            <title>
                143. k8s取得登入憑證
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/143. k8s取得登入憑證/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;幫同事新建一組drone 自動部署的新專案，&lt;br /&gt;
要發版到自建的k8s上面，&lt;br /&gt;
終於碰到我不想面對的東西了。&lt;br /&gt;
kube_ca ，kube_token  ，我哪知道這兩個東西在哪裏阿&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;從 &lt;a href=&quot;https://github.com/vallard/drone-kube/blob/master/DOCS.md&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Drone Kubernetes&lt;/a&gt;可以知道，一個是使用者，一個是ca認證的key，&lt;br /&gt;
但我還不知道去哪生這兩個東西出來。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;KUBE_TOKEN&lt;/strong&gt; This plugin has one authentication method and that is to use the token to authorize the user.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;KUBE_CA&lt;/strong&gt; This should be the base64 encoding of your certificate authority. You can get this string by running the command:&lt;/p&gt;
&lt;p&gt;跑去問了一下chatGPT，得到答案。&lt;br /&gt;
執行指令前，必須先連到你要取得的cluster上。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep cluster-admin | awk &#39;{print $1}&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我的列出有很多個，就拿第一個看起來也最像的來用了。&lt;br /&gt;
admin-user-token-tm7g4&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/143-fig.1.jpg&quot; alt=&quot;143-fig.1.jpg&quot; /&gt;&lt;br /&gt;
這邊就會看到token。&lt;/p&gt;
&lt;p&gt;再來是ca&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl config view --raw --minify --flatten -o jsonpath=&#39;{.clusters[].cluster.certificate-authority-data}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/143-fig.2.jpg&quot; alt=&quot;143-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;放到drone上面，驗證，收工。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/143-fig.3.jpg&quot; alt=&quot;143-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/authentication/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用者認證&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/143. k8s取得登入憑證/" />
        </entry>
        <entry>
            <title>
                139. openlens add pod shell or logs button
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/139. openlens add pod shell or logs button/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;len在6.X版本後，要登入才能用。&lt;br /&gt;
那個時候也正好跳去openlens，在那之前都可以從pod右上角的按鈕，&lt;br /&gt;
快速進入到pod裏面，或是查pod log，但在6.2.4之後就消失了。&lt;br /&gt;
直到現在6.4.10(寫這篇時的版本)，還是沒有。&lt;br /&gt;
最後得知是因為Lens才把那段移掉。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;安裝方式&quot; tabindex=&quot;-1&quot;&gt;安裝方式&lt;/h3&gt;
&lt;p&gt;到 Extensions  直接貼上下面的來源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@alebcay/openlens-node-pod-menu
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/139-fig.2.jpg&quot; alt=&quot;139-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;來源&quot; tabindex=&quot;-1&quot;&gt;來源&lt;/h3&gt;
&lt;p&gt;主要是框起來的功能，&lt;br /&gt;
對於比較不熟悉的kubectl指令的人來說，非常實用。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/139-fig.1.jpg&quot; alt=&quot;139-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以當初沒有的時候，反而是我同事無法接受。&lt;br /&gt;
至少我還能用指令的方式查我要的東西。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl exec -it pod_name bash
kubectl logs pod_name 
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;今天心血來潮查查看有沒有相關問題，是bug還是已移除。&lt;br /&gt;
才知道了，原來是Lens把它從openLens移除，&lt;br /&gt;
詳細可參考下面連結&lt;br /&gt;
&lt;a href=&quot;https://github.com/lensapp/lens/issues/6819&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://github.com/lensapp/lens/issues/6819&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/lensapp/lens/issues/6823&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;OpenLens 6.3.0 - No Logs or Shell buttons&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之後再試試其他的 &lt;a href=&quot;https://github.com/devtron-labs/devtron&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; devtron&lt;/a&gt; 或 &lt;a href=&quot;https://github.com/kubeshop/monokle&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Monokle&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/139. openlens add pod shell or logs button/" />
        </entry>
        <entry>
            <title>
                137. kubecolor 直觀的kubectl
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/137. kubecolor 直觀的kubectl/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;剛好看到有人的文章說 kubecolor美美的kubectl就來試用了XD&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;mac  or linux 安裝&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;brew install hidetatz/tap/kubecolor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kubecolor get pod 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/137-fig.1.jpg&quot; alt=&quot;137-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;但我平常打kubectl打習慣了，突然要改用那個覺得好麻煩，&lt;br /&gt;
改別名吧&lt;/p&gt;
&lt;p&gt;新增別名&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;alias kubectl=&amp;quot;kubecolor&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;移除別名&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;unalias kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但這個只有暫時，要永久的話，需要到.bash_profile設定&lt;br /&gt;
mac 是在 個人目錄底下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;沒有的話，就新建檔案，然後輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alias kubectl=&amp;quot;kubecolor&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;p.s mac 的環境變數載入順序為&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/etc/profile -&amp;gt;  /etc/paths -&amp;gt;  ~/.bash_profile -&amp;gt;  ~/.bash_login -&amp;gt;  ~/.profile -&amp;gt;  ~/.bashrc&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ref&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hidetatz/kubecolor&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kubecolor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.796t.com/p/1133106.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;mac 組態環境變數，講的太仔細了，非常棒&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/137. kubecolor 直觀的kubectl/" />
        </entry>
        <entry>
            <title>
                123.Helm 使用方式
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/123.Helm 使用方式/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;最近要用coturn，看到有人用helm 架在k8s上面，就順便來試試了。&lt;br /&gt;
之前剛開始接觸k8s，碰到helm一堆錯誤，無法執行。&lt;br /&gt;
現在想應該是裏面有些設定要修改的關係，&lt;br /&gt;
現在應該會比較好了吧！？&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h2 id=&quot;架構&quot; tabindex=&quot;-1&quot;&gt;架構&lt;/h2&gt;
&lt;p&gt;helm的架構，可先產生一個範例檔，&lt;br /&gt;
看有哪些東西。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm create ezio
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;在Helm裏面，將kubernetes的應用程式稱為Chart&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;tree ezio

ezio
├── Chart.yaml
├── charts
├── templates
│   ├── NOTES.txt
│   ├── _helpers.tpl
│   ├── deployment.yaml
│   ├── hpa.yaml
│   ├── ingress.yaml
│   ├── service.yaml
│   ├── serviceaccount.yaml
│   └── tests
│       └── test-connection.yaml
└── values.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Chart.yaml ：包含了chart的內容描述&lt;/li&gt;
&lt;li&gt;charts(folder) ：此目錄可能包含了其他不同的 chart，也可稱為 &lt;code&gt;subcharts&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;templates(folder)：此目錄為要部署的所有類型範本&lt;/li&gt;
&lt;li&gt;values.yaml ： 參數設定檔，所有的變數都寫在這。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;templates內寫的參數，通常為&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.Values.replicas&lt;/code&gt;：表示values.yaml裏面的replicas參數&lt;/p&gt;
&lt;p&gt;其他非values的取得方式，參考 &lt;a href=&quot;https://godleon.github.io/blog/DevOps/Helm-v3-Chart-Template-Guide/#Built-in-Objects&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Built-in Objects&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;template有一些可能會用到的函數，&lt;br /&gt;
主要有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pipeline ( linux 裏面常見到的 &lt;code&gt;|&lt;/code&gt; )&lt;/li&gt;
&lt;li&gt;if/else&lt;/li&gt;
&lt;li&gt;with（&lt;a href=&quot;http://xn--vb-xm3cq78y.net/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;類似vb.net&lt;/a&gt; 的with）&lt;/li&gt;
&lt;li&gt;range(for loop)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;cheatsheet&quot; tabindex=&quot;-1&quot;&gt;Cheatsheet&lt;/h2&gt;
&lt;h4 id=&quot;dry-run&quot; tabindex=&quot;-1&quot;&gt;dry-run&lt;/h4&gt;
&lt;p&gt;先查看helm所產生的yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm install --dry-run coturn ./coturn 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;設定參數&quot; tabindex=&quot;-1&quot;&gt;設定參數&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;helm install coturn ./conturn --set certificate.enabled=false 

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;values-yaml&quot; tabindex=&quot;-1&quot;&gt;指定values.yaml&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;helm install coturn ./conturn -f myval.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;namespace&quot; tabindex=&quot;-1&quot;&gt;指定namespace&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;helm install coturn ./conturn -n tools
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;helm&quot; tabindex=&quot;-1&quot;&gt;看helm列表&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;  helm ls
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;chart&quot; tabindex=&quot;-1&quot;&gt;更新chart&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;helm upgrade coturn ./coturn
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;chart-1&quot; tabindex=&quot;-1&quot;&gt;移除chart&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;helm uninstall coturn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://godleon.github.io/blog/DevOps/Helm-v3-Chart-Template-Guide/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Helm] Helm v3 使用簡介&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10238998&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Helm介紹&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/123.Helm 使用方式/" />
        </entry>
        <entry>
            <title>
                118. kubernetes Dashboard
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/118. kubernetes Dashboard/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;以前GKE用習慣了，現在變成自建的k8s，只能用lens管，&lt;br /&gt;
雖然說不上有哪不足，但總是怪怪的。&lt;br /&gt;
今天查資料看到有這個UI，就架來看看了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;本機訪問&quot; tabindex=&quot;-1&quot;&gt;本機訪問&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/web-ui-dashboard/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;官方文件&lt;/a&gt;，安裝下去就好了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.1/aio/deploy/recommended.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行轉發來連到dashboard&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl proxy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;kubectl 會使得 Dashboard 可以通過 &lt;a href=&quot;http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/&lt;/a&gt; 訪問。&lt;/p&gt;
&lt;p&gt;登入畫面如下&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/118-fig.1.jpg&quot; alt=&quot;118-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;再來就需要產生一組token來做登入了。&lt;/p&gt;
&lt;p&gt;首先建立一組serviceAccount&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cat &amp;lt;&amp;lt;EOF | kubectl create -f -  
apiVersion: v1  
kind: ServiceAccount  
metadata:  
  name: admin
  namespace: kube-system  
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;綁定serviceAccount 與 角色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cat &amp;lt;&amp;lt;EOF | kubectl create -f -  
apiVersion: rbac.authorization.k8s.io/v1 
kind: ClusterRoleBinding  
metadata:  
  name: admin-user  
roleRef:  
  apiGroup: rbac.authorization.k8s.io  
  kind: ClusterRole  
  name: cluster-admin  
subjects:  
- kind: ServiceAccount  
  name: admin
  namespace: kube-system  
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Service Account建立完後，Kubernetes Token Controller 就會自動的為其產生一個 &lt;strong&gt;secret&lt;/strong&gt; resource(名稱為 &lt;code&gt;[SERVICE_ACCOUNT_NAME]-token-[RANDOM_STRING]&lt;/code&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin | awk &#39;{print $1}&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/118-fig.2.jpg&quot; alt=&quot;118-fig.2.jpg&quot; /&gt;&lt;br /&gt;
這邊取得的token即可在  Dashboard 上登入。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://godleon.github.io/blog/Kubernetes/k8s-Deploy-and-Access-Dashboard/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; 佈署 &amp;amp; 存取 Kubernetes Dashboard&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;外部訪問&quot; tabindex=&quot;-1&quot;&gt;外部訪問&lt;/h3&gt;
&lt;p&gt;更改service 內的 kubernetes-dashboard.kubenetes-dashboards&lt;br /&gt;
將cluster改成NodePort ，然後看對應的port多少就能登入了。&lt;br /&gt;
記得用https&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/118-fig.3.jpg&quot; alt=&quot;118-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.  &lt;a href=&quot;https://github.com/kubernetes/dashboard/tree/master/docs/user/accessing-dashboard&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;accessing-dashboard&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/118. kubernetes Dashboard/" />
        </entry>
        <entry>
            <title>
                105. linux系統時間與k8s
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/105. linux系統時間與k8s/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近弄之前的人自建的k8s，&lt;br /&gt;
才碰到一堆問題，&lt;br /&gt;
我的linux果然需要加強orz&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;linux&quot; tabindex=&quot;-1&quot;&gt;一般的linux內的時間顯示&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;timedatectl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/105.fig-1.jpg&quot; alt=&quot;105.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Local time  ：本機時間&lt;br /&gt;
Universal time ： UTC時間&lt;br /&gt;
RTC time： 硬體時間&lt;br /&gt;
NTP service : 自動效時&lt;br /&gt;
Time Zone: 時區&lt;/p&gt;
&lt;p&gt;當時間不對時，可以設定時間的自動效正&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;timedatectl set-ntp yes 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;設定完後，等一下（多久不確定，但不會立即），&lt;br /&gt;
UTC的時間應該就會自己效對。&lt;/p&gt;
&lt;p&gt;NTP伺服器（有需要再設定）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://time.google.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;time.google.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查詢各時區&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;timedatectl list-timezones
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;設定時區&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;timedatectl set-timezone Asia/Taipei
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://officeguide.cc/ubuntu-linux-timedatectl-time-synchronization-tutorial/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Ubuntu Linux 使用 timedatectl 校正時間、時區教學與範例&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;pod&quot; tabindex=&quot;-1&quot;&gt;Pod的時區設定&lt;/h3&gt;
&lt;p&gt;pod的時間會跟他所在的node時間一致，&lt;br /&gt;
所以當你的node 主機時間錯時，&lt;br /&gt;
pod的時間也會跟着錯。&lt;/p&gt;
&lt;p&gt;但基本上都是UTC，&lt;br /&gt;
如果要指定時區的話，&lt;br /&gt;
可以用volume掛載成特定地區。&lt;br /&gt;
或是直接在build image時，一併更改。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;pvc 掛載&lt;br /&gt;
時區檔案的位置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: Pod
metadata:
  name: busybox-sleep
spec:
  containers:
  - name: busybox
    image: busybox
    args:
    - sleep
    - &amp;quot;1000000&amp;quot;
    volumeMounts:
    - name: tz-config
      mountPath: /etc/localtime
  volumes:
    - name: tz-config
      hostPath:
        path: /usr/share/zoneinfo/Europe/Prague
        type: File
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Dockerfile更改&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &#92;
		 &amp;amp;&amp;amp; echo &amp;quot;Asia/Shanghai&amp;quot; &amp;gt; /etc/timezone
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gushiciku.cn/pl/gSGc/zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;k8s環境下處理容器時間問題的多種姿勢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/61947696/date-and-time-synchronization-among-the-pods-and-host-in-kubernetes&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;date and time synchronization among the pods and host in kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/105. linux系統時間與k8s/" />
        </entry>
        <entry>
            <title>
                104. rabbitmq operator安裝
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/104. rabbitmq operator安裝/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;接到同事說要裝rabbitmq，&lt;br /&gt;
說之前在dev有裝過，但在k8s上面沒看到，&lt;br /&gt;
用之前留下的yaml，會裝不起來，只好從頭來了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;本來是想參考他的&lt;a href=&quot;https://github.com/rabbitmq/diy-kubernetes-examples&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;這篇&lt;/a&gt;，結果看到第一段說
&lt;h3 id=&quot;stop-there-is-a-better-way&quot; tabindex=&quot;-1&quot;&gt;Stop! There is a Better Way!&lt;/h3&gt;
才知道rabbitmq有出了operator可供安裝。&lt;/li&gt;
&lt;li&gt;安裝rabbitmq operator&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubectl apply -f &amp;quot;https://github.com/rabbitmq/cluster-operator/releases/latest/download/cluster-operator.yml&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.rabbitmq.com/kubernetes/operator/install-operator.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Installing RabbitMQ Cluster Operator in a Kubernetes Cluster&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;部署yaml&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: rabbitmq.com/v1beta1
kind: RabbitmqCluster
metadata:
  name: dev-rabbitmq
spec:
  replicas: 3
  rabbitmq:
    additionalConfig: |
      default_user=admin
      default_pass=abc123
  service:
    type: NodePort

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因為是自建的k8s，沒有lb，所以就用NodePort了。&lt;br /&gt;
更詳細的參數請參考下面連結。&lt;br /&gt;
ref. &lt;a href=&quot;https://www.rabbitmq.com/kubernetes/operator/using-operator.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Using RabbitMQ Cluster Kubernetes Operator&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;問題排除&quot; tabindex=&quot;-1&quot;&gt;問題排除&lt;/h2&gt;
&lt;p&gt;中間有發生小插曲，k8s內沒有預設的storeageClass&lt;br /&gt;
導致建立pvc時發生錯誤，&lt;br /&gt;
雖然在上面的yaml上面能夠指定，&lt;br /&gt;
但可能是格式沒寫好，導致沒有產生statefuleSet 的pvc。&lt;br /&gt;
最後先指定目前的storageClass為預設的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl patch storageclass &amp;lt;your_storageclass_name&amp;gt; -p &#39;{&amp;quot;metadata&amp;quot;: {&amp;quot;annotations&amp;quot;:{&amp;quot;storageclass.kubernetes.io/is-default-class&amp;quot;:&amp;quot;true&amp;quot;}}}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://jeff-yen.medium.com/install-rabbitmq-in-kubernetes-8b009c28959f&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;install RabbitMQ in kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zamhuang.medium.com/rabbitmq-%E4%BA%94%E5%88%86%E9%90%98%E8%BC%95%E9%AC%86%E4%BA%86%E8%A7%A3-rabbitmq-%E9%81%8B%E4%BD%9C-fcaecbaa69d4&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;RabbitMQ】五分鐘輕鬆瞭解 RabbitMQ 運作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/104. rabbitmq operator安裝/" />
        </entry>
        <entry>
            <title>
                101. 批次修改hpa
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/101. 批次修改hpa/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;這又是因為懶惰而衍生出來的一篇，&lt;/p&gt;
&lt;p&gt;懶得一個一個點進去改HPA的數量，&lt;/p&gt;
&lt;p&gt;就寫sh搞定吧。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;參考 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/88.%E6%89%B9%E6%AC%A1%E4%BF%AE%E6%94%B9GCP%E7%9A%84label/&quot;&gt;88.批次修改GCP的label&lt;/a&gt;，建立一個文字檔 hpa.txt，&lt;br /&gt;
先用指令，將hpa的name取出存到文字檔內，因為是針對特定幾個修改，所以並沒有全拉。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get hpa;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文字檔內容如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;istio-yabo-api-prod-external
istio-yabo-api-prod-internal
istio-yabo-frontend-external-demo
istio-yabo-frontend-internal-demo
istio-yabo-frontend-prod-external
istio-yabo-frontend-prod-internal
istio-yabo-frontpage-external-prod
istio-yabo-frontpage-internal-prod
istio-yabo-huanggua-external-beta
istio-yabo-huanggua-external-prod
istio-yabo-huanggua-internal-beta
istio-yabo-huanggua-internal-prod
istio-yabo-landingpage-external-demo
istio-yabo-landingpage-external-prod
istio-yabo-landingpage-internal-demo
istio-yabo-landingpage-internal-prod
istio-yabo-pwa-external-prod
istio-yabo-pwa-internal-prod
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要是 kubectl patch hpa 做修改。&lt;br /&gt;
patch這功能看來頗強大，第一次見到，&lt;br /&gt;
改天可研究看看。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while read p; do                                                                                                                                             
  echo &amp;quot;$p&amp;quot;; kubectl patch hpa -p &#39;{&amp;quot;spec&amp;quot;:{&amp;quot;minReplicas&amp;quot;: 2}}&#39; -n istio-system $p; echo &amp;quot;done&amp;quot;;
done &amp;lt;hpa.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
-  &lt;a href=&quot;https://stackoverflow.com/questions/51808297/kubenetes-change-hpa-min-replica&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubenetes: change hpa min-replica&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://kubernetes.io/zh-cn/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 kubectl patch 更新 API 對象&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/101. 批次修改hpa/" />
        </entry>
        <entry>
            <title>
                0.K8s MOC
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/k8s/0.K8s MOC/</id>
            <content type="html">
                &lt;h1 id=&quot;基本概念&quot; tabindex=&quot;-1&quot;&gt;基本概念&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/27.K8s%E7%9A%84%E7%AF%80%E9%BB%9E%E9%81%B8%E6%93%87%E8%88%87%E6%B1%A1%E6%9F%93/&quot;&gt;27.K8s的節點選擇與污染&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/GKE/41.GKE%E7%AF%80%E9%BB%9E%E7%84%A1%E6%B3%95%E8%87%AA%E5%8B%95%E7%B8%AE%E5%B0%8F/&quot;&gt;41.GKE節點無法自動縮小&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/42.k8s%20PDB%EF%BC%88pod%E4%B8%AD%E6%96%B7%E9%A0%90%E7%AE%97%EF%BC%89/&quot;&gt;42.k8s PDB（pod中斷預算）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/105.%20linux%E7%B3%BB%E7%B5%B1%E6%99%82%E9%96%93%E8%88%87k8s/&quot;&gt;105. linux系統時間與k8s&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/123.Helm%20%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/&quot;&gt;123.Helm 使用方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/172.%20%E8%87%AA%E5%BB%BAk8s%E7%89%88%E6%9C%AC%E5%8D%87%E7%B4%9A/&quot;&gt;172. 自建k8s版本升級&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/192.%20%E8%87%AA%E5%BB%BA%E7%9A%84k8s%E6%8B%89%E5%8F%96private%20registry/&quot;&gt;192. 自建的k8s拉取private registry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/193.%20pod%20debug%E6%96%B9%E5%BC%8F/&quot;&gt;193. pod debug方式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;terraform&quot; tabindex=&quot;-1&quot;&gt;Terraform&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Terraform/82.%20Terraform%20vs%20Ansible/&quot;&gt;82. Terraform vs Ansible&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Terraform/147.%20%E7%94%A8chatGPT%E5%AD%B8Terraform/&quot;&gt;147. 用chatGPT學Terraform&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Terraform/148.%20Terraform%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/&quot;&gt;148. Terraform的基本概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Terraform/149.%20terraform%20%E9%83%A8%E7%BD%B2VM%EF%BC%8C%E5%95%93%E5%8B%95docker%E5%AE%89%E8%A3%9Dmetadata_startup_script/&quot;&gt;149. terraform 部署VM，啓動docker安裝metadata_startup_script&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;tools&quot; tabindex=&quot;-1&quot;&gt;Tools&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/118.%20kubernetes%20Dashboard/&quot;&gt;118. kubernetes Dashboard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/137.%20kubecolor%20%E7%9B%B4%E8%A7%80%E7%9A%84kubectl/&quot;&gt;137. kubecolor 直觀的kubectl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/139.%20openlens%20add%20pod%20shell%20or%20logs%20button/&quot;&gt;139. openlens add pod shell or logs button&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/162.%E6%9F%A5%E8%A9%A2%E5%B7%B2%E6%A3%84%E7%94%A8%E7%9A%84API/&quot;&gt;162.查詢已棄用的API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;yaml&quot; tabindex=&quot;-1&quot;&gt;yaml&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Yaml/2.%20k8s%20yaml%E6%92%B0%E5%AF%AB%20volume%20%E8%B8%A9%E5%9D%91%E7%AF%87/&quot;&gt;2. k8s yaml撰寫 volume 踩坑篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Yaml/12.%20k8s%20YAML%20%E5%B0%8F%E7%B4%B0%E7%AF%80/&quot;&gt;12. k8s YAML 小細節&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Yaml/85.%20gke-cronjob%E7%AD%86%E8%A8%98/&quot;&gt;85. gke-cronjob筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Yaml/87.kustomize%20%E5%85%B1%E7%94%A8label(optional%EF%BC%89/&quot;&gt;87.kustomize 共用label(optional）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Yaml/94.%20k8s%20%E7%B4%B0%E7%AF%80%E8%A3%9C%E5%85%85/&quot;&gt;94. k8s 細節補充&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Yaml/98.%20k8s%E4%B8%AD%E7%9A%84command%E8%88%87dockerfile%E7%9A%84%20CMD/&quot;&gt;98. k8s中的command與dockerfile的 CMD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Yaml/136.%20%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%AF%A9%E9%81%B8k8s%E7%9A%84deploy%E5%85%A7%E5%AE%B9/&quot;&gt;136. 一步步篩選k8s的deploy內容&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;gke&quot; tabindex=&quot;-1&quot;&gt;GKE&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/GKE/4.%20GKE%E4%BD%BF%E7%94%A8GPU/&quot;&gt;4. GKE使用GPU&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/GKE/37.SolrCloud%20on%20GKE/&quot;&gt;37.SolrCloud on GKE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/GKE/39.solrCloud%E7%9A%84%E5%88%9D%E9%AB%94%E9%A9%97/&quot;&gt;39.solrCloud的初體驗&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/GKE/44.srs%20%E5%BD%B1%E9%9F%B3%E4%B8%B2%E6%B5%81%20on%20GKE/&quot;&gt;44.srs 影音串流 on GKE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/GKE/50.GKE%20workload%20Identity%20%E5%AF%A6%E5%9C%B0%E6%BC%94%E7%B7%B4/&quot;&gt;50.GKE workload Identity 實地演練&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/GKE/56.%20GKE%E8%A8%98%E9%8C%84%20nginx%20log/&quot;&gt;56. GKE記錄 nginx log&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/GKE/70.%20GKE%20pvc%E9%82%84%E5%8E%9F/&quot;&gt;70. GKE pvc還原&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/GKE/71.gitlab%20on%20GKE%20%E7%81%BD%E5%AE%B3%E9%82%84%E5%8E%9F%E7%AD%86%E8%A8%98/&quot;&gt;71.gitlab on GKE 災害還原筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/101.%20%E6%89%B9%E6%AC%A1%E4%BF%AE%E6%94%B9hpa/&quot;&gt;101. 批次修改hpa&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/104.%20rabbitmq%20operator%E5%AE%89%E8%A3%9D/&quot;&gt;104. rabbitmq operator安裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/43.%E8%87%AA%E5%BB%BAECK%20on%20GKE/&quot;&gt;43.自建ECK on GKE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Yaml/74.%20kubernetes%20%E6%89%B9%E6%AC%A1%E6%AA%A2%E6%9F%A5yaml%E7%89%B9%E5%AE%9A%E5%AD%97%E5%85%83/&quot;&gt;74. kubernetes 批次檢查yaml特定字元&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/76.%20k8s%20error,The%20node%20was%20low%20on%20resource../&quot;&gt;76. k8s error,The node was low on resource..&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/144.%20k8s%20%E7%9A%84sercret%E8%A4%87%E8%A3%BD/&quot;&gt;144. k8s 的sercret複製&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/151.%20kubeadm%E9%87%8D%E6%96%B0%E7%94%A2%E7%94%9F%E9%A9%97%E8%AD%89/&quot;&gt;151. kubeadm重新產生驗證&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/k8s/troubleshooting-kubernetes.zh_cn.v2.png&quot; alt=&quot;troubleshooting-kubernetes.zh_cn.v2.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/k8s/0.K8s MOC/" />
        </entry>
        <entry>
            <title>
                89. istio 常見狀態碼
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/istio/89. istio 常見狀態碼/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近用istio偵測，常碰到某個服務狀態會掉到80%以下，&lt;br /&gt;
那時都有看到APM的程式報錯，但沒人反應，最近有次發生在上班時間，&lt;br /&gt;
馬上聯絡同事看他的服務有沒有正常，&lt;br /&gt;
最後一路追，&lt;br /&gt;
發現狀態碼是回 503 DC ，對這個關鍵字有印象，但常會忘記他的全名。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/89-fig.1.png&quot; alt=&quot;89-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;下列為envoy常見縮寫比對&lt;/p&gt;
&lt;p&gt;HTTP and TCP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UH&lt;/strong&gt;: No healthy upstream hosts in upstream cluster in addition to 503 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UF&lt;/strong&gt;: Upstream connection failure in addition to 503 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UO&lt;/strong&gt;: Upstream overflow (&lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/circuit_breaking#arch-overview-circuit-break&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;circuit breaking&lt;/a&gt;) in addition to 503 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NR&lt;/strong&gt;: No &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/http_routing#arch-overview-http-routing&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;route configured&lt;/a&gt; for a given request in addition to 404 response code, or no matching filter chain for a downstream connection.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;URX&lt;/strong&gt;: The request was rejected because the &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#envoy-v3-api-field-config-route-v3-retrypolicy-num-retries&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;upstream retry limit (HTTP)&lt;/a&gt; or &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto#envoy-v3-api-field-extensions-filters-network-tcp-proxy-v3-tcpproxy-max-connect-attempts&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;maximum connect attempts (TCP)&lt;/a&gt; was reached.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NC&lt;/strong&gt;: Upstream cluster not found.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DT&lt;/strong&gt;: When a request or connection exceeded &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-max-connection-duration&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;max_connection_duration&lt;/a&gt; or &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto#envoy-v3-api-field-extensions-filters-network-tcp-proxy-v3-tcpproxy-max-downstream-connection-duration&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;max_downstream_connection_duration&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP only&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DC&lt;/strong&gt;: Downstream connection termination.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LH&lt;/strong&gt;: Local service failed &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/health_checking#arch-overview-health-checking&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;health check request&lt;/a&gt; in addition to 503 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UT&lt;/strong&gt;: Upstream request timeout in addition to 504 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: Connection local reset in addition to 503 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UR&lt;/strong&gt;: Upstream remote reset in addition to 503 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UC&lt;/strong&gt;: Upstream connection termination in addition to 503 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DI&lt;/strong&gt;: The request processing was delayed for a period specified via &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/fault_filter#config-http-filters-fault-injection&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;fault injection&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FI&lt;/strong&gt;: The request was aborted with a response code specified via &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/fault_filter#config-http-filters-fault-injection&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;fault injection&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RL&lt;/strong&gt;: The request was ratelimited locally by the &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/rate_limit_filter#config-http-filters-rate-limit&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;HTTP rate limit filter&lt;/a&gt; in addition to 429 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UAEX&lt;/strong&gt;: The request was denied by the external authorization service.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RLSE&lt;/strong&gt;: The request was rejected because there was an error in rate limit service.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IH&lt;/strong&gt;: The request was rejected because it set an invalid value for a &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/http/router/v3/router.proto#envoy-v3-api-field-extensions-filters-http-router-v3-router-strict-check-headers&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;strictly-checked header&lt;/a&gt; in addition to 400 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SI&lt;/strong&gt;: Stream idle timeout in addition to 408 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DPE&lt;/strong&gt;: The downstream request had an HTTP protocol error.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UPE&lt;/strong&gt;: The upstream response had an HTTP protocol error.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UMSDR&lt;/strong&gt;: The upstream request reached max stream duration.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;OM&lt;/strong&gt;: Overload Manager terminated the request.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DF&lt;/strong&gt;: The request was terminated due to DNS resolution failure.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;envoy Access logging&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://www.cnblogs.com/xuliang666/p/12089915.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;istio之envoy常見術語及狀態碼&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/istio/89. istio 常見狀態碼/" />
        </entry>
        <entry>
            <title>
                75. istio virtual service 常用參數
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/istio/75. istio virtual service 常用參數/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;有些東西偶爾會用，但碰到時就忘了怎麼寫，&lt;br /&gt;
還要回去翻一下，&lt;br /&gt;
此篇包含&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;set/remove header&lt;/li&gt;
&lt;li&gt;match header host 正規表示&lt;/li&gt;
&lt;li&gt;fault 回傳特定狀態&lt;/li&gt;
&lt;li&gt;allow cors&lt;/li&gt;
&lt;li&gt;rewrite&lt;/li&gt;
&lt;li&gt;match uri 正規表示&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;當同一個virtual service內，有多個match uri時，優先順序，是由上到下。&lt;br /&gt;
　&lt;br /&gt;
例如：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;match:
	- uri:
			prefix : /api
	- uri:
		    prefix: /api/video		
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這樣是永遠到不了 /api/video的&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;set/remove header&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;add or modify header&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spec:
  http:
    - name: api
      headers:
        request:
          set:
            x-forward-for: 127.0.0.1
      match:
        - uri:
            prefix: /api
      
      route:
        - destination:
            host: reverse-proxy.abc.svc.cluster.local
            port:
              number: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;remove header&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spec:
  http:
    - name: api
      headers:
        request:
          remove:
            - x-forward-for
      match:
        - uri:
            prefix: /api
      
      route:
        - destination:
            host: reverse-proxy.abc.svc.cluster.local
            port:
              number: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;match header host&lt;br /&gt;
當 header host有對應到 這兩個 domain其中一個的話，&lt;br /&gt;
則轉到對應的路徑&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;http:
  - match:
      - headers:
          Host:
            regex: (api.asia.com|api.american.com)
        uri:
          prefix: /api-v2
    rewrite:
      uri: /api
    route:
      - destination:
          host: reverse-proxy.abc.svc.cluster.local
          port:
            number: 80
        weight: 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;符合正則的皆進入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
hosts:
  - &#39;*&#39;
gateways:
  - istio-system/istio-gateway-external
  - istio-system/istio-gateway-internal
http:
  - match:
      - headers:
          Host:
            regex: sxqa2.?&#92;.777.+&#92;.com
    route:
      - destination:
          host: video-admin-api-primary
          port:
            number: 80
        weight: 100
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;fault&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;當路徑有倒到 api/v1/abc時，直接回傳 487的錯誤碼。&lt;br /&gt;
（這其實是拿來模擬錯誤用的）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http:
  - fault:
      abort:
        httpStatus: 487
        percentage:
          value: 100
    match:
      - uri:
          prefix: /api/v1/abc
    name: fault
    route:
      - destination:
          host: reverse-proxy.abc.svc.cluster.local
          port:
            number: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;allow cors&lt;br /&gt;
開啟 cors的允許範圍&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;http:
  - corsPolicy:
      allowHeaders:
        - &#39;*&#39;
      allowOrigin:
        - &#39;*&#39;
    match:
      - uri:
          prefix: /api
    name: filedownload
    route:
      - destination:
          host:  reverse-proxy.abc.svc.cluster.local
          port:
            number: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;rewrite&lt;br /&gt;
覆寫本來的uri&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;http:
  - match:
      - uri:
          prefix: /apmapi
    name: api
    rewrite:
      uri: /api
    route:
      - destination:
          host: reverse-proxy.abc.svc.cluster.local
          port:
            number: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在api之後的通通進去，但這種就無法使用rewrite了。&lt;br /&gt;
因為會將uri全部取代掉。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http:
  - match:
      - uri:
          regex: ^/api/.*
    route:
      - destination:
          host: yabo-api-qa-primary
          port:
            number: 80
        weight: 100
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/istio/75. istio virtual service 常用參數/" />
        </entry>
        <entry>
            <title>
                73. istio sidecar 注入規則
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/istio/73. istio sidecar 注入規則/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;因為drone 的 kubernetes Runner的關係，&lt;br /&gt;
導致我有一個ns要預設取消istio inject，&lt;br /&gt;
但某些特定的pod要注入就失敗了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;先來看一張官方做的表(1)，&lt;br /&gt;
其實就很好解釋為什麼不會注入了。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;namespaceSelector match&lt;/th&gt;
&lt;th&gt;default policy&lt;/th&gt;
&lt;th&gt;Pod override annotation &lt;a href=&quot;http://sidecar.istio.io/inject&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;sidecar.istio.io/inject&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;Sidecar injected?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;enabled&lt;/td&gt;
&lt;td&gt;true (default)&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;enabled&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;disabled&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;disabled&lt;/td&gt;
&lt;td&gt;false (default)&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;enabled&lt;/td&gt;
&lt;td&gt;true (default)&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;enabled&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;disabled&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;disabled&lt;/td&gt;
&lt;td&gt;false (default)&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;各欄位解釋，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;namespaceSelector match：各namespace的 istio-inject是 enable或 disable&lt;/li&gt;
&lt;li&gt;default policy： 這個預設都是enable，要查看使用command或到configmap查看 istio-sidecar-injector&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;kubectl -n istio-system get configmap istio-sidecar-injector -o jsonpath=&#39;{.data.config}&#39; | grep policy:

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Pod override annotation ： 直接指定pod會不會注入的 annotation&lt;/li&gt;
&lt;li&gt;Sidecar injected ：結果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;結論，&lt;br /&gt;
namespace只要是 disabled的，通通不會inject sidecar&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
1. &lt;a href=&quot;https://istio.io/latest/docs/ops/configuration/mesh/injection-concepts/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Automatic Sidecar Injection&lt;/a&gt;&lt;br /&gt;
2. &lt;a href=&quot;https://istio.io/latest/zh/docs/ops/common-problems/injection/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Sidecar 自動注入問題&lt;/a&gt;&lt;br /&gt;
3. &lt;a href=&quot;https://morpheushuang.medium.com/istio-automatic-sidecar-injection-543-4981ae7375f7&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;關於Istio Automatic Sidecar Injection那檔事&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/istio/73. istio sidecar 注入規則/" />
        </entry>
        <entry>
            <title>
                7. Istio安裝及使用
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/istio/7. Istio安裝及使用/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;k8s還沒摸很熟，新的東西就過來了。&lt;br /&gt;
這次是server mesh架構...&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;前個工作還沒結束，新的東西就來了。&lt;br /&gt;
這次搞Istio，當然可以在東西都建立完後，再開始玩。&lt;br /&gt;
但這樣就會變成要把舊的pod砍掉重新建立了。&lt;/p&gt;
&lt;h2 id=&quot;istio&quot; tabindex=&quot;-1&quot;&gt;Istio 知識圖譜&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/servicemesher/istio-knowledge-map/master/png/istio-knowledge-map.png&quot; alt=&quot;image&quot; /&gt;&lt;br /&gt;
ref.&lt;a href=&quot;https://github.com/servicemesher/istio-knowledge-map&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio Knowledge Map&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安裝前&quot; tabindex=&quot;-1&quot;&gt;安裝前&lt;/h2&gt;
&lt;p&gt;有查到要安裝istio 有最低的資源限制，但沒看到有明確的指定。&lt;br /&gt;
目前測試GKE的機器  設成 cpu 1 ram 2G 會發生 timeout的錯誤，&lt;br /&gt;
改成 cpu 2,ram 4G 則無此狀況。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/7.fig-4.jpg&quot; alt=&quot;7.fig-4.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://stackoverflow.com/questions/64373346/istioctl-install-fails-with-multiple-timeouts&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;istioctl install fails with multiple timeouts&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;機器大小設定&quot; tabindex=&quot;-1&quot;&gt;機器大小設定&lt;/h2&gt;
&lt;p&gt;主要的節點區域，cpu則會吃到 900 mCPU，記憶體 2.75G&lt;br /&gt;
還沒安裝 kiali,jaeger,prometheus...等，&lt;br /&gt;
開機器大小時，需特別注意。&lt;/p&gt;
&lt;h2 id=&quot;開始安裝&quot; tabindex=&quot;-1&quot;&gt;開始安裝&lt;/h2&gt;
&lt;p&gt;這次要安裝在GKE上，此次安裝的配置是 minimal版，&lt;br /&gt;
各版本的差異，不要看中文的，沒有更新。如果要看原理可以看。&lt;br /&gt;
請參考 &lt;a href=&quot;https://istio.io/latest/docs/setup/additional-setup/config-profiles/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Installation Configuration Profiles&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; curl -L https://istio.io/downloadIstio | sh -
 cd istio-1.8.1
 export PATH=$PWD/bin:$PATH
 istioctl install
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;移除安裝&quot; tabindex=&quot;-1&quot;&gt;移除安裝&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;istioctl x uninstall --purge&lt;/code&gt;&lt;br /&gt;
(注意 purge會把共用的東西通通刪光光，不使用purge也可刪除，但會留下 deployment以及 service)&lt;br /&gt;
istioctl x uninstall -f /Users/ezio_liu/Documents/k8s/Sample-Yaml/istio-sample-newingeressway.yaml   （當初安裝的yaml)&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://istio.io/latest/docs/setup/getting-started/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Getting Started&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://istio.io/latest/docs/setup/install/istioctl/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Uninstall Istio&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安裝套件&quot; tabindex=&quot;-1&quot;&gt;安裝套件&lt;/h2&gt;
&lt;p&gt;在原目錄下執行&lt;/p&gt;
&lt;p&gt;kubectl apply -f samples/addons&lt;br /&gt;
第一次執行完可能會有錯誤，可以在執行一次。&lt;br /&gt;
因執行建置的機器，會有時間差。&lt;br /&gt;
ref. &lt;a href=&quot;https://github.com/istio/istio/tree/release-1.8/samples/addons&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Telemetry Addons&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;namespace-istio&quot; tabindex=&quot;-1&quot;&gt;在namespace上面 植入 istio&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;kubectl label namespaces auto istio-injection=enabled
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本來想使用自動植入，就是連這行也不用打。&lt;br /&gt;
但是 有些 k8s版本，本身會禁止這個行為，需要的話要另行打開。&lt;br /&gt;
ref. &lt;a href=&quot;https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/#automatic-sidecar-injection&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Automatic sidecar injection&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此時可建立一個pod ，就可看到裡面多了一個 container&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/7.%20fig-1.jpg&quot; alt=&quot;7. fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果植入sidecar失敗，出現&lt;br /&gt;
Internal error occurred: failed calling webhook &amp;quot;&lt;a href=&quot;http://sidecar-injector.istio.io/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;sidecar-injector.istio.io&lt;/a&gt;&amp;quot;: Post &lt;a href=&quot;https://istiod.istio-system.svc/inject?timeout=30s:&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://istiod.istio-system.svc:443/inject?timeout=30s:&lt;/a&gt; context deadline exceeded&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/7.fig-5.jpg&quot; alt=&quot;7.fig-5.jpg&quot; /&gt;&lt;br /&gt;
需開啟GKE的master防火牆規則，增加 tcp:15017 的 port&lt;br /&gt;
(題外話，如果要使用kiali的話，請開啟 tcp: 8080 的 port，不然你會看kiali一直在轉圈圈)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/7.fig-6.jpg&quot; alt=&quot;7.fig-6.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;不知道要設定哪個防火牆規則，可下指令尋找&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute firewall-rules list --filter=&amp;quot;name~gke-${CLUSTER_NAME}-[0-9a-z]*-master&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中的 ${CLUSTER_NAME} 需改為你要尋找的叢集名稱&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute firewall-rules update &amp;lt;firewall-rule-name&amp;gt; --allow tcp:10250,tcp:443,tcp:15017,tcp:8080
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://istio.io/latest/docs/setup/platform-setup/gke/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Google Kubernetes Engine&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;開啟套件&quot; tabindex=&quot;-1&quot;&gt;開啟套件&lt;/h2&gt;
&lt;p&gt;我是使用GKE，原本以為要能夠連到內部的服務，都要走外部ip&lt;br /&gt;
今天在亂點的時候，點到了這個地方，將那行指令複製，在本機執行。&lt;br /&gt;
前提是你的gcloud要有認證。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/7.%20fig-2.jpg&quot; alt=&quot;7. fig-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;他就能夠透過通訊埠轉發的方式存取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/7.%20fig-3.jpg&quot; alt=&quot;7. fig-3.jpg&quot; /&gt;&lt;br /&gt;
由(fig.3) 可以看到，他將本機的8080對到了service內的20001，&lt;br /&gt;
所以直接開啟網頁指向 localhost:8080 就可以看到該網頁的內容了。&lt;/p&gt;
&lt;h1 id=&quot;佈署時由上往下開始佈署&quot; tabindex=&quot;-1&quot;&gt;佈署時由上往下開始佈署&lt;/h1&gt;
&lt;h2 id=&quot;destination-rule&quot; tabindex=&quot;-1&quot;&gt;DestinationRule&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: localgo
  namespace: auto
spec:
  host: localgo
  trafficPolicy:
    loadBalancer:
      simple: LEAST_CONN
  subsets:
    - name: Localgov1
      labels:
        version: v1
    - name: v2
      labels:
        version: v2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/destination-rule/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Destination Rule&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;參數說明&lt;br /&gt;
trafficPolicy內的 loadBalancer:&lt;br /&gt;
代表的是幾種流量分發方式：&lt;br /&gt;
•Round_Robin： 輪詢演算法，顧名思義請求將會依次發給每一個例項，來共同分擔所有的請求。&lt;/p&gt;
&lt;p&gt;•Random： 隨機演算法，將所有的請求隨機分發給健康的例項&lt;/p&gt;
&lt;p&gt;•Least_Conn: 最小連線數，在所有健康的例項中任選兩個，將請求發給連線數較小的那一個例項。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.mdeditor.tw/pl/2AOq/zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;idou老師教你學Istio 19 : Istio 流量治理功能原理與實戰&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;virtual-service&quot; tabindex=&quot;-1&quot;&gt;VirtualService&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: localgo-vs
  namespace: auto
spec:
  hosts:
  - &amp;quot;*&amp;quot;
  gateways:
    - istio-ingressgateway
  http:
  - name: &amp;quot;route-v1&amp;quot;
    route:
    - destination:
        port:
          number: 80
        host: localgo.auto.svc.cluster.local    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#這裡就是指向你真正服務&quot;&gt;#這裡就是指向你真正服務&lt;/a&gt; service 的名稱喔
        subset: Localgov1   &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#這裡指的是DestinationRule的subset&quot;&gt;#這裡指的是DestinationRule的subset&lt;/a&gt;.name
      weight: 80
    - destination:
        port:
          number: 80
        host: localgo.auto.svc.cluster.local
        # 上面 destionation 下面的 host 名稱會這麼長，這是 k8s 內部實際 dns 全名，如果需要跨 namspace 存取，就需要用這樣的全名方式指定。
        # {service name}.{namespace}.svc.cluster.local 這就是它的規則
        subset: v2
      weight: 20
      corsPolicy:  ##限制
        allowOrigin:    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#允許所有來源&quot;&gt;#允許所有來源&lt;/a&gt;
          - &#39;*&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;corsPolicy 有以下的選項&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;allowOrigins&lt;/li&gt;
&lt;li&gt;allowMethods&lt;/li&gt;
&lt;li&gt;allowHeaders&lt;/li&gt;
&lt;li&gt;exposeHeaders&lt;/li&gt;
&lt;li&gt;maxAge&lt;/li&gt;
&lt;li&gt;allowCredentials&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;weight 則是用來做流量分配用的&lt;br /&gt;
同一個route內，相加必須 =100&lt;/p&gt;
&lt;p&gt;詳細說明，參考下面連結&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://istio.io/latest/zh/docs/reference/config/networking/virtual-service/#CorsPolicy&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;CorsPolicy細項設定&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然後在 這邊還有另一種是 match的用法，&lt;br /&gt;
虛擬服務中定義的第一條規則有最高優先級，&lt;br /&gt;
當第一個沒有match到相對應的規則時，&lt;br /&gt;
則繼續往下執行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: localgo-vs
  namespace: auto
spec:
  hosts:
  - &amp;quot;*&amp;quot;
  gateways:
    - istio-ingressgateway
  http:
  - name: &amp;quot;route-v1&amp;quot;
    match:
    - uri:
        prefix: /reviews
    route:
    - destination:
        port:
          number: 80
        host: localgo.auto.svc.cluster.local    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#這裡就是指向你真正服務&quot;&gt;#這裡就是指向你真正服務&lt;/a&gt; service 的名稱喔
        subset: Localgov1   &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#這裡指的是DestinationRule的subset&quot;&gt;#這裡指的是DestinationRule的subset&lt;/a&gt;.name
  - name: &amp;quot;route-v3&amp;quot;
    match:
      - uri:
          prefix: /Player
    route:
     - destination:
        port:
          number: 80
        host: localgo.auto.svc.cluster.local    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#這裡就是指向你真正服務&quot;&gt;#這裡就是指向你真正服務&lt;/a&gt; service 的名稱喔
        subset: Localgov1   &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#這裡指的是DestinationRule的subset&quot;&gt;#這裡指的是DestinationRule的subset&lt;/a&gt;.name       
  - name: &amp;quot;route-v2&amp;quot;
    route:
    - destination:
        port:
          number: 80
        host: localgo.auto.svc.cluster.local
        # 上面 destionation 下面的 host 名稱會這麼長，這是 k8s 內部實際 dns 全名，如果需要跨 namspace 存取，就需要用這樣的全名方式指定。
        # {service name}.{namespace}.svc.cluster.local 這就是它的規則
        subset: v2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;match 下面的用法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;exact (完全匹配)&lt;/li&gt;
&lt;li&gt;prefix  (只有前綴)&lt;/li&gt;
&lt;li&gt;regex (正規表示法)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面那段的規則為，當網址進來後，如果網域的後面不是reviews的話，&lt;br /&gt;
則往下執行到route-v3，如果網址為 Player的話，則執行下面的路由&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/virtual-service/#StringMatch&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;StringMatch&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://istio.io/latest/zh/docs/concepts/traffic-management/#more-about-routing-rules&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;路由規則&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10247889&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Day24 什麼是 istio virtual service?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;gateway&quot; tabindex=&quot;-1&quot;&gt;gateway&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: istio-ingressgateway
  # 這裡就是填入kubectl get service -n istio-system 所查到的 istio-ingressgateway，實務上如果你有多個 ip ，就會有多個 gateway 代理，
  # 然後就要描述多個 gateway 去使用 gateway 代理
  namespace: auto
spec:
  selector:
    istio: ingressgateway   # 使用默認的控制器
  servers:
  - port: &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#加密傳輸&quot;&gt;#加密傳輸&lt;/a&gt;
      number: 443
      name: https
      protocol: HTTPS
    tls:
      mode: SIMPLE
      serverCertificate: /etc/istio/ingressgateway-certs/tls.crt &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#設定憑證路徑&quot;&gt;#設定憑證路徑&lt;/a&gt;
      privateKey: /etc/istio/ingressgateway-certs/tls.key  &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#設定憑證路徑&quot;&gt;#設定憑證路徑&lt;/a&gt;
    hosts:
     - &amp;quot;*&amp;quot; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#該服務對應domain&quot;&gt;#該服務對應domain&lt;/a&gt;
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
     - &amp;quot;*&amp;quot; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#該服務對應domain&quot;&gt;#該服務對應domain&lt;/a&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10247372&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;istio gateway 是什麼？&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;ingressgateway&quot; tabindex=&quot;-1&quot;&gt;同一個叢集安裝多個ingressgateway&lt;/h3&gt;
&lt;p&gt;滿滿的坑，卡了兩天才搞定。&lt;/p&gt;
&lt;p&gt;這邊要改使用operator安裝&lt;br /&gt;
所以先初始化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;istioctl operator init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://istio.io/latest/docs/setup/install/operator/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio Operator Install&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再來設定新增的 ingressgateway&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kind: IstioOperator
apiVersion: install.istio.io/v1alpha1
metadata:
  annotations:
    install.istio.io/ignoreReconcile: &#39;true&#39;
  name: video-state
  namespace: istio-system
spec:
  addonComponents:
    istiocoredns:
      enabled: false
  components:
    base:
      enabled: true
    cni:
      enabled: false
    ingressGateways:
        - name: ingressgateway-private
          namespace: istio-system
          enabled: true
          k8s:
              env:
                - name: ISTIO_META_ROUTER_MODE
                  value: standard          
              hpaSpec:
                minReplicas: 2
              overlays:
                    - kind: HorizontalPodAutoscaler
                      name: ingressgateway-private
                      patches:
                        - path: metadata.labels.app
                          value: ingressgateway-private
                        - path: metadata.labels.istio
                          value: ingressgateway-private
                        - path: spec.scaleTargetRef.name
                          value: ingressgateway-private
                    - kind: Deployment
                      name: ingressgateway-private
                      patches:
                        - path: metadata.labels.app
                          value: ingressgateway-private
                        - path: metadata.labels.istio
                          value: ingressgateway-private
                        - path: spec.selector.matchLabels.app
                          value: ingressgateway-private
                        - path: spec.selector.matchLabels.istio
                          value: ingressgateway-private
                        - path: spec.template.metadata.labels.app
                          value: ingressgateway-private
                        - path: spec.template.metadata.labels.istio
                          value: ingressgateway-private
                    - kind: Service
                      name: ingressgateway-private
                      patches:
                        - path: metadata.labels.app
                          value: ingressgateway-private
                        - path: metadata.labels.istio
                          value: ingressgateway-private
                        - path: spec.selector.app
                          value: ingressgateway-private
                        - path: spec.selector.istio
                          value: ingressgateway-private
                    - kind: PodDisruptionBudget
                      name: ingressgateway-private
                      patches:
                        - path: metadata.name
                          value: ingressgateway-private
                        - path: metadata.labels.app
                          value: ingressgateway-private
                        - path: metadata.labels.istio
                          value: ingressgateway-private
                        - path: spec.selector.matchLabels.app
                          value: ingressgateway-private
                        - path: spec.selector.matchLabels.istio
                          value: ingressgateway-private
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先使用&lt;br /&gt;
istioctl manifest generate -f newingeressway.yaml&lt;br /&gt;
預先編譯一下，看有沒有成功。 istioctl manifest的原理，有點像是kustomize，&lt;br /&gt;
有一個基底，後面的程式都是根據這個基底去修改覆蓋。&lt;/p&gt;
&lt;p&gt;安裝的話，則是使用&lt;br /&gt;
istioctl manifest install -f newingeressway.yaml&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://discuss.istio.io/t/multiple-ingress-controller-services-via-istiooperator/7620&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Multiple ingress controller services via IstioOperator?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/istio/istio&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;istio&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://reader.epubee.com/books/mobile/f2/f2b61f60ba2d351d9bc7c69e933ab394/text00001.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio入門與實戰&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/istio/7. Istio安裝及使用/" />
        </entry>
        <entry>
            <title>
                62. isito 鏡像流量
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/istio/62. isito 鏡像流量/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;最近在測試 istio的鏡像流量，&lt;br /&gt;
想要針對舊的 websocket 做鏡像將流量導到新版的websocket上面。&lt;/p&gt;
&lt;p&gt;實測的結果，websocket不能用。&lt;br /&gt;
但http能夠使用，這是由於 istio的鏡像流量是 『 fire and forget』&lt;/p&gt;
&lt;p&gt;但websocket 是需要交握後，才能持續進行下面的步驟。&lt;br /&gt;
所以導致連線無法建立，但 RESTful的請求，是沒問題的。&lt;/p&gt;
&lt;p&gt;先決條件，&lt;br /&gt;
2個deployment，分別叫 A 跟 B，&lt;br /&gt;
label 使用 version：v1  以及 version: v2 做區別&lt;br /&gt;
1個 service ，分別指到這2個deployment&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: ws-qa
  namespace: istio
spec:
  hosts:
    - www.abc.com
    - yabo-ws-qa
  gateways:
    - istio-system/istio-gateway-external
    - istio-system/istio-gateway-internal     
  http:
  - match:
      - uri:
          regex: ^/ws/.*
    route:
      - destination:
          host: ws-qa
          subset: v1
          port:
            number: 80
        weight: 100
    mirror:
        host: ws-qa
        subset: v2
    mirrorPercentage: 
        value: 100.0
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
 name: ws-qa
 namespace: istio
spec:
 host: ws-qa
 subsets:
 - labels:
     version: v1
   name: v1
 - labels:
     version: v2
   name: v2 		
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用任一的壓測軟體，呼叫本來的網站，就會得到下圖的數據。&lt;br /&gt;
v2是鏡像流量，流量過去後就不會管是否回應。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/62-fig.1.jpg&quot; alt=&quot;62-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.servicemesher.com/istio-handbook/practice/traffic-shadow.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;流量鏡像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://istio.io/latest/docs/tasks/traffic-management/mirroring/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Mirroring&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/istio/62. isito 鏡像流量/" />
        </entry>
        <entry>
            <title>
                54. istio 掛載ECK kibana
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/istio/54. istio 掛載ECK kibana/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;正常設定vs的時候，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- match:
    - uri:
        prefix: /
  name: kibana
  route:
    - destination:
        host: quickstart-kb-http.default.svc.cluster.local
        port:
          number: 5601
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;會發生錯誤&lt;br /&gt;
upstream connect error or disconnect/reset before headers. reset reason: connection termination&lt;/p&gt;
&lt;p&gt;不管怎樣改vs還是不通，最後是要把kibana的設定改掉，&lt;/p&gt;
&lt;p&gt;完整的yaml如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: kibana.k8s.elastic.co/v1
kind: Kibana
metadata:
  name: quickstart
spec:
  version: 7.15.0
  count: 1
  elasticsearchRef:
    name: quickstart
  http:
    tls:
      selfSignedCertificate:
        disabled: true
    service:
      spec:
        ports:
          - name: http
            port: 5601
            targetPort: 5601   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重點在於一定要加 http 下面的設定。&lt;/p&gt;
&lt;p&gt;selfSignedCertificate ，請參考[3]&lt;/p&gt;
&lt;p&gt;補充：&lt;br /&gt;
[1] 的連結有提到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    metadata:
      annotations:
        sidecar.istio.io/rewriteAppHTTPProbers: &amp;quot;true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊請參考[2]&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/59643343/expose-kibana-eck-operator-via-istio-gateway-https-problem-error-503&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Expose kibana (eck operator) via istio gateway - https problem (Error 503)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://istio.io/latest/zh/docs/ops/configuration/mesh/app-health-check/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio 服務的健康檢查&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-kibana-http-configuration.html#k8s-kibana-http-publish&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;HTTP configuration&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.vercel.app/istio/54. istio 掛載ECK kibana/" />
        </entry>
        <entry>
            <title>
                35. istio virtualService delegate使用
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/istio/35. istio virtualService delegate使用/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;會用到delegate的原因，是為了要解決在維護時上的痛點。&lt;br /&gt;
因目前使用flagger canary，&lt;br /&gt;
導致每個服務就一個virtualService (下面會用VS代替)，&lt;br /&gt;
而多個服務會共用一個host ，導致在維護上的困難。&lt;br /&gt;
而且在kiali上面會出現警告(fig.1)，看了實在礙眼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/35-fig.1.jpg&quot; alt=&quot;35-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以使用delegate。這樣的話，流量會先導到 delegate vs，之後才會根據path到各服務的vs。&lt;/p&gt;
&lt;p&gt;delegate 有幾點要注意，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不支援 regex&lt;/li&gt;
&lt;li&gt;在delegate上寫rewrite不會被轉導，要在導過去的vs寫。&lt;/li&gt;
&lt;li&gt;目前測試只能在同一個namespace上面。如果不是用藍綠佈署自定義的話，在destination 上面，可以使用完整的FQDN，是可以執行的。(例如: video-admin-primary.default.svc.cluster.local)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;VS delegate&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: control-dashboard
  namespace: default
spec:
  hosts:
  - &amp;quot;*&amp;quot;
  gateways:
    - istio-gateway-external.istio-system.svc.cluster.local
  http:
    - delegate:
        name: video-admin
        namespace: default
      match:
        - uri:
            prefix: /ezio
        - uri:
            prefix: /abc
        - uri:
            prefix: /api
      name: reviews-v2-routes
    - delegate:
        name: tw-frontend
        namespace: default
      match:
        - uri:
            prefix: /
      name: tw-frontend
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;服務的 vs，（注意：此處的yaml是由flagger自動產生的）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kind: VirtualService
apiVersion: networking.istio.io/v1alpha3
metadata:
  name: video-admin
  namespace: default
spec:
  hosts: []
  http:
    - match:
        - uri:
            prefix: /api
        - uri:
            prefix: /abc
        - uri:
            prefix: /ezio
      rewrite:
        uri: /api
      route:
        - destination:
            host: video-admin-primary
          weight: 100
        - destination:
            host: video-admin-canary
          weight: 0

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ps. 使用canary的話，在service下面加上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delegation: true  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://docs.flagger.app/faq#how-does-flagger-interact-with-istio&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How does Flagger interact with Istio?&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: flagger.app/v1beta1
kind: Canary
metadata:
  name: example-api-qa-v2
  namespace: istio-example
spec:
  provider: istio
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: example-api-qa-v2
  autoscalerRef:
    apiVersion: autoscaling/v1
    kind: HorizontalPodAutoscaler
    name: example-api-qa-v2

  service:
    delegation: true    # use delegate
    name: example-api-qa-v2
    port: 80
    targetPort: 80
    portName: http
    portDiscovery: true

    trafficPolicy:
      tls:
        mode: DISABLE
    match:
      - uri:
          prefix: /api-v2
    rewrite:
      uri: /api
    timeout: 30s
  analysis:
    # analysis spend time  : interval * iterations 
    # 時間間隔 (默認 60s)
    interval: 30s
    # 回滾前的最大失敗指標檢查次數(可能因為檢查時間差的關係，至少會有兩次失敗)
    threshold: 5
    iterations: 1
    metrics:
      - name: request-success-rate
        thresholdRange:
          min: 99
        interval: 1m
      - name: request-duration
        thresholdRange:
          max: 500
        interval: 30s
    webhooks:
      - name: load-test-get
        type: pre-rollout
        url: http://flagger-loadtester.tools/
        timeout: 15s
        metadata:
          type: cmd
          cmd: &amp;quot;hey -z 1m -q 10 -c 2 http://example-api-qa-v2-canary.istio-example&amp;quot;
      - name: &amp;quot;notify&amp;quot;
        type: event
        url: http://webhook-api.tools/webhook/flagger
        timeout: 5s
        metadata:
          channel: &amp;quot;-1001429024676&amp;quot;
      - name: load-test
        type: rollout
        url: http://flagger-loadtester.tools/
        timeout: 5s
        metadata:
          type: cmd
          cmd: &amp;quot;hey -z 1m -q 10  http://example-api-qa-v2-canary.istio-example&amp;quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/virtual-service/#Delegate&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;VS Delegate&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPMatchRequest&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;VS HTTPMatchRequest&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/istio/35. istio virtualService delegate使用/" />
        </entry>
        <entry>
            <title>
                34. istio operator 安裝新的 ingress deploy及service
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/istio/34. istio operator 安裝新的 ingress deploy及service/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;主管挑戰DC失敗，變成又要變回舊的系統架構。暈...&lt;br /&gt;
用了istio是為了一個ip打所有服務，現在又變回去。&lt;br /&gt;
服務跟 ip 是一對一的存在。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;最簡單的安裝方式，可看前一篇 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/7.%20Istio%E5%AE%89%E8%A3%9D%E5%8F%8A%E4%BD%BF%E7%94%A8/&quot;&gt;7. Istio安裝及使用&lt;/a&gt;&lt;br /&gt;
以前新增的時候，都會同時安裝最原始的deploy 以及 service(fig.1)，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/34.fig-1.jpg&quot; alt=&quot;34.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以在新增新的ingressgateway的時候，需要先指定原始的istio-ingressgateway 為 enable:false。&lt;br /&gt;
這樣在安裝的時候，才不會同時安裝。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kind: IstioOperator
apiVersion: install.istio.io/v1alpha1
metadata:
annotations:
  install.istio.io/ignoreReconcile: &#39;true&#39;
name: istio-external-test
namespace: istio-system
spec:
addonComponents:
  istiocoredns:
    enabled: false
components:
  base:
    enabled: true
  cni:
    enabled: false
  ingressGateways:
      - name: istio-ingressgateway     # 20210730新增，可取消單獨佈署此yaml還會額外裝ingress-gateway
        enabled: false
      - name: ingressgateway-external              
        namespace: istio-system
        enabled: true
        k8s:
          service:
        # loadBalancerIP 要跟著改，最好先將IP設成靜態
            loadBalancerIP: 
            loadBalancerSourceRanges:
                # - 0.0.0.0/0   
                - 10.0.0.0/8
                - 172.16.0.0/12
                - 192.168.0.0/16 
          env:
            - name: ISTIO_META_ROUTER_MODE
              value: standard          
          hpaSpec:
            minReplicas: 1
          overlays:
                - kind: HorizontalPodAutoscaler
                  name: ingressgateway-external
                  patches:
                    - path: metadata.labels.app
                      value: ingressgateway-external
                    - path: metadata.labels.istio
                      value: ingressgateway-external
                    - path: spec.scaleTargetRef.name
                      value: ingressgateway-external
                - kind: Deployment
                  name: ingressgateway-external
                  patches:
                    - path: metadata.labels.app
                      value: ingressgateway-external
                    - path: metadata.labels.istio
                      value: ingressgateway-external
                    - path: spec.selector.matchLabels.app
                      value: ingressgateway-external
                    - path: spec.selector.matchLabels.istio
                      value: ingressgateway-external
                    - path: spec.template.metadata.labels.app
                      value: ingressgateway-external
                    - path: spec.template.metadata.labels.istio
                      value: ingressgateway-external
                - kind: Service
                  name: ingressgateway-external
                  patches:
                    - path: metadata.labels.app
                      value: ingressgateway-external
                    - path: metadata.labels.istio
                      value: ingressgateway-external
                    - path: spec.selector.app
                      value: ingressgateway-external
                    - path: spec.selector.istio
                      value: ingressgateway-external
                - kind: PodDisruptionBudget
                  name: ingressgateway-external
                  patches:
                    - path: metadata.name
                      value: ingressgateway-external
                    - path: metadata.labels.app
                      value: ingressgateway-external
                    - path: metadata.labels.istio
                      value: ingressgateway-external
                    - path: spec.selector.matchLabels.app
                      value: ingressgateway-external
                    - path: spec.selector.matchLabels.istio
                      value: ingressgateway-external
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/istio/34. istio operator 安裝新的 ingress deploy及service/" />
        </entry>
        <entry>
            <title>
                31.istio 抓蟲記
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/istio/31.istio 抓蟲記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;狀況很奇特，奇特到我不知道該從哪里找。簡單說就是gateway裡面有mesh的話，&lt;br /&gt;
就會有此坑出現。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;先說明一下環境，Deployment  A 的 VirtualService 有設定 domain , &lt;a href=&quot;http://abc.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;abc.com&lt;/a&gt;&lt;br /&gt;
此時進去 Deployment裡面的 pod ， 使用 curl 呼叫外部的ip，會發生404的錯誤。&lt;br /&gt;
e.g.   curl -v 123.213.123.213 -H &amp;quot;Host:abc.com&amp;quot;&lt;br /&gt;
但是，&lt;a href=&quot;http://xn--hostabc-7w3kl56ffok94z.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;如果Host不帶abc.com&lt;/a&gt; ，改帶任意的 domain，即可正常執行。&lt;/p&gt;
&lt;h2 id=&quot;除錯過程&quot; tabindex=&quot;-1&quot;&gt;除錯過程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用tcpdump ，將所有的封包撈出，但發現如果 host 帶 &lt;a href=&quot;http://abc.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;abc.com&lt;/a&gt; ，沒有任何的封包進出。&lt;br /&gt;
但帶任意 domain:  &lt;a href=&quot;http://def.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;def.com&lt;/a&gt; ，則會有封包進出。故開始懷疑是 sidecar的某些機制將流量導到本機，&lt;br /&gt;
以至於回傳404的錯誤。&lt;/p&gt;
&lt;p&gt;簡易的tcpdump使用，&lt;br /&gt;
詳細用法請參考連結&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  針對 host 是 123.213.123.213 且 port 是 80 的封包截取，並存入demo2.pcap的檔案
  tcpdump host 123.213.123.213 and port 80 -w demo2.pcap
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是從pod裡面看封包，會想哭，所以進一步要把封包的檔案放到自己的機器上，再使用wireshark看。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  將pod(api-beta-v2-primary-69797b47d6-bl6vf)，裡面的檔案 demo2.pcap 複製到本機上
  kubectl cp api-beta-v2-primary-69797b47d6-bl6vf:/app/demo2.pcap -n istio ./demo2.pcap
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.jinnsblog.com/2020/09/linux-tcpdump-network-traffic-tutorial.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Linux] Tcpdump 擷取封包指令範例教學&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查詢outbound handler&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;  istioctl proxy-config route api-beta-v2-primary-69797b47d6-bl6vf -n istio
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;終於查到了一個關鍵，在有問題domain，他match的path是另外一個virtualService(fig.1)，最後查到那個VirtualSerice ，在gateway上面多設了一組 mesh，&lt;br /&gt;
導致他一直在網格內繞，所以才會404。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/31.fig-1.jpg&quot; alt=&quot;31.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;額外補充，查詢 Inbound handler&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   istioctl proxy-config listener reviews-v1-54b8794ddf-jxksn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可直接用 istioctl pc 來取帶 proxy-config&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://jimmysong.io/blog/sidecar-injection-iptables-and-traffic-routing/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio 中的 Sidecar 注入及透明流量劫持過程詳解&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/istio/31.istio 抓蟲記/" />
        </entry>
        <entry>
            <title>
                30. istio的virtualservice match比對
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/istio/30. istio的virtualservice match比對/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近因為新的需求，再度跟istio的virtualservice槓上了。&lt;br /&gt;
這次要做的是針對domain去解析網址，host不再自定。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;踩到的坑很特別，根據官方文件上寫的是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For example, the following restricts the rule to match only requests where the URL path starts with /ratings/v2/ and the request contains a custom end-user header with value jason&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文章的範例如下，官方文件是說明當url path 符合 /ratings/v2 而且 header裡面的end-user的值為 jason 才會轉到正確的路由。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  apiVersion: networking.istio.io/v1beta1
  kind: VirtualService
  metadata:
  name: ratings-route
  spec:
  hosts:
  - ratings.prod.svc.cluster.local
  http:
  - match:
    - headers:
        end-user:
          exact: jason
      uri:
        prefix: &amp;quot;/ratings/v2/&amp;quot;
      ignoreUriCase: true
    route:
    - destination:
        host: ratings.prod.svc.cluster.local
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/virtual-service/?_ga=2.150842550.1248538041.1620980160-699625840.1605505006#HTTPMatchRequest&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;HTTPMatchRequest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再來就是我踩坑的地方，因為我不管怎麼測試，測試出來的都是 『或』，&lt;br /&gt;
也就是說 當流量進入時， 只要 url path 是 /api 『或』 header 的Host是 符合 qa2.777.+.com的正則，才會導去正確的路由。&lt;br /&gt;
跟官方文件的講法落差有點大，後來測試了老半天才發現，關鍵在 『 - 』。&lt;/p&gt;
&lt;p&gt;下面的程式，條件是 『或』，兩個條件其中一個過都會導到正確的路由&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;match:
  - headers:
      Host:
        regex: qa2&#92;.777.+&#92;.com
  - uri:
      prefix: /api
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面的程式，條件式 『而且』 ，兩個條件都要符合才會導到正確的路由&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;match:
  - headers:
      Host:
        regex: qa2.?&#92;.777.+&#92;.com
    uri:
      prefix: /api
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本來還有在探討另一種方法，直接在hosts上面做判斷(fig.1)，&lt;br /&gt;
但是測試出來只能針對 sub domain，如果把萬用字元放在後面，連存檔都會出錯握。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/30.fig-1.jpg&quot; alt=&quot;30.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hosts:
  - &amp;quot;*.777.com&amp;quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://github.com/istio/istio/issues/15456&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Support wildcard/regexp in VirtualService host&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#envoy-v3-api-msg-config-route-v3-virtualhost&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;config.route.v3.VirtualHost&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/istio/30. istio的virtualservice match比對/" />
        </entry>
        <entry>
            <title>
                23.istio的 prometheus截取GKE metrics
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/istio/23.istio的 prometheus截取GKE metrics/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;主要架構弄得差不多的，使用 istio 加上 drone 的 自動佈署，&lt;br /&gt;
再配合 flagger的藍綠佈署，藍綠佈署時使用telegram通知目前佈署進度。&lt;br /&gt;
，現在剩下監控這一塊。&lt;br /&gt;
然後，阿伯，出事拉....&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;一開始想使用grafana上面的樣板，原以爲只要這樣就好。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://grafana.com/grafana/dashboards/8588&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;1. Kubernetes Deployment Statefulset Daemonset metrics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://grafana.com/grafana/dashboards/13105&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;1 Kubernetes for Prometheus Dashboard CN 20201209&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10224491&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Prometheus 2 - Deploy Grafana&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是，發現我抓不到資料。直接連線至Prometheus裡面查詢也沒有，&lt;br /&gt;
於是斷定，我根本沒有撈資料到Prometheus。&lt;/p&gt;
&lt;p&gt;如果直接架設一個新的grafana不使用istio的grafana會不會比較好？&lt;br /&gt;
但是這樣本來istio的grafana dashboard (Fig.1) 就要自己建立了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/23-fig.1.jpg&quot; alt=&quot;23-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;kube-state-metrics&quot; tabindex=&quot;-1&quot;&gt;kube-state-metrics&lt;/h2&gt;
&lt;p&gt;查了一些資料，最後找到的方案是安裝 &lt;a href=&quot;https://github.com/kubernetes/kube-state-metrics&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kube-state-metrics&lt;/a&gt;&lt;br /&gt;
但是光安裝還是不行，必須要讓Prometheus抓得到資料才行。&lt;/p&gt;
&lt;p&gt;建議先將yaml檔抓下來，因為有些地方需要更改。&lt;br /&gt;
打開 standard/service.yaml&lt;br /&gt;
在metadata底下 加上   &lt;a href=&quot;http://prometheus.io/scrape:&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;prometheus.io/scrape:&lt;/a&gt; &#39;true&#39;&lt;br /&gt;
這是要讓prometheus 可以自動得去發現服務&lt;/p&gt;
&lt;p&gt;metadata完整的yaml如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;metadata:
  labels:
    app.kubernetes.io/name: kube-state-metrics
    app.kubernetes.io/version: v1.9.8
  annotations:
      prometheus.io/scrape: &#39;true&#39;
  name: kube-state-metrics
  namespace: kube-system
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後，佈署&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  kubectl apply -f standard
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;node-exporter&quot; tabindex=&quot;-1&quot;&gt;Node-Exporter&lt;/h2&gt;
&lt;p&gt;後來查了一下，這邊的指標資料已經在 cadvisor 裡面了，所以不用在額外做。&lt;br /&gt;
ref. &lt;a href=&quot;https://stackoverflow.com/questions/63741959/prometheus-node-exporter-issue-when-update-from-gke-1-15-to-1-16&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Prometheus (node_exporter) issue when update from GKE 1.15 to 1.16&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10225912&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Prometheus 5 - Node Exporter &amp;amp; Kube State Metrics&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.uj5u.com/qita/31194.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;prometheus（九） 收集kube-state-metrics指標資訊&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/istio/23.istio的 prometheus截取GKE metrics/" />
        </entry>
        <entry>
            <title>
                21. flagger 自動金絲雀佈署 for istio
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/istio/21. flagger 自動金絲雀佈署 for istio/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;本來自動佈署配上istio都好了，&lt;br /&gt;
但在實際上測試的時候發現，如果不導入自動藍綠佈署或金絲雀佈署的話，&lt;br /&gt;
到時開發人員發佈程式時，需要更改istio 的 VirtualService 以及 DestinationRule。&lt;br /&gt;
除非發佈的人懂這些東西，不然...改壞就...，所以只好先研究flagger了。減少開發人員佈署的know how，&lt;br /&gt;
只要git tag ，然後『等』  就好了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;簡易流程介紹&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前正在執行的deploy 為abc-primary ，當有新的deploy 佈署在 abc 時，flagger啟動，&lt;br /&gt;
先將流量從 abc-primary 轉到 abc ，因為abc 為新版本。&lt;br /&gt;
當流量全部轉到abc後，將 abc-primary 刪除，並佈署成新的版本。&lt;br /&gt;
當abc-primary佈署完後，再將 流量從 abc 轉回 abc-primary，&lt;br /&gt;
等待全部流量轉回來後，再將abc的deploy刪除。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;先安裝flagger&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;  kustomize build https://github.com/fluxcd/flagger/kustomize/istio?ref=main | kubectl apply -f -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://docs.flagger.app/install/flagger-install-on-kubernetes&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Flagger Install on Kubernetes&lt;/a&gt;&lt;br /&gt;
3. 佈署負載測試服務 flagger-loadtester&lt;br /&gt;
如果namespace要先建立test ，如果不想使用這個名稱，請下載yaml檔後修改 kustomization.yaml 的namespace&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/fluxcd/flagger/tree/main/kustomize/tester&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;flagger-loadtester&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  kubectl apply -k https://github.com/fluxcd/flagger//kustomize/tester?ref=main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這裏面主要是使用&lt;a href=&quot;https://github.com/rakyll/hey&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;hey&lt;/a&gt; 作爲連線測試的工具，&lt;br /&gt;
在後面的webhook會用到此服務。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;設定Canary&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此範例為AB佈署，另有金絲雀佈署，請參考&lt;br /&gt;
spec 底下的參數，&lt;br /&gt;
- &lt;a href=&quot;http://targetref.name/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;targetRef.name&lt;/a&gt; 是 deploy會截取現有的deploy設定，確認名稱與現有的deploy名稱一樣&lt;br /&gt;
- &lt;a href=&quot;http://autoscalerref.name/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;autoscalerRef.name&lt;/a&gt; 是 HPA會截取現有的HPA設定，確認名稱與現有的HPA名稱一樣。&lt;br /&gt;
- service.name是 service會截取現有的service設定，確認名稱與現有的service名稱一樣。&lt;br /&gt;
- service.host 需指定目前服務的domain，如果為ip只能有一組&lt;br /&gt;
- webhooks.metadata.cmd ，網址必須更改成服務能夠訪問的網址。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: flagger.app/v1beta1
kind: Canary
metadata:
name: video
namespace: sex-system
spec:
provider: istio
targetRef:
apiVersion: apps/v1
kind: Deployment
name: video-api
autoscalerRef:
apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
name: video-api

service:
name: video-api
port: 80
targetPort: 80
portName: http
portDiscovery: true
gateways:
  - istio-gateway-external.istio-system.svc.cluster.local
  - istio-gateway-internal.istio-system.svc.cluster.local
  - mesh
hosts:
  - 123.123.123.123
trafficPolicy:
  tls:
    mode: DISABLE
match:
  - uri:
      prefix: /
rewrite:
  uri: /
timeout: 30s
analysis:
# analysis spend time  : interval * iterations
# 時間間隔 (默認 60s)
interval: 30s
# 回滾前的最大失敗指標檢查次數(可能因為檢查時間差的關係，至少會有兩次失敗)
threshold: 5
iterations: 1
metrics:
  - name: request-success-rate
    thresholdRange:
      min: 99
    interval: 1m
  - name: request-duration
    thresholdRange:
      max: 500
    interval: 30s
webhooks:
  - name: load-test-get
    type: pre-rollout
    url: http://flagger-loadtester.tools/
    timeout: 15s
    metadata:
      type: cmd
      cmd: &amp;quot;hey -z 1m -q 10 -c 2 http://video-api-canary.test/api/v1/Health/health&amp;quot;
  - name: &amp;quot;notify&amp;quot;
    type: event
    url: http://webhook-api.tools/webhook/flagger
    timeout: 5s
    metadata:
      channel: &amp;quot;-1023450&amp;quot;  
  - name: load-test
    type: rollout
    url: http://flagger-loadtester.tools/
    timeout: 5s
    metadata:
      type: cmd
      cmd: &amp;quot;hey -z 1m -q 10  http://video-api-canary.test/api/v1/Health/health&amp;quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;寫好canary，然後直接佈署。&lt;br /&gt;
此時，k8s會根據你的設定，建立起 一些相關的service以及 deployment ，&lt;br /&gt;
例如，本來的deployment、service以及 hpa的 名稱叫 abc ，&lt;br /&gt;
那同時會建立 abc-primary 的deployment 跟 hpa，&lt;br /&gt;
以及 abc-canary 、 abc-primary 的 service  。&lt;/p&gt;
&lt;p&gt;然後再istio上面也會自動建立 VirtualService 跟 DestinationRule&lt;br /&gt;
所以Canary很重要、很重要、很重要。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://github.com/fluxcd/flagger/blob/main/artifacts/examples/istio-canary.yaml&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;flagger/artifacts/examples/istio-canary.yaml&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://docs.flagger.app/tutorials/istio-progressive-delivery#bootstrap&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio Canary Deployments&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://docs.flagger.app/tutorials/istio-ab-testing#bootstrap&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio A/B Testing&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;引入 grafana&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因為istio本身就有grafana了，所以我不想重複安裝，&lt;br /&gt;
到他們的&lt;a href=&quot;https://github.com/fluxcd/flagger/tree/main/charts/grafana/dashboards&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;git&lt;/a&gt;&lt;br /&gt;
將json檔下載下來，&lt;br /&gt;
到grafana匯入json(fig.1)，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/21.fig-1.jpg&quot; alt=&quot;21.fig-1.jpg&quot; /&gt;&lt;br /&gt;
此時會發生錯誤&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Template variables could not be initialized: Datasource named prometheus was not found
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原因是原本的json檔裡面的datasource是 prometheus&lt;br /&gt;
而目前安裝的是 Promethus ，將本來的json更改後再匯入。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://medium.com/expedia-group-tech/flagger-monitor-your-canary-deployments-with-grafana-21b9dd58b10e&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Flagger - Monitor Your Canary Deployments with Grafana&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;佈署失敗，重新佈署方式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;藍綠佈署或金絲雀佈署上面有提到，會自動新增一個deployment，再原有的名稱上面加上-primary，&lt;br /&gt;
然後原有的deployment還會存在，但他的pod會清除。&lt;br /&gt;
當有新的image時，會觸發動作，在原有的deployment上將pod產生出來，&lt;br /&gt;
然後開始做流量的導轉，並發佈新版本。&lt;br /&gt;
但在測試的時候，如果canary寫錯了，會導致發佈失敗。&lt;br /&gt;
此時修改完，重新apply ，也會卡在Fail的狀態，&lt;br /&gt;
需到 原本的deployment 增加 下面的程式，&lt;br /&gt;
讓canary重新觸發。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
spec:
  template:
    metadata:
      annotations:
        timestamp: &amp;quot;2020-03-10T14:24:48+0000&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://docs.flagger.app/faq#how-to-retry-a-failed-release&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to retry a failed release&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;佈署失敗原因&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前測試，~每次一定會跳這個出來~ ，已解決。差別只在次數&lt;br /&gt;
Halt advancement no values found for istio metric request-success-rate probably video-api.sex-system is not receiving traffic: running query failed: no values found&lt;/p&gt;
&lt;p&gt;用curl打 不會產生此錯誤，&lt;br /&gt;
interval 時間壓在30s ，此錯誤只會發生1次&lt;br /&gt;
interval 時間壓在20s ，此錯誤會發生2次&lt;br /&gt;
threshold：回滾最大錯誤發生次數，設成5，只要小於錯誤發生的次數，還是可以成功自動佈署&lt;/p&gt;
&lt;p&gt;有查到會發生這個錯誤的原因，如果在流量導轉期間沒有收到流量的話就會發生此錯誤。&lt;br /&gt;
所以要解決這個錯誤，要再 pre-rollout 的時候，先送一些連線過去。&lt;br /&gt;
這樣就不會有此錯誤發生了。&lt;/p&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://docs.flagger.app/usage/webhooks#load-testing&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Load Testing&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;監控方式&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;查詢flagger佈署狀態，需額外安裝&lt;a href=&quot;https://stedolan.github.io/jq/manual/#Basicfilters&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;jq&lt;/a&gt;（解析json的軟體)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    watch &amp;quot;kubectl -n istio-system logs deployment/flagger --tail=10 | jq &#39;.ts,.msg&#39;&amp;quot;
    或
    kubectl -n test describe canary/video-api | tail -20f
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;看流量比重&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    watch kubectl get canaries -A
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;9&quot;&gt;
&lt;li&gt;webhook主動通知&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在flagger裡面，有實作webhook，可以將事件的狀態通知給需要的人。&lt;br /&gt;
內建有 slack 、discord ， 這段我沒實作 ，看起來只要加參數即可，&lt;br /&gt;
請參考 &lt;a href=&quot;https://docs.flagger.app/usage/alerting&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Alerting&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但因為公司政策，我不能用slack所以只好自己做telegram了，&lt;br /&gt;
telegram做機器人還挺快的，改天再寫一篇關於telegram的使用方式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;webhooks:
- name: &amp;quot;notify&amp;quot;
  type: event
  url: http://webhook-api-v2.test/webhook/flagger
  timeout: 5s
  metadata:
    some: &amp;quot;some message&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在canary上面加入上面的程式碼，然後當有事件觸發時，&lt;br /&gt;
會回傳下面的json格式。&lt;/p&gt;
&lt;p&gt;注意 webhook-api-v2.test 是一個我自己建立在 namespce ：test ，deployment：webhook-api-v2 的api&lt;/p&gt;
&lt;p&gt;webhook其實就是自己建立一個api的接收機制，當server端有資料時，&lt;br /&gt;
會根據上面的url送出json給你，此時要怎麼利用，就看各自的需求了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
   &amp;quot;name&amp;quot;:&amp;quot;video&amp;quot;,
   &amp;quot;namespace&amp;quot;:&amp;quot;test&amp;quot;,
   &amp;quot;phase&amp;quot;:&amp;quot;Failed&amp;quot;,
   &amp;quot;metadata&amp;quot;:{
      &amp;quot;eventMessage&amp;quot;:&amp;quot;Canary failed! Scaling down abc.test&amp;quot;,
      &amp;quot;eventType&amp;quot;:&amp;quot;Warning&amp;quot;,
      &amp;quot;some&amp;quot;:&amp;quot;some message&amp;quot;,
      &amp;quot;timestamp&amp;quot;:&amp;quot;1616654792750&amp;quot;
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://studygolang.com/articles/15056&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;webhook 是什麼以及如何創建&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://medium.com/@justinlee_78563/line-bot-%E7%B3%BB%E5%88%97%E6%96%87-%E4%BB%80%E9%BA%BC%E6%98%AF-webhook-d0ab0bb192be&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;LINE Bot 系列文 — 什麼是 Webhook?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h2&gt;
&lt;p&gt;有時文章測試有問題的話，建議到他們的&lt;a href=&quot;https://github.com/fluxcd/flagger/tree/main/artifacts&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;git&lt;/a&gt;&lt;br /&gt;
找相關的範例，做測試。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://www.servicemesher.com/blog/automated-canary-deployments-with-flagger-and-istio/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;基於Flagger和Istio實現自動化金絲雀部署&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://wiki.shileizcc.com/confluence/pages/viewpage.action?pageId=84967496#Istio%E5%AE%9E%E8%B7%B5-%E8%87%AA%E5%8A%A8%E5%8C%96%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio 實踐&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.51cto.com/zero01/2572820&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Service Mesh - Istio實戰篇（上）&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://medium.com/google-cloud/automated-canary-deployments-with-flagger-and-istio-ac747827f9d1&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Automated canary deployments with Flagger and Istio&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.niewx.cn/istio/2020/12/10/istio%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;istio入門系列之自動化灰度發佈&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/istio/21. flagger 自動金絲雀佈署 for istio/" />
        </entry>
        <entry>
            <title>
                20. 訪問istio 內部負載平衡ip
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/istio/20. 訪問istio 內部負載平衡ip/</id>
            <content type="html">
                &lt;h2 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;h2 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;要指定內部負載平衡IP的話，一般在svc上面是只要指定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;metadata:
  annotations:
    cloud.google.com/load-balancer-type: &amp;quot;Internal&amp;quot;
spec:
    type: LoadBalancer    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這樣在GKE上面就會指定成內部負載平衡。&lt;br /&gt;
但在istio上面要指定的話，需在k8s底下新增 serviceAnnotations&lt;br /&gt;
像下面這樣（這是GKE的寫法，其他雲端機器設定的方式會不一樣）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;k8s:
  serviceAnnotations:
    cloud.google.com/load-balancer-type: &amp;quot;Internal&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他的參數請參考 istio安裝及使用 =&amp;gt; 同一個叢集安裝多個ingressgateway&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/20.fig-1.jpg&quot; alt=&quot;20.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://medium.com/faun/setup-multiple-ingress-gateways-in-istio-52ad0dc7f99d&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Setup Multiple Ingress Gateways in Istio&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://stackoverflow.com/questions/61963659/how-can-i-add-service-annotation-in-istio-operator-patch&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How can I add service annotation in istio operator patch&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;virtual-service&quot; tabindex=&quot;-1&quot;&gt;VirtualService的寫法&lt;/h3&gt;
&lt;p&gt;Gateway的寫法與之前的一致，&lt;br /&gt;
比較有差異的是VS的寫法&lt;/p&gt;
&lt;p&gt;hosts 需設定內部ip，不能使用 &amp;quot;*&amp;quot;&lt;br /&gt;
gateways  需增加mesh，表示路由是從網格內的流量來的。&lt;/p&gt;
&lt;p&gt;如果不在gateways上面，寫mesh，會發生&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;503 upstream connect error or disconnect/reset before headers. reset reason local reset istio
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;的錯誤。&lt;br /&gt;
會發現這個錯誤，是因為看了&lt;a href=&quot;https://kknews.cc/zh-tw/code/ja4r3ee.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio實踐避坑指南：10 大常見異常、最佳實踐及解決方案&lt;/a&gt;清楚網格內，與網格邊緣的差異，才知道增加此設定。&lt;/p&gt;
&lt;p&gt;最後yaml如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: vs-internal
  namespace: default
spec:
  hosts:
    - 10.4.0.37
  gateways:
    - mesh
    - istio-ingressgateway-internal.default.svc.cluster.local
  http:
    - corsPolicy:
        allowOrigin:
          - &#39;*&#39;
      match:
        - uri:
            exact: /api/v1/health
      name: route-v1
      route:
        - destination:
            host: abc.default.svc.cluster.local
            port:
              number: 80
          weight: 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://iter01.com/536043.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio 運維實戰系列（3）：讓人頭大的『無頭服務』-下&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.twblogs.net/a/5d3f73a9bd9eee51fbf92230?lang=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;記一次Istio間歇503的問題排查&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/istio/20. 訪問istio 內部負載平衡ip/" />
        </entry>
        <entry>
            <title>
                18.istio Virtual Service 跨namespace讀取 DestinationRule
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/istio/18.istio Virtual Service 跨namespace讀取 DestinationRule/</id>
            <content type="html">
                &lt;h2 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;因為在寫 vs的match uri，有發生一些坑，使用了prefix導致其他的VS都去抓到另一個VS的路徑，&lt;br /&gt;
於是想要讓所有的VS都用同一個VS，避免未來發生同樣的錯誤，不好找原因。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;目前的狀況是 A服務在 A 的namespace上面， B服務在 B 的 namespace上面。&lt;br /&gt;
正常的方式，&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/18.fig-1.jpg&quot; alt=&quot;18.fig-1.jpg&quot; /&gt;&lt;br /&gt;
VirtualService 跟 DestinationRule 都會各自在所屬服務上面的 namespace上面。&lt;br /&gt;
所以，如果有 三個服務，就會有 三個 VirtualService ，&lt;br /&gt;
同時 match uri的prefix部分，也都寫 /api /api2 /api3 的話，就會發現，服務不管怎麼呼叫都是呼叫到api&lt;br /&gt;
其實這也算我發生的錯誤，prefix 是只針對前面的字串符合就過了。&lt;br /&gt;
ref. &lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPMatchRequest&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;HTTPMatchRequest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但這個錯誤未來不知道有沒有辦法避免，是也能夠使用exact 完全符合的關鍵字來避免上面的錯誤發生。&lt;br /&gt;
但此時我就在思考，能不能未來都統一使用一個 VirtualService 就好，&lt;br /&gt;
這樣也方便管理。&lt;/p&gt;
&lt;p&gt;過程中的血淚，就不細說了。&lt;/p&gt;
&lt;p&gt;目前能做到的是 A、B 共用一個 VirtualService，此 VS在A的 namespace上面，&lt;br /&gt;
然後 DestinationRule 則分別在A、B 的namespace上面各架設一個。&lt;/p&gt;
&lt;p&gt;如果DR也想要共用的話，會發生錯誤，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  This subset’s labels are not found in any matching host
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;s&gt;想過使用指定的FQDN的label，來強迫他去指定的地方找deployment，但失敗了。&lt;br /&gt;
如果有人有看到方法還麻煩告知。&lt;/s&gt;&lt;br /&gt;
剛在寫文章的時候，有看到DR 也有exportTO的指令，&lt;br /&gt;
所以應該也是可以透過exportTO的方法，來共用同一個DR。&lt;/p&gt;
&lt;p&gt;目前的yaml寫法如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  exportTo:
    - &#39;*&#39;
  http:
    - match:
        - uri:
            prefix: /v2
      name: bale-api-v2
      rewrite:
        uri: /api
      route:
        - destination:
            host: bale-api.sex-system.svc.cluster.local
            port:
              number: 80
            subset: bale-api2
          weight: 80
        - destination:
            host: bale-api.sex-system.svc.cluster.local
            port:
              number: 80
            subset: bale-api
          weight: 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊在kiali會看到警告 Subnet not found (Fig.1)，但如果直接從Graph看流量分佈的話，是有在分流的。&lt;br /&gt;
這邊要注意，一定要加上  exportTO ，允許該服務可以跨過邊界去尋找到DR。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;exportTO:
  - &#39;*&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/virtual-service/#VirtualService&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;VirtualService&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/istio/istio/issues/15556&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Destination Rule is not applied to traffic from all namespaces it&#39;s exported to&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.cnblogs.com/charlieroro/p/13626429.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio 的配置分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/hxpjava1/article/details/108318645&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;VirtualService資源詳解&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/istio/18.istio Virtual Service 跨namespace讀取 DestinationRule/" />
        </entry>
        <entry>
            <title>
                15.istio服務無法訪問
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/istio/15.istio服務無法訪問/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;今天上班就發現這個情況，istio的服務無法訪問，但同一個叢集的另一個istio卻正常。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;看事件錯誤寫的是&lt;br /&gt;
&lt;code&gt;Readiness probe failed: HTTP probe failed with statuscode: 503&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/15.fig-1.jpg&quot; alt=&quot;15.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;pod 的狀態是running ，但istio-proxy 卻是 containers with unready status&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/15.fig-2.jpg&quot; alt=&quot;15.fig-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;根據錯誤訊息都沒找到相符合的資料&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://github.com/istio/istio/issues/23283&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Readiness probe failed: HTTP probe failed with statuscode: 503 &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#23283&quot;&gt;#23283&lt;/a&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;現在看istio-proxy的日誌，上面寫的是&lt;br /&gt;
Envoy proxy is NOT ready: config not received from Pilot (is Pilot running?)&lt;br /&gt;
這個似乎是原因..&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查看網格的狀況&lt;br /&gt;
istioctl proxy-status&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/15.fig-3.jpg&quot; alt=&quot;15.fig-3.jpg&quot; /&gt;&lt;br /&gt;
所屬的網格LDS寫 Never Ackonwledged&lt;br /&gt;
各欄位的意思如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LDS，Listener 發現服務：Listener 監聽器控制 sidecar 啟動端口監聽（目前只支持 TCP 協議），並配置 L3/L4 層過濾器，當網絡連接達到後，配置好的網絡過濾器堆棧開始處理後續事件。&lt;/li&gt;
&lt;li&gt;RDS，Router 發現服務：用於 HTTP 連接管理過濾器動態獲取路由配置，路由配置包含 HTTP 頭部修改（增加、刪除  HTTP 頭部鍵值），virtual hosts （虛擬主機），以及 virtual hosts 定義的各個路由條目。&lt;/li&gt;
&lt;li&gt;CDS，Cluster 發現服務：用於動態獲取 Cluster 信息。&lt;/li&gt;
&lt;li&gt;EDS，Endpoint 發現服務：用於動態維護端點信息，端點信息中還包括負載均衡權重、金絲雀狀態等，基於這些信息，sidecar 可以做出智能的負載均衡決策。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.servicemesher.com/istio-handbook/concepts/pilot.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Pilot&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;查看pod錯誤&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Envoy proxy is NOT ready: config not received from Pilot (is Pilot running?): cds updates: 1 successful, 0 rejected; lds updates: 0 successful, 1 rejected
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我一直以爲關鍵字是查前面的config not received from Pilot(is Pilot running?)&lt;br /&gt;
但後來開了工單找了Google工程師，他說重點是後面那句  lds updates: 0 successful, 1 rejected&lt;/p&gt;
&lt;p&gt;然後查看 istiod log，可以看到lds為什麼會rejected&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;warn	ads	ADS:LDS: ACK ERROR router~10.131.1.19~istio-ingressgateway-794bbdb877-np94z.istio-system~istio-system.svc.cluster.local-994 Internal:Error adding/updating listener(s) 0.0.0.0_8443: Invalid path: /etc/istio/ingressgateway-certs/tls.crt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這段在pod剛開始建立時也有出現此錯誤，看起來是https的憑證有問題，&lt;br /&gt;
本來佈署gateway的yaml檔像這樣&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: istio-ingressgateway-video
  namespace: sex-system
spec:
  selector:
    istio: ingressgateway   # 使用默認的控制器
  servers:
  - port: &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#加密傳輸&quot;&gt;#加密傳輸&lt;/a&gt;
      number: 443
      name: http
      protocol: HTTPS
    tls:
      mode: SIMPLE
      serverCertificate: /etc/istio/ingressgateway-certs/tls.crt &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#設定憑證路徑&quot;&gt;#設定憑證路徑&lt;/a&gt;
      privateKey: /etc/istio/ingressgateway-certs/tls.key  &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#設定憑證路徑&quot;&gt;#設定憑證路徑&lt;/a&gt;
    hosts:
      - &amp;quot;*&amp;quot; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#該服務對應domain&quot;&gt;#該服務對應domain&lt;/a&gt;
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
     - &amp;quot;*&amp;quot; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#該服務對應domain&quot;&gt;#該服務對應domain&lt;/a&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;憑證路徑是直接指向pod裡面的路徑，&lt;br /&gt;
但&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;google工程師說 istio v1.6開始gateway的tls已经不支援file mount类的设置了(i.e. &lt;code&gt;privateKey&lt;/code&gt;, &lt;code&gt;serverCertificate&lt;/code&gt;). 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，要麻自己建立 https的憑證 ，或者是乾脆不要https。&lt;br /&gt;
（ref. &lt;a href=&quot;https://istio.io/v1.8/docs/tasks/traffic-management/ingress/secure-ingress/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Secure Gateways&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;自己建立憑證的話，&lt;br /&gt;
根據上面的網址，產生 crt 跟 key ，然後使用&lt;/p&gt;
&lt;p&gt;kubectl create secret tls credential-httpbin -n istio-system --cert=./httpbin.com.crt --key=./httpbin.com.key&lt;/p&gt;
&lt;p&gt;建立sercret，最後再yaml內直接使用這個sercret的name&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: istio-ingressgateway-custom
  namespace: rd7-video
spec:
  selector:
    istio: ingressgateway-private   # 使用默認的控制器
  servers:
  - hosts:
      - httpbin.com
    port:
      name: httpbin
      number: 443
      protocol: HTTPS
    tls:
      credentialName: credential-httpbin
      mode: SIMPLE
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
     - &amp;quot;*&amp;quot; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#該服務對應domain&quot;&gt;#該服務對應domain&lt;/a&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;目前看起來是有直接解掉這個問題，&lt;br /&gt;
剛剛掛掉的pod，有變回正常的狀態。&lt;br /&gt;
但當初兩個pod，一個活着，另一個陣亡，還不知道爲何會這樣。&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/istio/15.istio服務無法訪問/" />
        </entry>
        <entry>
            <title>
                14.istio安裝時固定ip
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/istio/14.istio安裝時固定ip/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;如果刪除GKE的節點，重建新的話，必須要把istio移除，才能夠使用 遷移工作負載到不同node。&lt;br /&gt;
但如果已經將istio的ip ，綁上固定的domain，一旦移除就必須要重新綁定。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;以下內容都在GCP上面實作(istio 版本為1.8.2)。 騰訊雲不能這樣玩。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先將IP變成靜態，而不是臨時。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/14.fig-1.jpg&quot; alt=&quot;14.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;將下面yaml另存成檔案&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
spec:
  components:
    ingressGateways:
    - name: istio-ingressgateway
      enabled: true
      k8s:
        service:
          loadBalancerIP: 123.123.123.123
          loadBalancerSourceRanges:
          - 111.222.222.111/32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跟舊版的差異在必須加上name的名稱，不然在manifest generate 的時候會發生錯誤&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;安裝&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;istioctl install  -f value.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以先產生yaml看內容是不是有跟想象中的一樣&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;istioctl manifest generate -f value.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://cloud.tencent.com/developer/article/1607842&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio 1.5 部署指南修正版&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://istio.io/latest/docs/reference/config/istio.operator.v1alpha1/#ServiceSpec&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;IstioOperator Options&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/istio/14.istio安裝時固定ip/" />
        </entry>
        <entry>
            <title>
                11. istio 與 kiali
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/istio/11. istio 與 kiali/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;從istio扯到kiali，是說kiali是真的好用，看東西挺直覺得。&lt;br /&gt;
但有些警告，要解調就要照他的規範走&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;現在最常碰到的，也還沒解&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果使用GKE的私人叢集，請記得要把 master的防火牆規則，開啟8080 ，不然會發生讀取時需要一分鐘，資料才會出現。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;No matching workload found for gateway selector in this namespace&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/11.fig-1.jpg&quot; alt=&quot;11.fig-1.jpg&quot; /&gt;&lt;br /&gt;
簡單講就是目前的namespace沒有找到目前的 ingressgateway，未來可能會發生問題&lt;br /&gt;
ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kiali.io/documentation/v1.13/validations/#_no_matching_workload_found_for_gateway_selector_in_this_namespace&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;No matching workload found for gateway selector in this namespace&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Port name must follow &amp;lt;protocol&amp;gt;[-suffix] form&lt;/code&gt;&lt;br /&gt;
service上的 port name 必須要符合格式，&lt;br /&gt;
格式必須為 &lt;code&gt;http-&lt;/code&gt; 這樣的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  namespace: rd7-video
  labels:
    app: video-api-qa
  name: video-api
spec:
  ports:
  # 需遵照格式 前面為 protocol 後面為 -suffix
  - name: &amp;quot;http-video&amp;quot;
    port: 80
  selector:
    app: video-api-qa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kiali.io/documentation/v1.13/validations/#_port_name_must_follow_protocol_suffix_form&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Port name must follow &amp;lt;protocol&amp;gt;[-suffix] form&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;另外，如果編輯config有錯時，&lt;br /&gt;
按了SAVE沒有反應，錯誤訊息可能在最上面，要將捲軸往上拉。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kiali.io/documentation/v1.13/validations/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;v1.13 validation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;為了kiali的健康度，最好是在pod上面寫個 readinessProbe（就緒探針）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;readinessProbe:
  failureThreshold: 3
  initialDelaySeconds: 30
  periodSeconds: 10
  successThreshold: 1
  tcpSocket:
    port: 80
  timeoutSeconds: 1
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;kiali健康度 檢查 pod 變成 proxy unsynced&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/istio/11.fig-2.jpg&quot; alt=&quot;11.fig-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kiali.io/documentation/latest/configuration/health/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;v1.28Health Configuration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/xuliang666/p/12089915.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;istio之envoy常見術語及狀態碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kiali.io/documentation/latest/features/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kiali圖表說明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;virtualservice is pointing to a non-existent gateway&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/2113395/50571006-acd1b680-0dd9-11e9-9b34-db3f1bc95e08.png&quot; alt=&quot;fig.3&quot; /&gt;&lt;/p&gt;
&lt;p&gt;因為gateway不在同一層的namespace上面，所以要設定名稱時，&lt;br /&gt;
要改用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gateways:
  - istio-ingressgateway-video.sex-system.svc.cluster.local
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/istio/11. istio 與 kiali/" />
        </entry>
        <entry>
            <title>
                0.istio MOC
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/istio/0.istio MOC/</id>
            <content type="html">
                &lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/73.%20istio%20sidecar%20%E6%B3%A8%E5%85%A5%E8%A6%8F%E5%89%87/&quot;&gt;73. istio sidecar 注入規則&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/89.%20istio%20%E5%B8%B8%E8%A6%8B%E7%8B%80%E6%85%8B%E7%A2%BC/&quot;&gt;89. istio 常見狀態碼&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;建置&quot; tabindex=&quot;-1&quot;&gt;建置&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/7.%20Istio%E5%AE%89%E8%A3%9D%E5%8F%8A%E4%BD%BF%E7%94%A8/&quot;&gt;7. Istio安裝及使用&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/11.%20istio%20%E8%88%87%20kiali/&quot;&gt;11. istio 與 kiali&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/14.istio%E5%AE%89%E8%A3%9D%E6%99%82%E5%9B%BA%E5%AE%9Aip/&quot;&gt;14.istio安裝時固定ip&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/20.%20%E8%A8%AA%E5%95%8Fistio%20%E5%85%A7%E9%83%A8%E8%B2%A0%E8%BC%89%E5%B9%B3%E8%A1%A1ip/&quot;&gt;20. 訪問istio 內部負載平衡ip&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/21.%20flagger%20%E8%87%AA%E5%8B%95%E9%87%91%E7%B5%B2%E9%9B%80%E4%BD%88%E7%BD%B2%20for%20istio/&quot;&gt;21. flagger 自動金絲雀佈署 for istio&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/23.istio%E7%9A%84%20prometheus%E6%88%AA%E5%8F%96GKE%20metrics/&quot;&gt;23.istio的 prometheus截取GKE metrics&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/34.%20istio%20operator%20%E5%AE%89%E8%A3%9D%E6%96%B0%E7%9A%84%20ingress%20deploy%E5%8F%8Aservice/&quot;&gt;34. istio operator 安裝新的 ingress deploy及service&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;virtual-service&quot; tabindex=&quot;-1&quot;&gt;VirtualService&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/11.%20istio%20%E8%88%87%20kiali/&quot;&gt;11. istio 與 kiali&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/30.%20istio%E7%9A%84virtualservice%20match%E6%AF%94%E5%B0%8D/&quot;&gt;30. istio的virtualservice match比對&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/35.%20istio%20virtualService%20delegate%E4%BD%BF%E7%94%A8/&quot;&gt;35. istio virtualService delegate使用&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/54.%20istio%20%E6%8E%9B%E8%BC%89ECK%20kibana/&quot;&gt;54. istio 掛載ECK kibana&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/62.%20isito%20%E9%8F%A1%E5%83%8F%E6%B5%81%E9%87%8F/&quot;&gt;62. isito 鏡像流量&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/75.%20istio%20virtual%20service%20%E5%B8%B8%E7%94%A8%E5%8F%83%E6%95%B8/&quot;&gt;75. istio virtual service 常用參數&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/89.%20istio%20%E5%B8%B8%E8%A6%8B%E7%8B%80%E6%85%8B%E7%A2%BC/&quot;&gt;89. istio 常見狀態碼&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/15.istio%E6%9C%8D%E5%8B%99%E7%84%A1%E6%B3%95%E8%A8%AA%E5%95%8F/&quot;&gt;15.istio服務無法訪問&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/18.istio%20Virtual%20Service%20%E8%B7%A8namespace%E8%AE%80%E5%8F%96%20DestinationRule/&quot;&gt;18.istio Virtual Service 跨namespace讀取 DestinationRule&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/31.istio%20%E6%8A%93%E8%9F%B2%E8%A8%98/&quot;&gt;31.istio 抓蟲記&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/istio/0.istio MOC/" />
        </entry>
        <entry>
            <title>
                blog.113. 微軟官方office 大量授權
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Window/blog.113. 微軟官方office 大量授權/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;YT亂看的時候，看到有一個影片，再講如何獲取免費的office，&lt;br /&gt;
這其實不是新聞，但有問題的通常都是再破解上面，&lt;br /&gt;
可能被人惡意亂塞間諜程式或木馬。&lt;br /&gt;
但現在驗證直接從官方來了&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;微軟官方SN：&lt;br /&gt;
&lt;a href=&quot;https://learn.microsoft.com/zh-tw/DeployOffice/vlactivation/gvlks&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;以 KMS 和 Active Directory 為基礎的 Office、Project 和 Visio 啟用 GVLK&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不想看圖片的，請直接看影片&lt;br /&gt;
&lt;a href=&quot;https://www.youtube.com/watch?v=VSjRx7Hoa60&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;如何免費獲取Office軟件？這是最強的安裝教學！ | 零度解說&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面快速說明過程，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先到 微軟官方下載 &lt;a href=&quot;https://www.microsoft.com/en-us/download/details.aspx?id=49117&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Office Deployment Tool&lt;/a&gt;，然後安裝到新的資料夾，這邊指定安裝到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; D:&#92;office  
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然後開啓 &lt;a href=&quot;https://config.office.com/deploymentsettings&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;office 自訂工具&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;選擇你要的產品、項目&lt;br /&gt;
（附註，LTSC代表的是Long Time Service Channel，長期服務通道)&lt;br /&gt;
產品版本：自行挑選&lt;br /&gt;
語言：繁體中文&lt;br /&gt;
授權與啓用：確認是KMS&lt;br /&gt;
其他預設即可。&lt;br /&gt;
好了後，按右上匯出，然後存到剛剛 1. 的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;D:&#92;office 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Container/blog.113-fig.1.jpg&quot; alt=&quot;blog.113-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以最高權限開啓命令提示字元，切換目錄到 剛剛下載的位置，然後下載office，下載完後安裝。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd D:&#92;office 
setup /download config.xml
setup /configure config.xml
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝完成後應該就會啓動了，如果沒有啓動，到剛剛office安裝的位置，通常在 下面位置，版本不同，後面的數字也會不同。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:&#92;Program Files&#92;Microsoft Office&#92;Office16
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以最高權限開啓命令提示字元，切換目錄到 5. 的位置，然後依序執行指令，完成後『重開電腦』。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;cd C:&#92;Program Files&#92;Microsoft Office&#92;Office16
slmgr /skms kms.03k.org
slmgr /ato
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Container/blog.113-fig.2.jpg&quot; alt=&quot;blog.113-fig.2.jpg&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Window/blog.113. 微軟官方office 大量授權/" />
        </entry>
        <entry>
            <title>
                174. win10 下載Microsoft Store的檔案
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Window/174. win10 下載Microsoft Store的檔案/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡唸&quot; tabindex=&quot;-1&quot;&gt;睡睡唸&lt;/h1&gt;
&lt;p&gt;看到XDM有新版的，因爲舊版只要下載有中文字的檔案，&lt;br /&gt;
檔案名稱就是亂碼，但是新版又只能從微軟商店下載...&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;找到網址&lt;br /&gt;
首先你要知道你要的程式的微軟官方商店網址。&lt;br /&gt;
直接用google搜尋即可。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Window/174-fig.1.jpg&quot; alt=&quot;174-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到&lt;a href=&quot;https://store.rg-adguard.net/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;網站&lt;/a&gt; ，貼上你的網址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;選擇副檔名為 『appxbundle』 下載&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Window/174-fig.2.jpg&quot; alt=&quot;174-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://adersaytech.com/tutorial/kb-article/download-ms-store-offline-package.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Win10/Win11 如何下載 Microsoft Store 離線安裝檔？&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Window/174. win10 下載Microsoft Store的檔案/" />
        </entry>
        <entry>
            <title>
                166. MSSQL版本差異
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Window/166. MSSQL版本差異/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;今天在查linux的MSSQL是什麼版本，才發現預設是開發版。&lt;br /&gt;
又延伸一個問題，開發板的上限到哪？&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;因為微軟的網站，連結常死掉，就先節錄過來了，&lt;br /&gt;
在linux上面安裝的是Developer開發者版本，&lt;br /&gt;
功能跟Enterprise一致。&lt;/p&gt;
&lt;h3 id=&quot;差異&quot; tabindex=&quot;-1&quot;&gt;差異&lt;/h3&gt;
&lt;p&gt;指列出資源使用的比較，其他細部功能，請參考下面網址&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;Enterprise&lt;/th&gt;
&lt;th&gt;標準&lt;/th&gt;
&lt;th&gt;Web&lt;/th&gt;
&lt;th&gt;Express&lt;/th&gt;
&lt;th&gt;快速&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;單一執行個體所使用的計算容量上限 - SQL Server 資料庫引擎1&lt;/td&gt;
&lt;td&gt;作業系統最大值&lt;/td&gt;
&lt;td&gt;限制為 4 個插槽或 24 個核心的較小者&lt;/td&gt;
&lt;td&gt;限制為 4 個插槽或 16 個核心的較小者&lt;/td&gt;
&lt;td&gt;限制為 1 個插槽或 4 個核心的較小者&lt;/td&gt;
&lt;td&gt;限制為 1 個插槽或 4 個核心的較小者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;單一執行個體所使用的計算容量上限 - Analysis Services 或 Reporting Services&lt;/td&gt;
&lt;td&gt;作業系統最大值&lt;/td&gt;
&lt;td&gt;限制為 4 個插槽或 24 個核心的較小者&lt;/td&gt;
&lt;td&gt;限制為 4 個插槽或 16 個核心的較小者&lt;/td&gt;
&lt;td&gt;限制為 1 個插槽或 4 個核心的較小者&lt;/td&gt;
&lt;td&gt;限制為 1 個插槽或 4 個核心的較小者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每個 SQL Server 資料庫引擎執行個體的緩衝集區記憶體上限&lt;/td&gt;
&lt;td&gt;作業系統最大值&lt;/td&gt;
&lt;td&gt;128 GB&lt;/td&gt;
&lt;td&gt;64 GB&lt;/td&gt;
&lt;td&gt;1410 MB&lt;/td&gt;
&lt;td&gt;1410 MB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每個 SQL Server 資料庫引擎執行個體的緩衝集區延伸容量上限&lt;/td&gt;
&lt;td&gt;32 * (最大伺服器記憶體設定)&lt;/td&gt;
&lt;td&gt;4 * (最大伺服器記憶體設定)&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每個 SQL Server 資料庫引擎執行個體的資料行存放區區段快取的記憶體上限&lt;/td&gt;
&lt;td&gt;無限制的記憶體&lt;/td&gt;
&lt;td&gt;32 GB&lt;/td&gt;
&lt;td&gt;16 GB&lt;/td&gt;
&lt;td&gt;352 MB&lt;/td&gt;
&lt;td&gt;352 MB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SQL Server 資料庫引擎中每個資料庫的記憶體最佳化資料大小上限&lt;/td&gt;
&lt;td&gt;無限制的記憶體&lt;/td&gt;
&lt;td&gt;32 GB&lt;/td&gt;
&lt;td&gt;16 GB&lt;/td&gt;
&lt;td&gt;352 MB&lt;/td&gt;
&lt;td&gt;352 MB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每個 Analysis Services 執行個體使用的記憶體上限&lt;/td&gt;
&lt;td&gt;作業系統最大值&lt;/td&gt;
&lt;td&gt;表格式：16 GB MOLAP：64 GB&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每個 Reporting Services 執行個體使用的記憶體上限&lt;/td&gt;
&lt;td&gt;作業系統最大值&lt;/td&gt;
&lt;td&gt;64 GB&lt;/td&gt;
&lt;td&gt;64 GB&lt;/td&gt;
&lt;td&gt;4 GB&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;關聯式資料庫大小上限&lt;/td&gt;
&lt;td&gt;524 PB&lt;/td&gt;
&lt;td&gt;524 PB&lt;/td&gt;
&lt;td&gt;524 PB&lt;/td&gt;
&lt;td&gt;10 GB&lt;/td&gt;
&lt;td&gt;10 GB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;訂價&quot; tabindex=&quot;-1&quot;&gt;訂價&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;SQL Server 2017 版本&lt;/th&gt;
&lt;th&gt;適合...&lt;/th&gt;
&lt;th&gt;授權模型&lt;/th&gt;
&lt;th&gt;通路供應情況&lt;/th&gt;
&lt;th&gt;公開無級別價格 (美元)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Enterprise&lt;/td&gt;
&lt;td&gt;全方位的任務關鍵性效能，可滿足嚴苛的資料庫和商業智慧需求。提供最高級的服務和效能，足以應付第 1 層工作負載。[7]&lt;/td&gt;
&lt;td&gt;每個核心[8]&lt;/td&gt;
&lt;td&gt;大量授權、代管&lt;/td&gt;
&lt;td&gt;14,256 美元[9]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Standard - 每一核心&lt;/td&gt;
&lt;td&gt;核心資料管理和商業智慧功能，能以最少的 IT 資源來處理非關鍵的工作負載。&lt;/td&gt;
&lt;td&gt;每個核心[8]&lt;/td&gt;
&lt;td&gt;大量授權、代管&lt;/td&gt;
&lt;td&gt;3,717 美元[9]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Standard - 伺服器 + CAL&lt;/td&gt;
&lt;td&gt;核心資料管理和商業智慧功能，能以最少的 IT 資源來處理非關鍵的工作負載。&lt;/td&gt;
&lt;td&gt;伺服器 + CAL[10]&lt;/td&gt;
&lt;td&gt;大量授權、代管、零售 FPP&lt;/td&gt;
&lt;td&gt;931 美元[9]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Developer&lt;/td&gt;
&lt;td&gt;具有完整功能的 SQL Server 軟體版本，可讓開發人員以符合成本效益的方式建置、測試和展示以 SQL Server 軟體為基礎的應用程式。&lt;/td&gt;
&lt;td&gt;每個使用者&lt;/td&gt;
&lt;td&gt;免費下載&lt;/td&gt;
&lt;td&gt;免費&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Web&lt;/td&gt;
&lt;td&gt;安全、符合成本效益且可高度調整的資料平台，可用來打造公用網站。僅供第三方軟體服務提供者使用。&lt;/td&gt;
&lt;td&gt;不適用&lt;/td&gt;
&lt;td&gt;僅提供代管&lt;/td&gt;
&lt;td&gt;請參閱代管合作夥伴的定價&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Express&lt;/td&gt;
&lt;td&gt;免費的入門級的資料庫，非常適合用來學習和建置最多 10 GB 的桌面與小型伺服器資料驅動應用程式。&lt;/td&gt;
&lt;td&gt;不適用&lt;/td&gt;
&lt;td&gt;免費下載&lt;/td&gt;
&lt;td&gt;免費&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://www.microsoft.com/zh-tw/sql-server/sql-server-2017?rtc=1&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SQLServer 2017&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://learn.microsoft.com/zh-TW/sql/sql-server/editions-and-components-of-sql-server-2017?view=sql-server-ver16#Cross-BoxScaleLimits&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SQL Server 2017 的版本及支援功能&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Window/166. MSSQL版本差異/" />
        </entry>
        <entry>
            <title>
                153.MSSQL減少資料庫大小
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Window/153.MSSQL減少資料庫大小/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;也不知道我怎麼也兼DBA了，有種MIS的感覺，啥都管。&lt;br /&gt;
如果資料量太多，刪除資料後，是不會把空間釋放的，&lt;br /&gt;
需要對資料庫做壓縮，容量才會還出來。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;順便說一下查容量的步驟&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查資料庫的容量&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT DB_NAME(database_id) N&#39;資料庫&#39;, physical_name N&#39;實體檔案&#39;, type_desc N&#39;檔案類型&#39;, state_desc N&#39;檔案狀態&#39;, size*8.0/1024 N&#39;檔案大小(MB)&#39;
FROM sys.master_files
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;查詢資料表大小&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT 
    t.NAME AS TableName,
    s.Name AS SchemaName,
    p.rows,
    SUM(a.total_pages) * 8 AS TotalSpaceKB, 
    CAST(ROUND(((SUM(a.total_pages) * 8) / 1024.00), 2) AS NUMERIC(36, 2)) AS TotalSpaceMB,
    SUM(a.used_pages) * 8 AS UsedSpaceKB, 
    CAST(ROUND(((SUM(a.used_pages) * 8) / 1024.00), 2) AS NUMERIC(36, 2)) AS UsedSpaceMB, 
    (SUM(a.total_pages) - SUM(a.used_pages)) * 8 AS UnusedSpaceKB,
    CAST(ROUND(((SUM(a.total_pages) - SUM(a.used_pages)) * 8) / 1024.00, 2) AS NUMERIC(36, 2)) AS UnusedSpaceMB
FROM 
    sys.tables t
INNER JOIN
    sys.indexes i ON t.OBJECT_ID = i.object_id
INNER JOIN 
    sys.partitions p ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id
INNER JOIN 
    sys.allocation_units a ON p.partition_id = a.container_id
LEFT OUTER JOIN 
    sys.schemas s ON t.schema_id = s.schema_id
WHERE 
    t.NAME NOT LIKE &#39;dt%&#39; 
    AND t.is_ms_shipped = 0
    AND i.OBJECT_ID &amp;gt; 255 
GROUP BY 
    t.Name, s.Name, p.Rows
ORDER BY 
    TotalSpaceMB DESC, t.Name
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;刪除完後，可以先做交易記錄檔壓縮&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;ALTER DATABASE table_name SET RECOVERY simple
use table_name
go
dbcc shrinkfile(&#39;table_name_log&#39;,2)

ALTER DATABASE table_name SET RECOVERY FULL
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;壓縮DB，將空間釋放，可以用指令，也可以直接用SSMS操作&lt;br /&gt;
指令，可以跟step 3 一起動作&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;1.  DBCC SHRINKDATABASE(N&#39;Stage_db&#39; )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或是直接照圖操作&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Window/153-fig.1.jpg&quot; alt=&quot;153-fig.1.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Window/153-fig.2.jpg&quot; alt=&quot;153-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ithelp.ithome.com.tw/questions/10209350&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SQL SERVER 壓縮資料庫後MDF沒變小&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hackmd.io/@ab-5tCCfRu2OkxqJptnkGg/BJFBvHD2w&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;MsSql 壓縮資料庫(含修復資料庫)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dotblogs.com.tw/jamesfu/2014/02/23/compression&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[SQL]斯斯有三種，SQL Server 上資料庫的「壓縮」也有三種喔 !&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/zh-tw/sql/t-sql/database-console-commands/dbcc-shrinkdatabase-transact-sql?view=sql-server-ver16&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;DBCC SHRINKDATABASE (Transact-SQL)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hackmd.io/@Not/H1YBRk6qw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;清除SQL Server Log檔 (交易紀錄)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dotblogs.com.tw/jamesfu/2015/05/16/deleterecords&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;解決大量資料刪除，造成資料庫交易紀錄檔案容量過大且耗費時間之處理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/Window/153.MSSQL減少資料庫大小/" />
        </entry>
        <entry>
            <title>
                160.Obsidian發佈網站
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/SideProject/160.Obsidian發佈網站/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;因為被google的blog搞了一波（原因請看&lt;a href=&quot;https://daimom3020.blogspot.com/2023/07/blog-post.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;這&lt;/a&gt; ），&lt;br /&gt;
讓我終於下定決心研究 md轉html的方法。&lt;/p&gt;
&lt;h1 id=&quot;發佈方式&quot; tabindex=&quot;-1&quot;&gt;發佈方式&lt;/h1&gt;
&lt;p&gt;從Obsidian發佈主要有幾種方法，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;官方提供 ，每個月8美金，詳情參考 &lt;a href=&quot;https://obsidian.md/publish&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;這裏&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;jekyll ，也有人是用這個掛上去的，格式稍微改一下，然後在github上面改一下設定，push上去就會自動部署了，改天再用另一篇介紹，因為要改許多東西，我就沒用這種了&lt;/li&gt;
&lt;li&gt;Obsidian的第三方plugin , Digital Garden ，本篇就是透過這套來發佈網站。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;原文連結： &lt;a href=&quot;https://dg-docs.ole.dev/getting-started/01-getting-started/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Digital Garden-Get start&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先在obsidian安裝 digital Garden&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/SideProject/160-fig.1.jpg&quot; alt=&quot;160-fig.1.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/SideProject/160-fig.2.jpg&quot; alt=&quot;160-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一個&lt;a href=&quot;https://daimom.vercel.app/github.com&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Github&lt;/a&gt;帳號。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;申請 &lt;a href=&quot;https://vercel.com/signup&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Vercel&lt;/a&gt;，用github帳號登入。&lt;br /&gt;
如果要用&lt;a href=&quot;https://www.netlify.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Netlify&lt;/a&gt;應該也可以，&lt;br /&gt;
這兩個網站都是直接用子域名作爲你的網站名稱，&lt;br /&gt;
github以前也有，但現在已經改掉了。&lt;br /&gt;
(記得在這邊，會問你要給Vercel哪個repostory的權限，可以全給，之後再到github 的設定指定repostory就好)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打開作者的&lt;a href=&quot;https://github.com/oleeskild/digitalgarden&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;repository &lt;/a&gt;，按下下面的部署按鈕，會到Vercel部署一個網站。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/SideProject/160-fig.3.jpg&quot; alt=&quot;160-fig.3.jpg&quot; /&gt;&lt;br /&gt;
如果你熟git的話，也可以直接clone那個repository，&lt;br /&gt;
再自己到vercel或Netlify部署上去也可以。&lt;/p&gt;
&lt;p&gt;如果你想要再本機測試開啓的話，&lt;br /&gt;
clone這個專案後，執行下面程式，注意需先安裝&lt;a href=&quot;https://nodejs.org/zh-tw/download&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;nodejs&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;npm install
npm run build
npm run start
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;再來需建立github token，這是為了讓Vercel可以讀取到你的repostory。&lt;br /&gt;
開啓&lt;a href=&quot;https://github.com/settings/tokens/new?scopes=repo&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;github token&lt;/a&gt;，取個名字、建立。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&quot;github-token&quot; tabindex=&quot;-1&quot;&gt;建立github token&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/SideProject/160-fig.4.jpg&quot; alt=&quot;160-fig.4.jpg&quot; /&gt;&lt;br /&gt;
Expiration ：到期天數，如果不想一直改的話，就設定沒有期限。&lt;br /&gt;
下面紅框是必須要有的權限。&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;
&lt;p&gt;打開你的obsidian的Digital Garden設定&lt;br /&gt;
在四個方塊裏面輸入你的資訊&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/SideProject/160-fig.5.jpg&quot; alt=&quot;160-fig.5.jpg&quot; /&gt;&lt;br /&gt;
Github Repo Name： 前面所新增的repostory的名稱&lt;br /&gt;
Github UserName：你的帳號名稱&lt;br /&gt;
Github Token：步驟5建立的資料&lt;br /&gt;
BaseUrl ：如果你剛剛已經初步在Vercel建立一個網站的話，應該就會看到你的網址。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/SideProject/160-fig.6.jpg&quot; alt=&quot;160-fig.6.jpg&quot; /&gt;&lt;br /&gt;
我這邊有兩個domain，前面的&lt;a href=&quot;http://daimom.vercel.app/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;http://daimom.vercel.app&lt;/a&gt;  是後來自定的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;發佈&lt;br /&gt;
先到你要設成首頁的文章上面，設定&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;dg-publish: true
dg-home: true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;dg-publish ：表示發佈&lt;br /&gt;
dg-home：表示設爲首頁&lt;/p&gt;
&lt;p&gt;再來你有兩種方法可以發佈，叫出Obsidian的命令面板&lt;br /&gt;
Win： CTRL+P&lt;br /&gt;
Mac：Cmd+P&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/SideProject/160-fig.7.jpg&quot; alt=&quot;160-fig.7.jpg&quot; /&gt;&lt;br /&gt;
先輸入dg，然後會看到 &lt;code&gt;Digital Garden: Publish Single Note&lt;/code&gt;&lt;br /&gt;
執行後就會發佈到Vercel。&lt;/p&gt;
&lt;p&gt;或是 GUI畫面&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/SideProject/160-fig.8.jpg&quot; alt=&quot;160-fig.8.jpg&quot; /&gt;&lt;br /&gt;
按下 &lt;code&gt;Publish unpublished Note&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;建置&lt;br /&gt;
如果你速度夠快，切到Vercel的網站，會看到Deployment正在執行的畫面，或是已經執行完成的畫面。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/SideProject/160-fig.9.jpg&quot; alt=&quot;160-fig.9.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;q-and-amp-a&quot; tabindex=&quot;-1&quot;&gt;Q&amp;amp;A&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;切換主題的時候，有時候會沒有更改，此時請按下 設定的 Update site 的Manage site Template按鈕，他會幫你建立PR。 ref. &lt;a href=&quot;https://dg-docs.ole.dev/getting-started/06-updating-the-template/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Updating the template&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;主題改得只有顏色跟字體大小，如果要右邊的路徑圖可以到設定打開 &lt;code&gt;Show local graph for notes&lt;/code&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/SideProject/160-fig.10.jpg&quot; alt=&quot;160-fig.10.jpg&quot; /&gt;&lt;br /&gt;
更多的設定，請參考&lt;a href=&quot;https://dg-docs.ole.dev/getting-started/03-note-settings/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Note settings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本篇的theme是 &lt;code&gt;Rmaki&lt;/code&gt; ，一些小設定是我改css跟js改出來的。&lt;/li&gt;
&lt;li&gt;如果要整批加入發佈的yaml，可以考慮使用 &lt;a href=&quot;https://github.com/chhoumann/MetaEdit&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;MetaEdit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;將Vercel的權限限縮特定repostory，先到github的個人設定畫面，找到 Application&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/SideProject/160-fig.11.jpg&quot; alt=&quot;160-fig.11.jpg&quot; /&gt;&lt;br /&gt;
按下Configure&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/SideProject/160-fig.12.jpg&quot; alt=&quot;160-fig.12.jpg&quot; /&gt;&lt;br /&gt;
從原先的All repostories改成 Only select repositories，&lt;br /&gt;
最後指定你的repository即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://dg-docs.ole.dev/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Digital Garden Doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://fengrin.me/posts/2022-12-19-publish-your-website-free-use-your-local-note-obsidian-gitHub-netlify&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;免費直接把筆記發佈成網站:Obsidian + GitHub + Netlify&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://notes.oldwinter.top/obsidian-%E7%9B%AE%E5%89%8D%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84%E5%85%8D%E8%B4%B9%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88-%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%95%99%E7%A8%8B&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;obsidian 目前最完美的免費發佈方案 - 漸進式教學&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/SideProject/160.Obsidian發佈網站/" />
        </entry>
        <entry>
            <title>
                125. Google sheet Query
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/SideProject/125. Google sheet Query/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;今天收到個消息，說要給user hosts的檔案，&lt;br /&gt;
裏面內容要包含目前的dns跟ip的對應，&lt;br /&gt;
但我日後不想手動更新阿...&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h2 id=&quot;開始發想&quot; tabindex=&quot;-1&quot;&gt;開始發想&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;本來是想用if ，單獨判斷一個欄位是不是符合規則。&lt;br /&gt;
但這樣會有個問題，當資料變動時，就必須手動拉公式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查到一個&lt;a href=&quot;https://vocus.cc/article/6162ebdafd89780001c6fb8b&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;importrange&lt;/a&gt;的函數，可以整批匯入資料，&lt;br /&gt;
但這樣我還是要分析截取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在查資料過程中，發現query函數，能夠整個sheet搜尋 ，&lt;br /&gt;
就像SQL語法一樣，就決定是你了！！！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;實作&quot; tabindex=&quot;-1&quot;&gt;實作&lt;/h2&gt;
&lt;p&gt;QUERY使用 欄位的做關鍵字，&lt;br /&gt;
不過只有基本的查詢功能。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;=query(Prod!4:1010,&amp;quot;select D,E,G where G=&#39;Y&#39; order by E desc&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/SideProject/125-fig.1.jpg&quot; alt=&quot;125-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;比較特別的應該是&lt;br /&gt;
where裏面的 文字搜尋&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Where A contains &#39;Ezio&#39;      查詢包含Ezio的字
Where A starts with &#39;Ezio&#39;   查詢Ezio開頭的字
Where A ends with &#39;Ezio&#39;     查詢Ezio結尾的字
Where A like &#39;%Ezio&#39;         跟SQL的like差不多意思
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，like 後面接 % 是 任意字元  ,  如果接 _ 就是一個字元&lt;/p&gt;
&lt;p&gt;多了一些mysql 的語法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select A,B limit 3       只取3行的資料
select A,B offset 3      跳過3行，開始取資料
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;還有一個特別的，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select A,B SKIPPING 2     每隔2行抓一次資料
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他相似的就&lt;br /&gt;
聚合函數  SUM()、AVG()、COUNT()、MAX()、MIN()&lt;br /&gt;
排序 order by&lt;br /&gt;
另外還支援 PIVOT&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://vocus.cc/mrsheet/606b50b8fd897800011eba1d&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;QUERY 函式大解析（一）：基本原理與 SELECT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/SideProject/125. Google sheet Query/" />
        </entry>
        <entry>
            <title>
                README
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/</id>
            <content type="html">
                &lt;h1 id=&quot;度估記事本&quot; tabindex=&quot;-1&quot;&gt;度估記事本&lt;/h1&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;懶人，始終相信科技始終來自於人類的惰性。&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;懶是一種方式，卻不是一種態度。&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;你如果想要有更多的時間偷懶，就一定要有最高的效率。&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;obsidian&quot; tabindex=&quot;-1&quot;&gt;用Obsidian發佈網站&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/SideProject/160.Obsidian%E7%99%BC%E4%BD%88%E7%B6%B2%E7%AB%99/&quot;&gt;160.Obsidian發佈網站&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;last-post&quot; tabindex=&quot;-1&quot;&gt;Last Post:&lt;/h1&gt;
&lt;p&gt;最近事情多，寫了也都沒分類，有點麻煩。&lt;br /&gt;
日後應該是先發佈，改天再歸類到各自的資料夾好了。&lt;br /&gt;
希望不會累積太多沒歸類到資料夾。&lt;/p&gt;
&lt;p&gt;1/12&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/192.%20%E8%87%AA%E5%BB%BA%E7%9A%84k8s%E6%8B%89%E5%8F%96private%20registry/&quot;&gt;192. 自建的k8s拉取private registry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/193.%20pod%20debug%E6%96%B9%E5%BC%8F/&quot;&gt;193. pod debug方式&lt;/a&gt;]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;11/8&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Observability/184.%20grafana%20error%20%20reverse%20proxy%20settings%20on%20istio/&quot;&gt;184. grafana error  reverse proxy settings on istio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Terraform/183.%20Terrafrom%20%E5%BB%BA%E7%AB%8Bprivate%20cluster/&quot;&gt;183. Terrafrom 建立private cluster&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Network/182.%20Fortigate%20%E8%A8%AD%E5%AE%9A%20%E5%85%A7%E9%83%A8%E6%9C%8D%E5%8B%99%E8%B2%A0%E8%BC%89%E5%B9%B3%E8%A1%A1/&quot;&gt;182. Fortigate 設定 內部服務負載平衡&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/181.%20cloudstorage%E7%84%A1%E6%B3%95%E4%BD%BF%E7%94%A8cloudflare%E8%BD%89%E5%9D%80/&quot;&gt;181. cloudstorage無法使用cloudflare轉址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/Price/180.%20GCP%20%E7%9B%A3%E6%8E%A7%E8%B2%BB%E7%94%A8/&quot;&gt;180. GCP 監控費用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;tag&quot; tabindex=&quot;-1&quot;&gt;Tag列表&lt;/h1&gt;
&lt;p&gt;💡：Map Of Content&lt;br /&gt;
💻：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Code/0.Code%20MOC/&quot;&gt;0.Code MOC&lt;/a&gt;&lt;br /&gt;
🐳：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Container/0.Container%20MOC/&quot;&gt;Container MOC&lt;/a&gt;&lt;br /&gt;
⏱：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Drone/0.Drone%20MOC/&quot;&gt;0.Drone MOC&lt;/a&gt;&lt;br /&gt;
🗒：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/0.EFK%20MOC/&quot;&gt;EFK MOC&lt;/a&gt;&lt;br /&gt;
☁︎：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/0.GCP%20MOC/&quot;&gt;GCP MOC&lt;/a&gt;&lt;br /&gt;
📥：inbox&lt;br /&gt;
⛵️：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/0.istio%20MOC/&quot;&gt;istio MOC&lt;/a&gt;&lt;br /&gt;
⎈：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/0.K8s%20MOC/&quot;&gt;k8s MOC&lt;/a&gt;&lt;br /&gt;
🐧：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/0.Linux%20MOC/&quot;&gt;Linux MOC&lt;/a&gt;&lt;br /&gt;
🍎：Apple&lt;br /&gt;
☎️：Network&lt;br /&gt;
👁：Observability&lt;br /&gt;
🎮：Game&lt;br /&gt;
🆒：Side Project&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;what-is-moc&quot; tabindex=&quot;-1&quot;&gt;What is MOC ?&lt;/h1&gt;
&lt;p&gt;當單一筆記的數量越來越多時，就能夠構成一個MOC(Map of Contens)&lt;br /&gt;
詳細請參考下面連結，&lt;br /&gt;
&lt;a href=&quot;https://medium.com/pm%E7%9A%84%E7%94%9F%E7%94%A2%E5%8A%9B%E5%B7%A5%E5%85%B7%E7%AE%B1/%E6%95%B8%E4%BD%8D%E7%AD%86%E8%A8%98%E5%A4%AA%E5%A4%9A%E5%BE%88%E5%87%8C%E4%BA%82%E6%80%8E%E9%BA%BC%E8%BE%A6-451a6cb4ab17&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;數位筆記太多很凌亂怎麼辦？使用 MOC 架構有系統地管理數百則的數位筆記&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;舊筆記&quot; tabindex=&quot;-1&quot;&gt;舊筆記&lt;/h1&gt;
&lt;p&gt;2021年以前文章請至 &lt;a href=&quot;https://daimom3020.blogspot.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;度估記事本&lt;/a&gt; 查詢&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/" />
        </entry>
        <entry>
            <title>
                184. grafana error  reverse proxy settings on istio
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Observability/184. grafana error  reverse proxy settings on istio/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;搬project，就想乾脆上istio了，&lt;br /&gt;
然後就卡到怎麼以前的grafana開的起來，現在的開不起來。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;照以前的方式設定完 root_url，&lt;br /&gt;
還是出現相同錯誤&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Observability/184-fig.1.jpg&quot; alt=&quot;184-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;查文件後才發現，&lt;br /&gt;
應該是新版(9.5.5)需要加上&lt;code&gt;serve_from_sub_path&lt;/code&gt;的參數，&lt;br /&gt;
如果碰到只加了root_url也是看到錯誤，就再加個參數吧。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;grafana.ini&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[server]
root_url = &amp;quot;http://&amp;lt;ip&amp;gt;/grafana/&amp;quot;
serve_from_sub_path = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;virtualservice.yaml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: istio-virtualservice
  namespace: istio-system
spec:
  hosts:
  - &amp;quot;&amp;lt;ip&amp;gt;&amp;quot;
  gateways:
    - istio-system/istio-gateway
  http: 
  - name: &amp;quot;grafana&amp;quot;
    match:
      - uri:
          prefix: /grafana/
      - uri:
          exact: /grafana
    route:
      - destination:
          port:
            number: 3000
          host:  grafana.istio-system.svc.cluster.local  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://grafana.com/tutorials/run-grafana-behind-a-proxy/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Run Grafana behind a reverse proxy&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Observability/184. grafana error  reverse proxy settings on istio/" />
        </entry>
        <entry>
            <title>
                179.  install Bindplane
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Observability/179.  install Bindplane/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近看完2023 Google  Cloud summit ，&lt;br /&gt;
看到一個新東西，OpenTelemetry，可以不用埋程式用sidecar的方式，&lt;br /&gt;
就能做到Observability的trace，&lt;br /&gt;
一開始安裝OpenTelemetry，後來發現，&lt;br /&gt;
他好肥（測試cluster空間不足），之後還搞錯了一件事情。&lt;br /&gt;
後來改測試Bindplane。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;what-is-bindplane&quot; tabindex=&quot;-1&quot;&gt;What is Bindplane?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Bindplane is an open source solution utilizing the OpAMP protocol to configure, monitor, and deploy various collectors.&lt;br /&gt;
Bindplane 是一個開源解決方案，利用 OpAMP 協定來設定、監控和部署各種收集器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;他是一個監控跟log的收集器，他並不是像efk或google cloud那樣的東西。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://isitobservable.io/open-telemetry/what-is-bindplane-and-what-does-it-do&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;What is OpAMP? And what is Bindplane?&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;安裝&quot; tabindex=&quot;-1&quot;&gt;安裝&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Helm add source&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-ssh&quot;&gt;helm repo add &amp;quot;bindplane&amp;quot; &#92; &amp;quot;https://observiq.github.io/bindplane-op-helm&amp;quot;
helm repo update
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;建立組態 values.yaml&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;config:
  username: &amp;quot;admin&amp;quot;
  password: &amp;quot;admin&amp;quot;
  secret_key: &amp;quot;13c15d7c-233e-49e3-bef4-f7498f33518f&amp;quot;
  sessions_secret: &amp;quot;a4e5aa85-5df4-4edd-8cfe-d8a7257d09dd&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/observIQ/bindplane-op-helm/tree/main/charts/bindplane&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;完整設定參數&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;安裝&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;helm upgrade --install &amp;quot;bindplane&amp;quot; &#92;
  --values &amp;quot;values.yaml&amp;quot; &#92;
  --namespace bindplane &#92;
  --create-namespace &#92;
  bindplane/bindplane
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://docs.bindplane.observiq.com/docs/kubernetes-deploy-bindplane-op-server&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Deploy BindPlane OP Server on K8s&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;設定&quot; tabindex=&quot;-1&quot;&gt;設定&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;設定port forward轉過去服務上&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kubectl port-forward -n bindplane svc/bindplane 3001
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/Observability/179.  install Bindplane/" />
        </entry>
        <entry>
            <title>
                178. Install Prometheus Operator
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Observability/178. Install Prometheus Operator/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近看完2023 Google  Cloud summit ，&lt;br /&gt;
看到一個新東西，OpenTelemetry，可以不用埋程式用sidecar的方式，&lt;br /&gt;
就能做到Observability的trace，&lt;br /&gt;
但在那之前，我要先在測試叢集裝一下Prometheus Operator，&lt;br /&gt;
不然資料傳不過去。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;git clone&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/prometheus-operator/kube-prometheus
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;install&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kubectl apply --server-side -f manifests/setup
kubectl wait &#92;
	--for condition=Established &#92;
	--all CustomResourceDefinition &#92;
	--namespace=monitoring
kubectl apply -f manifests/
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;刪除&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubectl delete --ignore-not-found=true -f manifests/ -f manifests/setup
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不過這個安裝方式，會包含&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&quot;https://github.com/prometheus-operator/prometheus-operator&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Prometheus Operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Highly available &lt;a href=&quot;https://prometheus.io/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Prometheus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Highly available &lt;a href=&quot;https://github.com/prometheus/alertmanager&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Alertmanager&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/prometheus/node_exporter&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Prometheus node-exporter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kubernetes-sigs/prometheus-adapter&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Prometheus Adapter for Kubernetes Metrics APIs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kubernetes/kube-state-metrics&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kube-state-metrics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://grafana.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Grafana&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自定安裝的話，也可以利用helm&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自訂安裝,&lt;a href=&quot;https://github.com/prometheus-community/helm-charts/blob/main/charts/kube-prometheus-stack/values.yaml&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;設定參考&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm install test prometheus-community/kube-prometheus-stack --namespace monitoring --create-namespace --values values.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Observability/178-fig.1.jpg&quot; alt=&quot;178-fig.1.jpg&quot; /&gt;&lt;br /&gt;
上面指令使用test當關鍵字，所以部署時也會在上面增加&lt;/p&gt;
&lt;h1 id=&quot;補充&quot; tabindex=&quot;-1&quot;&gt;補充&lt;/h1&gt;
&lt;p&gt;如果不想自己架Prometheus，也不想用Google Cloud Monitor，&lt;br /&gt;
可以考慮Google自己出的 &lt;a href=&quot;https://cloud.google.com/stackdriver/docs/managed-prometheus?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Google Managed Prometheus 官方文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/prometheus-operator/kube-prometheus&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Github- kube-prometheus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.amis.com/kubernetes-operators-prometheus-3584edd72275&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Helm安裝 Prometheus Operator — 為 Kubernetes 設定及管理 Prometheus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/%E8%BC%95%E9%AC%86%E5%B0%8F%E5%93%81-pks%E8%88%87k8s%E7%9A%84%E9%BB%9E%E6%BB%B4/google-managed-prometheus-gmp-522a25572e35&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Google Managed Prometheus (GMP)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/Observability/178. Install Prometheus Operator/" />
        </entry>
        <entry>
            <title>
                99. nginx的除錯筆記
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Network/99. nginx的除錯筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;我一直對nginx不太熟，&lt;br /&gt;
目前也只到了會用，大部分的指令看得懂。&lt;br /&gt;
但湊在一起，還是要查一下。&lt;/p&gt;
&lt;p&gt;這次的錯誤就發生在我以為的問題上&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;又多了一個新服務要架設，&lt;br /&gt;
所以想當然，東西又丟到我這來了。&lt;br /&gt;
這次跟以前的比較不一樣，這次是一個全新的服務。&lt;br /&gt;
所以之前的自動佈署、yaml、nginx設定檔通通重來。&lt;br /&gt;
雖然說是重來，但也只是複製貼上改一改，然後就炸了XDDDD&lt;/p&gt;
&lt;p&gt;我複製之前的設定檔像這個樣子。中間刪除了很多東西，&lt;br /&gt;
請不要照抄。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server_tokens off;
log_format  client  &#39;$remote_addr - $remote_user [$time_local] , &#39;
                  &#39;http-host: &amp;quot;$http_host&amp;quot; , URL: &amp;quot;$request&amp;quot;  , request-status : &amp;quot;$status&amp;quot;  ,   &#39;
                  &#39;body-byte: $body_bytes_sent  ,http-referer: &amp;quot;$http_referer&amp;quot;  ,&#39;
                  &#39;user-agent: &amp;quot;$http_user_agent&amp;quot; , X-Forwarded-For : &amp;quot;$http_x_forwarded_for&amp;quot; ,  &#39;
                  &#39; request-time: &amp;quot;$request_time&amp;quot;  , response_time : &amp;quot;$upstream_response_time&amp;quot;  &#39;;

client_max_body_size 100m;
gzip on;
gzip_min_length 1k;
gzip_buffers 4 16k;
gzip_comp_level 5;
gzip_types text/plain text/css application/x-javascript application/javascript application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;

# GCP HTTP(S) LoadBalancer will add Via, but nginx check it to disable compress by default...
gzip_proxied any;
gzip_vary on;

server {
    listen 80 default_server;
    listen [::]:80 default_server;
    access_log  /dev/stdout   client;
      error_log /dev/stderr;
        
    index index.html index.htm;
    location = /favicon.ico { access_log off; log_not_found off; }
    location = /robots.txt  { access_log off; log_not_found off; }
      

    location /api/socket.io/ {
        proxy_pass http://rd5-api;
        proxy_set_header Host $host;
        proxy_set_header token $rd5_token;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        # proxy_set_header X-NginX-Proxy true;
        proxy_set_header X-Real-IP $remote_addr;
        # proxy_set_header via &#39;proxy_pass/token-proxy ws&#39;;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection &amp;quot;Upgrade&amp;quot;;
        proxy_read_timeout 1d;
        
    }

    location /50x.html {
        root /usr/share/nginx/html/frontend-client/;
        internal;
    }
    location /healthz {
        access_log off;
        return 200 &#39;ok&#39;;
    }

    location / {
        error_page 418 = @fjysdz;
        recursive_error_pages on;

        if ($host = &#39;yb-test.fjysdz.cn&#39;) {
           return 418;
        }
        rewrite &amp;quot;^(.*)&#92;$&amp;quot; $1 permanent; # 去除url尾部重複斜線
        root /usr/share/nginx/html/frontend-client/$dir;
        add_header via frontend-proxy;
        try_files $uri $uri/ /index.html /index.htm =404;
    }



}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後就出現錯誤了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;server_tokens&amp;quot; directive is not allowed here&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我百思不得其解，我明明是照抄的怎麼會錯。&lt;br /&gt;
後來將server_tokens搬進去 server 的區塊內，好了能跑了。&lt;br /&gt;
但又爆出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;log_format&amp;quot; directive is not allowed here&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我又只好在最外層加上http {}  ，但心中一直有一個疑問，&lt;br /&gt;
為什麼會失敗！？&lt;/p&gt;
&lt;p&gt;最後變成這樣&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
events {
     worker_connections 1024;
}
http {

log_format  client  &#39;$remote_addr - $remote_user [$time_local] , &#39;
                  &#39;http-host: &amp;quot;$http_host&amp;quot; , URL: &amp;quot;$request&amp;quot;  , request-status : &amp;quot;$status&amp;quot;  ,   &#39;
                  &#39;body-byte: $body_bytes_sent  ,http-referer: &amp;quot;$http_referer&amp;quot;  ,&#39;
                  &#39;user-agent: &amp;quot;$http_user_agent&amp;quot; , X-Forwarded-For : &amp;quot;$http_x_forwarded_for&amp;quot; ,  &#39;
                  &#39; request-time: &amp;quot;$request_time&amp;quot;  , response_time : &amp;quot;$upstream_response_time&amp;quot;  &#39;;

client_max_body_size 100m;
gzip on;
gzip_min_length 1k;
gzip_buffers 4 16k;
gzip_comp_level 5;
gzip_types text/plain text/css application/x-javascript application/javascript application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;

# GCP HTTP(S) LoadBalancer will add Via, but nginx check it to disable compress by default...
gzip_proxied any;
gzip_vary on;

server {

    server_tokens off;
    listen 80 default_server;
    listen [::]:80 default_server;
    access_log  /dev/stdout   client;
      error_log /dev/stderr;
        
    index index.html index.htm;
    location = /favicon.ico { access_log off; log_not_found off; }
    location = /robots.txt  { access_log off; log_not_found off; }
      
    location /conf/domain {
       access_log off;
        default_type application/json;
        add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;
        add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET&#39;;
        return 200 &#39;{&amp;quot;domain&amp;quot;:&amp;quot;500015&amp;quot;, &amp;quot;site&amp;quot;: &amp;quot;porn1&amp;quot; ,&amp;quot;cdn&amp;quot;:&amp;quot;x-cdn-yb&amp;quot;}&#39;;
    }

    # frontend-client
    error_page 404 /404.html;
    error_page 500 502 503 504 /50x.html;
    location /404.html {
        root /usr/share/nginx/html/frontend-client/;
        internal;
    }
    location /50x.html {
        root /usr/share/nginx/html/frontend-client/;
        internal;
    }
    location /healthz {
        access_log off;
        return 200 &#39;ok&#39;;
    }

    location / {
        rewrite &amp;quot;^(.*)&#92;$&amp;quot; $1 permanent; # 去除url尾部重複斜線
        root /usr/share/nginx/html/$dir;
        add_header via frontend-proxy;
        try_files $uri $uri/ /index.html /index.htm =404;
    }


}


}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跑是能正常跑了，但頁面載入一直出問題，&lt;br /&gt;
因為nginx log正常了，就聯絡前端同仁幫看一下。&lt;br /&gt;
他說從伺服器取得的css context-type有問題。&lt;br /&gt;
查了一下，又發現一個東西沒帶。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;include /etc/nginx/mime.types;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;為什麼一個能跑一個不能跑？？？&lt;br /&gt;
最後發現一個重點。&lt;/p&gt;
&lt;h3 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h3&gt;
&lt;p&gt;Nginx 的設定檔預設的位置是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/etc/nginx/nginx.conf&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然後，這個檔案裡面會先寫好預設的設定。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &#39;
                      &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39;
                      &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&#39;;

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#tcp_nopush&quot;&gt;#tcp_nopush&lt;/a&gt;     on;

    keepalive_timeout  65;

    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#gzip&quot;&gt;#gzip&lt;/a&gt;  on;

    include /etc/nginx/conf.d/*.conf;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以能跑的服務，是因為他的設定檔放在 conf.d 裡面，&lt;br /&gt;
所以是從 nginx.conf載入 /etc/nginx/conf.d/*.conf 的設定。&lt;/p&gt;
&lt;p&gt;而不能跑的服務，我是將設定檔直接覆蓋 /etc/nginx/nginx.conf  ，&lt;br /&gt;
所以上面那一些設定我都沒寫到。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.796t.com/content/1546357704.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;nginx中CSS重定向解析有問題——mime.type詳解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/188358/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Nginx筆記（二）Nginx基礎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/Network/99. nginx的除錯筆記/" />
        </entry>
        <entry>
            <title>
                92. proxy 代理
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Network/92. proxy 代理/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;代理伺服器，以前最常用過的應該是Hinet的proxy，&lt;br /&gt;
在以前網路不快的時候，有時會掛prxoy，來讓瀏覽速度變快。&lt;br /&gt;
proxy的用途主要也是如此，將user的請求透過prxoy去跟網站取得資料，再回給user。&lt;/p&gt;
&lt;p&gt;但proxy分成很多種..下面簡單說明&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;HTTP代理&lt;br /&gt;
主要用於存取網頁，一般有內容過濾和快取功能（將HTTP請求轉發到所需的HTTP伺服器）。&lt;br /&gt;
user使用方法，是瀏覽器掛http代理伺服器後，去瀏覽網頁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP代理&lt;br /&gt;
伺服器端實作轉發TCP請求，當訪問本機的port時，會轉到指定ip的port上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP代理&lt;br /&gt;
伺服器端實作轉發UDP請求，當訪問本機的port時，會轉到指定ip的port上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;內網穿透&lt;br /&gt;
將內網服務提供給外部做使用, Ngrok,frp&lt;br /&gt;
，當請求連到外網server的固定port時，轉發到內網服務的port上。&lt;br /&gt;
（需在提供服務的內網server及外網的server分別設定）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SOCKS代理&lt;br /&gt;
只是單純傳遞封包，不關心具體協定和用法，所以速度快很多（更低的協定，SOCKS5能處理udp protocol)。&lt;br /&gt;
第五層協定，故能處理HTTP，HTTPS，POP3，SMTP和FTP。&lt;br /&gt;
user簡易使用方法：使用 ssh tunnel 連到內部主機。&lt;br /&gt;
(比較偏伺服器端建設，需額外的軟體透過socks協定連入)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SS代理&lt;br /&gt;
Shadowsocks，基於SOCKS5代理方式的加密協定&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref.&lt;br /&gt;
1. &lt;a href=&quot;https://zh.wikipedia.org/zh-tw/SOCKS&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SOCKS&lt;/a&gt;&lt;br /&gt;
2. &lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;代理伺服器&lt;/a&gt;&lt;br /&gt;
3. &lt;a href=&quot;https://www.netadmin.com.tw/netadmin/zh-tw/technology/E76819FB28CC4C3D99D3A6C37B6BD3F4&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;實戰frp內網穿透　內部主機也能對外服務&lt;/a&gt;&lt;br /&gt;
4. &lt;a href=&quot;https://www.easyatm.com.tw/wiki/SOCKS5%E4%BB%A3%E7%90%86&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SOCKS5代理&lt;/a&gt;&lt;br /&gt;
5. &lt;a href=&quot;https://yangxikun.com/http/2017/09/16/http-proxy.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Golang動手寫一個Http Proxy&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;題外話補充：&lt;/p&gt;
&lt;h2 id=&quot;正向代理：&quot; tabindex=&quot;-1&quot;&gt;正向代理：&lt;/h2&gt;
&lt;p&gt;代理用戶端，讓伺服器不知道用戶的IP&lt;/p&gt;
&lt;h2 id=&quot;反向代理：&quot; tabindex=&quot;-1&quot;&gt;反向代理：&lt;/h2&gt;
&lt;p&gt;代理伺服器端，讓用戶不知道伺服器端的IP&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://www.pressplay.cc/author/28A3631456F0C5949514CAD4CB43150D&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;用人類語言跟你說甚麼是正向代理(Forward Proxy)和反向代理(Reverse Proxy)&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Network/92. proxy 代理/" />
        </entry>
        <entry>
            <title>
                182. Fortigate 設定 內部服務負載平衡
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Network/182. Fortigate 設定 內部服務負載平衡/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;&amp;amp;(&lt;/em&gt;&amp;amp;%(%^&amp;amp;&lt;em&gt;%@#$%^((&amp;amp;^%&lt;/em&gt; 一連串消音，&lt;br /&gt;
說過我只會簡易的網路管理，然後現在叫我搞這個，&lt;br /&gt;
目前是第二次，再來一次，直接畢業好了。&lt;br /&gt;
直接去改客戶的防火牆設定是你瘋了，還是我瘋了。&lt;br /&gt;
弄不好網路全斷誰負責！？&lt;br /&gt;
還是你認爲網路很簡單，那你他馬的怎麼不自己搞。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;要達成的目標，user呼叫一個ip網址，會自動轉到其他的伺服器上面 。&lt;/p&gt;
&lt;p&gt;主要參考fortigate官網說明，&lt;a href=&quot;https://docs.fortinet.com/document/fortigate/6.2.15/cookbook/713497/virtual-server&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Virtual server&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;測試使用的FortiOS版本為 7.2.5&lt;/p&gt;
&lt;h4 id=&quot;簡略說明&quot; tabindex=&quot;-1&quot;&gt;簡略說明&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;打開 Virtual server&lt;br /&gt;
如果沒看到，需到 System -&amp;gt; Feature Visibility 開啓 Additional Features底下的  Load Balance&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Network/182-fig.1.png&quot; alt=&quot;182-fig.1.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;新增Virtual Server&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Network/182-fig.2.png&quot; alt=&quot;182-fig.2.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;新增Firewall Policy&lt;br /&gt;
問題點在 Inspection Mode ，選擇 Flow-based的話，會找不到你剛剛設定的virtual server，必需設定Proxy-based才有&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Network/182-fig.3.png&quot; alt=&quot;182-fig.3.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Network/182-fig.4.png&quot; alt=&quot;182-fig.4.png&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;troubleshoting&quot; tabindex=&quot;-1&quot;&gt;troubleshoting&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;測試結果跟沒走virtual server不一樣？&lt;br /&gt;
檢查看看 virtual server 的 Persistence 有沒有設定 HTTP Cookie&lt;/li&gt;
&lt;li&gt;呼叫api，發現呼叫的都是同一個ip&lt;br /&gt;
檢查一下 Load Balancing method 是不是設定成 Static，上面設定就設錯了，導致固定只打同一個。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Network/182-fig.5.png&quot; alt=&quot;182-fig.5.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;Firewall Policy的 Inspection Mode 沒出現選項&lt;br /&gt;
這塊比較不確定，但我是先到 System -&amp;gt; Feature Visibility 開啓 Security Features底下的  Zero Trust Network Access後，才突然跑出來，但我把他關掉，也沒有消失...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://docs.fortinet.com/document/fortigate/6.2.15/cookbook/713497/virtual-server&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Virtual server&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Network/182. Fortigate 設定 內部服務負載平衡/" />
        </entry>
        <entry>
            <title>
                176. Nginx cheat sheet
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Network/176. Nginx cheat sheet/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;驗證nginx的http2開啓方式時，&lt;br /&gt;
才突然驚覺我需要一個nginx cheat sheet&lt;br /&gt;
不然怎麼單純回個狀態都不知道去哪抄&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h4 id=&quot;response-200&quot; tabindex=&quot;-1&quot;&gt;response 200&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;location / {
    add_header Content-Type text/plain;
    return 200 &#39;Hey James,Say Hello Nginx&#39;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;自簽憑證&quot; tabindex=&quot;-1&quot;&gt;自簽憑證&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout example.key -out example.crt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Common Name時，記得輸入你目前電腦的ip，&lt;br /&gt;
產生完後，掛載對應的volume到nginx裏面。&lt;br /&gt;
更改config。&lt;/p&gt;
&lt;p&gt;docker-compose.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;
version: &#39;3.8&#39;
services:
  nginx-lb:
    container_name: nginx
    image: nginx
    pull_policy: if_not_present
    restart: always
    volumes:
      - ./certs:/etc/ssl
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./proxy.conf:/etc/nginx/conf.d/proxy.conf
    ports:
      - 443:443
      - 80:80
    networks:
      - internal
networks:
  internal:
    name: internal
    driver: bridge
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;proxy.conf(某個nginx版本後 http2開啓的方式要改用下面的方式)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
    listen       443 ssl;
    server_name  192.168.1.106;
    http2 on;

    ssl_certificate           /etc/ssl/example.crt;
    ssl_certificate_key       /etc/ssl/example.key;
    ssl_protocols             TLSv1.3 TLSv1.2;
    ssl_prefer_server_ciphers on;
    ssl_ecdh_curve            X25519:secp521r1:secp384r1;
    ssl_ciphers               TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    ssl_session_cache         shared:TLS:2m;
    ssl_buffer_size           4k;

	location / {
	    add_header Content-Type text/plain;
	    return 200 &#39;Hey James,Say Hello Nginx&#39;;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;proxy-pass&quot; tabindex=&quot;-1&quot;&gt;Proxy_pass&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;proxy_pass url&lt;/code&gt; 中包含路徑時，結尾的 &lt;code&gt;/&lt;/code&gt; 最好同 &lt;code&gt;location&lt;/code&gt; 匹配規則一致。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://xuexb.github.io/learn-nginx/example/proxy_pass.html#url-%E5%8F%AA%E6%98%AF-host&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;proxy_pass url 反向代理的坑&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Network/176. Nginx cheat sheet/" />
        </entry>
        <entry>
            <title>
                169. Nginx的負載平衡
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Network/169. Nginx的負載平衡/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡唸&quot; tabindex=&quot;-1&quot;&gt;睡睡唸&lt;/h1&gt;
&lt;p&gt;雖然知道nginx應該可以做到負載平衡，&lt;br /&gt;
但從來沒弄過，&lt;br /&gt;
查了一下，還挺簡單的。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;主要有四種模式，&lt;br /&gt;
都是寫在upstream底下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;輪詢(Round Robin) ：什麼都不要寫，預設的方法&lt;/li&gt;
&lt;li&gt;最少連接(least_conn)：會轉發到伺服器連接數最少的那臺&lt;/li&gt;
&lt;li&gt;ip地址雜湊(ip_hash)：使用者會連到特定的伺服器上&lt;/li&gt;
&lt;li&gt;權重劃分(weight)：根據權重比例切換伺服器，這種寫法跟上面的三種不一樣。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.cnblogs.com/felixzh/p/9047021.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Nginx負載平衡的4種方式 ：輪詢-Round Robin 、Ip地址-ip_hash、最少連接-least_conn、加權-weight=n&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;config.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;upstream yolox-brand {
    least_conn;
    server yolox-brand-1:8080;
    server yolox-brand-2:8080;
}

server {
    listen       80;
    server_name  192.168.1.79;

    location / {
        proxy_pass         http://yolox-brand;
        proxy_redirect     off;
        proxy_set_header   Host $host;
        proxy_set_header   X-Real-IP $remote_addr;
        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header   X-Forwarded-Host $server_name;
        
        proxy_hide_header  &#39;Access-Control-Allow-Origin&#39;;
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods &#39;GET, POST, OPTIONS&#39;;
        add_header Access-Control-Allow-Headers &#39;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#39;;

        if ($request_method = &#39;OPTIONS&#39;) {
            return 204;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後，docker-compose.yaml如下，&lt;br /&gt;
要注意別把config檔塞錯地方了，不然會碰到 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Network/99.%20nginx%E7%9A%84%E9%99%A4%E9%8C%AF%E7%AD%86%E8%A8%98/&quot;&gt;99. nginx的除錯筆記&lt;/a&gt;的錯誤&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version: &#39;3.8&#39;
services:
  python-1:
    container_name: yolox-brand-1
    image: busybox
    pull_policy: if_not_present
    restart: always
    networks:
      - internal
  python-2:
    container_name: yolox-brand-2
    image: busybox
    pull_policy: if_not_present
    restart: always
    networks:
      - internal
  nginx-lb:
    container_name: nginx
    image: nginx
    pull_policy: if_not_present
    restart: always
    volumes:
      - ./proxy.conf:/etc/nginx/conf.d/proxy.conf
    ports:
      - 80:80
    networks:
      - internal
networks:
  internal:
    name: internal
    driver: bridge
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;補充，&lt;code&gt;proxy_pass url&lt;/code&gt; 中包含路徑時，結尾的 &lt;code&gt;/&lt;/code&gt; 最好同 &lt;code&gt;location&lt;/code&gt; 匹配規則一致。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://xuexb.github.io/learn-nginx/example/proxy_pass.html#url-%E5%8C%85%E5%90%AB%E8%B7%AF%E5%BE%84&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;proxy_pass url 反向代理的坑&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Network/169. Nginx的負載平衡/" />
        </entry>
        <entry>
            <title>
                106. zyxel 與 fortigate 建立VPN 點對點通道
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Network/106. zyxel 與 fortigate 建立VPN 點對點通道/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;換公司後，DevOps還要兼網管，&lt;br /&gt;
然後，在辦公室還要連vpn才能連到dev的開發環境（？&lt;br /&gt;
我很懶，為什麼要這樣對我，&lt;br /&gt;
所以...就改了吧。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Network/106.fig-1.png&quot; alt=&quot;106.fig-1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;預計完成的架構圖如上&lt;/p&gt;
&lt;p&gt;有幾個地方的坑很深，&lt;br /&gt;
建議都先查一下。&lt;/p&gt;
&lt;p&gt;本次做的是site to site VPN連線&lt;/p&gt;
&lt;h3 id=&quot;1&quot; tabindex=&quot;-1&quot;&gt;1. 檢查小烏龜跟防火牆的連線方式&lt;/h3&gt;
&lt;p&gt;因爲有申請固定ip，但本來是透過小烏龜連到外網，&lt;br /&gt;
後來一查才發現應該是要讓Firewall自己擁有實體ip才對。&lt;br /&gt;
不用再透過FW。&lt;/p&gt;
&lt;p&gt;有幾種解法，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;小烏龜改bridge mode （網路上看到的都這種居多）&lt;/li&gt;
&lt;li&gt;小烏龜改浮動ip撥接，然後再FW上使用固定ip 撥接方式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重點是要讓防火牆有直接的對外ip，環境上會比較單純。&lt;br /&gt;
我之前的環境，小烏龜連到Zyxel 是192.168.1.X ，&lt;br /&gt;
然後小烏龜接防火牆走wan port，但到內部的機器ip也是192.168.1.X，&lt;/p&gt;
&lt;h3 id=&quot;2-ip-sec&quot; tabindex=&quot;-1&quot;&gt;2.設定 ipSec&lt;/h3&gt;
&lt;p&gt;這邊設定的方式網路上很多種，可以先看一下 &lt;a href=&quot;https://community.zyxel.com/tw/discussion/13794/nebula-x-firewall-%E8%88%87fortigate%E5%BB%BA%E7%AB%8Bipsec%E7%AB%99%E5%88%B0%E7%AB%99site-to-site-vpn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [Nebula x Firewall]與Fortigate建立IPSec站到站site-to-site VPN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;關鍵點在，Phase 1、Phase 2跟金鑰的設定一定要兩臺一樣。&lt;/p&gt;
&lt;p&gt;我在連線的時候，一直碰到ZyXel 連vpn時 一直timeout，&lt;br /&gt;
最後是在改完 1 的架構以後，一整個雨過天晴&lt;/p&gt;
&lt;p&gt;Zyxel的IPsec設定&lt;br /&gt;
本地的ip跟遠端的ip要分清楚&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Network/106.fig-2.png&quot; alt=&quot;106.fig-2.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Network/106.fig-3.png&quot; alt=&quot;106.fig-3.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;fortigate的IPsec通道 設定&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Network/106.fig-4.jpg&quot; alt=&quot;106.fig-4.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Network/106.fig-5.jpg&quot; alt=&quot;106.fig-5.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Network/106.fig-6.jpg&quot; alt=&quot;106.fig-6.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然後檢查連線有沒有通，&lt;br /&gt;
兩邊都要設定好，才會通。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Network/106.fig-6-2.jpg&quot; alt=&quot;106.fig-6-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;3&quot; tabindex=&quot;-1&quot;&gt;3. 設定路由&lt;/h3&gt;
&lt;p&gt;我看的網路上的教學，他們是一設定好後，就連的通了。&lt;br /&gt;
但我怎麼連就是不通。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用tracert看路由，是只跑到192.168.1.1 (Zyxel FW上)，就沒在往下了。於是先弄個（ZyXel )策略路由，看轉不轉的過去。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Network/106.fig-7.jpg&quot; alt=&quot;106.fig-7.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fortigate的防火牆策略及路由，防火牆記得不能開NAT。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Network/106.fig-11.jpg&quot; alt=&quot;106.fig-11.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Network/106.fig-12.jpg&quot; alt=&quot;106.fig-12.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;fortigate上面檢查的方式有兩種&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;撈封包，然後用wireshark看&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Network/106.fig-8.jpg&quot; alt=&quot;106.fig-8.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Network/106.fig-9.jpg&quot; alt=&quot;106.fig-9.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;到fortigate的 CLI控制檯下指令查(這個比較快)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;diag debug reset
diag debug flow filter clear
diagnose sniffer packet any &amp;quot;host 192.168.103.221 and icmp&amp;quot; 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正常的話，會像這樣有回應&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Network/106.fig-10.jpg&quot; alt=&quot;106.fig-10.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我當時碰到的是有流量打到 fortigate的機器上，但沒有轉過去，&lt;br /&gt;
所以路由跟防火牆&lt;/p&gt;
&lt;h3 id=&quot;結語&quot; tabindex=&quot;-1&quot;&gt;結語&lt;/h3&gt;
&lt;p&gt;花了我三天的時間，我真的只是個半吊子的網管，網路我不熟阿  嗚嗚...(╥﹏╥)&lt;br /&gt;
讓我懷念起以前當MIS時的防火牆設定，都是廠商幫我們設定的，我們只要稍微知道一些管理就好，感謝ShareTech 。老闆！！如果下次採購時，我還在的話，我要換廠商啊啊啊。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ichiayi.com/tech/fortigate_tips&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;有關 FortiGate 防火牆相關設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://community.zyxel.com/tw/discussion/13794/nebula-x-firewall-%E8%88%87fortigate%E5%BB%BA%E7%AB%8Bipsec%E7%AB%99%E5%88%B0%E7%AB%99site-to-site-vpn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [Nebula x Firewall]與Fortigate建立IPSec站到站site-to-site VPN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/Network/106. zyxel 與 fortigate 建立VPN 點對點通道/" />
        </entry>
        <entry>
            <title>
                102. OSI七層
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Network/102. OSI七層/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;因為一直背不起來 OSI七層，上網查了下發現還真的有人發明了口訣&lt;br /&gt;
OSI由最上層往下&lt;br /&gt;
All People Seem To Need Domino&#39;s Pizza&lt;br /&gt;
（所有的人看來都需要達美樂比薩)&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Application ：應用層&lt;br /&gt;
主要功能是處理應用程式，進而提供使用者網路應用服務，&lt;br /&gt;
透過通訊協定(DHCP、FTP、HTTP...)和資料操作，將資訊整合起來，提供給使用者進行操作&lt;/li&gt;
&lt;li&gt;Presentation ：展示層&lt;br /&gt;
展示層主要負責轉譯、加密和壓縮資料&lt;/li&gt;
&lt;li&gt;Session ：會議層&lt;br /&gt;
會議層主要負責建立網絡連線，等到資料傳輸結束時，再將連線中斷。&lt;/li&gt;
&lt;li&gt;Transport ：傳輸層&lt;br /&gt;
傳輸層的主要用途是，協助OSI前三層與OSI後三層進行溝通，傳輸層也負責處理流量控制和錯誤控制。&lt;/li&gt;
&lt;li&gt;Network ：網路層&lt;br /&gt;
網路層是針對位於不同網路(WAN)的兩個裝置，促進兩者之間的資料傳輸。&lt;br /&gt;
(路由器及Layer 3交換器即屬於第三層的網路設備，主要以IP作為資料傳輸依據)&lt;/li&gt;
&lt;li&gt;Data Link：資料連結層&lt;br /&gt;
資料連結層是針對位於相同網路(LAN)的兩個裝置，促進兩者之間的資料傳輸。&lt;br /&gt;
(網路交換器（Switch）是這個層級常見的設備，主要在區域網路上運作，能依據MAC位址，將網路資料傳送到目的主機上。)&lt;/li&gt;
&lt;li&gt;Physical：實體層&lt;br /&gt;
實體層主要是用來定義設備裝置之間位元資料傳輸，也就是透過物理線材連接至其他實體設備，傳遞0和1的數位訊號。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://vocus.cc/article/618c7853fd8978000108c4d5&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;OSI 七層架構&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://www.ithome.com.tw/tech/47085&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;什麼是OSI的7層架構？&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Network/102. OSI七層/" />
        </entry>
        <entry>
            <title>
                0.Network MOC
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Network/0.Network MOC/</id>
            <content type="html">
                &lt;h1 id=&quot;基礎&quot; tabindex=&quot;-1&quot;&gt;基礎&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Network/92.%20proxy%20%E4%BB%A3%E7%90%86/&quot;&gt;92. proxy 代理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Network/102.%20OSI%E4%B8%83%E5%B1%A4/&quot;&gt;102. OSI七層&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;nginx&quot; tabindex=&quot;-1&quot;&gt;Nginx&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Network/169.%20Nginx%E7%9A%84%E8%B2%A0%E8%BC%89%E5%B9%B3%E8%A1%A1/&quot;&gt;169. Nginx的負載平衡&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Network/176.%20Nginx%20cheat%20sheet/&quot;&gt;176. Nginx cheat sheet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Network/99.%20nginx%E7%9A%84%E9%99%A4%E9%8C%AF%E7%AD%86%E8%A8%98/&quot;&gt;99. nginx的除錯筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Network/106.%20zyxel%20%E8%88%87%20fortigate%20%E5%BB%BA%E7%AB%8BVPN%20%E9%BB%9E%E5%B0%8D%E9%BB%9E%E9%80%9A%E9%81%93/&quot;&gt;106. zyxel 與 fortigate 建立VPN 點對點通道&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/Network/0.Network MOC/" />
        </entry>
        <entry>
            <title>
                php exec ssh 發生 Host key verification failed 錯誤
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/php exec ssh 發生 Host key verification failed 錯誤/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;前幾天一直在找php的exec坑，&lt;br /&gt;
最後終於解了，&lt;br /&gt;
記錄一下。&lt;/p&gt;
&lt;p&gt;正文&lt;br /&gt;
首先來段code，&lt;br /&gt;
這段的用途是要把 檔案從A 複製到 B ，&lt;br /&gt;
如果直接在A執行 scp 的指令，是正常的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
exec(&amp;quot;scp -i /var/www/.ssh/id_rsa -r /var/www/html/WebService/upload/tmp/fe8abe8e88fb3a2d88cc17a45a7575b1.png www-data@10.7.0.17:/var/www/html/tmp/ 2&amp;gt;&amp;amp;1&amp;quot;, $output, $return_var);
print_r($output);
echo &amp;quot;return&amp;quot; .$return_var;
echo &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
exec(&amp;quot;ssh -i /var/www/.ssh/id_rsa www-data@10.7.0.17 2&amp;gt;&amp;amp;1&amp;quot;, $output,$return_var);
print_r($output);
echo &amp;quot;return:&amp;quot;.$return_var;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這段程式，有額外加上 2&amp;gt;&amp;amp;1  這是將錯誤印出來的方式&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;使用 2&amp;gt;&amp;amp;1, 命令就會輸出shell執行時的錯誤到$output變量, 輸出該變量即可分析。&lt;br /&gt;
備註: exec有3個參數，第一個是要執行的命令，第二個是參數是一個數組，數組的值是由第一個命令執行後生成的，第三個參數執行的狀態，0表示成功，其他都表示失敗。&lt;/p&gt;
&lt;p&gt;(ref. &lt;a href=&quot;https://blog.csdn.net/zy112289/article/details/52671373&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://blog.csdn.net/zy112289/article/details/52671373&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;然後終於有錯誤訊息了，這個錯誤卻讓我很慌....&lt;br /&gt;
Host key verification failed&lt;/p&gt;
&lt;p&gt;查了一下是驗證的錯誤，都說基本上就是刪除 known_host 就好了。&lt;br /&gt;
但刪了主機、本機都一樣&lt;br /&gt;
(ref. &lt;a href=&quot;https://blog.csdn.net/iteye_19045/article/details/103704924&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://blog.csdn.net/iteye_19045/article/details/103704924&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;使用find 去尋找所有的*.pub檔案，根據裡面的內容做修改，並在主機及本機加上權限&lt;br /&gt;
(ref. &lt;a href=&quot;https://xenby.com/b/220-%E6%95%99%E5%AD%B8-%E7%94%A2%E7%94%9Fssh-key%E4%B8%A6%E4%B8%94%E9%80%8F%E9%81%8Ekey%E9%80%B2%E8%A1%8C%E5%85%8D%E5%AF%86%E7%A2%BC%E7%99%BB%E5%85%A5&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://xenby.com/b/220-教學-產生ssh-key並且透過key進行免密碼登入&lt;/a&gt;)&lt;br /&gt;
/var/www/.ssh/id_rsa，有參照之前主機設定，權限設定成 www-data（此時我沒注意到，另一個關鍵點）。&lt;/p&gt;
&lt;p&gt;解決方案&lt;br /&gt;
1.先登入最高權限&lt;br /&gt;
sudo -i&lt;br /&gt;
2.切換成www-data&lt;br /&gt;
su www-data&lt;br /&gt;
3.先連線&lt;br /&gt;
ssh 10.7.0.17&lt;/p&gt;
&lt;p&gt;釐清原因&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一開始我以為只要是使用者帳號，都應該會在 home底下有使用者的資料夾，但不知道www-data，&lt;br /&gt;
不會建立這個資料夾，預設截取 /var/www/.ssh的 id_rsa&lt;/li&gt;
&lt;li&gt;exec 可能讀不到 /var/www/.ssh/id_rsa 的檔案&lt;/li&gt;
&lt;li&gt;ssh的機制是這樣的，假設A要連線到B，要連線的話，須將 A的 .pub 金鑰，複製到B的 authorized_keys。&lt;br /&gt;
第一次進入時，會將A金鑰記憶再B的known_host上，讓日後A可以快速連線。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，只要連線過一次，就會記憶目前的金鑰到主機上，日後就能夠直接使用IP連線&lt;br /&gt;
程式會像以下，不再需要-i ，預設就會抓id_rsa來使用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;?php
exec(&amp;quot;scp -r /var/www/html/WebService/upload/tmp/fe8abe8e88fb3a2d88cc17a45a7575b1.png 10.7.0.17:/var/www/html/tmp/ 2&amp;gt;&amp;amp;1&amp;quot;, $output, $return_var);
print_r($output);
echo &amp;quot;return&amp;quot; .$return_var;
echo &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
exec(&amp;quot;ssh  10.7.0.17 2&amp;gt;&amp;amp;1&amp;quot;, $output,$return_var);
print_r($output);
echo &amp;quot;return:&amp;quot;.$return_var;
?&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/php exec ssh 發生 Host key verification failed 錯誤/" />
        </entry>
        <entry>
            <title>
                93. shellscript解析
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/93. shellscript解析/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
F=&amp;quot;proxy-linux-amd64.tar.gz&amp;quot;
set -e
if [ -e /tmp/proxy ]; then
    rm -rf /tmp/proxy
fi
mkdir /tmp/proxy
cd /tmp/proxy

echo -e &amp;quot;&#92;n&amp;gt;&amp;gt;&amp;gt; downloading ... $F&#92;n&amp;quot;
manual=&amp;quot;https://snail.gitee.io/proxy/manual/&amp;quot;
LAST_VERSION=$(curl --silent &amp;quot;https://mirrors.host900.com/https://api.github.com/repos/snail007/goproxy/releases/latest&amp;quot; | grep -Po &#39;&amp;quot;tag_name&amp;quot;:&amp;quot;&#92;K.*?(?=&amp;quot;)&#39;)
wget  -t 1 &amp;quot;https://mirrors.host900.com/https://github.com/snail007/goproxy/releases/download/${LAST_VERSION}/$F&amp;quot;

echo -e &amp;quot;&amp;gt;&amp;gt;&amp;gt; installing ... &#92;n&amp;quot;
# &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#install&quot;&gt;#install&lt;/a&gt; proxy
tar zxvf $F &amp;gt;/dev/null
set +e
killall -9 proxy &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
set -e
cp -f proxy /usr/bin/
chmod +x /usr/bin/proxy
if [ ! -e /etc/proxy ]; then
    mkdir /etc/proxy
    cp blocked /etc/proxy
    cp direct  /etc/proxy
fi
if [ ! -e /etc/proxy/proxy.crt ]; then
    cd /etc/proxy/
    proxy keygen -C proxy &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 
fi
rm -rf /tmp/proxy
version=`proxy --version 2&amp;gt;&amp;amp;1`
echo  -e &amp;quot;&amp;gt;&amp;gt;&amp;gt; install done, thanks for using snail007/goproxy $version&#92;n&amp;quot;
echo  -e &amp;quot;&amp;gt;&amp;gt;&amp;gt; install path /usr/bin/proxy&#92;n&amp;quot;
echo  -e &amp;quot;&amp;gt;&amp;gt;&amp;gt; configuration path /etc/proxy&#92;n&amp;quot;
echo  -e &amp;quot;&amp;gt;&amp;gt;&amp;gt; uninstall just exec : rm /usr/bin/proxy &amp;amp;&amp;amp; rm -rf /etc/proxy&#92;n&amp;quot;
echo  -e &amp;quot;&amp;gt;&amp;gt;&amp;gt; How to using? Please visit : $manual&#92;n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;幾個不常用到的指令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;tar :解壓縮&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/dev/null    ，這個在linux上面表示 黑洞，不做任何處理。&lt;br /&gt;
所以 tar zxvf &lt;mjx-container class=&quot;MathJax&quot; jax=&quot;SVG&quot; style=&quot;direction: ltr; position: relative;&quot;&gt;&lt;svg style=&quot;overflow: visible; min-height: 1px; min-width: 1px; vertical-align: -0.566ex;&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;30.139ex&quot; height=&quot;2.262ex&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewBox=&quot;0 -750 13321.6 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;scale(1,-1)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;1D439&quot; d=&quot;M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1026.8,0)&quot;&gt;&lt;path data-c=&quot;3E&quot; d=&quot;M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot; transform=&quot;translate(2082.6,0)&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;2F&quot; d=&quot;M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2582.6,0)&quot;&gt;&lt;path data-c=&quot;1D451&quot; d=&quot;M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3102.6,0)&quot;&gt;&lt;path data-c=&quot;1D452&quot; d=&quot;M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3568.6,0)&quot;&gt;&lt;path data-c=&quot;1D463&quot; d=&quot;M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot; transform=&quot;translate(4053.6,0)&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;2F&quot; d=&quot;M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(4553.6,0)&quot;&gt;&lt;path data-c=&quot;1D45B&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(5153.6,0)&quot;&gt;&lt;path data-c=&quot;1D462&quot; d=&quot;M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(5725.6,0)&quot;&gt;&lt;path data-c=&quot;1D459&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(6023.6,0)&quot;&gt;&lt;path data-c=&quot;1D459&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(6321.6,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;表&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(7321.6,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;示&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(8321.6,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;說&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(9321.6,0)&quot;&gt;&lt;text data-variant=&quot;italic&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot; font-style=&quot;italic&quot;&gt;，&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(10321.6,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;解&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(11321.6,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;壓&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(12321.6,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;縮&lt;/text&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;mjx-assistive-mml unselectable=&quot;on&quot; display=&quot;inline&quot; style=&quot;top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; position: absolute; padding: 1px 0px 0px 0px; border: 0px; display: block; width: auto; overflow: hidden;&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mrow data-mjx-texclass=&quot;ORD&quot;&gt;&lt;mo&gt;/&lt;/mo&gt;&lt;/mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mrow data-mjx-texclass=&quot;ORD&quot;&gt;&lt;mo&gt;/&lt;/mo&gt;&lt;/mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;表&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;示&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;說&lt;/mi&gt;&lt;mi&gt;，&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;解&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;壓&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;縮&lt;/mi&gt;&lt;/math&gt;&lt;/mjx-assistive-mml&gt;&lt;/mjx-container&gt;F的檔案，但不印出任何的訊息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;set -e  在 &amp;quot;set -e&amp;quot;之後出現的代碼，一旦出現了返回值非零，整個腳本就會立即退出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;set +e 在 &amp;quot;set +e&amp;quot;之後出現的代碼，一旦出現了返回值非0，腳本還是會繼續執行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;if -e ...判斷此目標是否存在，存在回true&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://www.ltsplus.com/linux/dev-null-2-and-1-meanning&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;“&amp;gt; /dev/null 2&amp;gt;&amp;amp;1” 的意思&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://blog.csdn.net/xiaofei125145/article/details/39345331&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; 學習筆記： shell 中的 set -e ， set +e 用法&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://unix.stackexchange.com/questions/127743/what-does-if-e-name-mean-where-name-is-a-path-to-a-directory&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;What does &amp;quot;if [ -e $name ]&amp;quot; mean? Where $name is a path to a directory&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/93. shellscript解析/" />
        </entry>
        <entry>
            <title>
                65. Linux command - grep
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/65. Linux command - grep/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;用途&quot; tabindex=&quot;-1&quot;&gt;用途&lt;/h3&gt;
&lt;p&gt;通常是用在某些指令後的處理上。&lt;/p&gt;
&lt;p&gt;以前的話，通常是把指令執行完後，&lt;br /&gt;
再將內容貼去excel做處理&lt;/p&gt;
&lt;p&gt;這邊也很常用到pipe  ，&lt;/p&gt;
&lt;p&gt;簡單的例子，要找出這個資料夾內有多少檔案。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls | wc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;會有三個值， 換行數、字數、字元數&lt;/p&gt;
&lt;p&gt;但如果要針對 副檔名是 jpg的話，&lt;br /&gt;
就必須要用grep 在做加總&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls | grep -c &#92;.jpg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果只單純做加總的話，後面必須給個要加總的東西。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls | grep -c .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;後面的參數為 正則表示法&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.gtwang.org/linux/linux-io-input-output-redirection-operators/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux I/O 輸入與輸出重新導向，基礎概念教學&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.gtwang.org/linux/linux-wc-command-tutorial-examples/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux 使用 wc 指令計算字數、行數教學與範例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.runoob.com/linux/linux-comm-grep.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux grep 命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.gtwang.org/linux/linux-grep-command-tutorial-examples/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux 匹配文字 grep 指令用法教學與範例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/65. Linux command - grep/" />
        </entry>
        <entry>
            <title>
                63.alpine linux apk ERROR unable to select packages
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/63.alpine linux apk ERROR unable to select packages/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;這好像是在查問題的時候碰到的，&lt;br /&gt;
因為某些奇怪的網路問題，&lt;br /&gt;
導致必須抓封包查詢，然後又因為在GKE的內網，&lt;br /&gt;
不能在本機撈.&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;要安裝一個linux類似fiddler的軟體，&lt;br /&gt;
搜尋alpine liunx 的 repository有找到，&lt;br /&gt;
但一直無法安裝。&lt;br /&gt;
會出現&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ERROR: unable to select packages:
  mitmproxy (no such package):
    required by: world[mitmproxy]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;後來才發現，他的repository是 測試的&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Linux/63.fig-1.jpg&quot; alt=&quot;63.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以安裝時，要指定 repository的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apk add mitmproxy --repository=http://dl-cdn.alpinelinux.org/alpine/edge/testing/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hasanaltin.com/error-unable-to-select-packages-error-on-alpine-linux/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ERROR: unable to select packages error on Alpine Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/62218240/how-to-add-a-edge-testing-package-to-alpine-linux&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to add a edge/testing package to Alpine Linux?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pkgs.alpinelinux.org/packages&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;alpine Linux - package search&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wiki.alpinelinux.org/wiki/Enable_Community_Repository&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;alpine Linux - Enable Community Repository&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/63.alpine linux apk ERROR unable to select packages/" />
        </entry>
        <entry>
            <title>
                6. 編譯ffmpeg 硬體加速的坑
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/6. 編譯ffmpeg 硬體加速的坑/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近的案子..要幫同仁搞ffmpeg的機器，如果沒有使用顯卡加速是個很愉快的事情&lt;br /&gt;
但扯到顯卡就滿滿的坑了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;環境：GKE，開啟GPU節點，詳細的使用方法可參考之前寫過的 GKE使用GPU&lt;br /&gt;
環境設定那部分，有開工單去問google，他們有說要改文件。&lt;/p&gt;
&lt;p&gt;1.編譯時找不到 libnpp&lt;br /&gt;
ERROR: libnpp not found&lt;/p&gt;
&lt;p&gt;安裝 CUDA Toolkit&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://www.pugetsystems.com/labs/hpc/How-to-install-CUDA-9-2-on-Ubuntu-18-04-1184/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to install CUDA 9.2 on Ubuntu 18.04&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;amp;target_arch=x86_64&amp;amp;target_distro=Ubuntu&amp;amp;target_version=1804&amp;amp;target_type=runfilelocal&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;CUDA Toolkit 11.2 Downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;wget &lt;a href=&quot;https://developer.download.nvidia.com/compute/cuda/11.2.0/local_installers/cuda_11.2.0_460.27.04_linux.run&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://developer.download.nvidia.com/compute/cuda/11.2.0/local_installers/cuda_11.2.0_460.27.04_linux.run&lt;/a&gt;&lt;br /&gt;
sudo sh cuda_11.2.0_460.27.04_linux.run&lt;/p&gt;
&lt;p&gt;安裝時，不要另外裝驅動，只裝cuda&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;參數設定編碼允許png,出現錯誤&lt;br /&gt;
--enable-decoder=png --enable-encoder=png&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Disabled png_decoder because not all dependencies are satisfied: zlib&lt;/p&gt;
&lt;p&gt;需要先安裝 zlib&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://stackoverflow.com/questions/11040847/ffmpeg-png-watermark-issue&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ffmpeg &amp;amp; png watermark issue&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get install zlib1g-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;編譯完成後，執行發生錯誤，找不到libnpp&lt;br /&gt;
ffmpeg: error while loading shared libraries: libnppig.so.11: cannot open shared object file: No such file or directory&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://superuser.com/questions/1246209/libnppig-so-8-0-missing-ffmpeg&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;libnppig.so.8.0 Missing FFmpeg&lt;/a&gt;&lt;br /&gt;
設定參數&lt;br /&gt;
export LD_LIBRARY_PATH=/usr/local/cuda-11.2/targets/x86_64-linux/lib&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;驅動不支援&lt;br /&gt;
Driver does not support the required nvenc API version. Required: 11.0 Found: 9.0&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The minimum required Nvidia driver for nvenc is 455.28 or newer&lt;br /&gt;
Error initializing output stream 0:0 -- Error while opening encoder for output stream &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#0&quot;&gt;#0&lt;/a&gt;:0 - maybe incorrect parameters such as bit_rate, rate, width or height&lt;/p&gt;
&lt;p&gt;切到 nv-codec-headers 的資料夾底下，切換分支&lt;br /&gt;
git checkout sdk/9.0&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://blog.csdn.net/qq_23282479/article/details/107579032&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[記錄一個bug]關於運行ffmpeg with cuda出錯問題：Driver does not support the required nvenc API version..... [已解決|記錄一個bug]關於運行ffmpeg with cuda出錯問題：Driver does not support the required nvenc API version..... [已解決]&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;使用浮水印轉檔出現錯誤&lt;br /&gt;
Impossible to convert between the formats supported by the filter &#39;graph 0 input from stream 0:0&#39; and the filter &#39;auto_scaler_0&#39;&lt;br /&gt;
Error reinitializing filters!&lt;br /&gt;
Failed to inject frame into filter network: Function not implemented&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前寫的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ffmpeg -hwaccel cuvid -y -i 49805.mp4 -i logo.png &#92;
-filter_complex &amp;quot;[0]scale=&#39;min(1280,iw)&#39;:-1[bg];[1][bg]scale2ref=w=&#39;iw*15/100&#39;:h=&#39;iw*15/100*166/446&#39;[wm][vid];[vid][wm]overlay=10:10&amp;quot; &#92;
-c:v h264_nvenc ezio.mp4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;會發生上面的錯誤(auto_scaler_0)，但只要將 cuvid改成 nvdec 就正常了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ffmpeg -hwaccel nvdec -y -i 49805.mp4 -i logo.png &#92;
-filter_complex &amp;quot;[0]scale=&#39;min(1280,iw)&#39;:-1[bg];[1][bg]scale2ref=w=&#39;iw*15/100&#39;:h=&#39;iw*15/100*166/446&#39;[wm][vid];[vid][wm]overlay=10:10&amp;quot; &#92;
-c:v h264_nvenc ezio.mp4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://forums.developer.nvidia.com/t/filter-complex-through-cuda-hevc-cuvid-with-ffmpeg-input-4k-hevc-help-needed/70894/5&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Filter complex through CUDA hevc_cuvid with FFMPEG input 4k hevc, help needed&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;
&lt;p&gt;轉碼時查詢 詳細的log記錄&lt;br /&gt;
在ffmpeg的後面加上 -loglevel debug&lt;br /&gt;
ref. &lt;a href=&quot;http://hk.uwenku.com/question/p-kdwwpile-bz.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;FFMPEG的默認像素格式將圖像堆棧編碼為電影&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ffmpeg 常用指令&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ffmpeg -hwaccels  查詢能用的硬體加速&lt;br /&gt;
ffmpeg -codecs | grep cuvid  查看ffmpeg支持的cuvid的編碼格式&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;http://notes.maxwi.com/2017/03/01/ubuntu-compile-ffmpeg-with-cuvid-nvenc-npp/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Ubuntu 16.04下編譯ffmpeg支持CUDA下的cuvid vnenc和NPP&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.yisu.com/zixun/7438.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用GPU硬件加速FFmpeg視頻轉碼及排坑&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他參考項目&lt;br /&gt;
ref. &lt;a href=&quot;https://arnon.dk/matching-sm-architectures-arch-and-gencode-for-various-nvidia-cards/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Matching CUDA arch and CUDA gencode for various NVIDIA architectures&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/qq_29350001/article/details/72625866&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;FFmpeg再學習 -- Linux 安裝說明(參數說明)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/eae199a4cce0&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;在k8s中調用NVIDIA-GPU&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/nightseas/gpgpu_applications/blob/master/docker/ffmpeg/Dockerfile#L24&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;在k8s中調用NVIDIA-GPU(Dockerfile)&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/6. 編譯ffmpeg 硬體加速的坑/" />
        </entry>
        <entry>
            <title>
                51.curl 筆記
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/51.curl 筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;最近在K網路架構，有些東西有點概念了。&lt;/p&gt;
&lt;p&gt;此時來看這張圖終於瞭解一點。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Linux/51.fig-1.png&quot; alt=&quot;51.fig-1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://blog.cloudflare.com/a-question-of-timing/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;A Question of Timing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先來看這張圖，&lt;br /&gt;
有幾個關鍵字縮寫必須要先知道&lt;br /&gt;
SYN ： 同步序列號&lt;br /&gt;
ACK ： 要求回應&lt;br /&gt;
FIN   ：結束&lt;br /&gt;
SEQ  ： 序列號&lt;/p&gt;
&lt;p&gt;這邊簡單講，要更詳細的內容，建議去看一下&lt;a href=&quot;https://notfalse.net/7/three-way-handshake&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;TCP 三向交握 (Three-way Handshake)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在這張圖裡面沒有SEQ這個，因為沒畫出來，在SYN的時候，就會包含SEQ在裡面了。&lt;/p&gt;
&lt;p&gt;流程簡單說是這樣的，TCP是有順序性的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;clinet 詢問DNS server ，網域與IP的對應&lt;/li&gt;
&lt;li&gt;client 發出請求&lt;/li&gt;
&lt;li&gt;server 回應&lt;/li&gt;
&lt;li&gt;client 回應，我知道你回了。&lt;/li&gt;
&lt;li&gt;server 開始建立ssl憑證&lt;/li&gt;
&lt;li&gt;client 發出內容請求&lt;/li&gt;
&lt;li&gt;server 回應內容&lt;/li&gt;
&lt;li&gt;結束&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;好了，再來才是講curl ，&lt;br /&gt;
先建立一個 txt檔，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#92;n
 # DNS 解析時間，也就是查詢到 IP 的時間&#92;n
 time_namelookup: %{time_namelookup}&#92;n
 # TCP 連線時間，就是 TCP 三項交握的時間&#92;n
 time_connect: %{time_connect}&#92;n
 # SSL 連線的時間&#92;n
 time_appconnect: %{time_appconnect}&#92;n
 # 從開始到最後一個請求的時間，如果網頁有跳轉就會有時間&#92;n
 time_redirect: %{time_redirect}&#92;n
 # 從開始到響應開始的時間&#92;n
 time_pretransfer: %{time_pretransfer}&#92;n
 # 從開始到響應開始傳輸的時間&#92;n
 time_starttransfer: %{time_starttransfer}&#92;n
 ----------&#92;n
 # 整體時間&#92;n
 time_total: %{time_total}&#92;n
&#92;n

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;curl -w @curl-format.txt -o /dev/null https://daimom3020.blogspot.com/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊要注意， @curl-format.txt 這邊不能使用路徑方式去找檔案。如果怕改天找不到檔案的話，&lt;br /&gt;
curl 可以改成下面的指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -o /dev/null https://daimom3020.blogspot.com/ -w &amp;quot;                   
 # DNS 解析時間，也就是查詢到 IP 的時間
 time_namelookup: %{time_namelookup}
 # TCP 連線時間，就是 TCP 三項交握的時間
 time_connect: %{time_connect}
 # SSL 連線的時間
 time_appconnect: %{time_appconnect}
 # 從開始到最後一個請求的時間，如果網頁有跳轉就會有時間
 time_redirect: %{time_redirect}
 # 從開始到響應開始的時間
 time_pretransfer: %{time_pretransfer}
 # 從開始到響應開始傳輸的時間
 time_starttransfer: %{time_starttransfer}
 ----------
 # 整體時間
 time_total: %{time_total}
&#92;n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;搭配上方的圖片來看，&lt;br /&gt;
這邊顯示的時間是累加的，如果要算出區間的時間，&lt;br /&gt;
需要自行做相減。&lt;/p&gt;
&lt;p&gt;例如，&lt;br /&gt;
要知道server處理資料的時間多長，&lt;br /&gt;
可使用 time_starttransfer - time_pretransfer ，&lt;br /&gt;
就可得知server處理資料的時間。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.clarence.tw/2019/05/01/curl-details-tcp-ssl-connection-time/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;CURL 詳細資料包含 TCP 與 SSL 連線時間&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weifangan/article/details/80741981&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;CURL -w 參數詳解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://man.linuxde.net/curl&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;curl命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.howtogeek.com/439199/15-special-characters-you-need-to-know-for-bash/&quot; title=&quot;15 Special Characters You Need to Know for Bash&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;15 Special Characters You Need to Know for Bash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://begin4learn.gitbooks.io/begin-to-learn-linux/content/Command/Command_T_symbol.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Command symbol 符號_Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/2147101?from=15425&amp;amp;areaSource=102001.2&amp;amp;traceId=yoo0SjU9fE6zKa1DI8qyZ&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;curl 所有參數介紹&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;驗證網站是否為http2 ，&lt;br /&gt;
簡單說明&lt;br /&gt;
-v  顯示呼叫的步驟&lt;br /&gt;
-s Silent模式。不輸出任務內容&lt;br /&gt;
-o 指定輸出目錄&lt;/p&gt;
&lt;p&gt;只用 -s 的話，還是會輸出內容。&lt;br /&gt;
只用 -o的話，不會輸出內容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	curl https://www.cloudflare.com  --http2 -vso /dev/null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是的話，會出現 using http2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Linux/51.fig-2.jpg&quot; alt=&quot;51.fig-2.jpg&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/51.curl 筆記/" />
        </entry>
        <entry>
            <title>
                49.npm 與 yarn 比較
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/49.npm 與 yarn 比較/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;回傳值&lt;/th&gt;
&lt;th&gt;方法名稱&lt;/th&gt;
&lt;th&gt;說明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;npm install&lt;/td&gt;
&lt;td&gt;yarn install&lt;/td&gt;
&lt;td&gt;安裝 json.package 所有依賴&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm install [package]&lt;/td&gt;
&lt;td&gt;(N/A)&lt;/td&gt;
&lt;td&gt;Yarn不支援直接安裝套件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm install --save [package]&lt;/td&gt;
&lt;td&gt;yarn add [paakage]&lt;/td&gt;
&lt;td&gt;儲存在 json.package中的dependencies&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm install --save-dev [package]&lt;/td&gt;
&lt;td&gt;yarn add [paakage] --dev&lt;/td&gt;
&lt;td&gt;儲存在 json.package中的devDependencies&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm install --global [package]&lt;/td&gt;
&lt;td&gt;yarn global add [package]&lt;/td&gt;
&lt;td&gt;安裝在電腦全域中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm uninstall [package]&lt;/td&gt;
&lt;td&gt;(N/A)&lt;/td&gt;
&lt;td&gt;Yarn不支援直接安裝與移除套件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm uninstall --save [package]&lt;/td&gt;
&lt;td&gt;yarn remove [package]&lt;/td&gt;
&lt;td&gt;移除dependencies某套件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm uninstall --save-dev [package]&lt;/td&gt;
&lt;td&gt;yarn remove [package]&lt;/td&gt;
&lt;td&gt;移除devDependencies某套件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rm -rf node_modules &amp;amp;&amp;amp; npm install&lt;/td&gt;
&lt;td&gt;yarn upgrade&lt;/td&gt;
&lt;td&gt;更新node_modules&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10191745&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;用Yarn取代npm加速開發&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/49.npm 與 yarn 比較/" />
        </entry>
        <entry>
            <title>
                48.SSH無法連線，REMOTE HOST IDENTIFICATION HAS CHANGED
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/48.SSH無法連線，REMOTE HOST IDENTIFICATION HAS CHANGED/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;出現下圖的錯誤，&lt;br /&gt;
[[48.fig-1.jpg]]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一般都是用文字編輯器開啟 /root/.ssh/known_hosts&lt;br /&gt;
將舊10.7.10.48 的key刪除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但這次碰到沒有權限，只能下指令刪除了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -R 10.7.10.48
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/48.SSH無法連線，REMOTE HOST IDENTIFICATION HAS CHANGED/" />
        </entry>
        <entry>
            <title>
                33. centos 7安裝redis 改port
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/33. centos 7安裝redis 改port/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;最簡單地安裝方式，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;yum install redis
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;編輯 /etc/redis.conf&lt;br /&gt;
找到 port 6379 ，將它改為 port 8090&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重啟服務  sudo systemctl restart redis&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;發現服務無法啟動(fig.1)，查log(fig.2)，發現沒有權限。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[[33.fig-1.jpg]]&lt;/p&gt;
&lt;p&gt;[[33.fig-2.jpg]]&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;selinux的問題，要麻關掉，要麻新增port&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo: semanage: command not found

安裝
yum install policycoreutils-python
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後執行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo semanage port -a -t redis_port_t -p tcp 8090
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://stackoverflow.com/questions/53009361/redis-creating-server-tcp-listening-socket-6388-bind-permission-denied&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Redis: Creating Server TCP listening socket *:6388: bind: Permission denied&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.opencli.com/linux/fix-semanage-command-not-found&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;解決 semanage command not found&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;重開redis。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo systemctl restart redis
sudo systemctl status redis
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://blog.yowko.com/install-redis-error/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;安裝 Redis 時遇到的錯誤排除&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/33. centos 7安裝redis 改port/" />
        </entry>
        <entry>
            <title>
                173. Linux殭屍程式
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/173. Linux殭屍程式/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;看文章看到一篇詳解，TOP指令，重新把linux的top理解一遍。&lt;br /&gt;
然後看到一個怪名詞 zombie ，這是我理解的意思嗎！？&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;簡單說有點像是windows 的應用程式，要死不死，卡在那邊當掉的情況。&lt;/p&gt;
&lt;p&gt;每一個process都會有一個parent process，&lt;br /&gt;
當child process處於結束與尚未結束中間時會發生。&lt;br /&gt;
詳細，請參考&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10302966&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Day 17: 殭屍與孤兒&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;top 顯示PPID&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;執行 top&lt;/li&gt;
&lt;li&gt;按下&lt;code&gt;f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;選擇需要的欄位，按&lt;code&gt;d&lt;/code&gt; 或 &lt;code&gt;space&lt;/code&gt; 選擇&lt;/li&gt;
&lt;li&gt;按下&lt;code&gt;→&lt;/code&gt; 鍵盤的方向鍵，然後按&lt;code&gt;上下鍵&lt;/code&gt;可以調整順序&lt;/li&gt;
&lt;li&gt;按&lt;code&gt;q&lt;/code&gt;離開&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Linux/173.fig-1.jpg&quot; alt=&quot;173.fig-1.jpg&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/173. Linux殭屍程式/" />
        </entry>
        <entry>
            <title>
                171. linux top指令詳解
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/171. linux top指令詳解/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡唸&quot; tabindex=&quot;-1&quot;&gt;睡睡唸&lt;/h1&gt;
&lt;p&gt;linux常用 top ，看目前os裏面哪個程式資源吃比較兇，&lt;br /&gt;
但每次都是只看固定幾個欄位，&lt;br /&gt;
最近剛好喵到完整的說明。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;一般top會長這樣&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Linux/171.fig-1.jpg&quot; alt=&quot;171.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;第一行&quot; tabindex=&quot;-1&quot;&gt;第一行&lt;/h3&gt;
&lt;p&gt;top&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;15:40:37&lt;/th&gt;
&lt;th&gt;目前時間&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;up 6 days&lt;/td&gt;
&lt;td&gt;已開機時間&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3 users&lt;/td&gt;
&lt;td&gt;目前登入的使用者數量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;load average&lt;/td&gt;
&lt;td&gt;1 min,5 min,15min的系統瓶均負載&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;第二行&quot; tabindex=&quot;-1&quot;&gt;第二行&lt;/h3&gt;
&lt;p&gt;Tasks&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;419 total&lt;/th&gt;
&lt;th&gt;總處理程序&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1 running&lt;/td&gt;
&lt;td&gt;執行中的程式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;418 sleeping&lt;/td&gt;
&lt;td&gt;睡眠中的程式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0 stopped&lt;/td&gt;
&lt;td&gt;停止中的程式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0 zombie&lt;/td&gt;
&lt;td&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/173.%20Linux%E6%AE%AD%E5%B1%8D%E7%A8%8B%E5%BC%8F/&quot;&gt;173. Linux殭屍程式&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;第三行&quot; tabindex=&quot;-1&quot;&gt;第三行&lt;/h3&gt;
&lt;p&gt;%Cpu(s):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;0.2 us&lt;/th&gt;
&lt;th&gt;使用者佔用的CPU&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0.1 sy&lt;/td&gt;
&lt;td&gt;核心空間佔用的CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0 ni&lt;/td&gt;
&lt;td&gt;改變過優先順序的程式佔用的CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;99.7 id&lt;/td&gt;
&lt;td&gt;閒置的CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0 wa&lt;/td&gt;
&lt;td&gt;IO等待佔用的CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0 hi&lt;/td&gt;
&lt;td&gt;硬體中斷(Hardware IRQ)佔用C的PU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0 si&lt;/td&gt;
&lt;td&gt;軟體中斷(Software IRQ)佔用的CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0 st&lt;/td&gt;
&lt;td&gt;偷取時間(Steal Time)佔用的CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Hardware IRQ : 硬體中斷是從外部裝置（如磁碟控製器、網路卡、鍵盤控製器、外部計時器、硬體感應器等）發送到處理器的電子警報訊號&lt;/p&gt;
&lt;p&gt;ref .  &lt;a href=&quot;https://blog.ycrash.io/2020/11/28/hardware-interrupt-time-hi-time-in-top/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Hardware Interrupt time – ‘hi’ time in top&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Software IRO：軟體中斷從程式引發的中斷行爲&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://blog.ycrash.io/2020/11/28/software-interrupt-time-si-time-in-top/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Software Interrupt time – ‘si’ time in top&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Steal CPU Time ：虛擬機器的CPU在虛擬機監護程式正在處理其他虛擬機器時，等待實際CPU的時間百分比。&lt;/p&gt;
&lt;p&gt;ref.  &lt;a href=&quot;https://blog.ycrash.io/2020/11/28/steal-cpu-time-st-time-in-top/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Steal CPU time – ‘st’ time in top&lt;br /&gt;
竊取 CPU 時間 – 頂部的「st」時間&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;第四行&quot; tabindex=&quot;-1&quot;&gt;第四行&lt;/h3&gt;
&lt;p&gt;MiB Mem&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;64207.4 total&lt;/th&gt;
&lt;th&gt;物理記憶體總量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;7866.7 free&lt;/td&gt;
&lt;td&gt;可用記憶體&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16649.0 used&lt;/td&gt;
&lt;td&gt;已使用記憶體&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;39691.6 buff/cache&lt;/td&gt;
&lt;td&gt;緩存的記憶體量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;第五行&quot; tabindex=&quot;-1&quot;&gt;第五行&lt;/h3&gt;
&lt;p&gt;MiB Swap&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;2048.0 total&lt;/th&gt;
&lt;th&gt;虛擬記憶體總量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2048.0 free&lt;/td&gt;
&lt;td&gt;可用虛擬記憶體總量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0 used&lt;/td&gt;
&lt;td&gt;已使用虛擬記憶體&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;46765.3.0 avail Mem&lt;/td&gt;
&lt;td&gt;可用記憶體[free+(buff/cache)]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;補充 Linux的計算方式跟windows的不一樣，&lt;br /&gt;
當 『可以被應用程式使用，但被暫時借去做別的用途』，&lt;br /&gt;
在Linux裏面也是顯示為used。&lt;/p&gt;
&lt;p&gt;所以要查目前記憶體使用量可以改用&lt;code&gt;htop&lt;/code&gt;或&lt;code&gt;free -m&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ref . &lt;a href=&quot;https://blog.gtwang.org/linux/linux-cache-memory-linux/&quot; title=&quot;Linux 的記憶體快取（Cache Memory）功能：Linux 系統把記憶體用光了？&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux 的記憶體快取（Cache Memory）功能：Linux 系統把記憶體用光了？&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;第七行&quot; tabindex=&quot;-1&quot;&gt;第七行&lt;/h3&gt;
&lt;p&gt;預設的欄位名稱&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PID&lt;/code&gt;: 執行任務的 Process ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;USER&lt;/code&gt;: 執行任務的使用者名稱&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PR&lt;/code&gt;: 任務的優先度 (Priority)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NI&lt;/code&gt;: 任務的 Nice Value，負的值代表優先度高，正的值代表優先度低&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VIRT&lt;/code&gt;: 總共用到多少 kB 虛擬記憶體 (Virtual Memory)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RES&lt;/code&gt;: 實體記憶體 (Resident Size) 大小 kB&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SHR&lt;/code&gt;: 總共用到多少 kB 的共享記憶體 (Shared Memory)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt;: 狀態 (Status)
&lt;ul&gt;
&lt;li&gt;R 代表執行中&lt;/li&gt;
&lt;li&gt;D 代表不可中斷睡眠 (不可被 signal 打斷通常在等 I/O)&lt;/li&gt;
&lt;li&gt;S 代表睡眠 (可被喚醒)&lt;/li&gt;
&lt;li&gt;T 中斷中或停止，可能是被 &lt;code&gt;SIGSTOP&lt;/code&gt; 或 &lt;code&gt;SIGTSTP&lt;/code&gt; 停止，或是被 degubber 中斷 (ptrace)&lt;/li&gt;
&lt;li&gt;Z 代表殭屍，通常發生在 Child 已經執行完，等待 Parent 結束或回收&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%CPU&lt;/code&gt;: 佔用到多少 CPU %，注意到一個核心是 100%，所以多核心是可以操過 100% 的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%MEM&lt;/code&gt;: 佔用到多少全部記憶體多少比例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TIME+&lt;/code&gt;: 程式已經執行多少時間，單位1/100秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COMMAND&lt;/code&gt;: 任務的指令名稱&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非預設的欄位名稱，&lt;br /&gt;
叫出來的方式為 &lt;code&gt;f&lt;/code&gt; -&amp;gt; 選擇欄位(&lt;code&gt;space&lt;/code&gt;)  -&amp;gt; 離開(&lt;code&gt;q&lt;/code&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PPID&lt;/code&gt;: 執行任務的 Process ID的父親 （原因參考&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/173.%20Linux%E6%AE%AD%E5%B1%8D%E7%A8%8B%E5%BC%8F/&quot;&gt;173. Linux殭屍程式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UID&lt;/code&gt;:執行程式的使用者ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RUID&lt;/code&gt;: 真正的使用者ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RUSER&lt;/code&gt;: 真正的使用者&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUID&lt;/code&gt;: 暫存使用者ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUSER&lt;/code&gt;: 暫存使用者名稱&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GID&lt;/code&gt;: 群組ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GROUP&lt;/code&gt;: 群組名稱&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PGRP&lt;/code&gt;: Process Group Id&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TTY&lt;/code&gt;: 控制終端的名稱&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TPGID&lt;/code&gt;: Tty Process Group Id&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SID&lt;/code&gt;:  session ID （一個login裏面的所有process)，有點像 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/134.%20%E9%97%9C%E9%96%89ssh%E9%80%A3%E7%B7%9A%E5%BE%8C%EF%BC%8C%E4%BB%8D%E5%8F%AF%E5%9F%B7%E8%A1%8C%E7%A8%8B%E5%BC%8F/&quot;&gt;134. 關閉ssh連線後，仍可執行程式&lt;/a&gt;裏面的screen&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nTH&lt;/code&gt;:  與一個進程關聯的執行緒數量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt;: 最後使用的CPU&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TIME&lt;/code&gt;: 程式已經執行多少時間，單位 1秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SWAP&lt;/code&gt;: 當前被移到交換區的記憶體大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CODE&lt;/code&gt;: 目前用於執行程式碼碼的物理記憶體&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DATA&lt;/code&gt;:一個程式保留的私有記憶體量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nMaj&lt;/code&gt;:已發生的主要分頁錯誤次數&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nMin&lt;/code&gt;:已發生的次要分頁錯誤次數&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nDRT&lt;/code&gt;: （已棄用）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WCHAN&lt;/code&gt;: 顯示了每個進程或執行緒目前正在等待的內核函數或事件的名稱或指針&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Flags&lt;/code&gt;:目前任務的排程標誌，以十六進製表示，並且去掉了零&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CGROUPS&lt;/code&gt;:表示程式所在的控制組的名稱&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUPGIDS&lt;/code&gt;:表示進程所在的父控制組的 ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUPGRPS&lt;/code&gt;:表示程式所在的父控制組的名稱&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TGID&lt;/code&gt;:  Thread Group Id&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OOMa&lt;/code&gt;: 用來調整每個進程的 OOMS 值，以影響其被終止的機率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OOMs&lt;/code&gt;: 記憶體分數，評估進程或任務對內存需求的數值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ENVIRON&lt;/code&gt;: 顯示所有的環境變數&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vMj&lt;/code&gt;: 主要分頁錯誤計數增量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vMn&lt;/code&gt;: 次要分頁錯誤計數增量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;USED&lt;/code&gt;: 記憶體 Res+Swap Size&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nsIPC&lt;/code&gt;: IPC 命名空間，用於隔離進程間通訊資源，確保它們在不同的命名空間中互不干擾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nsMNT&lt;/code&gt;: MNT 命名空間，用於隔離和管理不同命名空間中的檔案系統掛載點資訊&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nsNET&lt;/code&gt;: NET 命名空間，用於隔離和管理不同命名空間中的網絡資源和網絡設置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nsPID&lt;/code&gt;: PID 命名空間，用於隔離不同命名空間中的進程識別號，確保它們在各自的命名空間中具有唯一的 PID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nsUSER&lt;/code&gt;:USER 命名空間，用於隔離不同命名空間中的用戶和用戶許可權，確保它們在各自的命名空間中具有獨立的用戶身份和權限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nsUTS&lt;/code&gt;:UTS (UNIX Time-sharing System)命名空間，用於隔離不同命名空間中的主機名和域名設置，確保它們在各自的命名空間中具有獨立的組態&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LXC&lt;/code&gt;: LXC(Linux Containers)容器名稱&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RSan&lt;/code&gt;: 代表一個進程或任務正在使用的匿名內存的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RSfd&lt;/code&gt;: 代表一個進程或任務正在使用的檔案內存的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RSlk&lt;/code&gt;: 代表一個進程或任務正在使用的已鎖定頁面的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RSsh&lt;/code&gt;: 代表一個進程或任務正在使用的共享內存的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CGNAME&lt;/code&gt;: 控制組名稱，用於標識和管理相關的進程或資源的分組。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NU&lt;/code&gt;: &amp;quot;最後已知的 NUMA 節點&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://xie.infoq.cn/article/92ce399000f46e5d308b3d935&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;記憶體都去哪了&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.1ju.org/linux/top&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;top命令詳解示例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tigercosmos.xyz/post/2020/04/unix/top-usage/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Unix/Linux TOP 指令使用詳解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://manpages.ubuntu.com/manpages/lunar/en/man1/top.1.html#3.%20fields%20/%20columns&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ubntu-top&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hy-star.com.tw/tech/linux/process/process.html#session&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;LInux中的process&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/171. linux top指令詳解/" />
        </entry>
        <entry>
            <title>
                165. Linux網路追蹤工具- MTR
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/165. Linux網路追蹤工具- MTR/</id>
            <content type="html">
                &lt;h2 id=&quot;mtr&quot; tabindex=&quot;-1&quot;&gt;mtr&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;MTR 在一開始會針對指定的主機，以 &lt;code&gt;traceroute&lt;/code&gt; 找出中間的每一個網路節點（閘道器、路由器、橋接器等），然後使用 &lt;code&gt;ping&lt;/code&gt; 去檢查每一個節點的網路連線狀況&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安裝方式&quot; tabindex=&quot;-1&quot;&gt;安裝方式&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# Debian/Ubuntu
sudo apt install mtr

# RHEL/CentOS/Fedora
sudo yum install mtr

# MAC
brew install mtr

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MAC安裝後，無法執行，因爲安裝的路徑是在 /usr/local/sbin底下，&lt;br /&gt;
找尋自己的shell&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/163.Shell%E7%9A%84%E5%8D%80%E5%88%A5%E5%8F%8A%E6%9F%A5%E8%A9%A2/&quot;&gt;163.Shell的區別及查詢&lt;/a&gt;，增加指定路徑&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim ~/.bash_profile 
export PATH=$PATH:/usr/local/sbin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 sudo 執行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo mtr -c 5 -wbr https://daimom.vercel.app &amp;gt; output.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Linux/165.fig-1.jpg&quot; alt=&quot;165.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;參數介紹&quot; tabindex=&quot;-1&quot;&gt;參數介紹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
mtr -h 提供幫助命令 

mtr -v 顯示mtr的版本資訊 

mtr -r 以報告模式顯示

mtr -s 用來指定ping封包的大小 

mtr -n no-dns不對IP地址做域名解析 

mtr -a 來設定傳送封包的IP地址 這個對一個主機由多個IP地址是有用的 

mtr -i 使用這個參數來設定ICMP返回之間的要求默認是1秒 

mtr -4 IPv4 

mtr -6 IPv6

mtr -c 設定每秒傳送封包的數量
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;數據所代表的意思&lt;br /&gt;
以下是各個英文字母所代表的欄位：&lt;br /&gt;
RTT (Round Trip Time) 亦可稱為往返時間&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;L&lt;/code&gt;：封包遺失率（Loss ratio）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;D&lt;/code&gt;：封包遺失數（Dropped packets）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt;：封包接收數（Received packets）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt;：封包發送數（Sent Packets）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N&lt;/code&gt;：最新的 RTT（Newest RTT，單位為 ms）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt;：最佳的 RTT（Min/Best RTT，單位為 ms）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt;：平均的 RTT（Average RTT，單位為 ms）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;W&lt;/code&gt;：最差的 RTT（Max/Worst RTT，單位為 ms）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;V&lt;/code&gt;：標準差（Standard Deviation）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G&lt;/code&gt;：幾何平均（Geometric Mean）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;J&lt;/code&gt;：目前的 Jitter 值（Current Jitter）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;M&lt;/code&gt;：平均的 Jitter 值（Jitter Mean/Avg.）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X&lt;/code&gt;：最差的 Jitter 值（Worst Jitter）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;I&lt;/code&gt;：Interarrival Jitter&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cjkuo.net/linux_mtr/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;MTR 追蹤網路節點&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.gtwang.org/linux/mtr-linux-network-diagnostic-tool/&quot; title=&quot;MTR：Linux 網路診斷工具使用教學&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;MTR：Linux 網路診斷工具使用教學&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://what-a-good-day.blogspot.com/2019/02/mac-mtr.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;mac 安裝 mtr&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/165. Linux網路追蹤工具- MTR/" />
        </entry>
        <entry>
            <title>
                163.Shell的區別及查詢
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/163.Shell的區別及查詢/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;在測試gcloud安裝後，還是找不到gcloud command ，&lt;br /&gt;
於是開始了檢查之路。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;熟linux的應該都知道sh只是個代稱，你的sh是bash 、 zsh 或 dash，&lt;br /&gt;
都有可能。&lt;br /&gt;
所以判斷你的sh是哪一種&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo $SHELL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後你的sh會決定你的設定檔名稱是哪一個。&lt;br /&gt;
例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bash =&amp;gt; ~/.bashrc
zsh =&amp;gt;  ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果指令新增後，不想重啓Terminal的話，&lt;br /&gt;
可使用下面指令，將被指定目錄的bash讀入目前的環境中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/31037279/gcloud-command-not-found-while-installing-google-cloud-sdk&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud command not found - while installing Google Cloud SDK&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/163.Shell的區別及查詢/" />
        </entry>
        <entry>
            <title>
                16.dustise sleep 測試工具簡介
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/16.dustise sleep 測試工具簡介/</id>
            <content type="html">
                &lt;h2 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;之前就有用過 dustise/sleep ，用for 迴圈來打 網址做測試，&lt;br /&gt;
今天想說那裡面的http到底是哪一套工具，才發現原來裡面有那麼多的工具能用。&lt;br /&gt;
2021.03.18更新：又找到了幾款不錯用的工具，同步增加&lt;/p&gt;
&lt;h2 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;裡面的工具列表，可以參考他的&lt;a href=&quot;https://github.com/fleeto/sleep&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;git&lt;/a&gt;，&lt;br /&gt;
然後我們看到他的dockerfile,裡面有&lt;br /&gt;
bind-tools curl wrk vim&lt;br /&gt;
tcptraceroute iptables httpie bash&lt;br /&gt;
tini apache2-utils stress-ng strace&lt;br /&gt;
這次會抓幾個記錄一下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;bind-tools&lt;br /&gt;
安裝nslookup用，可查詢域名&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;      nslookup tw.yahho.com    &lt;/code&gt;&lt;br /&gt;
2. curl&lt;br /&gt;
取得網頁資料&lt;br /&gt;
&lt;code&gt;      curl ifconfig.me    &lt;/code&gt;&lt;br /&gt;
參數很多，通常會使用postman將要截取的資料轉成curl，再到command做測試。&lt;br /&gt;
如果只是要簡單測試，可以加上 -v 看詳細內容&lt;br /&gt;
3. wrk&lt;br /&gt;
模擬多人來網站時的效能，有點像壓力測試工具。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  wrk -t12 -c400 -d30s -T30s --latency http://localhost/productpage
  # -t12 用 12 個線程
  # -c400 模擬 400 個併發連接
  # -d30s 持續 30 秒
  # -T30s 設定超過 30 秒就算連接超時
  # --latency 響應時間的分佈情況
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.vercel.app/404&quot;&gt;[16.fig-1.jpg&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Latency: 響應時間&lt;/li&gt;
&lt;li&gt;Req/Sec: 每個線程每秒鐘的完成的請求數&lt;/li&gt;
&lt;li&gt;Avg: 平均值&lt;/li&gt;
&lt;li&gt;Stdev (Standard Deviation): 即標準偏差，是統計學的一個名詞，這裡表示請求響應時間的離散程度，值越大代表請求響應時間的差距越大，系統的響應約不穩定。&lt;/li&gt;
&lt;li&gt;Max: 最大值&lt;/li&gt;
&lt;li&gt;+/- Stdev: 正負一個標準差佔比&lt;/li&gt;
&lt;li&gt;Latency Distribution: 50% 在 3.23s 以內完成 / 99% 在 22.27s 以內完成&lt;/li&gt;
&lt;li&gt;Socket errors: 分為 連接錯誤, 讀取錯誤, 寫入錯誤, 超時錯誤&lt;/li&gt;
&lt;li&gt;Requests/sec: 每秒請求數量，也就是並發能力&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更詳細的說明，請參考：&lt;a href=&quot;https://mgleon08.github.io/blog/2018/04/09/http-benchmark/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;HTTP Benchmark 工具 Wrk&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;
&lt;p&gt;vim&lt;br /&gt;
文字編輯器，就不介紹了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tcptraceroute&lt;br /&gt;
路由追蹤器，追蹤網路死在哪一層&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;  traceroute tw.yahoo.com
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;
&lt;p&gt;iptables&lt;br /&gt;
路由表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;httpie&lt;br /&gt;
之前使用&lt;br /&gt;
for i in &lt;code&gt;seq 20&lt;/code&gt;;do http --body &lt;a href=&quot;http://ipaddress/api/v1/Health/health&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;http://ipaddress/api/v1/Health/health&lt;/a&gt;; done;&lt;br /&gt;
打網址的指令。&lt;br /&gt;
httpie 是一個 HTTP 的命令行客戶端。其目標是讓 CLI 和 web 服務之間的交互儘可能的人性化。&lt;br /&gt;
想用來取代wget ,curl 等功能，然後畫面比較美觀，如果回來的是json，那差異會更大。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[[16.fig-2.jpg]]&lt;/p&gt;
&lt;p&gt;下載&lt;br /&gt;
http --download &lt;a href=&quot;http://example.org/file&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;example.org/file&lt;/a&gt;&lt;br /&gt;
只看header&lt;br /&gt;
http -h &lt;a href=&quot;http://ipaddress/productpage&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;http://ipaddress/productpage&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://tonydeng.github.io/2015/07/10/httpie-howto/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;HTTPie:超爽的HTTP命令行客戶端&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://keelii.com/2018/09/03/HTTPie/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;HTTPie 官方文檔中文翻譯版&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;同場加註&lt;/p&gt;
&lt;p&gt;jid&lt;br /&gt;
&lt;a href=&quot;https://github.com/simeji/jid&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://github.com/simeji/jid&lt;/a&gt;&lt;br /&gt;
jq&lt;br /&gt;
&lt;a href=&quot;https://stedolan.github.io/jq/manual/#Basicfilters&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://stedolan.github.io/jq/manual/#Basicfilters&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;hey&lt;br /&gt;
&lt;a href=&quot;https://github.com/rakyll/hey&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://github.com/rakyll/hey&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;e.g.  加上 method ,content/type ,dataraw&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hey -z 3m -q 10 -c 3 -m POST -T &#39;application/json&#39; -d &#39;{ &amp;quot;method&amp;quot;: &amp;quot;GetUrlForWard&amp;quot;,  &amp;quot;host&amp;quot;: &amp;quot;landing500023.com&amp;quot;}&#39; https://landing500023.com/query.php
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/16.dustise sleep 測試工具簡介/" />
        </entry>
        <entry>
            <title>
                134. 關閉ssh連線後，仍可執行程式
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/134. 關閉ssh連線後，仍可執行程式/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;怎麼最近都在搞shell script阿..&lt;br /&gt;
這次是要把gce的圖片搬到gcs上面，&lt;br /&gt;
總計有三萬多張，一般執行時，如果碰到ssh斷線，執行就失敗了，&lt;br /&gt;
所以要讓他就算ssh斷線，也仍會執行&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;目前有兩種方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;nohup&lt;br /&gt;
算是最簡單，容易用的方式，直接 在後面接command就能用了，&lt;br /&gt;
但我禮拜五掛着，然後禮拜一回來看，發現程式掛了，cpu還飆到100，&lt;br /&gt;
就算用 指令找到pid後，強制刪除，還是有command在執行，最後只能重開。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;	ps -aux | grep &amp;quot;copyfile.sh&amp;quot;
	kill -9 &amp;lt;PID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://noter.tw/3946/ssh-%E9%81%A0%E7%AB%AF%E7%99%BB%E5%87%BA%E5%BE%8C%E7%B9%BC%E7%BA%8C%E5%9F%B7%E8%A1%8C/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SSH 遠端登出後繼續執行&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;screen&lt;br /&gt;
yum直接搜尋會找不到package，需要先額外安裝epel-release&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;yum install epel-release
yum install screen
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用方式&lt;/p&gt;
&lt;p&gt;先建立一個screen&lt;br /&gt;
可指定名稱&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;screen -S &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在screen裏面，執行程式，離開時按&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl+a -&amp;gt; ctrl（不放）+d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看目前有哪些 screen&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;screen -ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Linux/134.fig-1.jpg&quot; alt=&quot;134.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;回到剛剛的screen，可以上面指令看到這個screen的id是58245。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;screen -r 58245
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.twblogs.net/a/5db3ccc2bd9eee310da06d04&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;【Linux】screen解決退出終端會話結束問題&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://intone.cc/2018/07/%e5%ad%b8%e6%9c%83%e4%bd%bf%e7%94%a8screen%e4%b8%8d%e5%86%8d%e6%80%95ssh%e4%b8%ad%e6%96%b7-linux%ef%bc%88centos-7%ef%bc%89/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;學會使用Screen,不再怕SSH中斷 Linux（Centos 7）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/134. 關閉ssh連線後，仍可執行程式/" />
        </entry>
        <entry>
            <title>
                133. shell script字串處理
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/133. shell script字串處理/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;shell script的字串處理，原本以爲只能用grep 跟 awk 走pipeline來用，&lt;br /&gt;
原來還能直接透過${} 來處理，shell script的水好深阿...&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;來個例子，&lt;br /&gt;
有個tag 叫 dev_1.1.23 ，我只要後面的版號就好，該怎麼做。&lt;/p&gt;
&lt;p&gt;本來做法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash
set -x
abc=&amp;quot;dev_1.1.23&amp;quot;
echo $abc|grep -o &#39;&#92;d.&#92;d.&#92;d.&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用 grep 取值，並只顯示符合正則的字串， 所以要用 -o&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.1.23&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果改用${}的文字非貪婪左刪除&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash
set -x
abc=&amp;quot;dev_1.1.23&amp;quot;
echo ${abc#*_}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;1.1.23&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Linux/133.fig-1.jpg&quot; alt=&quot;133.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;除了左刪除，也能做到右刪除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 小比對左
## 大比對左
% 小比對右
%% 大比對右
* 用來比對然後刪除

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ps.&lt;br /&gt;
set -x 是屬於xtrace的應用，用來除錯的。&lt;br /&gt;
也可以在執行的時候，加上 bash -x &lt;a href=&quot;http://curl.sh/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;curl.sh&lt;/a&gt; ，&lt;br /&gt;
這樣使用&lt;br /&gt;
詳細參考&lt;a href=&quot;https://hackmd.io/@seterrychen/rkZINBjKH&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Shell script前言&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.sunxidong.com/449.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux Shell 指令碼中 ${} 用法&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/133. shell script字串處理/" />
        </entry>
        <entry>
            <title>
                132. shell script 雙引號與單引號
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/132. shell script 雙引號與單引號/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;最近寫CI/CD，碰到一堆shell script的指令，&lt;br /&gt;
以前都是try error一路試過去的，&lt;br /&gt;
沒碰到什麼太大問題，直到現在那一長串，我才終於發瘋。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;簡單說法&quot; tabindex=&quot;-1&quot;&gt;簡單說法&lt;/h3&gt;
&lt;p&gt;shell script的 單引號 『 &#39; 』括起來的字，&lt;br /&gt;
會保留引號內每個字元，就是說裏面的變數不會變。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;abc=&amp;quot;a&amp;quot;
echo &#39;$abc&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就是印出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$abc&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而雙引號 『 &amp;quot; 』 括起來的字，&lt;br /&gt;
不會保留引號內的字元，就是說裏面的變數會跟着變&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;abc=a
echo &amp;quot;$abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;印出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以看起來會像這樣&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Linux/132.fig-1.jpg&quot; alt=&quot;132.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果變成單引號包雙引號，或是 雙引號包單引號&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;echo &#39;&amp;quot;$abc&amp;quot;&#39;
echo &amp;quot;&#39;$abc&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;$abc&lt;br /&gt;
&#39;a&#39;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;詳細說法&quot; tabindex=&quot;-1&quot;&gt;詳細說法&lt;/h3&gt;
&lt;p&gt;單引號：&lt;br /&gt;
shell 將逐字解釋單引號內的封閉文字，並且不會插入任何內容，包括變數、反引號、某些 &#92; 轉義符等，所有字元都會維持原始字面意義&lt;/p&gt;
&lt;p&gt;雙引號：&lt;br /&gt;
允許 shell 解釋美元符號 ( $ )、反引號 ( ` )、反斜槓 ( &#92; ) 和驚嘆號 (！）， 這些字元與雙引號一起使用時具有特殊含義，並且在顯示之前對其進行評估&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://officeguide.cc/bash-tutorial-quoted-strings-and-special-characters/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; Bash 程式設計教學與範例：單引號、雙引號、跳脫字元&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.51cto.com/article/685657.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;終於知道 Shell 中單引號雙引號的區別了&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;p.s 上面宣告的 abc 叫做本地變數(local variable)，&lt;br /&gt;
如果用上了export 則是 環境變數(environment variable)&lt;/p&gt;
&lt;p&gt;常見變數錯誤&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A = B #=號前後不能有空格
1A=B &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#變量名稱不能以數字開頭&quot;&gt;#變量名稱不能以數字開頭&lt;/a&gt;
$A=B &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#變量的名稱裡有&quot;&gt;#變量的名稱裡有&lt;/a&gt;$
a=B  &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#這跟a&quot;&gt;#這跟a&lt;/a&gt;=b是不同的
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://jasonblog.github.io/note/shell/2315.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; shell十三問之5:問var=value 在export前後的差在哪?&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/132. shell script 雙引號與單引號/" />
        </entry>
        <entry>
            <title>
                116. 安裝linux server 基本設定
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/116. 安裝linux server 基本設定/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;好久沒弄ubuntu了，有些預設要設定的東西，&lt;br /&gt;
還真的久沒用就忘記，&lt;br /&gt;
筆記筆記。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;新增使用者&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sudo useradd it
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;修改密碼&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sudo passwd it
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://blog.gtwang.org/linux/linux-useradd-command-tutorial-examples/&quot; title=&quot;Linux 新增使用者 useradd 指令用法教學與範例&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux 新增使用者 useradd 指令用法教學與範例&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指定帳號，輸入sudo免密碼&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;echo &amp;quot;username ALL=(ALL) NOPASSWD: ALL&amp;quot; &amp;gt; /etc/sudoers.d/username
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10270945?sc=hot&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;第8章：管理本地端主機之使用者與群組(二)&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更改固定ip，修改裏面的檔案 *.network-manager-all.yaml&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd /etc/netplan/

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;network:  
  version: 2  
  renderer: NetworkManager  
  ethernets:  
    ens33:  
      dhcp4: no  
      addresses: [192.168.103.231/24]  
      gateway4: 192.168.0.1  
      nameservers:  
        addresses: [8.8.8.8,8.8.4.4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成後，先測試&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo netplan try
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.ruyut.com/2021/12/ubuntu-ip.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Ubuntu] 設定固定ip&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般使用者執行docker&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sudo usermod -a -G docker ${USER}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行完後，需重新登入&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/116. 安裝linux server 基本設定/" />
        </entry>
        <entry>
            <title>
                114. alpine linux 宣告變數,error bad variable name
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/114. alpine linux 宣告變數,error bad variable name/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;頭一次碰到這種坑，&lt;br /&gt;
我linux有待加強 （哭&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;先看執行結果，&lt;br /&gt;
變數後面不能接空格，不然會出現錯誤。&lt;br /&gt;
等號後面也不能接空格，不然會出現錯誤。&lt;br /&gt;
平常程式寫太順，都習慣按空格了，&lt;br /&gt;
結果....&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/ # export ab = &amp;quot;hello world&amp;quot;
sh: export: : bad variable name
/ # EXPORT ab = &amp;quot;hello world&amp;quot;
sh: EXPORT: not found
/ # export ab=&amp;quot;helloworld&amp;quot;
/ # echo $ab
helloworld
/ # export ab = &amp;quot;helloworld&amp;quot;
sh: export: : bad variable name
/ # export ab =&amp;quot;helloworld&amp;quot;
sh: export: : bad variable name
/ # export ab= &amp;quot;helloworld&amp;quot;
/ # echo $ab
helloworlda
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/114. alpine linux 宣告變數,error bad variable name/" />
        </entry>
        <entry>
            <title>
                108. linux shell 進階指令
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/108. linux shell 進階指令/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;我也不知道這算不算進階？&lt;br /&gt;
但平常我應該不會用，本文有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;計算某個開頭的tag數量有多少&lt;/li&gt;
&lt;li&gt;for迴圈的資料寫到文字檔&lt;/li&gt;
&lt;li&gt;取得檔案詳細時間&lt;/li&gt;
&lt;li&gt;取得檔案列表後刪除&lt;/li&gt;
&lt;li&gt;xargs 參數&lt;/li&gt;
&lt;li&gt;只顯示資料夾&lt;/li&gt;
&lt;li&gt;只顯示檔案&lt;/li&gt;
&lt;li&gt;ls參數&lt;/li&gt;
&lt;li&gt;計算目錄底下的檔案數&lt;/li&gt;
&lt;li&gt;查詢使用者&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;tag&quot; tabindex=&quot;-1&quot;&gt;計算某個開頭的tag數量有多少&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;for tag in $(git tag --sort -version:refname -l &amp;quot;1.1.*&amp;quot;); do
  echo $tag;
  let i++
done
echo $i;
unset i;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;for&quot; tabindex=&quot;-1&quot;&gt;for迴圈的資料寫到文字檔&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;for i in {20221201..20221202}
do
  for j in {00..01}
  do
      echo &amp;quot;mkdir $i$j&amp;quot; 
  done
done  &amp;gt; 1.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;取得檔案詳細時間&quot; tabindex=&quot;-1&quot;&gt;取得檔案詳細時間&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ls --full-time | sort -k6
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;取得檔案列表後刪除&quot; tabindex=&quot;-1&quot;&gt;取得檔案列表後刪除&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ls | grep 4793877c | xargs -p rm -f
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;xargs&quot; tabindex=&quot;-1&quot;&gt;xargs 參數&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;-I {} 將指令帶到後面的{}執行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ls nfs | head -10 | xargs -t -I {} ls nfs/{}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;-t   顯示執行的指令&lt;br /&gt;
-p 執行前的確認&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.gtwang.org/linux/xargs-command-examples-in-linux-unix/&quot; title=&quot;Linux 系統 xargs 指令範例與教學&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux 系統 xargs 指令範例與教學&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.runoob.com/linux/linux-comm-xargs.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux xargs 命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;只顯示資料夾&quot; tabindex=&quot;-1&quot;&gt;只顯示資料夾&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ls -l | grep
{ &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#d&quot;&gt;#d&lt;/a&gt;}
   # 利用詳細資訊，判斷開頭是不是 d(directory)
ls -d */
ls -F | grep &#92;/$  # 檔案名稱的最後如果有/表示是folder
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;只顯示檔案&quot; tabindex=&quot;-1&quot;&gt;只顯示檔案&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ls -F /etc | grep -v &#39;/$&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;ls&quot; tabindex=&quot;-1&quot;&gt;ls參數&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;-l  顯示檔案與目錄的詳細資訊&lt;br /&gt;
-a 顯示隱藏的檔案與目錄&lt;br /&gt;
-h 輸出的資訊以比較容易閱讀的格式呈現&lt;br /&gt;
-F 檔案名稱的後面加上檔案類型的標示字元&lt;br /&gt;
-r 檔案的列表以反向的排序列出&lt;br /&gt;
-R 用遞迴的方式列出所有子目錄的檔案&lt;br /&gt;
-S 檔案依照檔案的大小來排序&lt;br /&gt;
-d 只列出目錄，後面不加上*/   無法顯示&lt;br /&gt;
--full-time 顯示完整時間&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;計算目錄底下的檔案數&quot; tabindex=&quot;-1&quot;&gt;計算目錄底下的檔案數&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; find ./ -type f -name *.*| wc -l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;find [obj_directory] [-type f] [-name filename]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;find參數說明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;obj_directory：要搜尋的路徑&lt;br /&gt;
-type：要搜尋的類型，f=檔案，d=目錄&lt;br /&gt;
-iname：不區分大小寫&lt;br /&gt;
-name：後面接檔名，可加萬用字元(*)，搜尋類似檔名的檔案&lt;/p&gt;
&lt;p&gt;wc [-l]&lt;br /&gt;
&lt;strong&gt;wc參數說明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;-c: 統計位元組數&lt;br /&gt;
-l：統計行數&lt;br /&gt;
-m：統計字元數。不能與 -c 一起使用。&lt;br /&gt;
-w 統計字數。一個字被定義為由空白、跳格或換行字元分隔的字串。&lt;br /&gt;
-L 列印最長行的長度。&lt;br /&gt;
-help 顯示説明資訊。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://yosia.net/article/181&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [Linux] 計算目錄底下的檔案數&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;查所有使用者&quot; tabindex=&quot;-1&quot;&gt;查所有使用者&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cat /etc/passwd | awk -F: &#39;{print $1}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://devconnected.com/how-to-list-users-and-groups-on-linux/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; How To List Users and Groups on Linux&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;刪除使用者&quot; tabindex=&quot;-1&quot;&gt;刪除使用者&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;userdel -r &amp;lt;userID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://medium.com/%E4%B8%80%E5%80%8B%E5%B0%8F%E5%B0%8F%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E9%9A%A8%E6%89%8B%E7%AD%86%E8%A8%98/gcp-%E9%81%87%E5%88%B0permission-denied-publickey-%E6%80%8E%E9%BA%BC%E8%BE%A6-e41e26ebdf47&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [GCP]遇到permission denied (publickey)怎麼辦？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.gtwang.org/linux/linux-ls-command-tutorial/&quot; title=&quot;Linux 的 ls 指令教學與常用範例整理&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux 的 ls 指令教學與常用範例整理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hy-star.com.tw/tech/linux/pipe/pipe.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;管線/重新導向&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;linux&quot; tabindex=&quot;-1&quot;&gt;linux何時安裝&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;stat / | awk &#39;/Birth: /{print $2 &amp;quot; &amp;quot; substr($3,1,5)}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://linuxiac.com/how-to-find-linux-os-installation-date/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux Installation Date: How to Discover Your System’s Age&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/108. linux shell 進階指令/" />
        </entry>
        <entry>
            <title>
                0.Linux MOC
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Linux/0.Linux MOC/</id>
            <content type="html">
                &lt;h1 id=&quot;basic&quot; tabindex=&quot;-1&quot;&gt;basic&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/132.%20shell%20script%20%E9%9B%99%E5%BC%95%E8%99%9F%E8%88%87%E5%96%AE%E5%BC%95%E8%99%9F/&quot;&gt;132. shell script 雙引號與單引號&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/133.%20shell%20script%E5%AD%97%E4%B8%B2%E8%99%95%E7%90%86/&quot;&gt;133. shell script字串處理&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/163.Shell%E7%9A%84%E5%8D%80%E5%88%A5%E5%8F%8A%E6%9F%A5%E8%A9%A2/&quot;&gt;163.Shell的區別及查詢&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;setting&quot; tabindex=&quot;-1&quot;&gt;Setting&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/33.%20centos%207%E5%AE%89%E8%A3%9Dredis%20%E6%94%B9port/&quot;&gt;33. centos 7安裝redis 改port&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/49.npm%20%E8%88%87%20yarn%20%E6%AF%94%E8%BC%83/&quot;&gt;49.npm 與 yarn 比較&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/116.%20%E5%AE%89%E8%A3%9Dlinux%20server%20%E5%9F%BA%E6%9C%AC%E8%A8%AD%E5%AE%9A/&quot;&gt;116. 安裝linux server 基本設定&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;tools&quot; tabindex=&quot;-1&quot;&gt;Tools&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/16.dustise%20sleep%20%E6%B8%AC%E8%A9%A6%E5%B7%A5%E5%85%B7%E7%B0%A1%E4%BB%8B/&quot;&gt;16.dustise sleep 測試工具簡介&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/51.curl%20%E7%AD%86%E8%A8%98/&quot;&gt;51.curl 筆記&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/65.%20Linux%20command%20-%20grep/&quot;&gt;65. Linux command - grep&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/93.%20shellscript%E8%A7%A3%E6%9E%90/&quot;&gt;93. shellscript解析&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/108.%20linux%20shell%20%E9%80%B2%E9%9A%8E%E6%8C%87%E4%BB%A4/&quot;&gt;108. linux shell 進階指令&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/134.%20%E9%97%9C%E9%96%89ssh%E9%80%A3%E7%B7%9A%E5%BE%8C%EF%BC%8C%E4%BB%8D%E5%8F%AF%E5%9F%B7%E8%A1%8C%E7%A8%8B%E5%BC%8F/&quot;&gt;134. 關閉ssh連線後，仍可執行程式&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/165.%20Linux%E7%B6%B2%E8%B7%AF%E8%BF%BD%E8%B9%A4%E5%B7%A5%E5%85%B7-%20MTR/&quot;&gt;165. Linux網路追蹤工具- MTR&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/171.%20linux%20top%E6%8C%87%E4%BB%A4%E8%A9%B3%E8%A7%A3/&quot;&gt;171. linux top指令詳解&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/173.%20Linux%E6%AE%AD%E5%B1%8D%E7%A8%8B%E5%BC%8F/&quot;&gt;173. Linux殭屍程式&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/php%20exec%20ssh%20%E7%99%BC%E7%94%9F%20Host%20key%20verification%20failed%20%E9%8C%AF%E8%AA%A4/&quot;&gt;php exec ssh 發生 Host key verification failed 錯誤&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/114.%20alpine%20linux%20%E5%AE%A3%E5%91%8A%E8%AE%8A%E6%95%B8,error%20bad%20variable%20name/&quot;&gt;114. alpine linux 宣告變數,error bad variable name&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/48.SSH%E7%84%A1%E6%B3%95%E9%80%A3%E7%B7%9A%EF%BC%8CREMOTE%20HOST%20IDENTIFICATION%20HAS%20CHANGED/&quot;&gt;48.SSH無法連線，REMOTE HOST IDENTIFICATION HAS CHANGED&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/63.alpine%20linux%20apk%20ERROR%20unable%20to%20select%20packages/&quot;&gt;linux安裝測試package&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Linux/0.Linux MOC/" />
        </entry>
        <entry>
            <title>
                GCP費用
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/Price/GCP費用/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;GCP的費用主要分三塊，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;機器規格的開機費用&lt;br /&gt;
簡單說就是，機器開機的話產生的費用，但要注意的GCP他有續用折扣，當你用越多就能夠打折。而且他會主動合併未滿一個月機器，再一起算費用。&lt;br /&gt;
ref.
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.cloud-ace.tw/google-cloud-platform/pricing/gcp-is-cheap-each-discount-plan-introduction/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; 聽說 GCP 費用最低？各種折扣方案完整說明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/compute/docs/sustained-use-discounts&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;持續使用折扣&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;硬碟的費用&lt;br /&gt;
恩...就開機器時，所需要的硬碟空間大小費用，就算你機器關機一樣照算。&lt;br /&gt;
ref. &lt;a href=&quot;https://cloud.google.com/compute/disks-image-pricing#persistentdisk&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;磁碟和映像價格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;網路的費用&lt;br /&gt;
以伺服器的角度來說，ingress(流量進來）不算錢，egress（流量出去）算錢。&lt;br /&gt;
以使用者的角度來說，上傳不用錢，下載要錢。&lt;br /&gt;
ref. &lt;a href=&quot;https://blog.cloud-ace.tw/google-cloud-platform/pricing/gcp-price-estimate/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GCP 如何計費？就像水電費一樣&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;registry&quot; tabindex=&quot;-1&quot;&gt;Registry&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Artifact Registry&lt;/th&gt;
&lt;th&gt;Container Registry&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0.5GB以下免費，超過0.5GB，每GB 0.1 美元&lt;/td&gt;
&lt;td&gt;根據cloudStorage計價&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;網路輸出另計&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/artifact-registry/pricing?hl=zh-tw#storage&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Artifact Registry 定價&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/Price/GCP費用/" />
        </entry>
        <entry>
            <title>
                GCP CPU用途
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/Price/GCP CPU用途/</id>
            <content type="html">
                &lt;h1 id=&quot;官方建議&quot; tabindex=&quot;-1&quot;&gt;官方建議&lt;/h1&gt;
&lt;p&gt;下表是官方建議的機器型號及用途&lt;br /&gt;
ref.&lt;a href=&quot;https://cloud.google.com/compute/docs/general-purpose-machines&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;通用機器系列&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;E2&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web 服務&lt;/li&gt;
&lt;li&gt;中小型資料庫&lt;/li&gt;
&lt;li&gt;應用提供服務&lt;/li&gt;
&lt;li&gt;後台應用&lt;/li&gt;
&lt;li&gt;微服務&lt;/li&gt;
&lt;li&gt;虛擬桌面&lt;/li&gt;
&lt;li&gt;開發環境&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;N2、N2D、Tau T2D、N1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web 服務&lt;/li&gt;
&lt;li&gt;大中型資料庫&lt;/li&gt;
&lt;li&gt;應用提供服務&lt;/li&gt;
&lt;li&gt;後台應用&lt;/li&gt;
&lt;li&gt;快取&lt;/li&gt;
&lt;li&gt;媒體/流式傳輸&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tau T2A&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;應用服務、Web 服務和遊戲服務&lt;/li&gt;
&lt;li&gt;嵌入式系統開發&lt;/li&gt;
&lt;li&gt;Arm 上的 CI/CD 開發&lt;/li&gt;
&lt;li&gt;視訊和圖片編碼、轉碼和處理&lt;/li&gt;
&lt;li&gt;數字廣告交易和投放&lt;/li&gt;
&lt;li&gt;快取伺服器&lt;/li&gt;
&lt;li&gt;計算型藥品研發&lt;/li&gt;
&lt;li&gt;Android 開發&lt;/li&gt;
&lt;li&gt;自動駕駛或傳統汽車軟體開發&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他 N2D 跟 Tau T2D都是AMD的CPU，價格比N2的便宜&lt;/p&gt;
&lt;p&gt;以同樣的 4 cpu , 16GB memory 來比較價格的話，&lt;br /&gt;
改天要開到N2的話，可以試試N2D的機器。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;類型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;CPU&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;記憶體&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;價格&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;n2-standard-4&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;4&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;16GB&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$0.1942&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;n2d-standard-4&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;4&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;16GB&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$0.1690&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;e2-standard-4&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;4&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;16GB&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$0.13402&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;更詳細的價格，參考 &lt;a href=&quot;https://cloud.google.com/compute/vm-instance-pricing&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;虛擬機器實例價格&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/Price/GCP CPU用途/" />
        </entry>
        <entry>
            <title>
                180. GCP 監控費用
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/Price/180. GCP 監控費用/</id>
            <content type="html">
                &lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;價格&lt;a href=&quot;https://cloud.google.com/stackdriver/pricing?hl=zh-cn#binary-units&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;1&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;每月免費配額&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Logging&lt;/a&gt; 儲存*&lt;/td&gt;
&lt;td&gt;$0.50/GiB；  &lt;br /&gt;將日誌流式傳輸到日誌儲存桶儲存空間，以便編入索引、查詢和分析的一次性費用；包括日誌儲存桶中長達 30 天的儲存費用。 查詢和分析日誌資料不會產生額外費用。&lt;/td&gt;
&lt;td&gt;每個項目每月的前 50 GiB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Logging&lt;/a&gt; 保留†&lt;/td&gt;
&lt;td&gt;對於保留超過 30 天的日誌，每月每 GiB 為 $0.01；根據留存率按月結算。&lt;/td&gt;
&lt;td&gt;在&lt;a href=&quot;https://cloud.google.com/logging/quotas?hl=zh-cn#logs_retention_periods&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;默認保留期限&lt;/a&gt;內保留的日誌不會產生保留費用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;日誌記錄&lt;/a&gt;入站流量‡&lt;/td&gt;
&lt;td&gt;無需額外費用&lt;/td&gt;
&lt;td&gt;不適用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs/routing/overview?hl=zh-cn#ingesting-routing&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;日誌路由器&lt;/a&gt;♦&lt;/td&gt;
&lt;td&gt;無需額外費用&lt;/td&gt;
&lt;td&gt;不適用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs/log-analytics?hl=zh-cn#analytics&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Log Analytics&lt;/a&gt;♣&lt;/td&gt;
&lt;td&gt;無需額外費用&lt;/td&gt;
&lt;td&gt;不適用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;logging&quot; tabindex=&quot;-1&quot;&gt;Logging保留&lt;/h2&gt;
&lt;p&gt;Logging保留的費用，在默認保留的天數為以下&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;日誌儲存桶&lt;/th&gt;
&lt;th&gt;默認保留期限&lt;/th&gt;
&lt;th&gt;自訂保留期限&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_Required&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;400 天&lt;/td&gt;
&lt;td&gt;不可組態&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_Default&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;30 天&lt;/td&gt;
&lt;td&gt;可組態&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用者定義&lt;/td&gt;
&lt;td&gt;30 天&lt;/td&gt;
&lt;td&gt;可組態&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&quot;code-required-code&quot; tabindex=&quot;-1&quot;&gt;&lt;code&gt;_Required&lt;/code&gt; 日誌儲存桶&lt;/h5&gt;
&lt;p&gt;Cloud Logging 會自動將以下類型的日誌路由到 &lt;code&gt;_Required&lt;/code&gt; 儲存桶：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs/audit?hl=zh-cn#admin-activity&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;管理員活動稽核日誌&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs/audit?hl=zh-cn#system-event&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;系統事件稽核日誌&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Google Workspace 管理員稽核日誌&lt;/li&gt;
&lt;li&gt;企業版群組稽核日誌&lt;/li&gt;
&lt;li&gt;登錄稽核日誌&lt;/li&gt;
&lt;li&gt;Access Transparency 日誌。如需瞭解如何啟用 Access Transparency 日誌，請參閱 &lt;a href=&quot;https://cloud.google.com/assured-workloads/access-transparency/docs/overview?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Access Transparency 日誌文件&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;code-default-code&quot; tabindex=&quot;-1&quot;&gt;&lt;code&gt;_Default&lt;/code&gt; 日誌儲存桶&lt;/h5&gt;
&lt;p&gt;除非您停用或以其他方式修改 &lt;code&gt;_Default&lt;/code&gt; 接收器，否則未儲存在 &lt;code&gt;_Required&lt;/code&gt; 儲存桶中的任何日誌條目都會被 &lt;code&gt;_Default&lt;/code&gt; 接收器路由到 &lt;code&gt;_Default&lt;/code&gt; 儲存桶。如需瞭解如何修改接收器，請參閱&lt;a href=&quot;https://cloud.google.com/logging/docs/export/configure_export_v2?hl=zh-cn#managing_sinks&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;管理接收器&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Cloud Logging 會自動將以下類型的日誌路由到 &lt;code&gt;_Default&lt;/code&gt; 儲存桶：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs/audit?hl=zh-cn#data-access&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;資料訪問稽核日誌&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs/audit?hl=zh-cn#policy_denied&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;政策拒絕稽核日誌&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除非您為 &lt;code&gt;_Default&lt;/code&gt; 儲存桶&lt;a href=&quot;https://cloud.google.com/logging/docs/buckets?hl=zh-cn#custom-retention&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;組態自訂保留&lt;/a&gt;，否則 Cloud Logging 會將日誌保留 30 天。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/stackdriver/pricing?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Google Cloud 的維運套件價格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/logging/quotas?hl=zh-cn#logs_retention_periods&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;日誌保留期限&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs/routing/overview?hl=zh-cn#buckets&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;路由和儲存概覽&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/Price/180. GCP 監控費用/" />
        </entry>
        <entry>
            <title>
                126. GCP 硬碟費用比較
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/Price/126. GCP 硬碟費用比較/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;CloudStorage&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Standard ：適合短期儲存和經常存取的資料&lt;/li&gt;
&lt;li&gt;Nearline ： 適用於備份項目和一個月存取不到一次的資料&lt;/li&gt;
&lt;li&gt;Coldline：最適合用於災難復原，以及儲存「每季存取少於一次」的資料&lt;/li&gt;
&lt;li&gt;Archive ：適合以數位方式長期保存一年存取不到一次的資料&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面為每月每GB的空間費用&lt;/p&gt;
&lt;p&gt;|                 | Standard 儲存空間 | Nearline 儲存空間 | Coldline 儲存空間 | 封存儲存空間     |    |&lt;br /&gt;
|-----------------|---------------|---------------|---------------|------------|&lt;br /&gt;
| 台灣 (asia-east1) | $0.020 美元     | $0.010 美元     | $0.005 美元     | $0.0015 美元 |&lt;/p&gt;
&lt;p&gt;如果有網路流量，額外在算&lt;/p&gt;
&lt;p&gt;| 每月用量      | 輸出至世界各地 (亞洲和澳洲除外) | 輸出至亞洲地區 (中國除外，但含香港) | 輸出至中國地區 (香港除外) | 輸出至澳洲地區，從位於澳洲的 Cloud Storage 區域輸出 | 輸入 |   |   |   |   |&lt;br /&gt;
|-----------|-------------------|---------------------|----------------|-----------------------------------|----|&lt;br /&gt;
| 0 至 1 TB  | $0.12 美元          | $0.12 美元            | $0.23 美元       | $0.19 美元                          | 免費   |&lt;br /&gt;
| 1 至 10 TB | $0.11 美元          | $0.11 美元            | $0.22 美元       | $0.18 美元                          | 免費   |&lt;br /&gt;
| 10 TB 以上  | $0.08 美元          | $0.08 美元            | $0.20 美元       | $0.15 美元                          | 免費  |&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/storage/pricing?hl=zh-tw#asia&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;價目表&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/Price/126. GCP 硬碟費用比較/" />
        </entry>
        <entry>
            <title>
                97. Anthos 初體驗
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/97. Anthos 初體驗/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;每個月增加 50 美&lt;/li&gt;
&lt;li&gt;create new cluster ,無法更改現有(Anthos)&lt;/li&gt;
&lt;li&gt;只能用workload identity&lt;/li&gt;
&lt;li&gt;cpu至少四個，total 要八個&lt;/li&gt;
&lt;li&gt;Anthos 跟 Anthos Service Mesh 不一樣&lt;br /&gt;
ref. &lt;a href=&quot;https://cloud.google.com/service-mesh/docs/ui-differences&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Anthos 與 Anthos Service Mesh 界面差異&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果在mac上，參照&lt;a href=&quot;https://cloud.google.com/service-mesh/docs/unified-install/install-dependent-tools&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;文件&lt;/a&gt;，執行的話會出現一些錯誤。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;mac不支援此指令，&lt;/li&gt;
&lt;li&gt;也不要使用cloudShell，會因為VPCSC 而出現錯誤&lt;/li&gt;
&lt;li&gt;最佳解法，使用linux系統&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt; docker  run -it --rm   -v &amp;quot;$HOME&amp;quot;/.config:/root/.config -v /Users/ezio_liu/Documents/kill:/data google/cloud-sdk:latest

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因為有將 gcp驗證 掛載到image內，所以不用在驗證一次。&lt;br /&gt;
可以使用下面指令，看人員有沒有驗證&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud auth list 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最後，使用下面指令安裝&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./asmcli install   &#92;
--project_id rd7-project &#92;
--cluster_name istio-test &#92;
--cluster_location asia-east1-b &#92;
--fleet_id rd7-project &#92;
--output_dir asmcli_output &#92;
--managed  &#92;
--ca mesh_ca
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;--managed 是使用 代管式anthos&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/97. Anthos 初體驗/" />
        </entry>
        <entry>
            <title>
                95.cloud build的問題
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/95.cloud build的問題/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;在建置cloud build時遇到問題，&lt;br /&gt;
經查詢後推測問題在於，&lt;br /&gt;
cloud build的google service當他在運作過程，&lt;br /&gt;
需要向私有專案內的gke cluster操作，&lt;br /&gt;
cloud build是使用google的浮動ip，&lt;br /&gt;
在此處應該是被block掉了所以無法完成cloud build建置&lt;/p&gt;
&lt;p&gt;錯誤訊息：Unable to connect to the server: dial tcp 124.111.27.75:443: i/o timeout&lt;/p&gt;
&lt;p&gt;(IP為cluster端點ip)&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/build/docs/troubleshooting#io_timeout_error&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;google錯誤排解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;現階段有三種方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自架CICD系統&lt;/li&gt;
&lt;li&gt;GKE 直接開放 0.0.0.0/0 &amp;gt; 這有安全疑慮&lt;/li&gt;
&lt;li&gt;使用 private conn &amp;gt; 這複雜度很高且不彈性&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/95.cloud build的問題/" />
        </entry>
        <entry>
            <title>
                9.GCP網路對外的方式
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/9.GCP網路對外的方式/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;這算是先前一直有問題，但不知道為什麼，也沒去查原因。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;為了要正確對應，讓其他機器開白名單，不得不弄清楚，到底怎麼一回事。&lt;br /&gt;
之前同事都說是走cloudNat，但我直接連去 vm  or pod裡面，&lt;br /&gt;
用curl &lt;a href=&quot;http://ifconfig.me/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ifconfig.me&lt;/a&gt; 抓到的ip都不是我所知道的ip，&lt;br /&gt;
(&lt;a href=&quot;http://ifconfig.me/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ifconfig.me&lt;/a&gt; 是一個網址，單純顯示目前連去網站的ip位置)&lt;/p&gt;
&lt;p&gt;CloudNAT 的基本概念，主要是可提供內部機器對外連線&lt;br /&gt;
ref. &lt;a href=&quot;https://cloud.google.com/nat/docs/overview&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Cloud NAT 概覽&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基本的設定方式，&lt;br /&gt;
ref. &lt;a href=&quot;https://cloud.google.com/nat/docs/using-nat&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 Cloud NAT&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GCE沒有問題，基本上沒有外部ip而且又沒設定cloudNAT的話，就是無法連接外網。&lt;br /&gt;
然而有外部ip位置的話，Google Cloud 會自動對來源與該接口的主內部 IP 地址匹配的數據包執行一對一 NAT。&lt;br /&gt;
但GKE就有點問題了，就算沒有設定外部ip，還是能夠對外，&lt;br /&gt;
而且抓到的ip位置，你不知道是從何而來，也不是CloudNAT的IP&lt;/p&gt;
&lt;p&gt;最後從&lt;a href=&quot;https://cloud.google.com/nat/docs/troubleshooting#internet-wo-nat&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;問題排查&lt;/a&gt;這邊找到了答案，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;確保您的 Google Kubernetes Engine (GKE) 集群是一個專用集群。非專用集群中的每個節點虛擬機都具有外部 IP 地址，因此每個節點都可以使用 Virtual Private Cloud (VPC) 網絡中下一個躍點為默認互聯網網關而不依賴 Cloud NAT 的路由。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;簡單說，如果沒有設定專有集群（私有叢集），本身的node是具有對外的ip，所以還沒到CloudNAT之前，&lt;br /&gt;
就直接從node節點出去了。這部分可以到pod裡面 抓取對外ip，然後去比對，這個pod所在的node的對外ip就知道了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters#console&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;建立私人叢集&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;2021-04-19&quot; tabindex=&quot;-1&quot;&gt;2021/04/19 更新&lt;/h1&gt;
&lt;p&gt;今天來算一下數學，&lt;/p&gt;
&lt;p&gt;上面有提到，當設成私有叢集或是VM，需要對外連線時，&lt;br /&gt;
需設定cloud nat ip，&lt;br /&gt;
當對外連線數量不足時，會發生許多奇怪的問題，&lt;br /&gt;
例如，佈署 deployment ，會發生image pull error ，pod無法啟動，一直重開...等等。&lt;/p&gt;
&lt;p&gt;[[9-fig.1.jpg]]&lt;/p&gt;
&lt;p&gt;每個 VM 執行個體的最低通訊埠數量 ：64&lt;br /&gt;
表示每台VM可以對外的連線數量。&lt;/p&gt;
&lt;p&gt;假設(fig.1)&lt;br /&gt;
對外的ip有兩個，&lt;br /&gt;
一個對外ip可以提供 64512的 port 給裡面的來源子網路與IP使用，&lt;br /&gt;
而我們上面設定 每個 VM 執行個體的最低通訊埠數量 為 64 ，&lt;br /&gt;
故 64512 * 2/64 = 2016 可提供的VM數量&lt;br /&gt;
表示 來源子網路與 IP 範圍 的VPC網路 可以提供給2016 個VM （包含 GCE 跟 GKE的節點） 使用。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/nat/docs/ports-and-addresses#port-reservation-examples&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Cloud NAT 地址和端口概覽&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/9.GCP網路對外的方式/" />
        </entry>
        <entry>
            <title>
                88.批次修改GCP的label
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/88.批次修改GCP的label/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;發現有一整批的資源沒有加過 label ，&lt;br /&gt;
GCE的硬碟、負載平衡的前端轉導規則..&lt;br /&gt;
有些條件不一樣，一個一個加會瘋掉。&lt;br /&gt;
工程師就是懶...寫sh吧&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;開始構思&quot; tabindex=&quot;-1&quot;&gt;開始構思&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;先把關鍵值拉出來 (1)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute forwarding-rules list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/88-fig.1.png&quot; alt=&quot;88-fig.1.png&quot; /&gt;&lt;br /&gt;
只有ip，要跑去每個叢集查資料，看這該歸屬哪個label，&lt;br /&gt;
太笨了，不行。&lt;/p&gt;
&lt;p&gt;先看一下forwarding-rules 有哪些資訊(2)，再把欄位顯示出來。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute forwarding-rules describe a0589a367cdc1470e839b05803958e2b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;裡面的description似乎蠻有用處的，可以幫忙釐清是哪個cluster&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/88-fig.2.jpg&quot; alt=&quot;88-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;用 --format (3)，顯示欄位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; gcloud compute forwarding-rules list  --format=&#39;table(name,IPAddress,description)&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/88-fig.3.jpg&quot; alt=&quot;88-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;開始寫bash&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;將name丟進 文字檔，&lt;br /&gt;
然後執行bash，bash的流程，迴圈讀檔案內容(4)，執行更新label指令(5)。這邊要注意，如果是ingress或是區域型的要額外加上 --global，&lt;br /&gt;
才能更新。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while read p; do
  echo &amp;quot;$p&amp;quot;; gcloud compute forwarding-rules update $p &#92;
    --update-labels=product=abc,env=prod,dept=rd; echo &amp;quot;done&amp;quot;;
done &amp;lt;lbfr.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/compute/forwarding-rules/list&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud compute forwarding-rules list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/compute/forwarding-rules/describe&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud compute forwarding-rules describe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/topic/formats&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud topic formats&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.compciv.org/topics/bash/loops/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;http://www.compciv.org/topics/bash/loops/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/compute/forwarding-rules/update&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud compute forwarding-rules update&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/88.批次修改GCP的label/" />
        </entry>
        <entry>
            <title>
                8.GCS使用方式
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/8.GCS使用方式/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;某個案子，要整個翻掉重做，這次要讓VM的機器跟GKE的pod能夠同時存取一個儲存空間，&lt;br /&gt;
預計使用Google Cloud Storage，踩了一個早上的坑。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;預計做兩個項目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在VM上面掛載gcs的資料夾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在GKE 上面的pod同時掛載 gcs的資料夾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在VM上面掛載gcs的資料夾&lt;br /&gt;
安裝方式，目前我的vm是 RedHat 所以用下面的方式，CentOS也是用同樣的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Configure the gcsfuse repo:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo tee /etc/yum.repos.d/gcsfuse.repo &amp;gt; /dev/null &amp;lt;&amp;lt;EOF
[gcsfuse]
name=gcsfuse (packages.cloud.google.com)
baseurl=https://packages.cloud.google.com/yum/repos/gcsfuse-el7-x86_64
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg
       https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Install gcsfuse:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;  sudo yum install gcsfuse
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成，其他安裝方式，請參考&lt;a href=&quot;https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/docs/installing.md&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GoogleCloudPlatform/gcsfuse/install.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;登入使用，&lt;br /&gt;
這邊先使用 gcloud auth login 做測試&lt;br /&gt;
先建立資料夾  mkdir upload&lt;br /&gt;
掛載  gcsfuse my-bucket upload&lt;br /&gt;
卸除掛載 fusermount -u upload&lt;/p&gt;
&lt;h3 id=&quot;debug&quot; tabindex=&quot;-1&quot;&gt;Debug用&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;gcsfuse --foreground --debug_gcs --debug_http --debug_fuse --debug_invariants --key-file=/home/user/Downloads/my-key.json mybucket /upload
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;google-application-credentials&quot; tabindex=&quot;-1&quot;&gt;永久加入GOOGLE_APPLICATION_CREDENTIALS變數&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;開啟 /etc/profiles
新增 export GOOGLE_APPLICATION_CREDENTIALS=&amp;quot;/home/user/Downloads/my-key.json&amp;quot;
修改檔案後要想馬上生效還要執行#
source /etc/profile不然只能在下次重進此使用者時生效。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://www.itread01.com/content/1547223515.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux系統環境變數和別名設定（永久生效和臨時生效）&lt;/a&gt;&lt;br /&gt;
附註，json檔案的取得在 IAM角色內的服務賬戶&lt;br /&gt;
ref.&lt;a href=&quot;https://cloud.google.com/iam/docs/creating-managing-service-account-keys&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;創建和管理服務帳號密鑰&lt;/a&gt;。&lt;br /&gt;
新增完GCS，記得把權限給服務賬戶。記得選擇完整權限（Fig. 1)&lt;/p&gt;
&lt;h3 id=&quot;自動掛載&quot; tabindex=&quot;-1&quot;&gt;自動掛載&lt;/h3&gt;
&lt;p&gt;有權限了已後，再來就是自動掛載了。&lt;br /&gt;
到/etc/fstab上，輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;my_bucket /home/ezio/upload gcsfuse key_file=key/key.json,rw,user,allow_other,uid=1008,gid=1009  0 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重開機測試看看，收工。&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://stackoverflow.com/questions/42638048/how-to-use-mount-command-in-fstab-file/42638136#42638136&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to use mount command in fstab file&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://serverfault.com/questions/1021950/gcsfuse-automount-on-a-non-root-user&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcsfuse automount on a non root user&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;查詢目前登入使用者的uid 跟 gid
id $(whoami)

如果要看全部使用者的話，
cat /etc/passwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;a href=&quot;http://linux.vbird.org/linux_basic/0410accountmanager/0410accountmanager-centos5.php#account_id&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux 的帳號與群組&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;在GKE 上面的pod同時掛載 gcs的資料夾&lt;br /&gt;
基本的方式，&lt;br /&gt;
先自己產生一個 image&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;FROM golang:1.14-alpine AS build-env
ENV GO111MODULE on

# WORKDIR /工作名錄名稱 當前的工作目錄名稱，若是不存在則會新建該目錄，
# 需要注意的是copy跟run的指令都是以WORKDIR為當前目錄下去跑的，
# 運用的時候需要注意相對位置。
WORKDIR $GOPATH/src

RUN go get -u github.com/googlecloudplatform/gcsfuse

COPY key.json .


FROM alpine:3.6
RUN apk add --no-cache ca-certificates fuse &amp;amp;&amp;amp; rm -rf /tmp/*
COPY --from=build-env /go/bin/gcsfuse /usr/local/bin
COPY --from=build-env /go/src/key.json /
WORKDIR /
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;佈署 Deployment&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: gcs-fuse
    version: v1
  namespace: debug
  name: gcsfuse-test
spec:
  replicas: 1
  selector:
    matchLabels:
      app: gcs-fuse
      version: v1
  template:
    metadata:
      labels:
        app: gcs-fuse
        version: v1
    spec:
      containers:
        - name: gcsfuse-test
          image: gcr.io/your-project/gcsfuse:v1.2
          # image: golang:1.14-alpine
          # command: [ &amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;--&amp;quot; ]
          # args: [ &amp;quot;while true; do sleep 600; done;&amp;quot; ]
          securityContext:
            privileged: true
          command:
            - &amp;quot;/bin/sh&amp;quot;
            - &amp;quot;-c&amp;quot;
            - &amp;quot;while true; do mkdir /upload ; gcsfuse --key-file=key.json your-bucket /folder; sleep 600; done; &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果跟現有的程式整合的話，&lt;br /&gt;
由於要執行多行指令，需使用shellScript的方式執行指令。&lt;br /&gt;
可能會遇到下列情況&lt;/p&gt;
&lt;h3 id=&quot;and-quot-exec-and-quot-init-sh-and-quot-permission-denied&quot; tabindex=&quot;-1&quot;&gt;&amp;quot;exec: &amp;quot;/init.sh&amp;quot;: permission denied&lt;/h3&gt;
&lt;p&gt;在Dockerfile上修改權限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RUN chmod +x /init.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://stackoverflow.com/questions/44687685/getting-permission-denied-in-docker-run&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;getting permission denied in docker run&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;exec-user-process-caused-and-quot-exec-format-error-and-quot&quot; tabindex=&quot;-1&quot;&gt;exec user process caused &amp;quot;exec format error&amp;quot;&lt;/h3&gt;
&lt;p&gt;有人說在sh的頂端加上&lt;br /&gt;
#!/bin/bash&lt;br /&gt;
但我試了沒用，在猜想可能是alpine linux沒有bash導致&lt;br /&gt;
所以改用下面這個&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ENTRYPOINT [&amp;quot;sh&amp;quot;,&amp;quot;/run.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://stackoverflow.com/questions/42494853/standard-init-linux-go178-exec-user-process-caused-exec-format-error&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;standard_init_linux.go:178: exec user process caused “exec format error”&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;sh-debug&quot; tabindex=&quot;-1&quot;&gt;執行sh時卡住，debug方式&lt;/h3&gt;
&lt;p&gt;用if else檢查&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if mkdir /upload; then
    echo &amp;quot;mkdir directory! Success&amp;quot; 1&amp;gt;&amp;amp;2
    gcsfuse --key-file=key.json yellow-video /upload
else
    echo &amp;quot;Could not mkdir directory!&amp;quot; 1&amp;gt;&amp;amp;2
    exit 1
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，最後找出來原因是因為先執行go的程式，導致後續卡住，所以先建立資料夾後，再執行go&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://www.opencli.com/linux/shell-script-exit-on-error&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Shell Script 遇到錯誤時自動退出離開&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/docs/authentication/getting-started&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;身份驗證入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.itread01.com/content/1547223515.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux系統環境變數和別名設定（永久生效和臨時生效）&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/8.GCS使用方式/" />
        </entry>
        <entry>
            <title>
                79. gcloud compute instance 筆記
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/79. gcloud compute instance 筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;因為公司政策，&lt;br /&gt;
要把label全部統一，之前有些已經命名過一次的但名稱不對，&lt;br /&gt;
一個一個改又好麻煩，&lt;br /&gt;
來寫command吧&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;指令演化順序&lt;/p&gt;
&lt;p&gt;Step 1.&lt;br /&gt;
先用指令撈出 GCE的全部列表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute instances --project=project list --format=&#39;table(name,status,labels.list())&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Step 2.&lt;/p&gt;
&lt;p&gt;找出label只有特定字元的列表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute instances --project=project list --format=&#39;table(name,status,labels.list())&#39; | grep product=abc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/79-fig.1.jpg&quot; alt=&quot;79-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;問題來了，如果我只要取name出來，作爲變數的話，&lt;br /&gt;
要怎麼做？&lt;br /&gt;
我也一下子想不出來，就先跑去看一下gcloud文件了。&lt;/p&gt;
&lt;p&gt;Step 3.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute instances --project=project list --filter=&amp;quot;labels.product:abc&amp;quot; --format=&amp;quot;table(name)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改用 &lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/topic/filters&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;filter&lt;/a&gt;去篩選，這樣就能只顯示名稱了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/79-fig.2.jpg&quot; alt=&quot;79-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Step 4.&lt;br /&gt;
加上for迴圈，將label.product改成 zzz&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for name in $(gcloud compute instances --project=project list --filter=&amp;quot;labels.product:abc&amp;quot; --format=&amp;quot;table(name)&amp;quot;); do
  gcloud compute instances update &amp;quot;$name&amp;quot; --update-labels product=zzz
done 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;附註：&lt;/p&gt;
&lt;p&gt;刪除label的指令&lt;br /&gt;
product 為 key值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute instances update beta-api01 --remove-labels product
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/compute/docs/labeling-resources#gcloud&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用標籤整理資&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud command&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/79. gcloud compute instance 筆記/" />
        </entry>
        <entry>
            <title>
                5. Google Cloud Function限制
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/5. Google Cloud Function限制/</id>
            <content type="html">
                &lt;h2 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;這次要生一個ffmpeg的環境出來，然後找阿找阿，&lt;br /&gt;
找到一篇文章，上面寫&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Google將Cloud Functions作業系統升級到了Ubuntu 18.04 LTS，擴大了可用函式庫的範圍，除了Imagemagick一直都有外，還多了Ffmpeg和Libcairo2系統函式庫，連無頭Chrome也有，使用者不只可以在Cloud Functions中處理影片，甚至還能進行網頁截圖。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref &lt;a href=&quot;https://www.ithome.com.tw/news/125258&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Google事件驅動無伺服器平臺Cloud Functions正式上線了!&lt;/a&gt;&lt;br /&gt;
然後不用架機器，就來看看這條路行不行的通吧&lt;/p&gt;
&lt;h2 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;找了一陣子，先注意到的是GCF的限制&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;timeout 預設1分鐘，最長9分鐘&lt;/li&gt;
&lt;li&gt;單一function可用memory為2G，超過會中斷&lt;br /&gt;
這兩個是我認為比較重要的部分，其他細項，&lt;br /&gt;
可參考&lt;br /&gt;
&lt;a href=&quot;https://firebase.google.com/docs/functions/quotas?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;配額和限制&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://medium.com/%E5%AE%85%E7%94%B7%E9%9B%9C%E5%AD%B8%E7%AD%86%E8%A8%98/%E6%B7%BA%E8%AB%87serverless-solution-%E4%BB%A5gcp-cloud-function%E7%82%BA%E4%BE%8B-6374bf74df98&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;淺談Serverless Solution — 以GCP Cloud Function為例&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;結論，拿來做影片轉檔的話...應該是沒辦法了。除非這影片夠小。&lt;/p&gt;
&lt;p&gt;不然只寫api看來是挺快的&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/5. Google Cloud Function限制/" />
        </entry>
        <entry>
            <title>
                46.列出GCE的所有VM
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/46.列出GCE的所有VM/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;如果要查特定的欄位，可以先列出instances 的結構，&lt;br /&gt;
看一下要什麼樣的資料。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute instances describe gke-xxxxxx-test-n2-8-819a6098-3b3r --zone=asia-east1-b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後就能湊出下面的語法了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute instances list --format=&amp;quot;table(
name,
zone.basename(),
networkInterfaces[].ipv6AccessConfigs[0].externalIpv6.notnull().list():label=EXTERNAL_IPV6,
networkInterfaces[].subnetwork)&amp;quot; | sort -k 5 | grep -E &#39;gateway.*test&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最前面的語法，是要取出子網路的名稱，以便計算該子網路內有幾台VM，&lt;br /&gt;
然後排序、比對 名稱裡面有  gateway而且後面是 test的VM。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://www.opencli.com/linux/grep-or-and-operators&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;grep 指令使用 or 及 and 查兩個條件以上&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/compute/instances/describe&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud compute instances describe&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/compute/instances/list&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud compute instances list&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/46.列出GCE的所有VM/" />
        </entry>
        <entry>
            <title>
                46.GCE機器列表內的CPU個數
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/46.GCE機器列表內的CPU個數/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;要算一下各服務所佔的比例，&lt;br /&gt;
大方向用VM的機器 cpu來算&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;如果用gcloud compute list 能夠列出機器的類型，但裡面的cpu數量還是不知道。&lt;/p&gt;
&lt;p&gt;找了一下發現有人寫好一個shell script，拿來改一下能夠直接列出cpu數量&lt;br /&gt;
跟連結的內容相比，我這邊多加了一個狀態。&lt;br /&gt;
因為有些機器是不開機的，當有任務時，才會開機，故大部分時間都是關機狀態。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Get instance name,zone for `${PROJECT}
for PAIR in $(&#92;
  gcloud compute instances list &#92;
  --project=${PROJECT} &#92;
  --format=&amp;quot;csv[no-heading](name,zone.scope(zones),status)&amp;quot;)
do
  # Parse result from above into instance and zone vars
  IFS=, read INSTANCE ZONE STATUS &amp;lt;&amp;lt;&amp;lt; ${PAIR}
  # Get the machine type value only
  MACHINE_TYPE=$(&#92;
    gcloud compute instances describe ${INSTANCE} &#92;
    --project=${PROJECT} &#92;
    --zone=${ZONE} &#92;
    --format=&amp;quot;value(machineType.scope(machineTypes))&amp;quot;)
  # If it&#39;s custom-${vCPUs}-${RAM} we&#39;ve sufficient info
  if [[ ${MACHINE_TYPE} == custom* ]]
  then
    IFS=- read CUSTOM CPU MEM &amp;lt;&amp;lt;&amp;lt; ${MACHINE_TYPE}
    printf &amp;quot;%s: vCPUs: %s; Mem: %s; Status: %s&#92;n&amp;quot; ${INSTANCE} ${CPU} ${MEM} ${STATUS}
  else
    # Otherwise, we need to call `machine-types describe`
    CPU_MEMORY=$(&#92;
      gcloud compute machine-types describe ${MACHINE_TYPE} &#92;
      --project=${PROJECT} &#92;
      --zone=${ZONE} &#92;
      --format=&amp;quot;csv[no-heading](guestCpus,memoryMb)&amp;quot;)
    IFS=, read CPU MEM &amp;lt;&amp;lt;&amp;lt; ${CPU_MEMORY}
    printf &amp;quot;%s: vCPUs: %s; Mem: %s; Status: %s&#92;n&amp;quot; ${INSTANCE} ${CPU} ${MEM} ${STATUS}
  fi
done


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.  &lt;a href=&quot;https://stackoverflow.com/questions/65888736/gcloud-command-to-display-vcpus-and-memory-assigned-to-instances&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud command to display vCPU&#39;s and Memory assigned to Instances&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/46.GCE機器列表內的CPU個數/" />
        </entry>
        <entry>
            <title>
                19. GCE硬碟增加容量大小
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/19. GCE硬碟增加容量大小/</id>
            <content type="html">
                &lt;h2 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;之前有加大過GCE的CPU跟ram，但怎麼加硬碟空間還真的不知道。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;先到GCE，開啟機器。選擇開機磁碟（可在開機的狀態下運作）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/19.fig-1.jpg&quot; alt=&quot;19.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;按下編輯，修改硬碟大小，儲存。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/19.fig-2.jpg&quot; alt=&quot;19.fig-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;
&lt;p&gt;重新整理畫面，會看到硬碟空間容量變了。但還沒完成，需要到機器裡面重新調整大小。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;lsblk 列出可用設備&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lsblk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINT&lt;br /&gt;
sda      8:0    0  35G  0 disk&lt;br /&gt;
└─sda1   8:1    0  30G  0 part /&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NAME：這是塊設備名。&lt;/li&gt;
&lt;li&gt;MAJ:MIN：本欄顯示主要和次要設備號。&lt;/li&gt;
&lt;li&gt;RM：本欄顯示設備是否可移動設備。注意，在設備sdb和sr0的RM值等於1，這說明他們是可移動設備。&lt;/li&gt;
&lt;li&gt;SIZE：本欄列出設備的容量大小信息。例如35G表明該設備大小為35GB，而1K表明該設備大小為1KB。&lt;/li&gt;
&lt;li&gt;RO：該項表明設備是否為只讀。在本案例中，所有設備的RO值為0，表明他們不是只讀的。&lt;/li&gt;
&lt;li&gt;TYPE：本欄顯示塊設備是否是磁盤或磁盤上的一個分區。在本例中，sda和sdb是磁盤，而sr0是只讀存儲（rom）。&lt;/li&gt;
&lt;li&gt;MOUNTPOINT：本欄指出設備掛載的掛載點。&lt;br /&gt;
ref. &lt;a href=&quot;https://man.linuxde.net/lsblk&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;lsblk命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;growpart 將全部多餘的空間給指定的分割區&lt;br /&gt;
extend  a partition	in a partition table to	fill available space&lt;br /&gt;
ubuntu 安裝方式：&lt;br /&gt;
&lt;code&gt;apt -y install cloud-guest-growpart&lt;/code&gt;&lt;br /&gt;
CentOS 安裝方式：&lt;br /&gt;
&lt;code&gt;yum -y install cloud-utils-growpart&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  growpart /dev/sda 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊的dev/sda 指的是disk,故sda與 1 中間有空格&lt;br /&gt;
ref. &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=growpart&amp;amp;manpath=Debian+8.1.0&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;growpart&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;p.s 如果出現 錯誤&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FAILED: sfdisk not found
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;請使用sudo growpart /dev/sda 1 的方式執行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;resize2fs 調整系統大小&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  resize2fs /dev/sda1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊的dev/sda1 指的是part ,故sda與 1 中間沒有空格&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.itread01.com/content/1541634723.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux基礎命令---resize2fs&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;df 檢查分割區大小&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;df -h
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;http://genesic.blogspot.com/2018/01/gcp.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcp 增加硬碟容量&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.timelog.to/a159164305&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;不關機、不拔硬碟擴充VM root 磁碟區 - growpart&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://docs.aws.amazon.com/zh_tw/AWSEC2/latest/UserGuide/recognize-expanded-volume-linux.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;調整磁碟區大小後擴展 Linux 檔案系統&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.skywebster.com/resize-ext-and-xfs-root-partition-without-lvm/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux 擴展ext2/3/4 xfs root分割區不用LVM&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果使用resize2fs 碰到錯誤訊息&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;resize2fs 1.45.6 (20-Mar-2020)&lt;br /&gt;
resize2fs: Bad magic number in super-block while trying to open /dev/sda2&lt;br /&gt;
Couldn&#39;t find valid filesystem superblock.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;表示你使用的可能是xfs系統，來查一下&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	mount 	
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/19.fig-3.jpg&quot; alt=&quot;19.fig-3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以必須改用下面指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xfs_growfs /dev/sda2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://blog.90.vc/archives/164&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;# xfs檔案系統擴容報resize2fs: Bad magic number in super-block while trying to open /dev/centos/root Couldn’t find valid filesystem superblock&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/19. GCE硬碟增加容量大小/" />
        </entry>
        <entry>
            <title>
                181. cloudstorage無法使用cloudflare轉址
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/181. cloudstorage無法使用cloudflare轉址/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;線上的圖片是使用GCP的Load balancer連到Google cloud storage，&lt;br /&gt;
之前測試沒問題，但後來 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/186.%20istio%E7%9A%84Authorization%20policy(%E7%99%BD%E5%90%8D%E5%96%AE)/#cloudflare&quot;&gt;186. istio的Authorization policy(白名單)#cloudflare轉發&lt;/a&gt; ，&lt;br /&gt;
client到origin server 都使用ssl連線後，就掛了，&lt;br /&gt;
因為Load balancer當初沒有設定SSL的憑證，導致無法連線。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;到GCP的憑證管理器，新增憑證。&lt;br /&gt;
一開始是沒有啓用的，必須先啓用&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/181-fig.2.jpg&quot; alt=&quot;181-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/181-fig.1.jpg&quot; alt=&quot;181-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;建立新憑證，不支援萬用字元&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/181-fig.3.jpg&quot; alt=&quot;181-fig.3.jpg&quot; /&gt;&lt;br /&gt;
這邊注意，建立完後，&lt;br /&gt;
可能需要等一陣子(幾小時）才會好，&lt;br /&gt;
建立完後一定要到LB綁定，呈現有使用者的狀態。&lt;br /&gt;
當好的時候，會看到狀態為『有效』。&lt;/p&gt;
&lt;p&gt;此時，再到Load Balancer那邊設定憑證，開啓https的入口即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/181-fig.4.jpg&quot; alt=&quot;181-fig.4.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;前面步驟，參考 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/140.%20gcs%20%E6%8E%9B%E8%BC%89domain/&quot;&gt;140. gcs 掛載domain&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/181. cloudstorage無法使用cloudflare轉址/" />
        </entry>
        <entry>
            <title>
                17. Gcloud AttributeError module importlib has no attribute util
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/17. Gcloud AttributeError module importlib has no attribute util/</id>
            <content type="html">
                &lt;h2 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/16.dustise%20sleep%20%E6%B8%AC%E8%A9%A6%E5%B7%A5%E5%85%B7%E7%B0%A1%E4%BB%8B/&quot;&gt;16.dustise sleep 測試工具簡介&lt;/a&gt; 上一篇，有講到httpie這個套件，簡單使用，我就直接在mac上裝了。&lt;br /&gt;
然後，gcloud,kubectl就掛了...&lt;/p&gt;
&lt;h2 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;錯誤碼是這樣，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  AttributeError: module &#39;importlib&#39; has no attribute &#39;util&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;後來一查，發現是kubectl 跟 python 3.9 的問題&lt;a href=&quot;https://github.com/kubernetes/kubectl/issues/970&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;AttributeError: module &#39;importlib&#39; has no attribute &#39;util&#39; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#970&quot;&gt;#970&lt;/a&gt;&lt;/a&gt;&lt;br /&gt;
本來是想直接升級kubectl就好&lt;a href=&quot;https://kubernetes.io/zh/docs/tasks/tools/install-kubectl/#install-with-homebrew-on-macos&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;在 macOS 上使用 Homebrew 安裝&lt;/a&gt;，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  brew upgrade kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;雖然升級完成了，&lt;br /&gt;
但查詢版本&lt;br /&gt;
kubectl version --client&lt;br /&gt;
出來的版本仍是舊的。&lt;/p&gt;
&lt;p&gt;後來才想到，我的kubectl 好像是跟gcloud 一起裝的，試了一下，連gcloud也是同樣的錯誤。&lt;br /&gt;
那就來升級gcloud吧。但只要輸入 gcloud components update 也是出現同樣的錯誤，那要怎麼升級...&lt;br /&gt;
所以，根據&lt;a href=&quot;https://stackoverflow.com/questions/64010263/attributeerror-module-importlib-has-no-attribute-util&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;這篇&lt;/a&gt;  先在terminal上面輸入，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export CLOUDSDK_PYTHON=python2   # 先指定使用其他python版本
gcloud components update          # 更新gcloud
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成。&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/17. Gcloud AttributeError module importlib has no attribute util/" />
        </entry>
        <entry>
            <title>
                164.gcloud install by bash
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/164.gcloud install by bash/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;因爲『懶』，所以要來搞個一個sh就能安裝完所有東西。&lt;br /&gt;
但在install gcloud就踩坑了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.google.com/sdk/docs/install-sdk?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;官方文件&lt;/a&gt;，這邊提到正常的安裝方式，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./google-cloud-sdk/install.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但這個是建立在人要在電腦前面輸入Y，於是改成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./google-cloud-sdk/install.sh --command-completion=true --path-update=true --quiet
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這樣才會在.bashrc 增加執行的參數。&lt;/p&gt;
&lt;p&gt;一開始沒有想到是沒有增加 .bashrc的關係，&lt;br /&gt;
只有一直出現找不到gcloud的錯誤，&lt;br /&gt;
最後確認&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/163.Shell%E7%9A%84%E5%8D%80%E5%88%A5%E5%8F%8A%E6%9F%A5%E8%A9%A2/&quot;&gt;163.Shell的區別及查詢&lt;/a&gt;的關係後，&lt;br /&gt;
才釐清是.bashrc沒加，&lt;br /&gt;
於是利用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./google-cloud-sdk/install.sh --help
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查詢有哪些參數可供使用。&lt;/p&gt;
&lt;h2 id=&quot;shell-script&quot; tabindex=&quot;-1&quot;&gt;完整shell script&lt;/h2&gt;
&lt;p&gt;完整install.sh如下，需使用root執行，不然在安裝gcloud會出錯，&lt;br /&gt;
update-cert.sh是另一個shell script，是用gsutil拿來抓gcs的資料用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl -O https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-cli-443.0.0-linux-x86_64.tar.gz
tar -xf google-cloud-cli-443.0.0-linux-x86_64.tar.gz
./google-cloud-sdk/install.sh --command-completion=true --path-update=true --quiet
source ~/.bashrc

gcloud auth activate-service-account view-bucket@project.iam.gserviceaccount.com --key-file=view-bucket.json

SCRIPTPATH=$(dirname &amp;quot;$(readlink -f $0)&amp;quot;)
chmod u+x update-cert.sh

echo &amp;quot;30 1 * * 1 root /bin/bash ${SCRIPTPATH}/update-cert.sh&amp;quot; &amp;gt;&amp;gt; /etc/crontab
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/31037279/gcloud-command-not-found-while-installing-google-cloud-sdk&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud command not found - while installing Google Cloud SDK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sdk/docs/install-sdk&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;install Google Cloud CLI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://andy6804tw.github.io/2020/07/21/linux-shell-script/#%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%B3%95&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [Shell Script] 執行sh檔案提示Permission denied&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://linux.vbird.org/linux_basic/centos7/0430cron.php&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;第十五章、例行性工作排程(crontab)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/164.gcloud install by bash/" />
        </entry>
        <entry>
            <title>
                161. GKE利用pubsub通知訊息到discord
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/161. GKE利用pubsub通知訊息到discord/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;本來以爲不需要，但GKE有時就會幫你升級master的版本，&lt;br /&gt;
神不知鬼不覺，就算用靜態版本也是。&lt;br /&gt;
雖然是不會影響到線上服務，&lt;br /&gt;
但還是最好知道一下是什麼時候升級的。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pub/Sub建立一個主題&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/161-fig.1.jpg&quot; alt=&quot;161-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GKE的叢集設定開啓通知，並選擇剛剛建立的主題&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/161-fig.2.jpg&quot; alt=&quot;161-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立Cloud Function&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/161-fig.3.jpg&quot; alt=&quot;161-fig.3.jpg&quot; /&gt;&lt;br /&gt;
環境選『第二代』，函式名稱自己命名。&lt;br /&gt;
觸發條件，『允許未經驗證的叫用』，再選擇 ADD TRIGER裏面的『Pub/Sub trigger』&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/161-fig.4.jpg&quot; alt=&quot;161-fig.4.jpg&quot; /&gt;&lt;br /&gt;
選擇剛剛建立的Pub/Sub主題&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/161-fig.5.jpg&quot; alt=&quot;161-fig.5.jpg&quot; /&gt;&lt;br /&gt;
在連線的地方，可選擇僅允許內部流量即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立程式碼&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/161-fig.6.jpg&quot; alt=&quot;161-fig.6.jpg&quot; /&gt;&lt;br /&gt;
選擇Go 1.20 ，進入點改成 sendDiscord&lt;br /&gt;
原始碼到&lt;a href=&quot;https://github.com/daimom/pubsub_notify&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;pubsub notify&lt;/a&gt;複製 function.go的程式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測試&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/161-fig.7.jpg&quot; alt=&quot;161-fig.7.jpg&quot; /&gt;&lt;br /&gt;
觸發GKE的升級後，就會發送訊息到Discord上面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;相關資訊&quot; tabindex=&quot;-1&quot;&gt;相關資訊&lt;/h2&gt;
&lt;h3 id=&quot;pub-sub&quot; tabindex=&quot;-1&quot;&gt;Pub/Sub價格&lt;/h3&gt;
&lt;p&gt;在每個日曆月，結算帳號的 &lt;strong&gt;Message Delivery Basic&lt;/strong&gt; SKU 的前 10 GiB 吞吐量免費&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/pubsub/pricing?hl=zh-cn#pubsub-pricing&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Pub/Sub 價格&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;pub-sub-1&quot; tabindex=&quot;-1&quot;&gt;Pub/Sub架構&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/161-fig.8.jpg&quot; alt=&quot;161-fig.8.jpg&quot; /&gt;&lt;br /&gt;
ref. &lt;a href=&quot;https://cloud.google.com/pubsub/docs/overview?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;什麼是 Pub/Sub？&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;the-request-was-not-authenticated&quot; tabindex=&quot;-1&quot;&gt;The request was not authenticated.&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The request was not authenticated. Either allow unauthenticated invocations or set the proper Authorization header. Read more at &lt;a href=&quot;https://cloud.google.com/run/docs/securing/authenticating&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://cloud.google.com/run/docs/securing/authenticating&lt;/a&gt; Additional troubleshooting documentation can be found at: &lt;a href=&quot;https://cloud.google.com/run/docs/troubleshooting#unauthorized-client&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://cloud.google.com/run/docs/troubleshooting#unauthorized-client&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果沒在 第三步驟，選擇『允許未經驗證的叫用』，事後需改到cloud run修改安全性。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/161-fig.9.jpg&quot; alt=&quot;161-fig.9.jpg&quot; /&gt;&lt;br /&gt;
從cloud function的連結到cloud run&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/161-fig.10.jpg&quot; alt=&quot;161-fig.10.jpg&quot; /&gt;&lt;br /&gt;
到安全性，將驗證改成『允許未經驗證的叫用』。&lt;br /&gt;
如果你仍然想要用需要驗證，&lt;br /&gt;
可能需要研究下，目前只允許內部流量調用。&lt;/p&gt;
&lt;h3 id=&quot;message-published-data&quot; tabindex=&quot;-1&quot;&gt;MessagePublishedData&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.google.com/eventarc/docs/cloudevents?hl=zh-cn#pubsub_1&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;pub/sub 事件的組成部分&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &amp;quot;subscription&amp;quot;: &amp;quot;projects/test-project/subscriptions/my-subscription&amp;quot;,
  &amp;quot;message&amp;quot;: {
    &amp;quot;attributes&amp;quot;: {
      &amp;quot;attr1&amp;quot;:&amp;quot;attr1-value&amp;quot;
    },
    &amp;quot;data&amp;quot;: &amp;quot;dGVzdCBtZXNzYWdlIDM=&amp;quot;,
    &amp;quot;messageId&amp;quot;: &amp;quot;message-id&amp;quot;,
    &amp;quot;publishTime&amp;quot;:&amp;quot;2021-02-05T04:06:14.109Z&amp;quot;,
    &amp;quot;orderingKey&amp;quot;: &amp;quot;ordering-key&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/161. GKE利用pubsub通知訊息到discord/" />
        </entry>
        <entry>
            <title>
                142.gcs cors設定
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/142.gcs cors設定/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;架構從本來的 NFS全部轉到GCS上了，&lt;br /&gt;
所以cors也要跟着設定&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;將下面檔案，存成json&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;[
    {
      &amp;quot;origin&amp;quot;: [&amp;quot;https://tester.abc.com/&amp;quot;],
      &amp;quot;method&amp;quot;: [&amp;quot;GET&amp;quot;,&amp;quot;PUT&amp;quot;,&amp;quot;POST&amp;quot;,&amp;quot;OPTIONS&amp;quot;,&amp;quot;DELETE&amp;quot;,&amp;quot;PATCH&amp;quot;],
      &amp;quot;responseHeader&amp;quot;: [&amp;quot;Content-Type&amp;quot;, &amp;quot;DNT&amp;quot;,&amp;quot;X-CustomHeader&amp;quot;,&amp;quot;X-LANG,Keep-Alive&amp;quot;,&amp;quot;User-Agent&amp;quot;,&amp;quot;X-Requested-With&amp;quot;,&amp;quot;If-Modified-Since,Cache-Control&amp;quot;,&amp;quot;X-Api-Key,X-Device-Id&amp;quot;,&amp;quot;Access-Control-Allow-Origin&amp;quot;],
      &amp;quot;maxAgeSeconds&amp;quot;: 3600
    }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行，收工。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gsutil cors set example_cors_file.json gs://example_bucket
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感覺我好像再騙文章。&lt;/p&gt;
&lt;p&gt;補充，origin不能用 * 的萬用符號，之前測了沒有效果 ，&lt;br /&gt;
未來會不會改不清楚。&lt;/p&gt;
&lt;p&gt;查看bucket有沒有設定cors則用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gsutil cors get gs://example_bucket
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/142-fig.1.jpg&quot; alt=&quot;142-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果要用gcloud/api，請看下面連結&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/storage/docs/using-cors?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;設定和查看 CORS 組態&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/142.gcs cors設定/" />
        </entry>
        <entry>
            <title>
                141. gcs自動刪除檔案
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/141. gcs自動刪除檔案/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;本篇的目標，測試用的bucket，每隔一段時間就刪除檔案。&lt;br /&gt;
或是轉到更便宜的bucket。&lt;br /&gt;
先說個概念，一個bucket裏面，他的檔案類型可以是不一樣的。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;上面那句話不懂的話，直接看圖吧。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/141-fig.1.jpg&quot; alt=&quot;141-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;由於每個儲存類型的價格不一樣，量大的話還是能省不少錢。&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/Price/126.%20GCP%20%E7%A1%AC%E7%A2%9F%E8%B2%BB%E7%94%A8%E6%AF%94%E8%BC%83/&quot;&gt;126. GCP 硬碟費用比較&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到bucket裏面選擇 『生命週期』-&amp;gt;新增規則&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/141-fig.2.jpg&quot; alt=&quot;141-fig.2.jpg&quot; /&gt;&lt;br /&gt;
動作看要選擇哪一種&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/141-fig.3.jpg&quot; alt=&quot;141-fig.3.jpg&quot; /&gt;&lt;br /&gt;
選擇條件&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/141-fig.4.jpg&quot; alt=&quot;141-fig.4.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;要注意的地方是，設定完不是馬上生效，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;對儲存桶生命週期組態的更改可能需要長達 24 小時才能生效，在此期間，對象生命週期管理可能仍會根據舊組態執行操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;設定完後，再來就是等待他執行了。&lt;/p&gt;
&lt;p&gt;另外，如果有多個規則的話，&lt;br /&gt;
目前GCP的優先順序為&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果多個規則同時滿足單個對象的條件，則 Cloud Storage 將基於以下考慮，僅執行與其中一個規則關聯的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Delete&lt;/code&gt; 操作優先於任何 &lt;code&gt;SetStorageClass&lt;/code&gt; 操作。&lt;/li&gt;
&lt;li&gt;將對象切換至&lt;a href=&quot;https://cloud.google.com/storage/pricing?hl=zh-cn#storage-pricing&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;靜態儲存價格&lt;/a&gt;最低的儲存類別的 &lt;code&gt;SetStorageClass&lt;/code&gt; 操作優先。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;p.s 如果你也跑去chtGPT提問的話，可能也會碰到我這個答案，但目前看起來GCS沒有標記這個東西了。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/141-fig.5.jpg&quot; alt=&quot;141-fig.5.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/storage/docs/lifecycle?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;對象生命週期管理&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/141. gcs自動刪除檔案/" />
        </entry>
        <entry>
            <title>
                140. gcs 掛載domain
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/140. gcs 掛載domain/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;這篇文章要完成得部分有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立LB，連結到GCS&lt;/li&gt;
&lt;li&gt;設定cloud Armor白名單&lt;/li&gt;
&lt;li&gt;Certificate Manager 增加 ssl憑證&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h2 id=&quot;建立負載平衡&quot; tabindex=&quot;-1&quot;&gt;建立負載平衡&lt;/h2&gt;
&lt;p&gt;建立負載平衡 -&amp;gt; HTTP(S) 負載平衡&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/140-fig.1.jpg&quot; alt=&quot;140-fig.1.jpg&quot; /&gt;&lt;br /&gt;
不能用區域的，因為區域的不支援後端值區&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/140-fig.2.jpg&quot; alt=&quot;140-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;h5 id=&quot;前端設定&quot; tabindex=&quot;-1&quot;&gt;前端設定&lt;/h5&gt;
&lt;p&gt;這邊建議最好就直接建立一個ip，不要用臨時的。&lt;br /&gt;
如果通訊協定要用https，需要設定憑證，所以這邊先選擇http就好&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/140-fig.3.jpg&quot; alt=&quot;140-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;h5 id=&quot;後端設定&quot; tabindex=&quot;-1&quot;&gt;後端設定&lt;/h5&gt;
&lt;p&gt;建立值區&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/140-fig.4.jpg&quot; alt=&quot;140-fig.4.jpg&quot; /&gt;&lt;br /&gt;
第一個箭頭，選擇你要建立的值區&lt;br /&gt;
第二個箭頭，看要不要建CDN&lt;br /&gt;
第三個箭頭，是設定白名單(cloud Armor)用的，這邊先不設定，等等第二部分會說&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/140-fig.5.jpg&quot; alt=&quot;140-fig.5.jpg&quot; /&gt;&lt;/p&gt;
&lt;h5 id=&quot;主機與路徑規則&quot; tabindex=&quot;-1&quot;&gt;主機與路徑規則&lt;/h5&gt;
&lt;p&gt;預設會直接進入bucket，這邊要注意，記得要將bucket 設定為公開。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/140-fig.6.jpg&quot; alt=&quot;140-fig.6.jpg&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;cloud-armor&quot; tabindex=&quot;-1&quot;&gt;設定cloud Armor&lt;/h2&gt;
&lt;p&gt;上一部份有說到設定白名單(cloud Armor)&lt;/p&gt;
&lt;p&gt;網路安全性-&amp;gt; Cloud Armor&lt;br /&gt;
這邊要增加的設定是 Edge 安全性政策，不是後端安全性政策，&lt;br /&gt;
因為只有edge安全性政策支援後端儲存分區&lt;br /&gt;
ref. &lt;a href=&quot;https://cloud.google.com/armor/docs/security-policy-overview?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;安全政策的類型&lt;/a&gt;。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/140-fig.8.jpg&quot; alt=&quot;140-fig.8.jpg&quot; /&gt;&lt;br /&gt;
新增的時候，選擇 Edge安全性政策，如果沒看到這個選項，&lt;br /&gt;
你可能已經進到政策裏面的規則了。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/140-fig.9.jpg&quot; alt=&quot;140-fig.9.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;建立完成後，可以從目標去新增要新增的對象，或是到負載平衡那邊做修改。&lt;/p&gt;
&lt;h5 id=&quot;cloud-armor-1&quot; tabindex=&quot;-1&quot;&gt;cloud armor 目標新增&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/140-fig.10.jpg&quot; alt=&quot;140-fig.10.jpg&quot; /&gt;&lt;br /&gt;
選擇『負載平衡器後端值區』，再選擇你的bucket&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/140-fig.11.jpg&quot; alt=&quot;140-fig.11.jpg&quot; /&gt;&lt;/p&gt;
&lt;h5 id=&quot;負載平衡器修改&quot; tabindex=&quot;-1&quot;&gt;負載平衡器修改&lt;/h5&gt;
&lt;p&gt;後端設定 -&amp;gt; 修改&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/140-fig.12.jpg&quot; alt=&quot;140-fig.12.jpg&quot; /&gt;&lt;br /&gt;
箭頭處選擇剛剛新增的 cloud armor規則&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/140-fig.13.jpg&quot; alt=&quot;140-fig.13.jpg&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;certificate-manager&quot; tabindex=&quot;-1&quot;&gt;Certificate Manager 新增憑證&lt;/h2&gt;
&lt;p&gt;ssl憑證，在GCP上面是可以直接幫你管理的。&lt;br /&gt;
雖然不支援 Wildcard SSL Certificate&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/140-fig.14.jpg&quot; alt=&quot;140-fig.14.jpg&quot; /&gt;&lt;br /&gt;
憑證分成自己管理與google代管，&lt;br /&gt;
自己管理，時間到就要自己上傳新的憑證。&lt;br /&gt;
google管理，不用管，時間到會自己展延，前提是你必須要有該domain。&lt;br /&gt;
選擇google代管的憑證，輸入要管理的domain&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/140-fig.15.jpg&quot; alt=&quot;140-fig.15.jpg&quot; /&gt;&lt;br /&gt;
儲存後，回到畫面應該會看到正在佈建中(PROVISIONING)，&lt;br /&gt;
這個需要一點時間，最久可能要到60 分&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/140-fig.16.jpg&quot; alt=&quot;140-fig.16.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然後到dns伺服器上面綁定domain跟ip了，&lt;br /&gt;
我是使用cloudflare，就不截圖了。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/load-balancing/docs/ssl-certificates/google-managed-certs?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 Google 管理的 SSL 證書&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;設定好了以後，回到負載平衡的前端設定&lt;br /&gt;
第一個箭頭，可以選擇跟上面一樣的ip（但你必須先幫他建立）&lt;br /&gt;
第二個箭頭，選擇剛剛新增的ssl憑證，記得一定要新增，&lt;br /&gt;
不然我卡了三個多小時還沒部署完。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/140-fig.17.jpg&quot; alt=&quot;140-fig.17.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/certificate-manager/docs/deploy?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;部署概覽&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;綜合設定&quot; tabindex=&quot;-1&quot;&gt;綜合設定&lt;/h2&gt;
&lt;p&gt;假設有一個情境是希望domain後面一定要有files才能看圖的話，&lt;br /&gt;
需要用到『進階型主機與路徑規則(第一個箭頭)』&lt;br /&gt;
第二個箭頭設定domain&lt;br /&gt;
第三個箭頭新增新的路徑規則&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/140-fig.7.jpg&quot; alt=&quot;140-fig.7.jpg&quot; /&gt;&lt;br /&gt;
路徑前置字串重新編寫，將/files轉成 / 訪問bucket&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/140-fig.18.jpg&quot; alt=&quot;140-fig.18.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;另外要注意，由於每個規則都有一條預設的條件，&lt;br /&gt;
『任何不相符合的項目』，這個可以選擇要不要導轉到其他網站。&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/140. gcs 掛載domain/" />
        </entry>
        <entry>
            <title>
                135. gsutil整批複製
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/135. gsutil整批複製/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;幫後端改圖片上傳的架構，直接把GCE(Google Compute Engine)的機器改成用GCS（GoogleCloudStorage），所以要把GCE的圖搬到GCS。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;首先要用到的是 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/135.%20gsutil%E6%95%B4%E6%89%B9%E8%A4%87%E8%A3%BD/&quot;&gt;關閉ssh連線後，仍可執行程式&lt;/a&gt; ，不然用gcloud 連線時間過久是會被切斷連線的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;1&quot; tabindex=&quot;-1&quot;&gt;情境 1  整批資料夾&lt;/h3&gt;
&lt;p&gt;將nfs資料夾裏面的所有檔案/資料夾複製到bucket裏面，&lt;br /&gt;
-m 是多工，-r 是複製底下資料夾的檔案&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gsutil  -m rsync -r nfs gs://systemfile-stage/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/storage/docs/gsutil/commands/rsync&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gsutil rsync &lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2&quot; tabindex=&quot;-1&quot;&gt;情境2 ，複製特定資料夾&lt;/h3&gt;
&lt;p&gt;需要先建立一個文字檔，將資料夾名稱寫入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rsync.txt

20220201
20220301
20220310
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;while read p;
do
  folder=$(echo &amp;quot;$p&amp;quot;);
  gsutil rsync -r nfs/$p gs://systemfile-stage/$p/
done &amp;lt; rsync.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;3&quot; tabindex=&quot;-1&quot;&gt;情境3，複製特定圖片&lt;/h3&gt;
&lt;p&gt;這邊只能根據你的來源隨機應變了，&lt;br /&gt;
我的文件格式為&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keepfile.csv

&amp;quot;files/20230217/104abc69-e612-4b6c-abe4-52b91b79562f.jpg&amp;quot;,&amp;quot;17/2/2023 19:27:46.79&amp;quot;
&amp;quot;files/20230217/7a30d9eb-5e7c-4eb8-93c9-a72e5bd74f78.jpg&amp;quot;,&amp;quot;17/2/2023 19:28:47.56&amp;quot;
&amp;quot;files/20230217/ea81d738-ff0c-416a-b6d9-3520fda8f0ed.jpg&amp;quot;,&amp;quot;17/2/2023 19:32:47.44&amp;quot;
&amp;quot;files/20230217/7a7e1c75-4bec-4831-9a58-fa9650a82df1.jpg&amp;quot;,&amp;quot;17/2/2023 19:33:24.94&amp;quot;
&amp;quot;files/20230217/cf495ecb-71a9-4d46-95f4-b051f260523a.jpg&amp;quot;,&amp;quot;17/2/2023 19:33:49.4&amp;quot;
&amp;quot;files/20230217/eb05163b-bc0f-4e3b-96d5-82b0bb4f3a8d.jpg&amp;quot;,&amp;quot;17/2/2023 19:34:41.463&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以，要改讀csv的格式，然後將路徑與檔案名稱拆開，&lt;br /&gt;
最後才複製圖片過去。但這個過成真的久，&lt;br /&gt;
如果可以最好是用rsync複製資料夾吧。&lt;/p&gt;
&lt;p&gt;$file的變數，拆解出來有&amp;quot; ，所以又用了&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/133.%20shell%20script%E5%AD%97%E4%B8%B2%E8%99%95%E7%90%86/&quot;&gt;133. shell script字串處理&lt;/a&gt;的方式，將&amp;quot;刪除。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while IFS=&amp;quot;,&amp;quot; read -r path date
do
  folder=$(echo &amp;quot;$path&amp;quot; | awk -F &#39;/&#39; &#39;{print $2}&#39;);
  file=$(echo &amp;quot;$path&amp;quot; | awk -F &#39;/&#39; &#39;{print $3}&#39;);
  gsutil cp -n nfs/$folder/${file%*&#92;&amp;quot;} gs://systemfile-stage/$folder/
done &amp;lt; keepfile-sort.csv
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.baeldung.com/linux/csv-parsing&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to Parse a CSV File in Bash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/storage/docs/gsutil/commands/cp&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gsutil cp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/135. gsutil整批複製/" />
        </entry>
        <entry>
            <title>
                130. Google IAP ssh失敗
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/130. Google IAP ssh失敗/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;為什麼會發生，俺不知道。&lt;br /&gt;
但好像是好之前硬碟空間不夠，我砍了資料夾的關係...&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;先看個錯誤訊息&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/130-fig.1.jpg&quot; alt=&quot;130-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;權限授權失敗，一般使用ssh連線的話，大部分都是server的ssh key出問題&lt;br /&gt;
可以先參考&lt;a href=&quot;https://medium.com/%E4%B8%80%E5%80%8B%E5%B0%8F%E5%B0%8F%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E9%9A%A8%E6%89%8B%E7%AD%86%E8%A8%98/gcp-%E9%81%87%E5%88%B0permission-denied-publickey-%E6%80%8E%E9%BA%BC%E8%BE%A6-e41e26ebdf47&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [GCP]遇到permission denied (publickey)怎麼辦？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以我才回想起，之前我好像去砍過資料夾。&lt;br /&gt;
所以先弄ssh能夠直連GCE的機器，再來細看裏面的狀況。&lt;/p&gt;
&lt;h3 id=&quot;ssh&quot; tabindex=&quot;-1&quot;&gt;SSH解法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;建立ssh key&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -C &amp;quot;ezio&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊使用ezio當作名稱&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;複製 public key&lt;br /&gt;
將 &lt;code&gt;~/.ssh/id_rsa.pub&lt;/code&gt;的內容複製&lt;br /&gt;
有 .pub的是公鑰  ，沒有的是 私鑰&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;貼上公鑰&lt;br /&gt;
到GCE的VM執行個體內，將剛剛取得的公鑰貼到 『安全殼層金鑰』&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/130-fig.2.jpg&quot; alt=&quot;130-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接用ssh連線&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	ssh ezio@32.12.32.12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般到這邊就結束了，但今天的主題是用IAP無法登入。&lt;br /&gt;
更詳細的ssh 用法，請參考下列網址&lt;br /&gt;
ref.&lt;br /&gt;
- &lt;a href=&quot;https://dotblogs.com.tw/as15774/2018/04/30/174737&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;### [Git] 多個SSH Key與帳號的設定(Mac) &lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://xenby.com/b/220-%E6%95%99%E5%AD%B8-%E7%94%A2%E7%94%9Fssh-key%E4%B8%A6%E4%B8%94%E9%80%8F%E9%81%8Ekey%E9%80%B2%E8%A1%8C%E5%85%8D%E5%AF%86%E7%A2%BC%E7%99%BB%E5%85%A5&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [教學] 產生SSH Key並且透過KEY進行免密碼登入&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;iap&quot; tabindex=&quot;-1&quot;&gt;IAP解法&lt;/h3&gt;
&lt;p&gt;能連進去了，終於確定裏面沒有我之前的資料夾。&lt;br /&gt;
所以應該是這樣導致無法登入？&lt;/p&gt;
&lt;p&gt;然後查了一下目前的使用者帳號&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat /etc/passwd | awk -F: &#39;{print $1}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有我mail的使用者帳號，&lt;br /&gt;
然後刪除！！！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;userdel -r daimom
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再來試試，用IAP登入，看能不能在VM上面重建一個使用者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute ssh --tunnel-through-iap  --project sms --zone asia-east1-b test-service01
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;還是同樣的權限失敗。&lt;/p&gt;
&lt;p&gt;最後，在GCE的設定畫面，將本來的安全殼層金鑰刪掉，強迫重建，&lt;br /&gt;
終於能連了&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/130-fig.3.jpg&quot; alt=&quot;130-fig.3.jpg&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/130. Google IAP ssh失敗/" />
        </entry>
        <entry>
            <title>
                13.騰訊雲連接GOOGLE雲
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/13.騰訊雲連接GOOGLE雲/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;又在搞新的東西了，這次要把騰訊雲（TKE）跟Google雲（GCP），做VPN對連，&lt;br /&gt;
這次一樣又弄了幾天....最後還是找了GOOGLE工程師協助。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;下面的步驟，基本上都是TKE跟GCP，互相切換設定。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;騰訊雲設定網關IP&lt;br /&gt;
私有網路-&amp;gt; VPN連接-&amp;gt;VPN網關&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;!&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.vercel.app/404&quot;&gt;13.fig-1.jpg&lt;/a&gt;&lt;br /&gt;
內容就照想輸入的打，輸入完成後會看到公網IP，為了方便溝通，就稱呼他為TKE的閘道IP。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;GCP設定VPN閘道&lt;br /&gt;
這邊的選項比較繁瑣，因為騰訊雲不支援IKEv2，同時也不支援BGP的協定，&lt;br /&gt;
所以Google要使用傳統VPN。&lt;br /&gt;
高可用性的VPN有些要求才能使用，請參考&lt;a href=&quot;https://cloud.google.com/network-connectivity/docs/vpn/how-to/moving-to-ha-vpn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;轉為高可用性 VPN&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/13.fig-2.jpg&quot; alt=&quot;13.fig-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/13.fig-2.jpg&quot; alt=&quot;13.fig-2.jpg&quot; /&gt;&lt;br /&gt;
從Fig.3 有連結可以切到 傳統VPN設定，&lt;br /&gt;
再來終於要開始設定GCP閘道IP了。&lt;br /&gt;
建立IP，這邊建立的就是GCP的閘道ip，這組就是要與 TKE的閘道IP 對聯的IP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/13.%20fig-4.jpg&quot; alt=&quot;13. fig-4.jpg&quot; /&gt;&lt;br /&gt;
其他的選項，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名稱： 自填&lt;/li&gt;
&lt;li&gt;網路： VPN 要連結的 Compute Engine 網路&lt;/li&gt;
&lt;li&gt;區域： 連結至 Compute Engine 網路的閘道所在地區&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;GCP的通道設定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/13.%20fig-5.jpg&quot; alt=&quot;13. fig-5.jpg&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名稱： 隨意&lt;/li&gt;
&lt;li&gt;遠端對等互連IP： TKE的閘道IP&lt;/li&gt;
&lt;li&gt;IKE版本：這邊選 IKEv1&lt;/li&gt;
&lt;li&gt;IKE預先共用金鑰： 可以自行輸入 或是 由系統產生，但要注意騰訊雲不支援 特殊符號（. / 之類的），&lt;br /&gt;
所以要注意自行產生的金鑰&lt;/li&gt;
&lt;li&gt;導向選項： 這邊選擇 『依據政策』&lt;br /&gt;
遠端網路ip範圍：輸入TKE的私有網路範圍，可以從『騰訊雲的私有網路-&amp;gt;私有網路』 看到 IPv4 CIDR (Fig.6)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/13.%20fig-6.jpg&quot; alt=&quot;13. fig-6.jpg&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;gcp&quot; tabindex=&quot;-1&quot;&gt;GCP的防火牆設定&lt;/h3&gt;
&lt;p&gt;可能需要配置防火牆規則，不確定。&lt;br /&gt;
ref. &lt;a href=&quot;https://cloud.google.com/network-connectivity/docs/vpn/how-to/configuring-firewall-rules&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;配置防火牆規則&lt;/a&gt;&lt;br /&gt;
4. 騰訊雲的對端網關設定&lt;br /&gt;
私有網路-&amp;gt;VPN連接-&amp;gt;對端網關&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/13.%20fig-7.jpg&quot; alt=&quot;13. fig-7.jpg&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名稱： 隨意&lt;/li&gt;
&lt;li&gt;公網IP: 這邊就是輸入 GCP的閘道ip&lt;/li&gt;
&lt;li&gt;標籤： 可以不打&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;騰訊雲的VPN通道設定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/13.%20fig-8.jpg&quot; alt=&quot;13. fig-8.jpg&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通道名稱：隨意&lt;/li&gt;
&lt;li&gt;地域： 連結至網路的區域&lt;/li&gt;
&lt;li&gt;VPN網關類型： 私有網路。 雲聯網指的是 騰訊雲內部各區域的私有網路互聯(ref.&lt;a href=&quot;https://cloud.tencent.com/document/product/877/18675&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;雲聯網產品概述&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;私有網路：  請看(Fig.6)&lt;/li&gt;
&lt;li&gt;VPN網關：  請看(Fig.1)&lt;/li&gt;
&lt;li&gt;對端網關：  請看(Fig.7)&lt;/li&gt;
&lt;li&gt;預共享金鑰： 請看(Fig.5) 的預先共享金鑰&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;SPD策略&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/13.fig-9.jpg&quot; alt=&quot;13.fig-9.jpg&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本端網段： 請看(Fig.6)&lt;/li&gt;
&lt;li&gt;對端網段： 請看(Fig.4)的網段&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;IKE、IPsec配置&lt;br /&gt;
需與下圖一摸一樣。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/13.fig-10.jpg&quot; alt=&quot;13.fig-10.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/network-connectivity/docs/vpn/concepts/supported-ike-ciphers&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;支持的 IKE 加密方式&lt;/a&gt;，此文內(IKEv1 加密方式的第二階段，指的就是 IPsec配置）&lt;/p&gt;
&lt;h3 id=&quot;ike&quot; tabindex=&quot;-1&quot;&gt;IKE 配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;版本： IKEv1&lt;/li&gt;
&lt;li&gt;加密算法： AES-128&lt;/li&gt;
&lt;li&gt;認證算法： SHA1&lt;/li&gt;
&lt;li&gt;協商模式： main&lt;/li&gt;
&lt;li&gt;DH group: DH2&lt;/li&gt;
&lt;li&gt;IKE SA Lifetime： 36600&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;i-psec&quot; tabindex=&quot;-1&quot;&gt;IPsec 配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;加密算法：AES-128&lt;/li&gt;
&lt;li&gt;認證算法：SHA1&lt;/li&gt;
&lt;li&gt;PFS： DH-GROUP2&lt;/li&gt;
&lt;li&gt;IPsec sa Lifetime：10800&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;結尾（不，還有路由要設定）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/13.fig-11.jpg&quot; alt=&quot;13.fig-11.jpg&quot; /&gt;&lt;br /&gt;
這邊會先看到VPN的通道狀態是 已聯通， 但如果實際去Ping機器，會發現還是不通。&lt;/p&gt;
&lt;ol start=&quot;9&quot;&gt;
&lt;li&gt;騰訊雲路由表設定&lt;br /&gt;
私有網路-&amp;gt;路由表-&amp;gt;默認路由表&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/13.%20fig-12.jpg&quot; alt=&quot;13. fig-12.jpg&quot; /&gt;&lt;br /&gt;
新增路由策略(Fig.13)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/13.%20fig-13.jpg&quot; alt=&quot;13. fig-13.jpg&quot; /&gt;&lt;br /&gt;
新增路由(Fig.14)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新增路由：這邊是從騰訊雲要跳去GCP的網段，所以這邊要輸入的是（Fig.9)的對端網段&lt;/li&gt;
&lt;li&gt;下一跳類型：選擇VPN網關&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/13.%20fig-14.jpg&quot; alt=&quot;13. fig-14.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;10&quot;&gt;
&lt;li&gt;結論&lt;br /&gt;
可能有人會想，為什麼騰訊雲要設定路由，&lt;br /&gt;
而GCP不用設定路由。&lt;br /&gt;
因為在設定(Fig.5)的時候，就已經幫你設定好了。&lt;br /&gt;
但如果走的是 依據路徑，那這塊就必須要自行設定了。&lt;br /&gt;
如果想要看路由表，可以到&lt;br /&gt;
GCP-&amp;gt;VPC網路-&amp;gt;路徑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/13.fig-15.jpg&quot; alt=&quot;13.fig-15.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/network-connectivity/docs/vpn/how-to/creating-static-vpns&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用靜態路由創建傳統 VPN&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/network-connectivity/docs/vpn/concepts/choosing-networks-routing#route-alignment&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;網絡和隧道路由&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://bbs.huaweicloud.com/forum/thread-19167-1-1.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;【VPN錦囊】 騰訊雲對接華為雲配置指南&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://cloud.tencent.com/developer/article/1731806?s=original-sharing&amp;amp;sharedUid=7435714&amp;amp;from=10680&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;通過VPN連接到VPC&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.gtwang.org/linux/mtr-linux-network-diagnostic-tool/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;MTR：Linux 網路診斷工具使用教學&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/13.騰訊雲連接GOOGLE雲/" />
        </entry>
        <entry>
            <title>
                129. nginx 掛載gcs
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/129. nginx 掛載gcs/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;今天要上QA測試了，然後我突然發現我之前測完沒留下筆記。&lt;br /&gt;
現在都快忘光了，還好最後有找回記憶。&lt;br /&gt;
來補一下了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;今天要做的是把GCS變成一個圖片上傳空間，&lt;br /&gt;
可以用nginx來訪問。&lt;/p&gt;
&lt;div class=&quot;transclusion internal-embed is-loaded&quot;&gt;&lt;a class=&quot;markdown-embed-link&quot; href=&quot;https://daimom.vercel.app/gcp/8-gcs/&quot; aria-label=&quot;Open link&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;svg-icon lucide-link&quot;&gt;&lt;path d=&quot;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;div class=&quot;markdown-embed&quot;&gt;
&lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;某個案子，要整個翻掉重做，這次要讓VM的機器跟GKE的pod能夠同時存取一個儲存空間，&lt;br /&gt;
預計使用Google Cloud Storage，踩了一個早上的坑。&lt;/p&gt;
&lt;h1 id=&quot;正文-1&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;預計做兩個項目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在VM上面掛載gcs的資料夾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在GKE 上面的pod同時掛載 gcs的資料夾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在VM上面掛載gcs的資料夾&lt;br /&gt;
安裝方式，目前我的vm是 RedHat 所以用下面的方式，CentOS也是用同樣的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Configure the gcsfuse repo:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo tee /etc/yum.repos.d/gcsfuse.repo &amp;gt; /dev/null &amp;lt;&amp;lt;EOF
[gcsfuse]
name=gcsfuse (packages.cloud.google.com)
baseurl=https://packages.cloud.google.com/yum/repos/gcsfuse-el7-x86_64
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg
       https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Install gcsfuse:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;  sudo yum install gcsfuse
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成，其他安裝方式，請參考&lt;a href=&quot;https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/docs/installing.md&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GoogleCloudPlatform/gcsfuse/install.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;登入使用，&lt;br /&gt;
這邊先使用 gcloud auth login 做測試&lt;br /&gt;
先建立資料夾  mkdir upload&lt;br /&gt;
掛載  gcsfuse my-bucket upload&lt;br /&gt;
卸除掛載 fusermount -u upload&lt;/p&gt;
&lt;h3 id=&quot;debug&quot; tabindex=&quot;-1&quot;&gt;Debug用&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;gcsfuse --foreground --debug_gcs --debug_http --debug_fuse --debug_invariants --key-file=/home/user/Downloads/my-key.json mybucket /upload
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;google-application-credentials&quot; tabindex=&quot;-1&quot;&gt;永久加入GOOGLE_APPLICATION_CREDENTIALS變數&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;開啟 /etc/profiles
新增 export GOOGLE_APPLICATION_CREDENTIALS=&amp;quot;/home/user/Downloads/my-key.json&amp;quot;
修改檔案後要想馬上生效還要執行#
source /etc/profile不然只能在下次重進此使用者時生效。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://www.itread01.com/content/1547223515.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux系統環境變數和別名設定（永久生效和臨時生效）&lt;/a&gt;&lt;br /&gt;
附註，json檔案的取得在 IAM角色內的服務賬戶&lt;br /&gt;
ref.&lt;a href=&quot;https://cloud.google.com/iam/docs/creating-managing-service-account-keys&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;創建和管理服務帳號密鑰&lt;/a&gt;。&lt;br /&gt;
新增完GCS，記得把權限給服務賬戶。記得選擇完整權限（Fig. 1)&lt;/p&gt;
&lt;h3 id=&quot;自動掛載&quot; tabindex=&quot;-1&quot;&gt;自動掛載&lt;/h3&gt;
&lt;p&gt;有權限了已後，再來就是自動掛載了。&lt;br /&gt;
到/etc/fstab上，輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;my_bucket /home/ezio/upload gcsfuse key_file=key/key.json,rw,user,allow_other,uid=1008,gid=1009  0 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重開機測試看看，收工。&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://stackoverflow.com/questions/42638048/how-to-use-mount-command-in-fstab-file/42638136#42638136&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to use mount command in fstab file&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://serverfault.com/questions/1021950/gcsfuse-automount-on-a-non-root-user&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcsfuse automount on a non root user&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;查詢目前登入使用者的uid 跟 gid
id $(whoami)

如果要看全部使用者的話，
cat /etc/passwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;a href=&quot;http://linux.vbird.org/linux_basic/0410accountmanager/0410accountmanager-centos5.php#account_id&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux 的帳號與群組&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;在GKE 上面的pod同時掛載 gcs的資料夾&lt;br /&gt;
基本的方式，&lt;br /&gt;
先自己產生一個 image&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;FROM golang:1.14-alpine AS build-env
ENV GO111MODULE on

# WORKDIR /工作名錄名稱 當前的工作目錄名稱，若是不存在則會新建該目錄，
# 需要注意的是copy跟run的指令都是以WORKDIR為當前目錄下去跑的，
# 運用的時候需要注意相對位置。
WORKDIR $GOPATH/src

RUN go get -u github.com/googlecloudplatform/gcsfuse

COPY key.json .


FROM alpine:3.6
RUN apk add --no-cache ca-certificates fuse &amp;amp;&amp;amp; rm -rf /tmp/*
COPY --from=build-env /go/bin/gcsfuse /usr/local/bin
COPY --from=build-env /go/src/key.json /
WORKDIR /
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;佈署 Deployment&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: gcs-fuse
    version: v1
  namespace: debug
  name: gcsfuse-test
spec:
  replicas: 1
  selector:
    matchLabels:
      app: gcs-fuse
      version: v1
  template:
    metadata:
      labels:
        app: gcs-fuse
        version: v1
    spec:
      containers:
        - name: gcsfuse-test
          image: gcr.io/your-project/gcsfuse:v1.2
          # image: golang:1.14-alpine
          # command: [ &amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;--&amp;quot; ]
          # args: [ &amp;quot;while true; do sleep 600; done;&amp;quot; ]
          securityContext:
            privileged: true
          command:
            - &amp;quot;/bin/sh&amp;quot;
            - &amp;quot;-c&amp;quot;
            - &amp;quot;while true; do mkdir /upload ; gcsfuse --key-file=key.json your-bucket /folder; sleep 600; done; &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果跟現有的程式整合的話，&lt;br /&gt;
由於要執行多行指令，需使用shellScript的方式執行指令。&lt;br /&gt;
可能會遇到下列情況&lt;/p&gt;
&lt;h3 id=&quot;and-quot-exec-and-quot-init-sh-and-quot-permission-denied&quot; tabindex=&quot;-1&quot;&gt;&amp;quot;exec: &amp;quot;/init.sh&amp;quot;: permission denied&lt;/h3&gt;
&lt;p&gt;在Dockerfile上修改權限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RUN chmod +x /init.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://stackoverflow.com/questions/44687685/getting-permission-denied-in-docker-run&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;getting permission denied in docker run&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;exec-user-process-caused-and-quot-exec-format-error-and-quot&quot; tabindex=&quot;-1&quot;&gt;exec user process caused &amp;quot;exec format error&amp;quot;&lt;/h3&gt;
&lt;p&gt;有人說在sh的頂端加上&lt;br /&gt;
#!/bin/bash&lt;br /&gt;
但我試了沒用，在猜想可能是alpine linux沒有bash導致&lt;br /&gt;
所以改用下面這個&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ENTRYPOINT [&amp;quot;sh&amp;quot;,&amp;quot;/run.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://stackoverflow.com/questions/42494853/standard-init-linux-go178-exec-user-process-caused-exec-format-error&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;standard_init_linux.go:178: exec user process caused “exec format error”&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;sh-debug&quot; tabindex=&quot;-1&quot;&gt;執行sh時卡住，debug方式&lt;/h3&gt;
&lt;p&gt;用if else檢查&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if mkdir /upload; then
    echo &amp;quot;mkdir directory! Success&amp;quot; 1&amp;gt;&amp;amp;2
    gcsfuse --key-file=key.json yellow-video /upload
else
    echo &amp;quot;Could not mkdir directory!&amp;quot; 1&amp;gt;&amp;amp;2
    exit 1
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，最後找出來原因是因為先執行go的程式，導致後續卡住，所以先建立資料夾後，再執行go&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://www.opencli.com/linux/shell-script-exit-on-error&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Shell Script 遇到錯誤時自動退出離開&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/docs/authentication/getting-started&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;身份驗證入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.itread01.com/content/1547223515.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux系統環境變數和別名設定（永久生效和臨時生效）&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;
 這篇有講到如何在deploy掛載GCS
通常就是要安裝一些東西。
&lt;p&gt;會使用到gcsfuse這個指令，&lt;br /&gt;
所以我選擇直接建一個image，&lt;br /&gt;
然後掛載的時候直接用那個image就好。&lt;/p&gt;
&lt;p&gt;gcs-download.json 是 要掛載GCS用的權限json檔&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM nginx:latest
WORKDIR /app

COPY gcs-download.json .
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#Start&quot;&gt;#Start&lt;/a&gt; CloudStorage
RUN apt update &amp;amp;&amp;amp; apt install -y gnupg lsb-release
RUN echo &amp;quot;deb https://packages.cloud.google.com/apt gcsfuse-$(lsb_release -c -s) main&amp;quot; |  tee /etc/apt/sources.list.d/gcsfuse.list
RUN curl https://packages.cloud.google.com/apt/doc/apt-key.gpg |  apt-key add -
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y gcsfuse
ENV GOOGLE_APPLICATION_CREDENTIALS=/app/gcs-download.json

WORKDIR /usr/share/nginx/html/files


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後部署的yaml，&lt;br /&gt;
這邊要注意的地方是&lt;br /&gt;
1.&lt;br /&gt;
nginx.conf  要加上 user root  ，&lt;br /&gt;
這是因爲gcs掛載資料夾是用root的角色，所以如果nginx不用root啓動，&lt;br /&gt;
會出現403的權限問題。&lt;br /&gt;
ref.  &lt;a href=&quot;https://www.linuxprobe.com/nginx-403-forbidden.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;四種解決Nginx出現403 forbidden 報錯的方法&lt;/a&gt;&lt;br /&gt;
2.&lt;br /&gt;
daemon off;  這部分指的是要讓nginx能夠在前景執行，不然pod會一直重開。&lt;br /&gt;
ref.  &lt;a href=&quot;https://www.cnblogs.com/JulianHuang/p/15753732.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;nginx -g &amp;quot;daemon off;&amp;quot; 你學廢了嗎？&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: ConfigMap
metadata:
  name: systemfile-nginx-config
  namespace: default
data:
  nginx.conf: |
    user  root;
    worker_processes  auto;

    error_log  /var/log/nginx/error.log notice;
    pid        /var/run/nginx.pid;


    events {
        worker_connections  1024;
    }


    http {
        include       /etc/nginx/mime.types;
        default_type  application/octet-stream;

        log_format  main  &#39;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &#39;
                          &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39;
                          &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&#39;;

        access_log  /var/log/nginx/access.log  main;

        sendfile        on;
        &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#tcp_nopush&quot;&gt;#tcp_nopush&lt;/a&gt;     on;

        keepalive_timeout  65;

        &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#gzip&quot;&gt;#gzip&lt;/a&gt;  on;

        include /etc/nginx/conf.d/*.conf;
    }

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: sms-systemfile-config
  namespace: default
data:
  default.conf: |
    server {
        listen           80  default_server;
        server_name      _;
        server_tokens    off;

        index index.html;

        location /files {
            alias        /usr/share/nginx/html/files;
            autoindex    on;
        }

        location / {
            root         /usr/share/nginx/html;
            index        index.html;
        }

        error_page       500 502 503 504  /50x.html;
        location = /50x.html {
            root         /usr/share/nginx/html;
        }
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: systemmanageservice-systemfile
  namespace: default
  labels:
    group: systemmanageservice
    app: systemfile
spec:
  replicas: 1
  revisionHistoryLimit: 5
  progressDeadlineSeconds: 15
  selector:
    matchLabels:
      group: systemmanageservice
      app: systemfile
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    type: RollingUpdate
  template:
    metadata:
      labels:
        group: systemmanageservice
        app: systemfile
    spec:
      containers:
        - name: systemmanageservice-systemfile
          image: gcs-nginx:0.0.2
          command:
            - /bin/bash
            - &#39;-c&#39;
            - &amp;gt;-
              gcsfuse systemfile-qa /usr/share/nginx/html/files &amp;amp;&amp;amp; nginx -g
              &amp;quot;daemon off;&amp;quot;;
          imagePullPolicy: Always # IfNotPresent, Always, Never
          securityContext:
            privileged: true
          ports:
            - name: http
              containerPort: 80
              protocol: TCP
          resources: {}
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
          volumeMounts:
            - name: config-volume
              mountPath: /etc/nginx/conf.d/default.conf
              subPath: default.conf
              readOnly: true
            - name: nginx-config-volume
              mountPath: /etc/nginx/nginx.conf
              subPath: nginx.conf
              readOnly: true              
      volumes:
        - name: config-volume
          configMap:
            name: sms-systemfile-config
            items:
              - key: default.conf
                path: default.conf
            defaultMode: 420
        - name: nginx-config-volume
          configMap:
            name: systemfile-nginx-config
            items:
              - key: nginx.conf
                path: nginx.conf
            defaultMode: 420
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      terminationGracePeriodSeconds: 30
      schedulerName: default-scheduler
      securityContext: {}

&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/129. nginx 掛載gcs/" />
        </entry>
        <entry>
            <title>
                128. 解決 the gcp auth plugin is deprecated in v1.22+
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/128. 解決 the gcp auth plugin is deprecated in v1.22+/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;每次下kubectl的指令總會跳這個錯誤出來，&lt;br /&gt;
不處理也沒什麼事，但就是都會出現。&lt;br /&gt;
今天...就解決吧&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;警告訊息通常是這樣，&lt;br /&gt;
但你deploy的服務都還是會跑。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WARNING: the gcp auth plugin is deprecated in v1.22+, unavailable in v1.26+; use gcloud instead.&lt;br /&gt;
To learn more, consult &lt;a href=&quot;https://cloud.google.com/blog/products/containers-kubernetes/kubectl-auth-changes-in-gke&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://cloud.google.com/blog/products/containers-kubernetes/kubectl-auth-changes-in-gke&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這是由於docker在安裝的時候，會順便將kubectl安裝進去，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;where kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以得到 kubectl的執行檔位置&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/usr/local/bin/kubectl&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查詢kubectl的softlink 位置，會查到kubectl的命令是跟docker連結的。&lt;br /&gt;
附註, &lt;code&gt;ll 跟 ls -la 同意&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls -la /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先將本來的softlink刪除，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rm /usr/local/bin/kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安裝gcloud版本的kubectl&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud components install kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;裝完後如果還不認識指令，&lt;br /&gt;
需要額外處理。&lt;/p&gt;
&lt;p&gt;先檢查一下gcloud有沒有安裝好kubectl，&lt;br /&gt;
如果path有路徑就代表正常，不然需要重新製作softlink&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud info | grep -i kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/128.fig-1.jpg&quot; alt=&quot;128.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;製作softlink&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ln /usr/local/Caskroom/google-cloud-sdk/latest/google-cloud-sdk/bin/kubectl /usr/local/bin/kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://blog.marsen.me/2022/06/08/2022/the_gcp_auth_plugin_is_deprecated/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[實作筆記] 錯誤處理 the gcp auth plugin is deprecated&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://stackoverflow.com/questions/51429553/how-to-set-path-to-kubectl-when-installed-using-gcloud-components-install&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to set path to kubectl when installed using gcloud components install?&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/128. 解決 the gcp auth plugin is deprecated in v1.22+/" />
        </entry>
        <entry>
            <title>
                127. fuse device not found, try &#39;modprobe fuse&#39; first
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/127. fuse device not found, try &#39;modprobe fuse&#39; first/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;以前用GKE掛載gcs的時候發生錯誤，fuse device not found, try &#39;modprobe fuse&#39; first。解決方法。&lt;br /&gt;
現在GKE有了新的掛載GCS方法了，&lt;a href=&quot;https://cloud.google.com/blog/products/containers-kubernetes/announcing-cloud-storage-fuse-and-gke-csi-driver-for-aiml-workloads&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Announcing Cloud Storage FUSE and GKE CSI driver for AI/ML workloads&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;目前我沒采用此方式，請他們改用api的方式上傳檔案了，&lt;br /&gt;
要訪問的話，用Load balancing 指向GCS bucket。&lt;br /&gt;
這文章用方法應該不太適用，&lt;br /&gt;
而且此方法有缺點，當你檔案數量太多時，會掛載不起來。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;
apt install -y gnupg lsb-release
export GCSFUSE_REPO=gcsfuse-`lsb_release -c -s`
export GCSFUSE_REPO=gcsfuse-buster
echo &amp;quot;deb https://packages.cloud.google.com/apt $GCSFUSE_REPO main&amp;quot; |  tee /etc/apt/sources.list.d/gcsfuse.list
curl https://packages.cloud.google.com/apt/doc/apt-key.gpg |  apt-key add -
apt-get update
apt-get install -y gcsfuse
export GOOGLE_APPLICATION_CREDENTIALS=/home/gcs-download.json
gcsfuse sms_backend_backup ./gcs-mount

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/127.fig-1.jpg&quot; alt=&quot;127.fig-1.jpg&quot; /&gt;&lt;br /&gt;
需要用特權模式&lt;br /&gt;
在yaml檔裏面，加上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    securityContext:
      privileged: true
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/127. fuse device not found, try &#39;modprobe fuse&#39; first/" />
        </entry>
        <entry>
            <title>
                121.cloudCDN設定
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/121.cloudCDN設定/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;之前測完後就忘了寫，&lt;br /&gt;
但今天有人問我才想起來，&lt;br /&gt;
我到底跑去哪設定的！？&lt;br /&gt;
現在趕緊補一下&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;如果已經在GCP上面建立好了負載平衡，&lt;br /&gt;
那就到後端設定，看要針對哪個服務去開啓cdn就好了。&lt;br /&gt;
上面有個逾時的設定，看要設定多少，&lt;br /&gt;
當初同事是有說他測30秒就會斷線一次，&lt;br /&gt;
所以我有把這邊拉長。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/121-fig.1.png&quot; alt=&quot;121-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;這邊設定完後，在cloudCDN上面就會多一個設定出來。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/121-fig.2.jpg&quot; alt=&quot;121-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;也能用指令去查，啓用cdn時的欄位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get BackendConfig
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-features#timeout&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;cloudCDN&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/121.cloudCDN設定/" />
        </entry>
        <entry>
            <title>
                120. 指令備份cloudSQL及下載
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/120. 指令備份cloudSQL及下載/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;有人不習慣ui操作，&lt;br /&gt;
加上他們是兩三個月用一次，&lt;br /&gt;
那就生個指令給他們用吧。&lt;/p&gt;
&lt;p&gt;做成自動化應該也可以，&lt;br /&gt;
只是要看一下權限要用誰的。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;主要的兩行指令，請將視角往下移&lt;/p&gt;
&lt;ol 來源=&quot;&quot;&gt;
&lt;li&gt;
&lt;p&gt;test-db01: cloudSQL的instance名稱&lt;br /&gt;
gs://data/desk-22-12-14.bak ：要存放cloudStorage的位置&lt;br /&gt;
Desk : 資料庫名稱&lt;/p&gt;
&lt;/li&gt;
&lt;li 目的=&quot;&quot;&gt;
&lt;p&gt;gcloud storage cp &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;gcloud beta sql export bak test-db01 gs://data/desk-22-12-14.bak &#92;
--database=Desk

gcloud storage cp  gs://data/desk-22-12-14.bak /Users/daimom/Downloads
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;執行 gcloud storage cp ，出現error   invalid choice storage&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;更新 gcloud components&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;gcloud components update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://stackoverflow.com/questions/42916677/gcloud-beta-functions-command-says-invalid-choice-functions&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud beta functions command says &amp;quot;Invalid choice functions&amp;quot;&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;權限問題&lt;br /&gt;
cloudSQL 備份權限&lt;br /&gt;
Cloud SQL Editor 角色和 &lt;code&gt;storage.objectAdmin&lt;/code&gt; IAM 角色&lt;br /&gt;
cloudStorage下載權限&lt;br /&gt;
這部分就需要到cloudStorage的bucket設定了&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/sql/docs/sqlserver/import-export/import-export-bak#gcloud&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 BAK 檔案匯出和匯入&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/storage/docs/downloading-objects?hl=zh-cn#downloading-an-object&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;從儲存桶下載對象&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/120. 指令備份cloudSQL及下載/" />
        </entry>
        <entry>
            <title>
                109.GCS臨時下載權限
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/109.GCS臨時下載權限/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;今天維護，後端同仁要cloudSQL的備份檔，&lt;br /&gt;
然後，因為他們都沒權限，只好丟去網路空間，給他們抓。&lt;br /&gt;
我就在想，沒道理阿，應該有個方法能夠開特定的檔案臨時給人用。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;由於GCS的權限是 &lt;a href=&quot;https://cloud.google.com/storage/docs/uniform-bucket-level-access&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;統一儲存分區級存取權&lt;/a&gt;，&lt;br /&gt;
所以不能細分檔案權限給別人用。&lt;br /&gt;
所以，開&lt;a href=&quot;https://cloud.google.com/storage/docs/access-control/signing-urls-with-helpers?hl=zh-cn&amp;amp;skip_cache=true%22&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;V4簽名&lt;/a&gt;，就能給別人訪問了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; gsutil signurl -d 1m gcs-download.json gs://ai-assist-data/&amp;quot;Cloud_SQL_Export_warehouse_2022-10-12 (06:03:23)&amp;quot;.bak
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1m 表示，只開放一分鐘的時間&lt;br /&gt;
gcs-download.json是SA，從IAM那邊找到一個有權限下載的帳號產生的金鑰。&lt;br /&gt;
gs 的網址，可以到詳細資料內取得 gsutil URI&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/109-fig.1.jpg&quot; alt=&quot;GCP/109-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;這個執行後，會得到一串&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/GCP/109-fig.2.jpg&quot; alt=&quot;GCP/109-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;把後面的https複製，就能拿來用了。&lt;/p&gt;
&lt;h2 id=&quot;錯誤處理&quot; tabindex=&quot;-1&quot;&gt;錯誤處理&lt;/h2&gt;
&lt;p&gt;如果在執行signurl的時候發生以下錯誤，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CommandException: The signurl command requires the pyopenssl library (try pip install pyopenssl or easy_install pyopenssl)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip3 install pyopenssl
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;其他方式&quot; tabindex=&quot;-1&quot;&gt;其他方式&lt;/h2&gt;
&lt;p&gt;將底下的檔案跑遞迴(-R)，通通設成public-read&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gsutil -m acl set -R -a public-read gs://bucket
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/109.GCS臨時下載權限/" />
        </entry>
        <entry>
            <title>
                0.GCP MOC
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/GCP/0.GCP MOC/</id>
            <content type="html">
                &lt;h1 id=&quot;price&quot; tabindex=&quot;-1&quot;&gt;Price&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/Price/GCP%E8%B2%BB%E7%94%A8/&quot;&gt;GCP費用&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/Price/GCP%20CPU%E7%94%A8%E9%80%94/&quot;&gt;GCP CPU用途&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/Price/180.%20GCP%20%E7%9B%A3%E6%8E%A7%E8%B2%BB%E7%94%A8/&quot;&gt;180. GCP 監控費用&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/Price/126.%20GCP%20%E7%A1%AC%E7%A2%9F%E8%B2%BB%E7%94%A8%E6%AF%94%E8%BC%83/&quot;&gt;126. GCP 硬碟費用比較&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;gcp&quot; tabindex=&quot;-1&quot;&gt;GCP&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/88.%E6%89%B9%E6%AC%A1%E4%BF%AE%E6%94%B9GCP%E7%9A%84label/&quot;&gt;88.批次修改GCP的label&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/5.%20Google%20Cloud%20Function%E9%99%90%E5%88%B6/&quot;&gt;5. Google Cloud Function限制&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/95.cloud%20build%E7%9A%84%E5%95%8F%E9%A1%8C/&quot;&gt;95.cloud build的問題&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/97.%20Anthos%20%E5%88%9D%E9%AB%94%E9%A9%97/&quot;&gt;97. Anthos 初體驗&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/120.%20%E6%8C%87%E4%BB%A4%E5%82%99%E4%BB%BDcloudSQL%E5%8F%8A%E4%B8%8B%E8%BC%89/&quot;&gt;120. 指令備份cloudSQL及下載&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/121.cloudCDN%E8%A8%AD%E5%AE%9A/&quot;&gt;121.cloudCDN設定&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/128.%20%E8%A7%A3%E6%B1%BA%20the%20gcp%20auth%20plugin%20is%20deprecated%20in%20v1.22+/&quot;&gt;128. 解決 the gcp auth plugin is deprecated in v1.22+&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/161.%20GKE%E5%88%A9%E7%94%A8pubsub%E9%80%9A%E7%9F%A5%E8%A8%8A%E6%81%AF%E5%88%B0discord/&quot;&gt;161. GKE利用pubsub通知訊息到discord&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/164.gcloud%20install%20by%20bash/&quot;&gt;164.gcloud install by bash&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/181.%20cloudstorage%E7%84%A1%E6%B3%95%E4%BD%BF%E7%94%A8cloudflare%E8%BD%89%E5%9D%80/&quot;&gt;181. cloudstorage無法使用cloudflare轉址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;gce&quot; tabindex=&quot;-1&quot;&gt;GCE&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/19.%20GCE%E7%A1%AC%E7%A2%9F%E5%A2%9E%E5%8A%A0%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F/&quot;&gt;GCE硬碟增加容量大小&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/46.%E5%88%97%E5%87%BAGCE%E7%9A%84%E6%89%80%E6%9C%89VM/&quot;&gt;46.列出GCE的所有VM&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/46.GCE%E6%A9%9F%E5%99%A8%E5%88%97%E8%A1%A8%E5%85%A7%E7%9A%84CPU%E5%80%8B%E6%95%B8/&quot;&gt;46.GCE機器列表內的CPU個數&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/79.%20gcloud%20compute%20instance%20%E7%AD%86%E8%A8%98/&quot;&gt;GCE指令&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/130.%20Google%20IAP%20ssh%E5%A4%B1%E6%95%97/&quot;&gt;130. Google IAP ssh失敗&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;gcs&quot; tabindex=&quot;-1&quot;&gt;GCS&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/8.GCS%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/&quot;&gt;GCS使用方式&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/109.GCS%E8%87%A8%E6%99%82%E4%B8%8B%E8%BC%89%E6%AC%8A%E9%99%90/&quot;&gt;109.GCS臨時下載權限&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/127.%20fuse%20device%20not%20found,%20try%20&#39;modprobe%20fuse&#39;%20first/&quot;&gt;127. fuse device not found, try &#39;modprobe fuse&#39; first&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/129.%20nginx%20%E6%8E%9B%E8%BC%89gcs/&quot;&gt;129. nginx 掛載gcs&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/135.%20gsutil%E6%95%B4%E6%89%B9%E8%A4%87%E8%A3%BD/&quot;&gt;135. gsutil整批複製&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/140.%20gcs%20%E6%8E%9B%E8%BC%89domain/&quot;&gt;140. gcs 掛載domain&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/141.%20gcs%E8%87%AA%E5%8B%95%E5%88%AA%E9%99%A4%E6%AA%94%E6%A1%88/&quot;&gt;141. gcs自動刪除檔案&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;netwrok&quot; tabindex=&quot;-1&quot;&gt;Netwrok&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/9.GCP%E7%B6%B2%E8%B7%AF%E5%B0%8D%E5%A4%96%E7%9A%84%E6%96%B9%E5%BC%8F/&quot;&gt;GCP網路對外的方式&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/13.%E9%A8%B0%E8%A8%8A%E9%9B%B2%E9%80%A3%E6%8E%A5GOOGLE%E9%9B%B2/&quot;&gt;13.騰訊雲連接GOOGLE雲&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/GCP/17.%20Gcloud%20AttributeError%20module%20importlib%20has%20no%20attribute%20util/&quot;&gt;17. Gcloud AttributeError module importlib has no attribute util&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/GCP/0.GCP MOC/" />
        </entry>
        <entry>
            <title>
                91. elasticsearch ingest processor補充
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/EFK/91. elasticsearch ingest processor補充/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;補充ingest 的 processor&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;上篇提到，正常要等ILM跑完後，所設定的default_pipeline才會寫入。&lt;br /&gt;
但今天是可以提早讓他跑ILM，這樣就會把預設的default_pipeline寫進去了。&lt;/p&gt;
&lt;p&gt;而只要在default_pipeline 設定好，後續再改pipeline的設定時，都會直接影響當下的設定。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在index template設定pipeline&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/90-fig.10.jpg&quot; alt=&quot;90-fig.10.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;到 Devtools 執行下面指令&lt;br /&gt;
強制datastream執行ILM&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;POST /filebeat-8.1.0/_rollover
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/data-streams.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;DataStream&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://www.gushiciku.cn/pl/gtvK/zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elasticsearch 7.X data stream 深入詳解&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;ingest&quot; tabindex=&quot;-1&quot;&gt;ingest 補充&lt;/h1&gt;
&lt;p&gt;processor分成好幾個類型&lt;/p&gt;
&lt;p&gt;上一篇是使用grok(這個是使用正則去篩選字串)，&lt;br /&gt;
有人建議使用Dissect，速度比grok快，但只適用於有固定分隔字串的message。&lt;/p&gt;
&lt;p&gt;下面簡單敘述用途，詳細就點連結過去看了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/append-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Append&lt;/a&gt;&lt;br /&gt;
在現有的字串內增加值&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/bytes-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Bytes&lt;/a&gt;&lt;br /&gt;
把空間計算方式(kb,mb,gb...)轉成byte&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/ingest-circle-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Circle&lt;/a&gt;&lt;br /&gt;
把圓形轉爲近似他們的規則多邊形（我也不知道這能做啥）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/community-id-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Community ID&lt;/a&gt;&lt;br /&gt;
計算網路資料流的id，能透過此id關聯相關的網路事件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/convert-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Convert&lt;/a&gt;&lt;br /&gt;
將欄位內容轉爲integer、long、float、double、string、boolean、ip&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/csv-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;CSV&lt;/a&gt;&lt;br /&gt;
將欄位中的的資料當作csv去辨別&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/date-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Date&lt;/a&gt;&lt;br /&gt;
將欄位內容轉爲日期格式&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/date-index-name-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Date index name&lt;/a&gt;&lt;br /&gt;
將日期取出作爲index的名稱&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/dissect-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Dissect&lt;/a&gt;&lt;br /&gt;
與grok相似，但不使用正則作爲結構化欄位&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/dot-expand-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Dot expander&lt;/a&gt;&lt;br /&gt;
會將 . 視爲一個物件的名稱，&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;  foo.bar :value
  foo : { 
	bar: value
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/drop-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Drop&lt;/a&gt;&lt;br /&gt;
根據條件刪除document&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/enrich-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Enrich&lt;/a&gt;&lt;br /&gt;
根據欄位規則，自動新增資料&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/fail-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Fail&lt;/a&gt;&lt;br /&gt;
當錯誤時，傳送訊息&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/fingerprint-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Fingerprint&lt;/a&gt;&lt;br /&gt;
計算document的hash值&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/foreach-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Foreach&lt;/a&gt;&lt;br /&gt;
當元素數量不確定時使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/geoip-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GeoIP&lt;/a&gt;&lt;br /&gt;
根據地理位置提供更多資訊&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/grok-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Grok&lt;/a&gt;&lt;br /&gt;
從document中截取結構化的字串出來(正則)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/gsub-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Gsub&lt;/a&gt;&lt;br /&gt;
使用正則或取代來轉換字串&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/htmlstrip-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;HTML strip&lt;/a&gt;&lt;br /&gt;
從欄位中移除html的tag&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/inference-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Inference&lt;/a&gt;&lt;br /&gt;
Uses a pre-trained data frame analytics model to infer against the data that is being ingested in the pipeline.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/join-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Join&lt;/a&gt;&lt;br /&gt;
將欄位中的array值用分隔符串起來&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/json-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;JSON&lt;/a&gt;&lt;br /&gt;
將json字串轉成json格式&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/kv-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;KV&lt;/a&gt;&lt;br /&gt;
指定欄位自動解析訊息&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/lowercase-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Lowercase&lt;/a&gt;&lt;br /&gt;
將字串轉成小寫&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/network-direction-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Network direction&lt;/a&gt;&lt;br /&gt;
根據來源IP及目的IP計算是 inbound或 outbonud&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/pipeline-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Pipeline&lt;/a&gt;&lt;br /&gt;
在pipeline內執行其他的pipeline&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/registered-domain-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Registered domain&lt;/a&gt;&lt;br /&gt;
解析domain，區分出 sub-doamin、top-level domain&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/remove-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Remove&lt;/a&gt;&lt;br /&gt;
移除欄位&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/rename-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Rename&lt;/a&gt;&lt;br /&gt;
更改欄位名稱&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/script-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Script&lt;/a&gt;&lt;br /&gt;
執行script&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/set-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Set&lt;/a&gt;&lt;br /&gt;
指令欄位寫值&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/ingest-node-set-security-user-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Set security user&lt;/a&gt;&lt;br /&gt;
通過預處理程序，從目前驗證的使用者截取資料&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/sort-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Sort&lt;/a&gt;&lt;br /&gt;
對欄位內的array做排序&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/split-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Split&lt;/a&gt;&lt;br /&gt;
使用分隔符號，將字串切成array&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/trim-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Trim&lt;/a&gt;&lt;br /&gt;
移除欄位空白&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/uppercase-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Uppercase&lt;/a&gt;&lt;br /&gt;
將字串轉成大寫&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/urldecode-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;URL decode&lt;/a&gt;&lt;br /&gt;
將URL網址解碼&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/uri-parts-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;URI parts&lt;/a&gt;&lt;br /&gt;
將URL請求拆開成URI object&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/user-agent-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;User agent&lt;/a&gt;&lt;br /&gt;
解析user_agent&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/EFK/91. elasticsearch ingest processor補充/" />
        </entry>
        <entry>
            <title>
                90. elasticsearch ingest pipeline
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/EFK/90. elasticsearch ingest pipeline/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;用filebeat 蒐集 nginx的資料，取得的Nginx資料沒再經過分解，&lt;br /&gt;
導致沒辦法運用在efk上面。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/90-fig.1.jpg&quot; alt=&quot;90-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;ui&quot; tabindex=&quot;-1&quot;&gt;先用UI講解步驟。&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先來看一下nginx的message，然後再分析裡面的欄位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;127.0.0.1 - - [06/May/2022:06:44:01 +0000] , http-host: &#92;&amp;quot;abc.boxing.com&#92;&amp;quot; , URL: &#92;&amp;quot;GET /static/tpl/analytics/index.html?v=51817715.1 HTTP/1.1&#92;&amp;quot;  , request-status : &#92;&amp;quot;200&#92;&amp;quot;  ,   body-byte: 0  ,http-referer: &#92;&amp;quot;https://abc.boxing.com/mobile&#92;&amp;quot;  ,user-agent: &#92;&amp;quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&#92;&amp;quot; , X-Forwarded-For : &#92;&amp;quot;132.235.211.18,10.107.10.14&#92;&amp;quot; ,   request-time: &#92;&amp;quot;0.000&#92;&amp;quot;  , response_time : &#92;&amp;quot;-&#92;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊的格式有特別去調整過，詳情可參考，&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/GKE/56.%20GKE%E8%A8%98%E9%8C%84%20nginx%20log/&quot;&gt;56. GKE記錄 nginx log&lt;/a&gt;。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;ingest pipeline&lt;br /&gt;
UI畫面，Stack Management -&amp;gt; Ingest Pipelines-&amp;gt; Create pipeline&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/90-fig.2.jpg&quot; alt=&quot;90-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Add a processor&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/90-fig.3.jpg&quot; alt=&quot;90-fig.3.jpg&quot; /&gt;&lt;br /&gt;
Processor ： Grok&lt;br /&gt;
Field ： message&lt;br /&gt;
patterns:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;%{IPORHOST:nginx.source.ip} %{USER:nginx.user.id} %{USER:nginx.user.name} &#92;&#92;[%{HTTPDATE:nginx.@timestamp}&#92;&#92;] , http-host: &#92;&amp;quot;%{DATA:nginx.url.host}&#92;&amp;quot; , URL: &#92;&amp;quot;%{WORD:nginx.http.request.method} %{DATA:nginx.url.path} HTTP/%{NUMBER:nginx.http.version}&#92;&amp;quot;  , request-status : &#92;&amp;quot;%{NUMBER:nginx.http.response.status_code:int}&#92;&amp;quot;  ,   body-byte: %{NUMBER:nginx.http.response.body.bytes:int}  ,http-referer: &#92;&amp;quot;%{DATA:nginx.http.request.referer}&#92;&amp;quot;  ,user-agent: %{QS:nginx.user_agent} , X-Forwarded-For : &#92;&amp;quot;%{DATA:nginx.http.request.xff}&#92;&amp;quot; ,   request-time: &#92;&amp;quot;%{NUMBER:nginx.http.request.time}&#92;&amp;quot;  , response_time : &#92;&amp;quot;(?:-|%{NUMBER:nginx.http.request.time:int})&#92;&amp;quot;    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此處的patterns是符合我上面(1)的訊息，所產生的。&lt;/p&gt;
&lt;p&gt;ps. Grok Debugger 記得要8.1後才有，如果版本過低，可以參考下方，用DevTools下指令的方式除錯。&lt;/p&gt;
&lt;p&gt;Grok簡單說，&lt;/p&gt;
&lt;blockquote 型態：要存的欄位名稱=&quot;&quot;&gt;
&lt;p&gt;%&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;型態有哪些，參考連結『 grok-patterns』&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/8.1/xpack-grokdebugger.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Grok Debugger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/8.1/grok-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Grok processor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/grok.html#grok-syntax&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Grokking grok&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/elastic/elasticsearch/blob/master/libs/grok/src/main/resources/patterns/legacy/grok-patterns&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;grok-patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;測試&lt;br /&gt;
寫好了後，不測試一下也不知道是對或錯，&lt;br /&gt;
到新建的畫面，右邊的中間，有Add Document的選項。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/90-fig.4.jpg&quot; alt=&quot;90-fig.4.jpg&quot; /&gt;&lt;br /&gt;
之後輸入要測試的範例&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/90-fig.5.jpg&quot; alt=&quot;90-fig.5.jpg&quot; /&gt;&lt;br /&gt;
內容為：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;    {
      &amp;quot;_source&amp;quot;: {
        &amp;quot;message&amp;quot;: &amp;quot;127.0.0.1 - - [06/May/2022:06:44:01 +0000] , http-host: &#92;&amp;quot;abc.boxing.com&#92;&amp;quot; , URL: &#92;&amp;quot;GET /static/tpl/analytics/index.html?v=51817715.1 HTTP/1.1&#92;&amp;quot;  , request-status : &#92;&amp;quot;200&#92;&amp;quot;  ,   body-byte: 0  ,http-referer: &#92;&amp;quot;https://abc.boxing.com/mobile&#92;&amp;quot;  ,user-agent: &#92;&amp;quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&#92;&amp;quot; , X-Forwarded-For : &#92;&amp;quot;132.235.211.18,10.107.10.14&#92;&amp;quot; ,   request-time: &#92;&amp;quot;0.000&#92;&amp;quot;  , response_time : &#92;&amp;quot;-&#92;&amp;quot;&amp;quot;
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按下 Run the pipeline，有成功就會跑結果出來了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/90-fig.6.jpg&quot; alt=&quot;90-fig.6.jpg&quot; /&gt;&lt;br /&gt;
失敗的話，會變成下面的圖。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/90-fig.7.jpg&quot; alt=&quot;90-fig.7.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;此處皆參考官方範例&lt;br /&gt;
ref. &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/common-log-format-example.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Example: Parse logs in the Common Log Format&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;api&quot; tabindex=&quot;-1&quot;&gt;使用api測試&lt;/h3&gt;
&lt;p&gt;在UI上面測試 Grok實在很累，除了用剛剛提到的 Grok Debug以外。&lt;br /&gt;
就是直接用api方式直接驗證了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note,  8.1 我用Grok Debugger 有些特殊字元會無法match ，但用API沒問題。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Nginx 為 ingest Pipeline Name&lt;/p&gt;
&lt;p&gt;以下API 皆在 DevTools驗證&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/90-fig.8.jpg&quot; alt=&quot;90-fig.8.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;驗證Document&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;POST _ingest/pipeline/Nginx/_simulate
{
  &amp;quot;docs&amp;quot;: [
    {
      &amp;quot;_source&amp;quot;: {
        &amp;quot;message&amp;quot;: &amp;quot;127.0.0.1 - - [06/May/2022:06:44:01 +0000] , http-host: &#92;&amp;quot;abc.boxing.com&#92;&amp;quot; , URL: &#92;&amp;quot;GET /static/tpl/analytics/index.html?v=51817715.1 HTTP/1.1&#92;&amp;quot;  , request-status : &#92;&amp;quot;200&#92;&amp;quot;  ,   body-byte: 0  ,http-referer: &#92;&amp;quot;https://abc.boxing.com/mobile&#92;&amp;quot;  ,user-agent: &#92;&amp;quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&#92;&amp;quot; , X-Forwarded-For : &#92;&amp;quot;132.235.211.18,10.107.10.14&#92;&amp;quot; ,   request-time: &#92;&amp;quot;0.000&#92;&amp;quot;  , response_time : &#92;&amp;quot;-&#92;&amp;quot;&amp;quot;
      }
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;修改grok&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;
PUT _ingest/pipeline/Nginx
{
  &amp;quot;description&amp;quot;: &amp;quot;My optional pipeline description&amp;quot;,
  &amp;quot;processors&amp;quot;: [
    {
      &amp;quot;grok&amp;quot;: {
        &amp;quot;description&amp;quot;: &amp;quot;Extract fields from &#39;message&#39;&amp;quot;,
        &amp;quot;field&amp;quot;: &amp;quot;message&amp;quot;,
        &amp;quot;patterns&amp;quot;: [&amp;quot;%{IPORHOST:nginx.source.ip} %{USER:nginx.user.id} %{USER:nginx.user.name} &#92;&#92;[%{HTTPDATE:nginx.@timestamp}&#92;&#92;] , http-host: &#92;&amp;quot;%{DATA:nginx.url.host}&#92;&amp;quot; , URL: &#92;&amp;quot;%{WORD:nginx.http.request.method} %{DATA:nginx.url.path} HTTP/%{NUMBER:nginx.http.version}&#92;&amp;quot;  , request-status : &#92;&amp;quot;%{NUMBER:nginx.http.response.status_code:int}&#92;&amp;quot;  ,   body-byte: %{NUMBER:nginx.http.response.body.bytes:int}  ,http-referer: &#92;&amp;quot;%{DATA:nginx.http.request.referer}&#92;&amp;quot;  ,user-agent: %{QS:nginx.user_agent} , X-Forwarded-For : &#92;&amp;quot;%{DATA:nginx.http.request.xff}&#92;&amp;quot; ,   request-time: &#92;&amp;quot;%{NUMBER:nginx.http.request.time}&#92;&amp;quot;  , response_time : &#92;&amp;quot;(?:-|%{NUMBER:nginx.http.request.time:int})&#92;&amp;quot;&amp;quot;],
         &amp;quot;ignore_failure&amp;quot;: false
      }
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ignore_failure 為忽略錯誤，false的話，只要有一個沒過，&lt;br /&gt;
ingest pipeline就會停止。&lt;/p&gt;
&lt;h3 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h3&gt;
&lt;p&gt;上述兩種方法，都可以建立且測試，就看哪種習慣。&lt;br /&gt;
但要將ingest 套用到data stream 或 index的話，&lt;br /&gt;
又是另一篇了....。&lt;/p&gt;
&lt;p&gt;不趕時間的方法，到  Index Managemenet 修改 Index  Templates&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/90-fig.9.jpg&quot; alt=&quot;90-fig.9.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;到 index settings 將 default_pipeline 修改為你的 ingest pipeline name&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/90-fig.10.jpg&quot; alt=&quot;90-fig.10.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然後就等 lifecycle條件達到時，建立新的index，就會套用上去了。&lt;/p&gt;
&lt;p&gt;趕時間的話，請看下一篇。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/ingest.html#set-default-pipeline&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;set-default-pipeline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/index-modules.html#index-default-pipeline&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;index.default_pipeline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://elasticstack.blog.csdn.net/article/details/105790798&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elasticsearch：Elastic可觀測性 - 運用 pipeline 使數據結構化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/EFK/90. elasticsearch ingest pipeline/" />
        </entry>
        <entry>
            <title>
                84.Elasticsearch筆記
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/EFK/84.Elasticsearch筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;上一篇是拿來修正目前版本與2.x版本的差異&lt;br /&gt;
這篇是拿來當筆記&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&quot;兩種查詢方式&quot; tabindex=&quot;-1&quot;&gt;兩種查詢方式&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;GET /megacorp/_search?q=last_name:Smith
GET /megacorp/_search
{
    &amp;quot;query&amp;quot; : {
        &amp;quot;match&amp;quot; : {
            &amp;quot;last_name&amp;quot; : &amp;quot;Smith&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&quot;搜尋方式&quot; tabindex=&quot;-1&quot;&gt;搜尋方式&lt;/h3&gt;
如果用kibana搜尋的話，差異就在一個有加 &amp;quot;&amp;quot;(雙引號)，另一個沒有&lt;br /&gt;
match_phrase ： 是有加雙引號的短句搜尋&lt;br /&gt;
match ： 是全文搜尋，分數越高的表示關連度越高&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/84-fig.1.jpg&quot; alt=&quot;84-fig.1.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&quot;aggreations&quot; tabindex=&quot;-1&quot;&gt;aggreations(聚合)&lt;/h3&gt;
類似sql的 group by 功能&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&quot;叢集健康度&quot; tabindex=&quot;-1&quot;&gt;叢集健康度&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;  GET _cluster/health/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;status 的狀態&lt;/p&gt;
&lt;p&gt;green：所有的主分片和副本分片都正常運行。&lt;br /&gt;
yellow：所有的主分片都正常運行，但不是所有的副本分片都正常運行。&lt;br /&gt;
red：有主分片沒能正常運行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&quot;node&quot; tabindex=&quot;-1&quot;&gt;集群node配對方式&lt;/h3&gt;
cluster.name相同，就會自動發現集群並加入。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/EFK/84.Elasticsearch筆記/" />
        </entry>
        <entry>
            <title>
                80. ECK 8.1 ,APM intergration安裝方式
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/EFK/80. ECK 8.1 ,APM intergration安裝方式/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;一兩個月沒看，沒想到版本就衝到8.1了，&lt;br /&gt;
照以前的做法，發現一堆錯誤，&lt;br /&gt;
precondition &#39;apm integration installed&#39; failed: error querying Elasticsearch for integration index templates: unexpected HTTP status: 404 Not Found..&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;版本升級後，架構變成下圖(1)&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/80-fig.0.png&quot; alt=&quot;80-fig.0.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以才導致下圖的錯誤發生，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/80-fig.1.jpg&quot; alt=&quot;80-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;原因是，ECK升級，&lt;br /&gt;
所以統一要先在kibana上面先安裝 APM intergration。&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;If you install version 8.2.0 of APM Server before installing the APM integration, you will see error logs similar to the following. You must go back and install the APM integration before data can be ingested into Elasticsearch.&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.elastic.co/guide/en/apm/guide/master/upgrade-8.0-self-standalone.html#_upgrade_steps&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Upgrade a self-installation of APM Server standalone to 8.2.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Step 1.&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/80-fig.2.jpg&quot; alt=&quot;80-fig.2.jpg&quot; /&gt;&lt;br /&gt;
Step 2.&lt;/p&gt;
&lt;p&gt;安裝APM server即可，安裝完後，&lt;br /&gt;
選擇 『Add Elastic Agent later』。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/80-fig.3.jpg&quot; alt=&quot;80-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
1. &lt;a href=&quot;https://www.elastic.co/guide/en/apm/guide/current/upgrade-to-apm-integration.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Upgrade to the Elastic APM integration&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/EFK/80. ECK 8.1 ,APM intergration安裝方式/" />
        </entry>
        <entry>
            <title>
                69. kibana錯誤解法 , parent Data too large...
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/EFK/69. kibana錯誤解法 , parent Data too large.../</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;最近用kibana做查詢或任何的API取資料時，&lt;br /&gt;
有機率會發生下列的錯誤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[parent] Data too large, data for [&amp;lt;http_request&amp;gt;] would be [1054296800/1005.4mb],&lt;br /&gt;
which is larger than the limit of [1020054732/972.7mb],&lt;br /&gt;
real usage: [1054296800/1005.4mb],&lt;br /&gt;
new bytes reserved: [0/0b], usages [request=83853312/79.9mb,&lt;br /&gt;
fielddata=0/0b, in_flight_requests=0/0b, model_inference=0/0b,&lt;br /&gt;
eql_sequence=0/0b, accounting=23686052/22.5mb]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;雖然說很偶發，但最近有越來越嚴重的趨勢。&lt;/p&gt;
&lt;p&gt;所以，鼻子摸一摸，來解決吧。&lt;/p&gt;
&lt;p&gt;首先看到這一篇  &lt;a href=&quot;https://discuss.elastic.co/t/what-does-this-error-mean-data-too-large-data-for-transport-request/209345&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;What does this error mean - Data too large, data for [&amp;lt;transport_request&amp;gt;]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這邊有很好的解釋，發生的原因。&lt;/p&gt;
&lt;p&gt;簡單說就是ES本身的斷路器發生作用，&lt;br /&gt;
導致請求失敗。&lt;/p&gt;
&lt;p&gt;斷路器的文章可參考下面&lt;br /&gt;
ref .&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/circuit-breaker.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;circuit breaker 斷路器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面的錯誤的意思表示，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[&amp;lt;http_request&amp;gt;] would be [1054296800/1005.4mb],&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;http_request的請求需要 1005.4 mb&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;which is larger than the limit of [1020054732/972.7mb],&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;請求的上限是 972.7mb&lt;/p&gt;
&lt;p&gt;此時可以到 DevTools ，輸入下面指令[1]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET _cat/nodes?v=true&amp;amp;h=name,node*,heap*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/69-fig.1.jpg&quot; alt=&quot;69-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到目前的記憶體使用量（注意，此圖並不是事發當下的記憶體使用量）&lt;/p&gt;
&lt;p&gt;解決方式[2]：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;當下查看heap.max 只有1G ，故先加大記憶體到2G。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: elasticsearch.k8s.elastic.co/v1
kind: Elasticsearch
metadata:
  name: yabo
  namespace: elastic-system
spec:
  version: 7.16.2
  nodeSets:
  - name: all
    count: 3
    podTemplate:
      spec:
        containers:
        - name: elasticsearch
          env:
          - name: ES_JAVA_OPTS
            value: -Xms2g -Xmx2g
          resources:
            requests:
              memory: 4Gi
            limits:
              memory: 4Gi  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-managing-compute-resources.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Manage compute resources&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;shards數量太多&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同樣50G的檔案，5個10G，跟1個50G  shards，&lt;br /&gt;
前者的ram使用量會比較多。&lt;br /&gt;
但shards設太高，當node 掛掉時，&lt;br /&gt;
回復的時間會變長。&lt;/p&gt;
&lt;p&gt;修改ILM的shard大小，建議範圍是在 10G~50G 之間，&lt;br /&gt;
但仍要視情況而定。&lt;br /&gt;
ref. &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/size-your-shards.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Size your shards&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
[1] : &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/68.ECK%20,%20api%E7%AD%86%E8%A8%98/&quot;&gt;68.ECK , api筆記&lt;/a&gt;&lt;br /&gt;
[2] : &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.14/fix-common-cluster-issues.html#high-jvm-memory-pressure&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; Fix common cluster issues&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/EFK/69. kibana錯誤解法 , parent Data too large.../" />
        </entry>
        <entry>
            <title>
                68.ECK , api筆記
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/EFK/68.ECK , api筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;在所有的api後面，加上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;v=true     顯示標題
sort=column name    排序
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查詢目前的es記憶體使用量&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;GET _cat/nodes?v=true&amp;amp;h=name,node*,heap*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;詳細的資料&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET _nodes/stats?filter_path=nodes.*.jvm.mem.pools.old
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.14/fix-common-cluster-issues.html#circuit-breaker-errors&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Fix common cluster issues&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顯示cluster狀態&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;GET _cluster/health/
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;顯示shard 明細&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;GET _cat/shards/filebeat*?v=true&amp;amp;s=index
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;顯示index明細&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;GET _cat/indices/filebeat*?v=true&amp;amp;s=index
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/EFK/68.ECK , api筆記/" />
        </entry>
        <entry>
            <title>
                67. ECK，filebeat LOG蒐集遺失
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/EFK/67. ECK，filebeat LOG蒐集遺失/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;最近同事回報說，pod 有些log沒有進到ECK裏面去，&lt;br /&gt;
一查還真的是這樣，&lt;br /&gt;
但QA環境沒問題，&lt;br /&gt;
偏偏Prod就炸了。&lt;/p&gt;
&lt;p&gt;本來也有想說是不是真的沒有log，&lt;br /&gt;
到filebeat的pod去查，那些沒進去的pod log也都是存在。&lt;/p&gt;
&lt;p&gt;log路徑&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/var/log/containers/
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;故先排除，服務沒有寫入log的可能性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;會不會是filebeat在讀取log時的暫存空間不足。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但如果是此情況的話，應該是全部的filebeat都會有log遺失，這次的情況是在某些node上的服務 log都有進到ES，&lt;br /&gt;
其他的node都沒有。但也是有此可能性。&lt;/p&gt;
&lt;p&gt;調整filebeat內部資源&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/ninjavan-tech/logging-with-efk-in-gke-e11676f781e6&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Logging with EFK in GKE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/configuring-internal-queue.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Configure the internal queue&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;filebeat一直重啟&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之後跑去看filebeat的pod狀態，&lt;br /&gt;
發現有很多個pod常常不斷的重新啟動，&lt;br /&gt;
再到裡面去看詳細內容，&lt;br /&gt;
發現cpu跟 記憶體的使用量很高，&lt;br /&gt;
推測可能是由於資源不足導致。&lt;/p&gt;
&lt;p&gt;查詢filebeat官方建議的使用資源是多少。&lt;/p&gt;
&lt;p&gt;filebeat建議使用&lt;br /&gt;
cpu : 500Mi&lt;br /&gt;
memory: 500Mi&lt;/p&gt;
&lt;p&gt;改完後，觀察了約一個禮拜，lod都有持續進去，應該是沒問題，但容量也因此爆增了。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-managing-compute-resources.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Manage compute resources&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/EFK/67. ECK，filebeat LOG蒐集遺失/" />
        </entry>
        <entry>
            <title>
                61. kibana 查詢語法
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/EFK/61. kibana 查詢語法/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;KQL其實沒很複雜，&lt;br /&gt;
建議把介紹&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/7.15/kuery-query.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kibana Query Language&lt;/a&gt;看完後基本上就會了。&lt;/p&gt;
&lt;p&gt;主要常用的是，使用 特定欄位搜尋，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;萬用字元 *&lt;/p&gt;
&lt;p&gt;例如，&lt;br /&gt;
今天要搜尋一個 pod Name 叫 grafana&lt;br /&gt;
那KQL 可輸入&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubernetes.pod.name: *grafana*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;搜尋出來的名稱，只要是 中間有 grafana的通通會列出。&lt;/p&gt;
&lt;p&gt;覺得前面名稱太長的話，&lt;a href=&quot;http://xn--pod-0v1e893z.name/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;輸入pod.name&lt;/a&gt;，用下拉選擇就好。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;引號使用&amp;quot; &amp;quot;&lt;br /&gt;
將裡面的字變成一個詞搜尋&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	message: &amp;quot;hello world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;不使用引號&lt;br /&gt;
裡面的字都會分別搜尋，已下面來說就是 會搜尋 hello 跟 world&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubernetes.pod.name: hello world
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;and 跟 or 條件&lt;br /&gt;
多條件查詢&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	message: &amp;quot;hello world&amp;quot; and kubernetes.pod.name:*grafana*
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;not 否定&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	not (kubernetes.pod.name: *grafana*)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;大於 小於 等於 判斷式  &amp;gt;, &amp;gt;= , &amp;lt;,&amp;lt;=&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	@timestamp &amp;lt; &amp;quot;2021-01-30&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;
&lt;p&gt;還有一種不使用KQL的查詢，Lucene&lt;br /&gt;
這種語法可支援正則表達式，但KQL不支援。&lt;br /&gt;
ref.&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/7.15/lucene-query.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Lucene query syntax&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nested fields 看來是可以查詢整串的json&lt;br /&gt;
但我想不到可以運用在哪&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜尋x-forward-for ip&lt;br /&gt;
有一個log如下圖，這個特別奇怪，不能加雙引號，&lt;br /&gt;
『.』 在kibana裡面似乎有特殊的用法，&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/61-fig.1.jpg&quot; alt=&quot;61-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubernetes.namespace: istio-sigua and message: 103.170.26.90*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要加雙引號的話，就必須搜尋完整的ip。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubernetes.namespace: istio-sigua and message: &amp;quot;221.210.89.170,10.120.17.1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;追根究底，還是要把message對應到欄位...&lt;br /&gt;
沒時間用阿QQ...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜尋url path&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubernetes.namespace: istio-sigua and message: &amp;quot;img/huawei_ans02.c7bcdbdf.jpg&amp;quot;
kubernetes.namespace: istio-sigua and message: &amp;quot;img*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;11&quot;&gt;
&lt;li&gt;特殊字元&lt;br /&gt;
如果要用特殊字元查詢的話，要加上 &#92; ，&lt;br /&gt;
但只限於下列這些關鍵字&lt;pre&gt;&lt;code&gt;+ - &amp;amp;&amp;amp; || ! ( ) { } [ ] ^ &amp;quot; ~ * ? : &#92; /
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/7.15/kuery-query.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kibana Query Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codingnote.cc/zh-hk/p/289218/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kibana查詢語言（KQL）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/cjfeii/article/details/79771399&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kibana查詢語法詳解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jesse.top/2020/08/25/elk/kibana%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kibana查詢語法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.aliyun.com/article/770157&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;大神都這麼做，讓 Kibana 搜索語法 query string 也能輕松上手&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/EFK/61. kibana 查詢語法/" />
        </entry>
        <entry>
            <title>
                60. ECK的 kibana 警告， server.publicBaseUrl is missing
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/EFK/60. ECK的 kibana 警告， server.publicBaseUrl is missing/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;kibana時常這個警告出來，&lt;br /&gt;
但我一直找不到config要在哪設定。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/60-fig.1.png&quot; alt=&quot;60-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;之後問了另外一組的大大，他之前也在弄ECK，&lt;br /&gt;
給了我這段。&lt;br /&gt;
加一個config在yaml裡面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: kibana.k8s.elastic.co/v1
kind: Kibana
metadata:
  name: yabo
  namespace: elastic-system
spec:
  version: 7.15.0
  count: 1
  config:
    server.publicBaseUrl: http://123.232.162/
  elasticsearchRef:
    name: yabo
  http:
    tls:
      selfSignedCertificate:
        disabled: true
    service:
      spec:
        ports:
          - name: http
            port: 5601
            targetPort: 5601    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://debugah.com/solved-kibana-7-14-0-error-server-publicbaseurl-is-missing-and-should-be-configured-when-running-in-a-production-environment-18768/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [Solved] Kibana 7.14.0 error: server.publicBaseUrl is missing and should be configured when running in a production environment.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/current/settings.html#server-basePath&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Configure Kibana&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/EFK/60. ECK的 kibana 警告， server.publicBaseUrl is missing/" />
        </entry>
        <entry>
            <title>
                57.filebeat 補充說明
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/EFK/57.filebeat 補充說明/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h2 id=&quot;filebeat&quot; tabindex=&quot;-1&quot;&gt;filebeat抓資料的方式&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;autodiscover&lt;/li&gt;
&lt;li&gt;without autodiscover&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要注意的是，如果用(2) 的方式，在GKE上面，你要使用 add_kubernetes_metadata，去取得pod name,namespace..等，&lt;br /&gt;
通通抓不到。&lt;/p&gt;
&lt;p&gt;因為(2)是直接去node的log裡面抓資料，並沒有透過api的方式，&lt;br /&gt;
所以如果要取得 pod name的話，可能要從log path着手。&lt;br /&gt;
應該是可以從ingest 去處理。&lt;/p&gt;
&lt;p&gt;但用(1)，資料就通通進來了。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/57.fig-1.jpg&quot; alt=&quot;57.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以還是用(1)吧。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-beat-configuration-examples.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Configuration Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/add-kubernetes-metadata.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Add Kubernetes metadata&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;排除資料的方式&quot; tabindex=&quot;-1&quot;&gt;排除資料的方式&lt;/h2&gt;
&lt;p&gt;沒有記錄log不知道，一記錄了才知道。&lt;br /&gt;
資料有夠肥。&lt;/p&gt;
&lt;p&gt;開始跟同仁說，沒有必要的不要留。&lt;br /&gt;
但有些是先天限制，就是會拼命印，那該怎麼解決。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;排除訊息內的特定文字，通通不收&lt;br /&gt;
在autodiscover 底下使用 exclude_lines&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;autodiscover:
  providers:
  - type: kubernetes
    node: ${NODE_NAME}                                              
    hints:
      enabled: true
      default_config:
        type: container
        paths:
        - /var/log/containers/*${data.kubernetes.container.id}.log
        exclude_lines: 
        - &amp;quot;.*(NAT rule custom-iptables|unknown operand).*&amp;quot;  # 排除 k8s-custom-iptables
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-log.html#filebeat-input-log-exclude-lines&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Log input&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;排除特定namespace&lt;br /&gt;
在  processors 底下加 drop_event，這邊有用到condition的條件，建議看一下文件比較清楚。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;processors:
- add_cloud_metadata: {}
- drop_event.when:
    or:
    - equals:
        kubernetes.namespace: &amp;quot;kube-system&amp;quot;
    - equals:
        kubernetes.namespace: &amp;quot;elastic-system&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/drop-event.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Drop events&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/60566173/how-we-can-filter-namespace-in-filebeat-kubernetes&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;how-we-can-filter-namespace-in-filebeat-kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/defining-processors.html#conditions&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;conditions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;移除特定欄位&quot; tabindex=&quot;-1&quot;&gt;移除特定欄位&lt;/h2&gt;
&lt;p&gt;有些欄位得到的值是重複的，&lt;br /&gt;
所以這些也都可以砍掉。&lt;br /&gt;
processors 底下加  drop_fields&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;processors:
- drop_fields:
      fields: 
        - &#39;kubernetes.node&#39;
        - &#39;kubernetes.namespace_uid&#39;
        - &#39;agent.hostname&#39;
        - &#39;cloud.account&#39;
        - &#39;cloud.provider&#39;
        - &#39;cloud.instance.name&#39;
        - &#39;container.id&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/drop-fields.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Drop fields from events&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;詳細參數說明&quot; tabindex=&quot;-1&quot;&gt;詳細參數說明&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type: log &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#input類型為log&quot;&gt;#input類型為log&lt;/a&gt;
enable: true &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#表示是該log類型配置生效&quot;&gt;#表示是該log類型配置生效&lt;/a&gt;
paths：     &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#指定要監控的日誌，目前按照Go語言的glob函數處理。沒有對配置目錄做遞歸處理，比如配置的如果是：&quot;&gt;#指定要監控的日誌，目前按照Go語言的glob函數處理。沒有對配置目錄做遞歸處理，比如配置的如果是：&lt;/a&gt;
- /var/log/* /*.log  &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#則只會去/var/log目錄的所有子目錄中尋找以&quot;&gt;#則只會去/var/log目錄的所有子目錄中尋找以&lt;/a&gt;&amp;quot;.log&amp;quot;結尾的文件，而不會尋找/var/log目錄下以&amp;quot;.log&amp;quot;結尾的文件。
recursive_glob.enabled: &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#啟用全局遞歸模式，例如/foo/&quot;&gt;#啟用全局遞歸模式，例如/foo/&lt;/a&gt;**包括/foo, /foo/*, /foo/*/*
encoding：#指定被監控的文件的編碼類型，使用plain和utf-8都是可以處理中文日誌的
exclude_lines: [&#39;^DBG&#39;] &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#不包含匹配正則的行&quot;&gt;#不包含匹配正則的行&lt;/a&gt;
include_lines: [&#39;^ERR&#39;, &#39;^WARN&#39;]  &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#包含匹配正則的行&quot;&gt;#包含匹配正則的行&lt;/a&gt;
harvester_buffer_size: 16384 &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#每個harvester在獲取文件時使用的緩沖區的字節大小&quot;&gt;#每個harvester在獲取文件時使用的緩沖區的字節大小&lt;/a&gt;
max_bytes: 10485760 &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#單個日誌消息可以擁有的最大字節數。max_bytes之後的所有字節都被丟棄而不發送。默認值為10MB&quot;&gt;#單個日誌消息可以擁有的最大字節數。max_bytes之後的所有字節都被丟棄而不發送。默認值為10MB&lt;/a&gt; (10485760)
exclude_files: [&#39;&#92;.gz$&#39;]  &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#用於匹配希望Filebeat忽略的文件的正則表達式列表&quot;&gt;#用於匹配希望Filebeat忽略的文件的正則表達式列表&lt;/a&gt;
ingore_older: 0 &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#默認為0，表示禁用，可以配置2h，2m等，注意ignore_older必須大於close_inactive的值&quot;&gt;#默認為0，表示禁用，可以配置2h，2m等，注意ignore_older必須大於close_inactive的值&lt;/a&gt;.表示忽略超過設置值未更新的
文件或者文件從來沒有被harvester收集
close_* &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#close_&quot;&gt;#close_&lt;/a&gt; *配置選項用於在特定標准或時間之後關閉harvester。 關閉harvester意味著關閉文件處理程序。 如果在harvester關閉
後文件被更新，則在scan_frequency過後，文件將被重新拾取。 但是，如果在harvester關閉時移動或刪除文件，Filebeat將無法再次接收文件
，並且harvester未讀取的任何數據都將丟失。
close_inactive  &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#啟動選項時，如果在制定時間沒有被讀取，將關閉文件句柄&quot;&gt;#啟動選項時，如果在制定時間沒有被讀取，將關閉文件句柄&lt;/a&gt;
讀取的最後一條日誌定義為下一次讀取的起始點，而不是基於文件的修改時間
如果關閉的文件發生變化，一個新的harverster將在scan_frequency運行後被啟動
建議至少設置一個大於讀取日誌頻率的值，配置多個prospector來實現針對不同更新速度的日誌文件
使用內部時間戳機制，來反映記錄日誌的讀取，每次讀取到最後一行日誌時開始倒計時使用2h 5m 來表示
close_rename &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#當選項啟動，如果文件被重命名和移動，filebeat關閉文件的處理讀取&quot;&gt;#當選項啟動，如果文件被重命名和移動，filebeat關閉文件的處理讀取&lt;/a&gt;
close_removed &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#當選項啟動，文件被刪除時，filebeat關閉文件的處理讀取這個選項啟動後，必須啟動clean_removed&quot;&gt;#當選項啟動，文件被刪除時，filebeat關閉文件的處理讀取這個選項啟動後，必須啟動clean_removed&lt;/a&gt;
close_eof &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#適合只寫一次日誌的文件，然後filebeat關閉文件的處理讀取&quot;&gt;#適合只寫一次日誌的文件，然後filebeat關閉文件的處理讀取&lt;/a&gt;
close_timeout &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#當選項啟動時，filebeat會給每個harvester設置預定義時間，不管這個文件是否被讀取，達到設定時間後，將被關閉&quot;&gt;#當選項啟動時，filebeat會給每個harvester設置預定義時間，不管這個文件是否被讀取，達到設定時間後，將被關閉&lt;/a&gt;
close_timeout 不能等於ignore_older,會導致文件更新時，不會被讀取如果output一直沒有輸出日誌事件，這個timeout是不會被啟動的，
至少要要有一個事件發送，然後haverter將被關閉
設置0 表示不啟動
clean_inactived &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#從注冊表文件中刪除先前收獲的文件的狀態&quot;&gt;#從注冊表文件中刪除先前收獲的文件的狀態&lt;/a&gt;
設置必須大於ignore_older+scan_frequency，以確保在文件仍在收集時沒有刪除任何狀態
配置選項有助於減小注冊表文件的大小，特別是如果每天都生成大量的新文件
此配置選項也可用於防止在Linux上重用inode的Filebeat問題
clean_removed &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#啟動選項後，如果文件在磁盤上找不到，將從注冊表中清除filebeat&quot;&gt;#啟動選項後，如果文件在磁盤上找不到，將從注冊表中清除filebeat&lt;/a&gt;
如果關閉close removed 必須關閉clean removed
scan_frequency &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#prospector檢查指定用於收獲的路徑中的新文件的頻率&quot;&gt;#prospector檢查指定用於收獲的路徑中的新文件的頻率&lt;/a&gt;,默認10s
tail_files：#如果設置為true，Filebeat從文件尾開始監控文件新增內容，把新增的每一行文件作為一個事件依次發送，
而不是從文件開始處重新發送所有內容。
symlinks：#符號鏈接選項允許Filebeat除常規文件外,可以收集符號鏈接。收集符號鏈接時，即使報告了符號鏈接的路徑，
Filebeat也會打開並讀取原始文件。
backoff： &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#backoff選項指定Filebeat如何積極地抓取新文件進行更新。默認1s，backoff選項定義Filebeat在達到EOF之後&quot;&gt;#backoff選項指定Filebeat如何積極地抓取新文件進行更新。默認1s，backoff選項定義Filebeat在達到EOF之後&lt;/a&gt;
再次檢查文件之間等待的時間。
max_backoff： &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#在達到EOF之後再次檢查文件之前Filebeat等待的最長時間&quot;&gt;#在達到EOF之後再次檢查文件之前Filebeat等待的最長時間&lt;/a&gt;
backoff_factor： &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#指定backoff嘗試等待時間幾次，默認是2&quot;&gt;#指定backoff嘗試等待時間幾次，默認是2&lt;/a&gt;
harvester_limit：#harvester_limit選項限制一個prospector並行啟動的harvester數量，直接影響文件打開數

tags &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#列表中添加標簽，用過過濾，例如：tags&quot;&gt;#列表中添加標簽，用過過濾，例如：tags&lt;/a&gt;: [&amp;quot;json&amp;quot;]
fields &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#可選字段，選擇額外的字段進行輸出可以是標量值，元組，字典等嵌套類型&quot;&gt;#可選字段，選擇額外的字段進行輸出可以是標量值，元組，字典等嵌套類型&lt;/a&gt;
默認在sub-dictionary位置
filebeat.inputs:
fields:
app_id: query_engine_12
fields_under_root &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#如果值為ture，那麼fields存儲在輸出文檔的頂級位置&quot;&gt;#如果值為ture，那麼fields存儲在輸出文檔的頂級位置&lt;/a&gt;

multiline.pattern &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#必須匹配的regexp模式&quot;&gt;#必須匹配的regexp模式&lt;/a&gt;
multiline.negate &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#定義上面的模式匹配條件的動作是&quot;&gt;#定義上面的模式匹配條件的動作是&lt;/a&gt; 否定的，默認是false
假如模式匹配條件&#39;^b&#39;，默認是false模式，表示講按照模式匹配進行匹配 將不是以b開頭的日誌行進行合並
如果是true，表示將不以b開頭的日誌行進行合並
multiline.match # 指定Filebeat如何將匹配行組合成事件,在之前或者之後，取決於上面所指定的negate
multiline.max_lines &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#可以組合成一個事件的最大行數，超過將丟棄，默認500&quot;&gt;#可以組合成一個事件的最大行數，超過將丟棄，默認500&lt;/a&gt;
multiline.timeout &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#定義超時時間，如果開始一個新的事件在超時時間內沒有發現匹配，也將發送日誌，默認是5smax_procs&quot;&gt;#定義超時時間，如果開始一個新的事件在超時時間內沒有發現匹配，也將發送日誌，默認是5smax_procs&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#設置可以同時執行的最大CPU數。默認值為系統中可用的邏輯CPU的數量。name&quot;&gt;#設置可以同時執行的最大CPU數。默認值為系統中可用的邏輯CPU的數量。name&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#為該filebeat指定名字，默認為主機的hostname&quot;&gt;#為該filebeat指定名字，默認為主機的hostname&lt;/a&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/zsql/p/13137833.htmll&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;一篇文章搞懂filebeat（ELK）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;filebeat-log&quot; tabindex=&quot;-1&quot;&gt;filebeat log寫入到檔案&lt;/h2&gt;
&lt;p&gt;filebeat在運作時，會產生一堆log，這些我原本都不想讓他輸出，直接寫在自己的檔案就好。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/57.fig-2.jpg&quot; alt=&quot;57.fig-2.jpg&quot; /&gt;&lt;br /&gt;
但沒測試成功，最後只好採用治標不治本的方式，&lt;br /&gt;
在該namespace底下的log通通不進ES。&lt;/p&gt;
&lt;p&gt;留一下查到的資料。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;logging:
    to_files: true
    metrics.enabled: false 
    files:
      path: &#39;/usr/share/filebeat/logs&#39;
      name: &#39;filebeat&#39;
      rotateeverybytes: 10485760 # = 10MB
      keepfiles: 7
      permission: &#39;0640&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/configuration-logging.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Configure logging&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;yaml-operator&quot; tabindex=&quot;-1&quot;&gt;完整yaml，使用operator&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: beat.k8s.elastic.co/v1beta1
kind: Beat
metadata:
  name: yabo
  namespace: elastic-system
spec:
  type: filebeat
  version: 7.15.0
  elasticsearchRef:
    name: yabo
  kibanaRef:
    name: yabo
  config:
    filebeat:
      autodiscover:
        providers:
        - type: kubernetes
          node: ${NODE_NAME}
          # templates:
          #   - condition:
          #       not:
          #         equals:
          #           kubernetes.namespace: kube-system
              #         - kubernetes.namespace: elastic-system 
              # config:
              #   - type: container
              #     paths:
              #     - /var/log/containers/*${data.kubernetes.container.id}.log                                                  
          hints:
            enabled: true
            default_config:
              type: container
              paths:
              - /var/log/containers/*${data.kubernetes.container.id}.log
              exclude_lines: 
              - &amp;quot;.*(NAT rule custom-iptables|unknown operand).*&amp;quot;  # 排除 k8s-custom-iptables
              - &amp;quot;.*(YABO_WS.Services.PromoWebSocketService|YABO_WS.BLL.ActivityEventLogic).*&amp;quot;      # 排除yabo-ws
    processors:
    - add_cloud_metadata: {}
    # - add_host_metadata: {}
    - drop_event.when:
        or:
        - equals:
            kubernetes.namespace: &amp;quot;kube-system&amp;quot;
        - equals:
            kubernetes.namespace: &amp;quot;elastic-system&amp;quot;
    - drop_fields:
          fields: 
            - &#39;kubernetes.node&#39;
            - &#39;kubernetes.namespace_uid&#39;
            - &#39;agent.hostname&#39;
            - &#39;cloud.account&#39;
            - &#39;cloud.provider&#39;
            - &#39;cloud.instance.name&#39;
            - &#39;container.id&#39;
    - decode_json_fields:
          fields: [&amp;quot;message&amp;quot;]
          target: &amp;quot;&amp;quot;
          overwrite_keys: true   
    # 測試沒用，無法寫到 
    # logging:
    #   to_files: true
    #   metrics.enabled: false 
    #   files:
    #     path: &#39;/usr/share/filebeat/logs&#39;
    #     name: &#39;filebeat&#39;
    #     rotateeverybytes: 10485760 # = 10MB
    #     keepfiles: 7
    #     permission: &#39;0644&#39;
  daemonSet:
    podTemplate:
      spec:
        serviceAccountName: filebeat
        automountServiceAccountToken: true
        terminationGracePeriodSeconds: 30
        dnsPolicy: ClusterFirstWithHostNet
        hostNetwork: true # Allows to provide richer host metadata
        containers:
        - name: filebeat
          securityContext:
            runAsUser: 0
            # If using Red Hat OpenShift uncomment this:
            &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#privileged&quot;&gt;#privileged&lt;/a&gt;: true
          volumeMounts:
          - name: varlogcontainers
            mountPath: /var/log/containers
          - name: varlogpods
            mountPath: /var/log/pods
          - name: varlibdockercontainers
            mountPath: /var/lib/docker/containers
          env:
            - name: NODE_NAME
              valueFrom:
                fieldRef:
                  fieldPath: spec.nodeName
        volumes:
        - name: varlogcontainers
          hostPath:
            path: /var/log/containers
        - name: varlogpods
          hostPath:
            path: /var/log/pods
        - name: varlibdockercontainers
          hostPath:
            path: /var/lib/docker/containers
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: filebeat
rules:
- apiGroups: [&amp;quot;&amp;quot;] # &amp;quot;&amp;quot; indicates the core API group
  resources:
  - namespaces
  - pods
  - nodes
  verbs:
  - get
  - watch
  - list
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: filebeat
  namespace: elastic-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: filebeat
subjects:
- kind: ServiceAccount
  name: filebeat
  namespace: elastic-system
roleRef:
  kind: ClusterRole
  name: filebeat
  apiGroup: rbac.authorization.k8s.io

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/jatq/articles/14651723.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ECK部署&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://arch-long.cn/articles/elasticsearch/FileBeat.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;FileBeat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.codeless.me/posts/elastic-beats-on-google-kubernetes-engine-gke/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elastic Beats on Google Kubernetes Engine (GKE)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/DanRoscigno/GKE-on-Prem-logging-and-metrics/blob/master/filebeat-kubernetes.yaml&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;filebeat-kubernetes.yaml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.deepnetwork.com/blog/2020/01/27/ELK-stack-filebeat-k8s-deployment.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to Setup an ELK Stack and Filebeat on Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/EFK/57.filebeat 補充說明/" />
        </entry>
        <entry>
            <title>
                55. es基本概念篇
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/EFK/55. es基本概念篇/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;先來個比較容易對比的表格，但不完全一樣，&lt;br /&gt;
有幾個是我自己加上去的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;RDBMS&lt;/th&gt;
&lt;th&gt;Elasticsearch&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;VM&lt;/td&gt;
&lt;td&gt;Node&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Table&lt;/td&gt;
&lt;td&gt;Index&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Row&lt;/td&gt;
&lt;td&gt;Document&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Column&lt;/td&gt;
&lt;td&gt;Field&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Schema&lt;/td&gt;
&lt;td&gt;Mapping&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SQL&lt;/td&gt;
&lt;td&gt;DSL&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://godleon.github.io/blog/Elasticsearch/Elasticsearch-getting-started/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Elasticsearch] 基本概念 &amp;amp; 搜尋入門&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;摘要&quot; tabindex=&quot;-1&quot;&gt;摘要&lt;/h2&gt;
&lt;h4 id=&quot;node&quot; tabindex=&quot;-1&quot;&gt;Node&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Master Node&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;處理建立/刪除 index 的 request，並實際執行&lt;/li&gt;
&lt;li&gt;決定每個 shard 要被分配到哪個 data node 上&lt;/li&gt;
&lt;li&gt;維護 &amp;amp; 更新 cluster state&lt;/li&gt;
&lt;li&gt;當 master node出問題，master eligible node（從cluster設定多個）會開始選舉，選出下一個 master node&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Coordinating Node(協調節點)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有node預設都是 Coordinating Node&lt;/li&gt;
&lt;li&gt;處理request的node 以及 最後進行結果的彙整&lt;/li&gt;
&lt;li&gt;coordinating node 可以直接接收 search request 並處理，不需要透過 master node 轉過來&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Data Node&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以保存資料的 node，每個 node 啟動後都會預設是 data node，可以透過設定 &lt;code&gt;node.data: false&lt;/code&gt; 停用 data node 功能&lt;/li&gt;
&lt;li&gt;透過增加 data node 可以解決資料水平擴展 &amp;amp; 解決單點故障導致資料遺失的問題&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cluster State（集群狀態)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包含所有node資訊&lt;/li&gt;
&lt;li&gt;包含所有index 及 相對應的 mapping/setting配置&lt;/li&gt;
&lt;li&gt;shard的路由資訊&lt;/li&gt;
&lt;li&gt;每個node上都有Cluster State，只有master 可修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;shard&quot; tabindex=&quot;-1&quot;&gt;Shard&lt;/h4&gt;
&lt;h6 id=&quot;shard-1&quot; tabindex=&quot;-1&quot;&gt;將索引劃分成多份的能力，這些份就叫做分片（shard）&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;shard 是 ES分散式儲存的基礎，包含 primary shard 及 replica shard&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每一個shard 就是一個  Lucene instance(用於全文檢索和搜尋 e.g. Solr,Elasticsearch...)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Primary Shard(提升系統儲存容量)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將一份被索引後的資料，分散到多個data node上存放&lt;/li&gt;
&lt;li&gt;primary shard 的數量在建立 index時就會指定，無法後續修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Replica Shard（提高資料可用性)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當primary shard遺失，Replica shard可以被推成 primary shard&lt;/li&gt;
&lt;li&gt;replica shard數量可動態調整，讓每個data node上都有完整資料&lt;/li&gt;
&lt;li&gt;可一定程度提高查詢的效能&lt;/li&gt;
&lt;li&gt;ES7.0開始，primary shard 預設為1 ,replica shard預設 為0&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如不設定replica shard，一旦data node 故障導致 primary shard遺失，資料無法復原&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shard設定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;replica shard設定過多，會降低clsuter整體的寫入效能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;replica shard 必須和 primary shard 被分配在不同的 data node 上；但所有的 primary shard 可以在同一個 data node 上&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;command&quot; tabindex=&quot;-1&quot;&gt;Command&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;取得Cluster 健康狀態&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	GET _cluster/health/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Status&lt;br /&gt;
- Green ：表示 Primary shard &amp;amp; Replica Shard可正常分配&lt;br /&gt;
- Yellow：表示 Primay shard可正常分配，但Replica shard 分配有問題&lt;br /&gt;
- Red：有Primary shard 無法正常分配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;取得 Shard狀態&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	GET _cat/shards
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/55.fig-1.jpg&quot; alt=&quot;55.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;p ：代表 primary shard&lt;br /&gt;
r  ：代表 replica shard&lt;br /&gt;
2. shard的分佈情形，在哪個node上&lt;br /&gt;
3. 每個shard包含的document數量 &amp;amp; 空間&lt;/p&gt;
&lt;h4 id=&quot;情境&quot; tabindex=&quot;-1&quot;&gt;情境&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;如果cluster 只有一個node ，全部會被 primary shard佔據，導致 replica shard 無法被分配，因此cluster健康狀態為 yellow&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;資料寫入&quot; tabindex=&quot;-1&quot;&gt;資料寫入&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;cache&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;資料寫入後無法變動，避免lock機制所帶來的效能問題&lt;/li&gt;
&lt;li&gt;因不可變動，若要讓新的document 可被搜尋，需要重建index&lt;/li&gt;
&lt;li&gt;寫入document前，會先寫到 Index Buffer的儲存空間&lt;/li&gt;
&lt;li&gt;滿足條件(Index Buffer佔滿) or 特定時間(預設一秒一次)，會將 Buffer 寫入 Segment 。寫入的過程叫Refresh。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;transaction log&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每個shard都有對應的transaction log&lt;/li&gt;
&lt;li&gt;寫入document的時候，同時也會寫入 transaction log&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://godleon.github.io/blog/Elasticsearch/Elasticsearch-distributed-mechanism/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Elasticsearch] 分散式特性 &amp;amp; 分散式搜尋的機制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/UbuntuTouch/article/details/99443042&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elasticsearch 中的一些重要概念: cluster, node, index, document, shards 及 replica&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/EFK/55. es基本概念篇/" />
        </entry>
        <entry>
            <title>
                53. apm error
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/EFK/53. apm error/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;錯誤訊息&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There are no ingest nodes in this cluster, unable to forward request to an ingest node.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ES的yaml&lt;br /&gt;
增加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;node.roles:
- ingest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Node&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/UbuntuTouch/article/details/99702199&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;如何在 Elasticsearch 中使用 pipeline API 來對事件進行處理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://discuss.elastic.co/t/there-are-no-ingest-nodes-in-this-cluster-unable-to-forward-request-to-an-ingest-node/279740&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;There are no ingest nodes in this cluster, unable to forward request to an ingest node&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/EFK/53. apm error/" />
        </entry>
        <entry>
            <title>
                52. ILM 設定
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/EFK/52. ILM 設定/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;使用預設的filebeat.yaml設定，&lt;br /&gt;
導致現在elasticsearch的log爆炸了。&lt;br /&gt;
連開都開不起來。&lt;br /&gt;
所以這次要解決兩個問題，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自動刪除舊的log&lt;/li&gt;
&lt;li&gt;將log根據日期分配&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;經過一早上的研究，發現我想得跟我要解決的問題不一樣XDDD&lt;/p&gt;
&lt;p&gt;所以本文會在探討ILM的設定&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;有些觀念跟我想得不一樣，&lt;br /&gt;
下圖看到的 indices，是在elasticSearch（簡稱ES）上，&lt;br /&gt;
所建立的。&lt;/p&gt;
&lt;p&gt;ES上的indices會長這樣&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/52-fig.1.jpg&quot; alt=&quot;52-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以跟fileBeat沒有關係，fileBeat只負責把資料丟過去ES上。&lt;/p&gt;
&lt;p&gt;當然裡面也有一些設定，等以後有空再來研究。&lt;/p&gt;
&lt;p&gt;首先到 kibana的畫面，&lt;br /&gt;
到 Management 中去設定ILM&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/52-fig.2.jpg&quot; alt=&quot;52-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;裡面的設定，請參考下面文章，&lt;br /&gt;
或是直接看英文也可以懂。&lt;/p&gt;
&lt;p&gt;但最好先看一下文章，es的 indices 區分成三個階段，&lt;br /&gt;
改完設定後，並不會立即生效，只有當過度到下一個階段的時候，配置才會生效。&lt;/p&gt;
&lt;p&gt;也就是說，如果你一直在 Hot phase，&lt;br /&gt;
那永遠不會執行你剛設定的參數。&lt;/p&gt;
&lt;p&gt;但一當你進入Warm phase時，&lt;br /&gt;
你剛剛設定的參數就都會執行了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/52-fig.3.jpg&quot; alt=&quot;52-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;另外在各個 phase ，能做的事情也都不一樣。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Index Lifecycle Management 的階段&lt;/th&gt;
&lt;th&gt;此階段中可以執行的操作有什麼&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Hot&lt;/td&gt;
&lt;td&gt;Force merge, Rollover, Set priority, Unfollow&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Warm&lt;/td&gt;
&lt;td&gt;Allocate, Force merge, Read only, Set priority, Shrink, Unfollow&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cold&lt;/td&gt;
&lt;td&gt;Allocate, Freeze, Set priority, Unfollow&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Delete&lt;/td&gt;
&lt;td&gt;Delete, Wait for snapshot&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;像要刪除 indices 的話，就必須要到 Delete phase的階段才可以。&lt;/p&gt;
&lt;p&gt;ps. 如果發現沒有看到 delete phase，&lt;br /&gt;
要先把下圖的開關切換過去，delete phase 才會出現。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/52-fig.4.jpg&quot; alt=&quot;52-fig.4.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;設定完後，可以到 Dev Tools ，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查詢有哪些 indices&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;GET /_cat/indices

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/52-fig.5.jpg&quot; alt=&quot;52-fig.5.jpg&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查indices狀態&lt;br /&gt;
將右邊的 indics，取代下面的url 。&lt;br /&gt;
這邊使用的 indices 名稱為 filebeat-7.15.0-2021.10.07-000001 ，如果要知道json內的內容意義，請參考下面連結『Explain lifecycle API』。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;GET filebeat-7.15.0-2021.10.07-000001/_ilm/explain
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/52-fig.6.jpg&quot; alt=&quot;52-fig.6.jpg&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;啟動 ILM&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;POST /_ilm/start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10244575&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;喬叔教 Elastic - 11 - 管理 Index 的 Best Practices (3/7) - Index Lifecycle Management (ILM)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/cn/blog/implementing-hot-warm-cold-in-elasticsearch-with-index-lifecycle-management&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用索引生命週期管理實現熱溫冷架構&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.7/ilm-explain-lifecycle.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Explain lifecycle API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://discuss.elastic.co/t/automatically-delete-old-indices/190276&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Automatically delete old indices&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;跟這次的問題沒關係，但還是留個連結&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://shazi.info/filebeat-harvester-%E7%9A%84-file-handler-close-%E8%88%87-clean-%E6%A9%9F%E5%88%B6/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Filebeat harvester 的 file handler close 與 clean 機制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.51cto.com/u_10120275/2132800&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;filebeat進程寫滿磁盤的情況處理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codingnote.cc/zh-tw/p/134769/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;一篇文章搞懂filebeat（ELK）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/whych/p/9958188.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Filebeat配置參考手冊&lt;/a&gt;]&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;curator&quot; tabindex=&quot;-1&quot;&gt;curator&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.twblogs.net/a/5e511223bd9eee21167f04b2&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;elasticsearch curator安裝及應用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@vidyasonawane20/install-and-configure-elasticsearch-curator-to-delete-the-old-indices-acee09344852&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Install and configure Elasticsearch Curator to delete the old indices.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.johnwu.cc/article/elk-purge-elasticsearch-index.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ELK 教學 - 定期清除 Elasticsearch 資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/EFK/52. ILM 設定/" />
        </entry>
        <entry>
            <title>
                43.自建ECK on GKE
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/EFK/43.自建ECK on GKE/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;Elastic Cloud on Kubernetes 簡化了在 Kubernetes 中運行 Elasticsearch 和 Kibana 的作業，包括設置、升級、快照、擴展、高可用性、安全性等&lt;/p&gt;
&lt;p&gt;istio 安裝時，開log&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;istioctl manifest install -f loadBalancerSourceRange.yaml --set meshConfig.accessLogFile=/dev/stdout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或是更改yaml ，加上 meshConfig這段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kind: IstioOperator
apiVersion: install.istio.io/v1alpha1
metadata:
  annotations:
    install.istio.io/ignoreReconcile: &#39;true&#39;
  name: istio-external
  namespace: istio-system
spec:
  meshConfig:
    accessLogFile: /dev/stdout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ECK&lt;/p&gt;
&lt;p&gt;Kubernetes before 1.16以上版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl create -f https://download.elastic.co/downloads/eck/2.1.0/crds.yaml
kubectl apply -f https://download.elastic.co/downloads/eck/2.1.0/operator.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需先安裝 elasticsearch Operator&lt;br /&gt;
ref.&lt;a href=&quot;https://operatorhub.io/operator/elastic-cloud-eck&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elasticsearch (ECK) Operator&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;佈署 elasticsearch&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
apiVersion: elasticsearch.k8s.elastic.co/v1
kind: Elasticsearch
metadata:
  name: quickstart
spec:
  version: 7.15.0
  nodeSets:
  - name: default
    count: 1
    config:
      node.store.allow_mmap: false
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;檢查狀態&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	kubectl get elasticsearch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到pod裡面測試elastic是否正常&lt;br /&gt;
密碼需使用 kubectl get secret  取得&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl https://10.107.201.126:9200 -u &#39;elastic:J1fO9bu8adfsepYK8rIu91a73o&#39; -k
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正常的話，會顯示&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/43-fig.0.jpg&quot; alt=&quot;43-fig.0.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;佈署kibana&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
apiVersion: kibana.k8s.elastic.co/v1
kind: Kibana
metadata:
  name: quickstart
spec:
  version: 7.15.0
  count: 1
  elasticsearchRef:
    name: quickstart
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;檢查狀態&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	kubectl get kibana
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;登入&lt;/p&gt;
&lt;p&gt;帳號：elastic&lt;br /&gt;
密碼：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get secret quickstart-es-elastic-user -o=jsonpath=&#39;{.data.elastic}&#39; | base64 --decode; echo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;轉port&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl port-forward service/quickstart-kb-http 5601
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;url : &lt;a href=&quot;https://localhost:5601/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://localhost:5601&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;beat&quot; tabindex=&quot;-1&quot;&gt;beat&lt;/h1&gt;
&lt;p&gt;Beats 其實是一系列工具的總稱，可以解決下列的問題：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;讀取檔案&lt;/li&gt;
&lt;li&gt;提取指標&lt;/li&gt;
&lt;li&gt;提取網路資料&lt;/li&gt;
&lt;li&gt;測試服務可用性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有這些 Filebeat, Metricbeat,Heartbeat,Packetbeat...等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/GeZmgxJ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;查詢目前有哪些index了&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/43-fig.1.jpg&quot; alt=&quot;43-fig.1.jpg&quot; /&gt;&lt;br /&gt;
到DevTools執行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET _cat/indices?s=index
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://www.elastic.co/beats/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Beats&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10235198&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;【ES新手，破門而入！】Day9 - 我見故我在！Observability 基礎之趴特睡&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10236378&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;【ES新手，破門而入！】Day13 - 關於 Metrics 的 23456 事&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;filebeat&quot; tabindex=&quot;-1&quot;&gt;Filebeat&lt;/h2&gt;
&lt;p&gt;日誌處理工具，只要會產生日誌的地方都可以使用它，它可以幫助你將日誌傳送到 Elasticsearch 或其他的系統。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Bj8v2F5.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
log 位置&lt;br /&gt;
/var/log/containers&lt;/p&gt;
&lt;p&gt;查詢傳了哪些資料到elastic search裡面。&lt;br /&gt;
同樣使用 Devtools&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET filebeat-*/_search
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/43-fig.2.jpg&quot; alt=&quot;43-fig.2.jpg&quot; /&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/57.filebeat%20%E8%A3%9C%E5%85%85%E8%AA%AA%E6%98%8E/&quot;&gt;57.filebeat 補充說明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://linyencheng.github.io/2020/09/09/elastic-observability-logging-introduction/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elastic Logging X Filebeat 深入理解&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;metricsbeat&quot; tabindex=&quot;-1&quot;&gt;Metricsbeat&lt;/h2&gt;
&lt;p&gt;將指標傳送到 Elasticsearch 分析，並搭配 Kibana 做視覺化。&lt;/p&gt;
&lt;p&gt;指標著重在資訊的週期性測量，讓我們可以瞭解系統的狀態如硬碟空間、CPU使用率等等。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10235524&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ES新手，破門而入！】Day10 - 眼見為憑！Observability 基礎之趴特佛&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;apm&quot; tabindex=&quot;-1&quot;&gt;APM&lt;/h2&gt;
&lt;p&gt;APM 的全名是 Application Performance Monitoring（應用程式效能監控），是用來回答下面兩個主要的問題：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;應用程式要花多久時間來答覆請求（request）？&lt;/li&gt;
&lt;li&gt;應用程式遇到什麼種類的錯誤？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Elastic APM 是由下列 4 個組件所構成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;APM Agents&lt;/li&gt;
&lt;li&gt;APM Server&lt;/li&gt;
&lt;li&gt;Elasticsearch&lt;/li&gt;
&lt;li&gt;Kibana&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/kyuDM8Q.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;apm-server&quot; tabindex=&quot;-1&quot;&gt;佈署APM server&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
apiVersion: apm.k8s.elastic.co/v1
kind: ApmServer
metadata:
  name: apm-server-quickstart
  namespace: default
spec:
  version: 7.15.0
  count: 1
  elasticsearchRef:
    name: quickstart
  kibanaRef:
    name: quickstart
  config:
    output:
      elasticsearch:
        host: [quickstart-es-http.default:9200]
        username: elastic
        password: &amp;quot;E1R10XXXXXXfr40&amp;quot;
        protocol: &amp;quot;http&amp;quot;
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊的password要直接下指令查詢，這個是前面登入kibana的密碼。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get secret quickstart-es-elastic-user -o=jsonpath=&#39;{.data.elastic}&#39; | base64 --decode; echo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;為了環境單純，所以只使用http，要用https請參考連結 &lt;a href=&quot;https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-apm-advanced-configuration.html#k8s-apm-existing-es&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Reference an existing Elasticsearch cluster&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://linyencheng.github.io/2020/09/12/elastic-apm-fundamentals/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elastic APM 基礎教學&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10235524&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ES新手，破門而入！】Day10 - 眼見為憑！Observability 基礎之趴特佛&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-apm-server.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Run APM Server on ECK&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;go-apm-agent&quot; tabindex=&quot;-1&quot;&gt;GO-APM agent&lt;/h2&gt;
&lt;p&gt;在建立 apm-server的時候，&lt;br /&gt;
會同時建立好 secret token ，這個同樣需要下指令取得，&lt;br /&gt;
之後在 agent上面設定完，才能將資料傳到 APM server上面。&lt;/p&gt;
&lt;p&gt;這邊取config  name為 ( [apm name]apm-token )&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  kubectl get secret apm-server-quickstart-apm-token -o=jsonpath=&#39;{.data.secret-token}&#39; | base64 --decode; echo
  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;設定APM server環境變數，由於我的服務都是docker image，&lt;br /&gt;
所以要把變數寫在Dockerfile裡面，當打包時，一併設定好&lt;a href=&quot;https://www.elastic.co/guide/en/apm/agent/go/current/configuration.html#config-server-url&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;環境變數&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
...
ENV ELASTIC_APM_SERVER_URL=https://apm-server-quickstart-apm-http.default:8200
ENV ELASTIC_APM_SERVICE_NAME=webhook
ENV ELASTIC_APM_SECRET_TOKEN=9m9XXXXXXGjwdIk41
ENV ELASTIC_APM_VERIFY_SERVER_CERT=false
ENV ELASTIC_APM_ENVIRONMENT=qa
...

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後再 main.go ，加上下面幾行。&lt;br /&gt;
這份go的程式，本身使用了 &lt;a href=&quot;https://www.elastic.co/guide/en/apm/agent/go/current/builtin-modules.html#builtin-modules-apmgorilla&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gorilla/mux&lt;/a&gt;的web框架&lt;/p&gt;
&lt;p&gt;所以照官方文件的說明，加上下面幾行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import (
	&amp;quot;github.com/gorilla/mux&amp;quot;

	&amp;quot;go.elastic.co/apm/module/apmgorilla&amp;quot;
)

func main() {
	router := mux.NewRouter()
	apmgorilla.Instrument(router)
	http.ListenAndServe(&amp;quot;:80&amp;quot;, router)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要只有  apmgorilla.Instrument(router) 這行，&lt;br /&gt;
然後只要有經過80 port的資料就通通都會進入到APM裡面了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/43-fig.3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;這張圖裡面的TPS意思，可參考 &lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.vercel.app/404&quot;&gt;blog.45.網站效能指標一覽（未）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://www.elastic.co/guide/en/cloud-on-k8s/master/k8s-apm-connecting.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;APM Server secret token&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.elastic.co/cn/blog/how-to-instrument-your-go-app-with-the-elastic-apm-go-agent&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;如何使用 Elastic APM Go 代理為 Go 應用裝載測量工具&lt;/a&gt;&lt;br /&gt;
[&lt;a href=&quot;https://myapollo.com.tw/zh-tw/docker-env/&quot; title=&quot;Docker 環境變數使用筆記&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Docker 環境變數使用筆記&lt;/a&gt;](&lt;a href=&quot;https://myapollo.com.tw/zh-tw/docker-env/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://myapollo.com.tw/zh-tw/docker-env/&lt;/a&gt;)&lt;br /&gt;
&lt;a href=&quot;https://www.gushiciku.cn/pl/pYOg/zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elastic APM-Go Agent介紹(中文翻譯)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.elastic.co/guide/en/cloud-on-k8s/master/k8s-apm-connecting.html#k8s-apm-secret-token&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;connect to the APM Server&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/UbuntuTouch/article/details/105527468&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Solutions：安全的APM服務器訪問&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;vue-apm-agent&quot; tabindex=&quot;-1&quot;&gt;vue-APM agent&lt;/h2&gt;
&lt;p&gt;安裝依賴套件&lt;/p&gt;
&lt;h2 id=&quot;kibana&quot; tabindex=&quot;-1&quot;&gt;Kibana&lt;/h2&gt;
&lt;div class=&quot;transclusion internal-embed is-loaded&quot;&gt;&lt;a class=&quot;markdown-embed-link&quot; href=&quot;https://daimom.vercel.app/efk/61-kibana/&quot; aria-label=&quot;Open link&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;svg-icon lucide-link&quot;&gt;&lt;path d=&quot;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;div class=&quot;markdown-embed&quot;&gt;
&lt;h1 id=&quot;前言-1&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文-1&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;KQL其實沒很複雜，&lt;br /&gt;
建議把介紹&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/7.15/kuery-query.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kibana Query Language&lt;/a&gt;看完後基本上就會了。&lt;/p&gt;
&lt;p&gt;主要常用的是，使用 特定欄位搜尋，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;萬用字元 *&lt;/p&gt;
&lt;p&gt;例如，&lt;br /&gt;
今天要搜尋一個 pod Name 叫 grafana&lt;br /&gt;
那KQL 可輸入&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubernetes.pod.name: *grafana*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;搜尋出來的名稱，只要是 中間有 grafana的通通會列出。&lt;/p&gt;
&lt;p&gt;覺得前面名稱太長的話，&lt;a href=&quot;http://xn--pod-0v1e893z.name/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;輸入pod.name&lt;/a&gt;，用下拉選擇就好。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;引號使用&amp;quot; &amp;quot;&lt;br /&gt;
將裡面的字變成一個詞搜尋&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	message: &amp;quot;hello world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;不使用引號&lt;br /&gt;
裡面的字都會分別搜尋，已下面來說就是 會搜尋 hello 跟 world&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubernetes.pod.name: hello world
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;and 跟 or 條件&lt;br /&gt;
多條件查詢&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	message: &amp;quot;hello world&amp;quot; and kubernetes.pod.name:*grafana*
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;not 否定&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	not (kubernetes.pod.name: *grafana*)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;大於 小於 等於 判斷式  &amp;gt;, &amp;gt;= , &amp;lt;,&amp;lt;=&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	@timestamp &amp;lt; &amp;quot;2021-01-30&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;
&lt;p&gt;還有一種不使用KQL的查詢，Lucene&lt;br /&gt;
這種語法可支援正則表達式，但KQL不支援。&lt;br /&gt;
ref.&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/7.15/lucene-query.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Lucene query syntax&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nested fields 看來是可以查詢整串的json&lt;br /&gt;
但我想不到可以運用在哪&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜尋x-forward-for ip&lt;br /&gt;
有一個log如下圖，這個特別奇怪，不能加雙引號，&lt;br /&gt;
『.』 在kibana裡面似乎有特殊的用法，&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/61-fig.1.jpg&quot; alt=&quot;61-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubernetes.namespace: istio-sigua and message: 103.170.26.90*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要加雙引號的話，就必須搜尋完整的ip。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubernetes.namespace: istio-sigua and message: &amp;quot;221.210.89.170,10.120.17.1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;追根究底，還是要把message對應到欄位...&lt;br /&gt;
沒時間用阿QQ...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜尋url path&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubernetes.namespace: istio-sigua and message: &amp;quot;img/huawei_ans02.c7bcdbdf.jpg&amp;quot;
kubernetes.namespace: istio-sigua and message: &amp;quot;img*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;11&quot;&gt;
&lt;li&gt;特殊字元&lt;br /&gt;
如果要用特殊字元查詢的話，要加上 &#92; ，&lt;br /&gt;
但只限於下列這些關鍵字&lt;pre&gt;&lt;code&gt;+ - &amp;amp;&amp;amp; || ! ( ) { } [ ] ^ &amp;quot; ~ * ? : &#92; /
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/7.15/kuery-query.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kibana Query Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codingnote.cc/zh-hk/p/289218/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kibana查詢語言（KQL）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/cjfeii/article/details/79771399&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kibana查詢語法詳解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jesse.top/2020/08/25/elk/kibana%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kibana查詢語法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.aliyun.com/article/770157&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;大神都這麼做，讓 Kibana 搜索語法 query string 也能輕松上手&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/7.15/kuery-query.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kibana Query Language&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/EFK/43.自建ECK on GKE/" />
        </entry>
        <entry>
            <title>
                111. filebeat error
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/EFK/111. filebeat error/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;禮拜一上班就聽同事再說，filebeat stage環境有問題，&lt;br /&gt;
我還在禮拜一症候群阿~~&lt;br /&gt;
哎～SRE的宿命，先修吧&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;一開始的問題很簡單，就output service設定錯誤，&lt;br /&gt;
無法連線。&lt;/p&gt;
&lt;p&gt;改完後，換另一個錯誤。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Validation Failed: 1: this action would add [2] total shards, but this cluster currently has [1000]/[1000] maximum shards open&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/EFK/111.fig-1.jpg&quot; alt=&quot;111.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;google一下，就看到&lt;a href=&quot;https://shazi.info/elasticsearch-7-x-node-%E9%96%8B%E6%94%BE-1000-%E5%80%8B-shards-%E9%99%90%E5%88%B6/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elasticsearch 7.x node 開放 1000 個 shards 限制&lt;/a&gt;了。&lt;br /&gt;
上面連結是用curl 打網址直接改，下面是到dev Tools下指令，&lt;br /&gt;
所以有點不一樣。&lt;br /&gt;
到kibana上的dev tools加上這段，把1000的上限拉大。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PUT _cluster/settings
{
  &amp;quot;persistent&amp;quot;: { 
    &amp;quot;cluster.max_shards_per_node&amp;quot;: &amp;quot;3000&amp;quot; 
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-update-settings.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;cluster-update-settings&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;non-zero-metrics-in-the-last-30s&quot; tabindex=&quot;-1&quot;&gt;Non-zero metrics in the last 30s&lt;/h3&gt;
&lt;p&gt;看filebeat裏面的訊息，一直出現這串。&lt;br /&gt;
關掉吧。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# If enabled, filebeat periodically logs its internal metrics that have changed
# in the last period. For each metric that changed, the delta from the value at
# the beginning of the period is logged. Also, the total values for
# all non-zero internal metrics are logged on shutdown. The default is true.
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#logging&quot;&gt;#logging&lt;/a&gt;.metrics.enabled: true

# The period after which to log the internal metrics. The default is 30s.
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#logging&quot;&gt;#logging&lt;/a&gt;.metrics.period: 30s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但在filebeat yaml中，是這樣的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;logging:
  metrics.enabled: false
  level: info
  to_files: true
  files:
    path: /var/log/filebeat
    name: filebeat
    keepfiles: 7
    permissions: 0644   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.  &lt;a href=&quot;https://discuss.elastic.co/t/non-zero-metrics-in-the-last-30s-meaning/173970&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Non-zero metrics in the last 30s: meaning&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/EFK/111. filebeat error/" />
        </entry>
        <entry>
            <title>
                0.EFK MOC
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/EFK/0.EFK MOC/</id>
            <content type="html">
                &lt;h1 id=&quot;概念&quot; tabindex=&quot;-1&quot;&gt;概念&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/55.%20es%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%AF%87/&quot;&gt;55. es基本概念篇&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.vercel.app/404&quot;&gt;81. Beat vs elastic agent&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.vercel.app/404&quot;&gt;83. Elasticsearch 權威指南 修正&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/84.Elasticsearch%E7%AD%86%E8%A8%98/&quot;&gt;84.Elasticsearch筆記&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;建置&quot; tabindex=&quot;-1&quot;&gt;建置&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/43.%E8%87%AA%E5%BB%BAECK%20on%20GKE/&quot;&gt;43.自建ECK on GKE&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;設定&quot; tabindex=&quot;-1&quot;&gt;設定&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/54.%20istio%20%E6%8E%9B%E8%BC%89ECK%20kibana/&quot;&gt;54. istio 掛載ECK kibana&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/52.%20ILM%20%E8%A8%AD%E5%AE%9A/&quot;&gt;52. ILM 設定&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/57.filebeat%20%E8%A3%9C%E5%85%85%E8%AA%AA%E6%98%8E/&quot;&gt;57.filebeat 補充說明&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/80.%20ECK%208.1%20,APM%20intergration%E5%AE%89%E8%A3%9D%E6%96%B9%E5%BC%8F/&quot;&gt;80. ECK 8.1 ,APM intergration安裝方式&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/90.%20elasticsearch%20ingest%20pipeline/&quot;&gt;90. elasticsearch ingest pipeline&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/91.%20elasticsearch%20ingest%20processor%E8%A3%9C%E5%85%85/&quot;&gt;91. elasticsearch ingest processor補充&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;usage&quot; tabindex=&quot;-1&quot;&gt;Usage&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/68.ECK%20,%20api%E7%AD%86%E8%A8%98/&quot;&gt;68.ECK , api筆記&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/61.%20kibana%20%E6%9F%A5%E8%A9%A2%E8%AA%9E%E6%B3%95/&quot;&gt;Kibana一般使用者查詢語法&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.vercel.app/404&quot;&gt;86. efk apm圖表&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/53.%20apm%20error/&quot;&gt;53. apm error&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/60.%20ECK%E7%9A%84%20kibana%20%E8%AD%A6%E5%91%8A%EF%BC%8C%20server.publicBaseUrl%20is%20missing/&quot;&gt;60. ECK的 kibana 警告， server.publicBaseUrl is missing&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/67.%20ECK%EF%BC%8Cfilebeat%20LOG%E8%92%90%E9%9B%86%E9%81%BA%E5%A4%B1/&quot;&gt;67. ECK，filebeat LOG蒐集遺失&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/69.%20kibana%E9%8C%AF%E8%AA%A4%E8%A7%A3%E6%B3%95%20,%20parent%20Data%20too%20large.../&quot;&gt;69. kibana錯誤解法 , parent Data too large...&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/EFK/111.%20filebeat%20error/&quot;&gt;111. filebeat error&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/EFK/0.EFK MOC/" />
        </entry>
        <entry>
            <title>
                78. drone k8s-runner 進階設定
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Drone/78. drone k8s-runner 進階設定/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;再上篇 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Drone/72.%20drone%20on%20GKE%20%E5%BB%BA%E7%AB%8B/&quot;&gt;72. drone on GKE 建立&lt;/a&gt;，有談到k8s runner，&lt;br /&gt;
那時候都在default 的 namespace上面運作，&lt;br /&gt;
所以沒什麼問題，&lt;br /&gt;
但一到了正式環境，要切專門的namespace，&lt;br /&gt;
就陣亡拉)))))&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;這篇會講到兩個東西，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RBAC(Role-based Access Control)&lt;/li&gt;
&lt;li&gt;drone k8s-runner policy&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;step-1&quot; tabindex=&quot;-1&quot;&gt;Step 1.&lt;/h3&gt;
&lt;p&gt;先從Cloud RBAC開始說起，&lt;/p&gt;
&lt;p&gt;基本概念如下圖&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/78-fig.1.png&quot; alt=&quot;78-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: default
  name: drone
rules:
- apiGroups:
  - &amp;quot;&amp;quot;
  resources:
  - secrets
  verbs:
  - create
  - delete
- apiGroups:
  - &amp;quot;&amp;quot;
  resources:
  - pods
  - pods/log
  verbs:
  - get
  - create
  - delete
  - list
  - watch
  - update

---

kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: drone
  namespace: default
subjects:
- kind: ServiceAccount
  name: default
  namespace: default
roleRef:
  kind: Role
  name: drone
  apiGroup: rbac.authorization.k8s.io
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;role ： 設定權限能做什麼事&lt;br /&gt;
roleBinding ： 要將哪個角色綁定權限到sa帳號&lt;/p&gt;
&lt;p&gt;這邊簡單說明roleBinding （因rolebinding的roleRef 無法指定ns)，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;將 role, namespace 在 default 的 drone 跟&lt;br /&gt;
serviceAccount的 namespace在 default 的 default 綁在一起，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更細項的說明，請參考 (1)~(4)&lt;/p&gt;
&lt;p&gt;當服務沒有指定是哪一個 『serviceAccountName』，就會使用預設的default 。&lt;/p&gt;
&lt;p&gt;所以，如果將namespace通通改成drone的話，會發生什麼事？&lt;br /&gt;
會先在drone的畫面看到 skip&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/78-fig.3.jpg&quot; alt=&quot;78-fig.3.jpg&quot; /&gt;&lt;br /&gt;
然後查看 k8s-runner的 log，會看到沒有權限，被拒絕執行。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/78-fig.2.jpg&quot; alt=&quot;78-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;step-2&quot; tabindex=&quot;-1&quot;&gt;Step 2.&lt;/h3&gt;
&lt;p&gt;再來要解決權限問題，&lt;br /&gt;
因為k8s-runner，預設都是使用 default(namespace)的default再建立pod。&lt;/p&gt;
&lt;p&gt;所以，現在有兩種做法（這邊會講第二種做法）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;role的權限，給他能夠在不同的ns也能佈署的權限（這部分應該是建立clusterRole，沒試過）。&lt;/li&gt;
&lt;li&gt;k8s-runner在pipeline時，要求在指定的namespace做動作。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;建立一個 policy(5) 的 yml，&lt;br /&gt;
底下的關鍵欄位，有在碰k8s的應該都很熟，&lt;br /&gt;
match這塊要再測試看看，這邊就先註解掉。&lt;br /&gt;
（文件上是說 ，可以用來定義多個policy用，&lt;br /&gt;
當有符合時，就執行下面的policy）&lt;/p&gt;
&lt;p&gt;這邊設定規則是，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;佈署時，佈署到drone的namespace ，&lt;br /&gt;
資源請求是 512Mi,節點選擇的label 是 disktype: ssd&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;kind: policy
name: drone

# match:
#   repo:
#   - &amp;quot;octocat/*&amp;quot;
#   - &amp;quot;octocat/hello-world&amp;quot;

metadata:
  namespace: drone

resources:
  request:
    memory: 512MiB
  # limit:
  #   cpu: 4000
  #   memory: 1GiB

node_selector:
  disktype: ssd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再來要在runner裡面掛載這個檔案，直接用 configMap將檔案載入。&lt;/p&gt;
&lt;p&gt;建立configmap&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; kubectl create configmap -n drone drone-policy --from-file=policy.yml --dry-run=client -o yaml | kubectl apply -f -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;k8s-runner內掛載configmap&lt;br /&gt;
要特別注意env ，&lt;br /&gt;
DRONE_POLICY_FILE(6)，需要指定你的yml位置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name:  drone-runner-k8s
  namespace: drone
  labels:
    drone:  runner-k8s
spec:
  replicas: 1
  selector:
    matchLabels:
      drone:  runner-k8s
  template:
    metadata:
      labels:
        drone:  runner-k8s
    spec:
      containers:
      - name: runner
        image: drone/drone-runner-kube:latest
        ports:
        - containerPort: 3000
        volumeMounts:
        - mountPath: /policy.yml
          name: policy
          subPath: policy.yml
        env:
        - name: DRONE_POLICY_FILE
          value: /policy.yml        
      volumes:
      - configMap:
          defaultMode: 420
          name: drone-policy
        name: policy  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;附註，如果node_selector，選擇的節點是ssd的硬碟的話，&lt;br /&gt;
時間會減少 35%。 但每個月會多13塊美金。&lt;/p&gt;
&lt;p&gt;再來下篇應該就是寫將drone完整導入istio的做法了&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 RBAC 鑑權&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.orchome.com/1308&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes權限管理之RBAC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10252766?sc=rss.iron&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Day-28 瞭解 Namespace 與 Rbac&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://godleon.github.io/blog/Kubernetes/k8s-How-to-access-resource-legally/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Kubernetes] 如何取得合法可用的權限，讓 pod 與 API server 溝通&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.drone.io/runner/kubernetes/configuration/policies/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Policies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.drone.io/runner/kubernetes/configuration/reference/drone-policy-file/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;DRONE_POLICY_FILE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jimmysong.io/kubernetes-handbook/guide/configure-pod-service-account.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;配置 Pod 的 Service Account&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.vercel.app/Drone/78. drone k8s-runner 進階設定/" />
        </entry>
        <entry>
            <title>
                77. drone build Open Source Edition
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Drone/77. drone build Open Source Edition/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;在某一天，drone就跳出來了 『Your license limit is exceeded。』&lt;br /&gt;
當下真是嚇死我了，當天又是維護日，&lt;br /&gt;
一堆程式要上版，自動佈署掛掉就完了，要通通手動上。&lt;br /&gt;
還好，沒事，只是跳個通知在那邊，查了一些文件，&lt;br /&gt;
都沒說到期了會怎樣，就這樣過了兩個月，&lt;br /&gt;
也都沒事發生，本來想繼續撐下去的，&lt;br /&gt;
但有其他東西要用，就順便一起動了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/77-fig.1.jpg&quot; alt=&quot;77-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;官方文件有寫到關於權限的部分，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Your license limit is exceeded ，這個是因為你build 超過了5000次，然後你又是直接抓官方版本的image才會出現這個通知。（OS：一開始測試當然直接抓官方的image來用阿...）&lt;/li&gt;
&lt;li&gt;基本上只要是年收入沒到 1 million（美金）的公司，都能免費使用，但要自己打包image。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他細項，可自行參考&lt;a href=&quot;https://docs.drone.io/enterprise/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;官方網站&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;build-image&quot; tabindex=&quot;-1&quot;&gt;Build image&lt;/h3&gt;
&lt;p&gt;我們可以先從官方的github看看，他們是怎麼編譯的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/harness/drone/blob/v2.9.1/.drone.yml&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;drone.yml&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先執行， &lt;a href=&quot;https://github.com/harness/drone/blob/v2.9.1/scripts/build.sh&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;scripts/build.sh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;再根據 &lt;a href=&quot;https://github.com/harness/drone/blob/v2.9.1/docker/Dockerfile.agent.linux.amd64&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;docker/Dockerfile.server.linux.amd64&lt;/a&gt; 的dockerfile去打包程式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面這段，直接存成dockerfile去編譯吧，&lt;br /&gt;
版本號自行更改。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;補充說明，&quot; tabindex=&quot;-1&quot;&gt;補充說明，&lt;/h4&gt;
&lt;p&gt;docker 在編譯的時候，&lt;br /&gt;
每一行指令 (前面有加 RUN 或COPY..的這種算一行），&lt;br /&gt;
都算是一個新的image，可以看到sha256的數值都不一樣，&lt;br /&gt;
所以用 cd drone 切 路徑的話，要再同一行把要執行的command，&lt;br /&gt;
都執行完。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM golang AS Builder

ENV DRONE_VERSION v2.9.1
WORKDIR $GOPATH/src
RUN git clone  https://github.com/drone/drone --branch ${DRONE_VERSION} --single-branch
RUN cd drone &amp;amp;&amp;amp; pwd  &amp;amp;&amp;amp; go mod download &amp;amp;&amp;amp; &#92;
   go build -ldflags &amp;quot;-extldflags &#92;&amp;quot;-static&#92;&amp;quot;&amp;quot; -tags=&amp;quot;nolimit&amp;quot; github.com/drone/drone/cmd/drone-server


FROM alpine:3.13 AS Certs

RUN apk add -U --no-cache ca-certificates

FROM alpine:3.13
EXPOSE 80 443
VOLUME /data

RUN [ ! -e /etc/nsswitch.conf ] &amp;amp;&amp;amp; echo &#39;hosts: files dns&#39; &amp;gt; /etc/nsswitch.conf

ENV GODEBUG netdns=go
ENV XDG_CACHE_HOME /data
ENV DRONE_DATABASE_DRIVER sqlite3
ENV DRONE_DATABASE_DATASOURCE /data/database.sqlite
ENV DRONE_RUNNER_OS=linux
ENV DRONE_RUNNER_ARCH=amd64
ENV DRONE_SERVER_PORT=:80
ENV DRONE_SERVER_HOST=localhost
ENV DRONE_DATADOG_ENABLED=true
ENV DRONE_DATADOG_ENDPOINT=https://stats.drone.ci/api/v1/series

COPY --from=Certs /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
COPY --from=Builder go/src/drone/drone-server /bin/drone-server

ENTRYPOINT [&amp;quot;/bin/drone-server&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本來想用go get 的方式，直接把程式build出來，&lt;br /&gt;
但一直卡在go 的&lt;a href=&quot;https://mileslin.github.io/2020/08/Golang/%E5%88%B0%E5%BA%95-go-get-%E7%9A%84%E7%89%88%E8%99%9F%E6%80%8E%E9%BA%BC%E9%81%8B%E4%BD%9C%E7%9A%84/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;版號限制&lt;/a&gt;，看了一些文章都說要改裡面的程式。&lt;br /&gt;
但這東西寫完，基本上就不會再動了。&lt;br /&gt;
只好用git clone把程式先抓下來，再build了。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1814669&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用容器方式編譯無功能限制的 Drone CI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://c.biancheng.net/view/123.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;go get命令——一鍵獲取代碼、編譯並安裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://willh.gitbook.io/build-web-application-with-golang-zhtw/01.0/01.3&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;go 命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/Drone/77. drone build Open Source Edition/" />
        </entry>
        <entry>
            <title>
                72. drone on GKE 建立
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Drone/72. drone on GKE 建立/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;gitlab的安裝方式，參考 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/GKE/71.gitlab%20on%20GKE%20%E7%81%BD%E5%AE%B3%E9%82%84%E5%8E%9F%E7%AD%86%E8%A8%98/&quot;&gt;71.gitlab on GKE 災害還原筆記&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再來是安裝drone的方式，&lt;br /&gt;
這邊之前沒寫文件，重試的時候搞了一陣子。&lt;/p&gt;
&lt;p&gt;要先知道 runner分成哪幾種，根據你的環境選擇你要的方式。&lt;/p&gt;
&lt;p&gt;在drone畫面，基本上都差不多。&lt;br /&gt;
有差異的點是再建置時，就直接看圖吧&lt;/p&gt;
&lt;p&gt;Drone Runner分成五種，適用於不同的情境&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Docker runner :是drone最常見的用法，pineline中的每一個step都起一個獨立的container運行特定任務，本文即是採用docker runner。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在建置時，會在該runner裡面執行docker，所以當下只會看到runner裡面的cpu跟ram使用量上升。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kubernetes runner:跟docker runner 的功能相似，只是改成Kubernetes 版本，如果你的服務要搭建在k8s上，就用這個。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/72-fig.2.jpg&quot; alt=&quot;72-fig.2.jpg&quot; /&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/72-fig.3.jpg&quot; alt=&quot;72-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;選擇kubernetes的版本，再建置時會在當下的叢集建立一個pod，&lt;br /&gt;
然後就會在裡面執行要跑得步驟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exec runner:用於你的專案不適合跑在容器內的狀況EX:MacOs專案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSH runner:直接以ssh 連線到遠端以default shell 執行pipeline流程，需要使用openssh 7.9 以上版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Digital Ocean runner :用於當你的pipeline需要權限可以操作整台虛擬機的情況，且不適合跑在容器內。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;角色&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;用戶&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Gitlab&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Drone Server&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Drone 主服務，提供Web界面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Drone Runner&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;我理解為實現各種操作的適配器，例如ssh、docker、k8s操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Drone Agent&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;操作主機 Docker API 的代理程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Docker Server&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;主機的 Doker 程序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/72-fig.1.jpg&quot; alt=&quot;72-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;發佈到GKE，&lt;a href=&quot;https://github.com/nytimes/drone-gke/blob/main/DOCS.md#template&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;參數說明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;發佈到GCR，&lt;a href=&quot;https://daimom.vercel.app/%5Bhttp://plugins.drone.io/drone-plugins/drone-gcr/%5D(http://plugins.drone.io/drone-plugins/drone-gcr/)&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;參數說明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再來就是要佈署 drone server跟 runner了。&lt;/p&gt;
&lt;h3 id=&quot;step-1&quot; tabindex=&quot;-1&quot;&gt;Step 1.&lt;/h3&gt;
&lt;p&gt;首先要到Gitlab，建立oAuth的id 跟token。&lt;br /&gt;
切記是在user Setting的 Application，&lt;br /&gt;
因為Gitlab是我建的，所以我有另一個Admin的區域，&lt;br /&gt;
不是在Admin裡面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/72-fig.4.jpg&quot; alt=&quot;72-fig.4.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/72-fig.5.jpg&quot; alt=&quot;72-fig.5.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;網頁不要關， Application ID 跟 Secret等等會用到。&lt;/p&gt;
&lt;br /&gt;
&lt;h3 id=&quot;step-2-drone-server&quot; tabindex=&quot;-1&quot;&gt;Step 2. drone Server&lt;/h3&gt;
&lt;br /&gt;
&lt;p&gt;將一些參數改成自己的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;yaml欄位&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;對應的欄位&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DRONE_GITLAB_CLIENT_ID&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Application ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DRONE_GITLAB_CLIENT_SECRET&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Secret&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DRONE_SERVER_HOST&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Callback URL 的domain&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DRONE_RPC_SECRET&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;自行建立，runner的secret需一致&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: gke-drone-server
  labels:
    app: drone
    drone: drone-server
    io.kompose.service: drone-server
spec:
  selector:
    matchLabels:
      app: drone
      drone: drone-server
      io.kompose.service: drone-server
  template:
    metadata:
      labels:
            app: drone
            drone: drone-server
            io.kompose.service: drone-server
    spec:
      containers:
      - env:
        - name: DRONE_GITLAB_CLIENT_ID    # OAuth 的 Application ID
          value: 5b2f90188137bab7b1c6959721feb6e55f1137919e5b4b5ce005bd5e15af536a      
        - name: DRONE_GITLAB_CLIENT_SECRET    # OAuth 的 Secret
          value: 4cc261149603b3df864677f5af37b55613f6f4d20dd65fbb3e4f77f0cbca9e15
        - name: DRONE_GITLAB_SERVER       # Gitlab Server
          value: http://35.234.26.234
        - name: DRONE_GIT_ALWAYS_AUTH     # Drone clone 時，是否每次都驗證
          value: &amp;quot;false&amp;quot;
        - name: DRONE_LOGS_COLOR          # Log 啟用顏色辨識
          value: &amp;quot;true&amp;quot;
        - name: DRONE_LOGS_DEBUG          # 選擇是否開啟 debug 模式
          value: &amp;quot;false&amp;quot;
        - name: DRONE_LOGS_PRETY
          value: &amp;quot;false&amp;quot;
        # - name: DRONE_LOGS_TRACE          &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#開啟log追蹤&quot;&gt;#開啟log追蹤&lt;/a&gt;
        #   value: &amp;quot;true&amp;quot;
        - name: DRONE_RUNNER_CAPACITY     # 表示一次可執行 n 個 job
          value: &amp;quot;3&amp;quot;
        - name: DRONE_SERVER_HOST         # Drone URL,不能加HTTP，解析會在加上HTTP
          value: 14.199.130.26
        - name: DRONE_SERVER_PROTO        # http 或者 https 連線設定
          value: http
        - name: DRONE_TLS_AUTOCERT        # 自動生成 ssl 證書，並接受 https 連線，末認為false
          value: &amp;quot;false&amp;quot;
        - name: DRONE_REGISTRATION_CLOSED # 啟用的話，管理員需在用戶登入前創建用戶
          value: &amp;quot;false&amp;quot;
        - name: DRONE_USER_CREATE         # 建立admin權限的使用者  cli登入用
          value: username:ezio,admin:true
        - name: DRONE_USER_FILTER         # 可操作 Drone 的用戶清單
          value: root,ezio
        - name: DRONE_RPC_SECRET
          value: 824de51510f08498fa770c7798e3cc9e
        image: drone/drone:2
        imagePullPolicy: &amp;quot;Always&amp;quot;
        name: drone-server        
        ports:
        - containerPort: 80
        resources: {}
        volumeMounts:
        - mountPath: /data
          name: drone-server-claim0
      restartPolicy: Always
      serviceAccountName: &amp;quot;&amp;quot;
      volumes:
      - name: drone-server-claim0
        persistentVolumeClaim:
          claimName: gke-drone-server-claim0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要其他git的安裝方式請參考 1. 的官方文件&lt;br /&gt;
ref.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://readme.drone.io/server/provider/gitlab/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Drone Gitlab&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;step-3-a-drone-runner-docker-runner&quot; tabindex=&quot;-1&quot;&gt;Step 3-a.  drone Runner - Docker Runner&lt;/h3&gt;
&lt;br /&gt;
&lt;p&gt;注意 DRONE_RPC_SECRET需與server一致。&lt;br /&gt;
這邊會用到 docker.sock，也是因為這個的關係，&lt;br /&gt;
才導致這次重新測試。&lt;/p&gt;
&lt;p&gt;k8s即將廢棄 Dockershim，改用containerd，&lt;br /&gt;
詳細內容就不多說了，有興趣的可參考 (1) 、 (2)&lt;/p&gt;
&lt;p&gt;雖然我實測出來的結果，&lt;br /&gt;
在containerd的node是可以用的。&lt;br /&gt;
有在想是不是因為核心還是 /var/run/docker.sock 個關係，&lt;br /&gt;
但隨著後續研究 docker.sock (3)，發覺應該是不能用的才對...&lt;br /&gt;
但為什麼能用還是搞不懂。但(4)的官方論壇有說，他不擔心這個問題，&lt;br /&gt;
實際上還真的沒問題...&lt;/p&gt;
&lt;p&gt;補充，&lt;br /&gt;
最近把node的 containerd 版本升到 1.20 後，Docker Runner就真的不能用了。應該是早期還在用舊版的containerd，所以才能跑。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: agent
spec:
  selector:
    matchLabels:
      drone: drone-agent
  replicas: 1
  template:
    spec:
      containers:
      - env:
        - name: DRONE_LOGS_DEBUG
          value: &amp;quot;false&amp;quot;
        # - name: DRONE_LOGS_TRACE          &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#開啟log追蹤&quot;&gt;#開啟log追蹤&lt;/a&gt;
        #   value: &amp;quot;true&amp;quot;
        - name: DRONE_RPC_SECRET
          value: 824de51510f08498fa770c7798e3cc9e
        - name: DRONE_RPC_HOST
          value: 14.199.130.26
        - name: DRONE_RPC_PROTO
          value: &amp;quot;http&amp;quot;
        - name: DRONE_RUNNER_CAPACITY
          value: &amp;quot;3&amp;quot;
        image: drone/drone-runner-docker:1
        imagePullPolicy: &amp;quot;&amp;quot;
        name: drone-agent
        resources: {}
        volumeMounts:
        - mountPath: /var/run/docker.sock
          name: docker-socket
      restartPolicy: Always
      serviceAccountName: &amp;quot;&amp;quot;
      volumes:
      - name: docker-socket
        hostPath:
          path: /var/run/docker.sock
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
1. &lt;a href=&quot;https://kubernetes.io/zh/docs/tasks/administer-cluster/migrating-from-dockershim/check-if-dockershim-deprecation-affects-you/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;檢查棄用 Dockershim 對你的影響&lt;/a&gt;&lt;br /&gt;
2. &lt;a href=&quot;https://kubernetes.io/zh/blog/2020/12/02/dockershim-faq/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;棄用 Dockershim 的常見問題&lt;/a&gt;&lt;br /&gt;
3. &lt;a href=&quot;https://ephrain.net/docker-%E6%8E%9B%E8%BC%89-var-run-docker-sock-%E7%9A%84%E7%94%A8%E6%84%8F%EF%BC%9F/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Docker] 掛載 /var/run/docker.sock 的用意？&lt;/a&gt;&lt;br /&gt;
4. &lt;a href=&quot;https://discourse.drone.io/t/docker-plugin-dockershim-deprecation-kubernetes-1-20/8850&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Drone Disscus -  Docker plugin &amp;amp; dockershim deprecation // Kubernetes 1.20+&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;step-3-b-drone-runner-kubernete-runner&quot; tabindex=&quot;-1&quot;&gt;Step 3-b.  drone Runner - kubernete Runner&lt;/h3&gt;
&lt;br /&gt;
&lt;p&gt;注意 DRONE_RPC_SECRET需與server一致。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: default
  name: drone
rules:
- apiGroups:
  - &amp;quot;&amp;quot;
  resources:
  - secrets
  verbs:
  - create
  - delete
- apiGroups:
  - &amp;quot;&amp;quot;
  resources:
  - pods
  - pods/log
  verbs:
  - get
  - create
  - delete
  - list
  - watch
  - update

---

kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: drone
  namespace: default
subjects:
- kind: ServiceAccount
  name: default
  namespace: default
roleRef:
  kind: Role
  name: drone
  apiGroup: rbac.authorization.k8s.io

---


apiVersion: apps/v1
kind: Deployment
metadata:
  name:  gke-drone-agent

  labels:
    app: drone
    drone: drone-agent
    io.kompose.service: drone-agent
spec:
  replicas: 1
  selector:
    matchLabels:
      app: drone
      drone: drone-agent
      io.kompose.service: drone-agent
  template:
    metadata:
      annotations:
        sidecar.istio.io/inject: &amp;quot;true&amp;quot;
      labels:
        app: drone
        drone: drone-agent
        io.kompose.service: drone-agent
    spec:
      containers:
      - name: runner
        image: drone/drone-runner-kube:latest
        ports:
        - containerPort: 3000
        env:
        - name: DRONE_RPC_SECRET
          value: 824de51510f08498fa770c7798e3cc9e
        - name: DRONE_RPC_HOST
          value: 14.199.130.26
        - name: DRONE_RPC_PROTO
          value: &amp;quot;http&amp;quot;
        - name: DRONE_RUNNER_CAPACITY
          value: &amp;quot;3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://docs.drone.io/runner/kubernetes/installation/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;KUBERNETES Runner&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;問題排除&quot; tabindex=&quot;-1&quot;&gt;問題排除&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;首先碰到的問題是，drone沒有反應，先檢查webhook&lt;br /&gt;
到專案底下的webhook選項，查看錯誤的訊息&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/72-fig.6.jpg&quot; alt=&quot;72-fig.6.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/72-fig.7.jpg&quot; alt=&quot;72-fig.7.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因為GKE的防火牆沒開的關係，導致webhook資料丟不過去。&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
2.  drone無法連線到gitlab&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/72-fig.8.jpg&quot; alt=&quot;72-fig.8.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;本來以為是防火牆的關係，但直接連進去pod裡面，呼叫這個網址是正常的。&lt;/p&gt;
&lt;p&gt;後來看到 (2) 的討論，我跟他們狀況一樣，應該也是istio造成的。&lt;br /&gt;
原以為是 drone server或 runner，有安裝istio的關係，&lt;br /&gt;
還特別寫了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;template:
  metadata:
    annotations:
      sidecar.istio.io/inject: &amp;quot;false&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;來阻止 istio的注入(3)。&lt;/p&gt;
&lt;p&gt;後來想了又想，才驚覺，我要取消的應該是整個namespace的istio注入，&lt;br /&gt;
因為當新的 pipeline建立時，就已經注入了istio的sidecar，&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/72-fig.2.jpg&quot; alt=&quot;72-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以要先讓這個namespace通通不能自動注入，&lt;br /&gt;
指定其他的deploy會自動注入。&lt;br /&gt;
自動注入的規則，請參考 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/istio/73.%20istio%20sidecar%20%E6%B3%A8%E5%85%A5%E8%A6%8F%E5%89%87/&quot;&gt;73. istio sidecar 注入規則&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;
&lt;p&gt;切換namespace，無法佈署&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref.&lt;br /&gt;
1. &lt;a href=&quot;https://docs.gitlab.com/ee/user/project/integrations/webhooks.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Gitlab Webhooks&lt;/a&gt;&lt;br /&gt;
2. &lt;a href=&quot;https://discourse.drone.io/t/drone-ci-pipeline-first-step-clone-failed-connection-refused/7626&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Drone CI pipeline first step clone failed: Connection refused&lt;/a&gt;&lt;br /&gt;
3. &lt;a href=&quot;https://istio.io/latest/zh/docs/setup/additional-setup/sidecar-injection/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;安裝 Sidecar&lt;/a&gt;&lt;br /&gt;
4. &lt;a href=&quot;https://istio.io/latest/docs/reference/config/annotations/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;istio -Resource Annotations&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Drone/72. drone on GKE 建立/" />
        </entry>
        <entry>
            <title>
                3. 撰寫drone.yml 筆記篇(未)
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Drone/3. 撰寫drone.yml 筆記篇(未)/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;換工作後，開始接觸k8s、GCP、GKE，再來是Drone。&lt;br /&gt;
k8s中又延伸了kustomize ，ymal的寫法、佈署方式。&lt;br /&gt;
GCP中的cloud armor、GCE ，然後GKE的架構&lt;br /&gt;
真的是....滿滿的坑阿。以上講到的，還處於懞懂中，&lt;br /&gt;
筆記不知道何年何月何日可寫&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;簡單說一下環境，在GKE上面佈署 drone 跟 gitlab，&lt;br /&gt;
當gitlab有條件觸發的話(例如在push 在master上)，會同時送出一個webhook給drone，&lt;br /&gt;
此時drone就會去gitlab  pull程式碼下來，做你想要的動作（例如，打包成image，把image送到gcr上面，再佈署到GKE上）。&lt;/p&gt;
&lt;p&gt;先來份yaml，建議可以先看一下yaml是什麼東西，這樣寫起來比較不會撞牆。&lt;br /&gt;
(ref. &lt;a href=&quot;https://zh.wikipedia.org/wiki/YAML&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://zh.wikipedia.org/wiki/YAML&lt;/a&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kind: pipeline
name: Pipeline(branch)

steps:      
- name: push2GCR(前哨)
  image: plugins/gcr
  settings:
    repo: gcr.io/rd7-project/landingpage
    tags:
      - latest
      - ${DRONE_COMMIT}
    # dockerfile: configs/beta/Dockerfile
    json_key:
      from_secret: GOOGLE_CREDENTIALS
    build_args:
      - website=beta

- name: deploy2GKE(前哨)
  image: nytimes/drone-gke
  environment:
    TOKEN:
      from_secret: GOOGLE_CREDENTIALS
  settings:
    project: rd7-project
    # 改拉參數傳入kube.yml內
    # template: configs/beta/.kube.yml
    vars:
      deployName: yaboxxx-landing-page-beta
      env: beta
    zone: asia-east1-a
    cluster: xbb-common
trigger:   
  # branch:
  #   - master
  ref:
    include:
      - refs/heads/master
  event:
    - push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分成三小塊來看，&lt;br /&gt;
如果以 --- 區分的話，那&lt;br /&gt;
kind: pipeline&lt;br /&gt;
name: Pipeline(branch)&lt;br /&gt;
是必須的。&lt;/p&gt;
&lt;p&gt;再來是 steps ，&lt;br /&gt;
根據步驟游上往下執行，如果要并行的話，則使用depend_on ，&lt;br /&gt;
這部分留到下次講。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;trigger ，這是觸發條件，表示在gitlab上面做了哪些動作，會觸發這個step（步驟）&lt;br /&gt;
這邊的觸發事件，常用到應該是 Branch、Reference 以及 Event&lt;br /&gt;
(ref. &lt;a href=&quot;https://docs.drone.io/pipeline/docker/syntax/trigger/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://docs.drone.io/pipeline/docker/syntax/trigger/&lt;/a&gt;)&lt;br /&gt;
Branch 跟 Event 比較好理解（但碰到Tag的事件又是另一回事了） 。&lt;br /&gt;
Reference 這個其實只要在你的git裡面下指令&lt;br /&gt;
tree .git/refs/&lt;br /&gt;
大概就會知道他在講些什麼，git的底層都是靠refs去用出來的&lt;br /&gt;
(&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;http://iissnan.com/progit/html/zh-tw/ch9_3.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;http://iissnan.com/progit/html/zh-tw/ch9_3.html&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://titangene.github.io/article/git-branch-ref.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://titangene.github.io/article/git-branch-ref.html&lt;/a&gt;&lt;br /&gt;
)&lt;br /&gt;
但要注意的是，drone 1.X，以後的版本不支援event的tag 與 branch 共存。&lt;br /&gt;
可以參考這篇&lt;br /&gt;
(&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://github.com/drone/drone/issues/2536&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://github.com/drone/drone/issues/2536&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://rabbit52.com/2019/11/drone-from-0-8-to-1-0/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://rabbit52.com/2019/11/drone-from-0-8-to-1-0/&lt;/a&gt;&lt;br /&gt;
)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;steps:&lt;br /&gt;
這部分則開始由上往下開始執行，&lt;br /&gt;
像上面的程式先做的是將程式打包後，上傳到GCR上面。&lt;br /&gt;
（最上面還有一段clone，會先做（這是drone預設的），將gitlab的程式複製到機器內，這樣才能做後面的上傳，&lt;br /&gt;
這一塊可以 參考 &lt;a href=&quot;https://docs.drone.io/pipeline/docker/syntax/cloning/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://docs.drone.io/pipeline/docker/syntax/cloning/&lt;/a&gt;  ）&lt;br /&gt;
上傳到GCR使用的 plugins/gcr ，這個image，裡面的參數請參考&lt;a href=&quot;http://plugins.drone.io/drone-plugins/drone-gcr/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;說明頁面&lt;/a&gt;&lt;br /&gt;
由於這邊需要上傳到GCR，故要先到Google 的 服務賬戶申請權限 ，除了需要push以外還必須要有 storage.buckets.get&lt;br /&gt;
這邊會取得一個json檔案，將內容塞入drone內的Sercets。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/3.%20fig-1.jpg&quot; alt=&quot;3. fig-1.jpg&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Drone/3. 撰寫drone.yml 筆記篇(未)/" />
        </entry>
        <entry>
            <title>
                119. Drone  plugin-Drone-docker 修改原始檔
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Drone/119. Drone  plugin-Drone-docker 修改原始檔/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;之前發現一個後端執行drone會發生的問題，&lt;br /&gt;
偶爾發生，但一段時間總會發生一次。&lt;br /&gt;
多個step同時build，會造成image錯亂。&lt;br /&gt;
好麻煩阿....&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;先來看幾張圖，應該就能瞭解我再說什麼了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/119-fig.1.jpg&quot; alt=&quot;119-fig.1.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/119-fig.2.jpg&quot; alt=&quot;119-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;首先看到第一張圖，他在執行docker build的時候，會用git commit的值，當作image的tag名稱。&lt;/p&gt;
&lt;p&gt;然後看第二張圖，直到build完image後，才會再根據你的tag去將image改成你要的tags&lt;/p&gt;
&lt;p&gt;所以我們來想一個情境，當A、B同時執行時，他們的git commit都一樣，&lt;br /&gt;
A已經build完了，正要執行最後一個步驟，將git commit tag改成正常的image tag 。&lt;br /&gt;
此時B也剛build完，所以他也產生了一個一模一樣的 commit tag的image，那A執行最後一個步驟時，他改得到底是誰的image？&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如果一個接一個step跑的話，時間大概需要 4分半，&lt;br /&gt;
但同步的話，只要1分半，時間快了三倍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以還是要想辦法解掉，本來有想幾個解法，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一次把程式都build一遍，放在同一個image內，&lt;br /&gt;
執行時，再根據參數看要執行哪個檔案。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;但是他們有一種情境是只要更新其中一個功能就好，那此時全部build就不太適合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;在drone step時，塞tag進去，但他只會在最後一個步驟，才會改image的tag ，這招也不行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;改plugin/gcr 了，在第一步驟時就把image的tag改掉，不要使用git commit，那就解掉這個問題了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;動手&quot; tabindex=&quot;-1&quot;&gt;動手&lt;/h2&gt;
&lt;p&gt;首先找到這個image的原始碼 &lt;a href=&quot;https://github.com/drone-plugins/drone-docker&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;drone-plugins/drone-docker&lt;/a&gt;，然後開始改吧。&lt;/p&gt;
&lt;p&gt;各環境main.go的package import docker 要先改掉，不改掉我不確定他會不會抓本機的package，我golang初學沒多久。&lt;/p&gt;
&lt;p&gt;修改前&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;import (
	&amp;quot;os&amp;quot;
	&amp;quot;runtime&amp;quot;

	&amp;quot;github.com/joho/godotenv&amp;quot;
	&amp;quot;github.com/sirupsen/logrus&amp;quot;
	&amp;quot;github.com/urfave/cli&amp;quot;

	docker &amp;quot;github.com/drone-plugins/drone-docker&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改後&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;import (
	&amp;quot;os&amp;quot;
	&amp;quot;runtime&amp;quot;

	&amp;quot;github.com/joho/godotenv&amp;quot;
	&amp;quot;github.com/sirupsen/logrus&amp;quot;
	&amp;quot;github.com/urfave/cli&amp;quot;

	docker &amp;quot;drone-docker&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後我在docker.go上面直接加了兩行，指定了tag，這不適合所有人，&lt;br /&gt;
因為你們的使用情境可能跟我不太一樣，我這邊是只要push到git後，drone會自動產生tag，所以如果不指定的話，我還是有tag的值可以取得。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;tag := build.Repo + &amp;quot;:&amp;quot; + build.Tags[0]

args := []string{
&amp;quot;build&amp;quot;,
&amp;quot;--rm=true&amp;quot;,
&amp;quot;-f&amp;quot;, build.Dockerfile,
&amp;quot;-t&amp;quot;, build.Name,
&amp;quot;-t&amp;quot;, tag,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，如果要知道plugin/gcr裏面有什麼環境變數可以拿來用的話，&lt;br /&gt;
可以在drone的step上面，執行export -p&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: publish-dev
  image: plugins/gcr
  pull: if-not-exists
  volumes:
    - name: docker
      path: /var/run/docker.sock   
  commands: 
    - export -p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行結果：&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/119-fig.3.jpg&quot; alt=&quot;119-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;改完後，執行下面的指令先產生go 的程式。&lt;br /&gt;
這個go的指令，我是從.drone.yaml抄出來的。&lt;br /&gt;
執行前記得先設定環境變數&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;export GOOS=linux
export GOARCH=amd64
export CGO_ENABLED=0
export GO111MODULE=on
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;go-build&quot; tabindex=&quot;-1&quot;&gt;Go build&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;go build -v -ldflags &amp;quot;-X main.version=${DRONE_COMMIT_SHA:0:8}&amp;quot; -a -tags netgo -o release/linux/amd64/drone-docker ./cmd/drone-docker
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;go build -v -ldflags &amp;quot;-X main.version=${DRONE_COMMIT_SHA:0:8}&amp;quot; -a -tags netgo -o release/linux/amd64/drone-gcr ./cmd/drone-gcr
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;docker-build&quot; tabindex=&quot;-1&quot;&gt;Docker build&lt;/h3&gt;
&lt;p&gt;將go的執行檔打包進去docker image內，&lt;br /&gt;
先打包到本機的docker:linux-amd64，&lt;br /&gt;
因為docker-gcr的dockerfile會去抓docker:linux-amd64 當作image的基底再產生檔案&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker build &#92;
  --label org.label-schema.build-date=$(date -u +&amp;quot;%Y-%m-%dT%H:%M:%SZ&amp;quot;) &#92;
  --label org.label-schema.vcs-ref=$(git rev-parse --short HEAD) &#92;
  --file docker/docker/Dockerfile.linux.amd64 --tag plugins/docker:linux-amd64 .
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker build &#92;
  --label org.label-schema.build-date=$(date -u +&amp;quot;%Y-%m-%dT%H:%M:%SZ&amp;quot;) &#92;
  --label org.label-schema.vcs-ref=$(git rev-parse --short HEAD) &#92;
  --file docker/gcr/Dockerfile.linux.amd64 --tag asia-east1-docker.pkg.dev/rouge-sms/docker-public/gcr:0.0.13 .
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;完成&quot; tabindex=&quot;-1&quot;&gt;完成&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/119-fig.4.jpg&quot; alt=&quot;119-fig.4.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;上圖可以看到，在docker build時，會同時下兩個tag，&lt;br /&gt;
一個還是維持git commit的值，但另一個就是拿repository加版本號當作tag。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://discourse.drone.io/t/drone-step-name-not-available-as-substitution-in-environment/8389&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;DRONE_STEP_NAME not available as substitution in environment&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;查資料時剛好有碰到這個問題，drone_step_name一直抓不到，原因再文章內。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/drone-plugins/drone-docker/compare/f9d0b60cb05ff9e37787651be4c54bfff2fe9a08..d41b50e5aa5ec4baf57f94448c1e7ce6c8f6282a&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; 修復在多模組java項目中，平行打包鏡像時，鏡像因為同名稱被覆蓋的問題&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;昨天才看到有人發了個PR修復同名稱的問題，感覺跟我的頗像，但實際看了，覺得不太適合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/Drone/119. Drone  plugin-Drone-docker 修改原始檔/" />
        </entry>
        <entry>
            <title>
                109. drone jsonnet 各種怪招
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Drone/109. drone jsonnet 各種怪招/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;本文章內容包含許多寫drone jsonnet會碰到的寫法。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在pipeline下comand的時候，有時會碰到多行指令湊在一起的情況，&lt;br /&gt;
在drone.yaml是直接這樣寫&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/109-fig.1.jpg&quot; alt=&quot;Drone/109-fig.1.jpg&quot; /&gt;&lt;br /&gt;
但如果要用jsonnet的話，要用&lt;code&gt;&#92;n&lt;/code&gt;換行，&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/109-fig.2.jpg&quot; alt=&quot;Drone/109-fig.2.jpg&quot; /&gt;&lt;br /&gt;
轉換後就會變成下圖&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/109-fig.3.jpg&quot; alt=&quot;109-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在執行command的時候，因為要先用&lt;code&gt;&amp;quot;&lt;/code&gt; 將指令包起來，如果裏面還要有&lt;code&gt;&amp;quot;&lt;/code&gt; 的話，必須在前面加上 &lt;code&gt;&#92;&lt;/code&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/109-fig.4.jpg&quot; alt=&quot;109-fig.4.jpg&quot; /&gt;&lt;br /&gt;
執行&lt;code&gt;drone jsonnet --stream --format&lt;/code&gt;後&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/109-fig.5.jpg&quot; alt=&quot;109-fig.5.jpg&quot; /&gt;&lt;br /&gt;
這是因爲 linux shell裏面，單引號跟雙引號的差別，詳細可看&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Linux/133.%20shell%20script%E5%AD%97%E4%B8%B2%E8%99%95%E7%90%86/&quot;&gt;shell script 雙引號與單引號&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果碰到很長的一串指令，例如if else之類的，改使用  @&#39;&#39; 將程式包起來。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;@&#39;
if [ -z $${TAG_FROM} ]

then

echo &amp;quot;錯誤：無來源TAG。&amp;quot;;

exit 1

fi&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;如果字串過長，想要換行的話， 可在雙引號內 使用 兩個&#92; &lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/109-fig.6.jpg&quot; alt=&quot;109-fig.6.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;用curl時，有些參數要用&amp;quot; ，所以在單引號使用 &amp;quot; &amp;quot; 固定參數，要先用 @ &#39;&#39; 包起來&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;  @&#39;OAUTH2_TOKEN=$(curl -XGET $${TOTP_AUTH_URL} &#92;&#92;
       -H &amp;quot;accept: application/json&amp;quot; &#92;&#92;
       -H &amp;quot;TOTP-PIN-CODE: $${pin}&amp;quot; &#92;&#92;
       -H &amp;quot;TOTP-USER: $${user}&amp;quot;)&#39;, 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://book.king011.com/view/en-US/view/google-jsonnet/tutorial&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; jsonnet教學 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jsonnet.org/learning/tutorial.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;jsonnet 官方說明 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jsonnet.org/ref/stdlib.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; Standard Library&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/Drone/109. drone jsonnet 各種怪招/" />
        </entry>
        <entry>
            <title>
                10.drone 使用 騰訊雲 K8S及 容器鏡像服務
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Drone/10.drone 使用 騰訊雲 K8S及 容器鏡像服務/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;科技始終來自於人性，現在要讓自動佈署可以支援到騰訊雲&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;1.發佈image到騰訊雲的容器鏡像服務&lt;/p&gt;
&lt;p&gt;直接先給 drone.yml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: push2TCR  
  image: plugins/docker
  settings:
    username:
      from_secret: TCR_user
    password:
      from_secret: TCR_PW
    build_args:
      - website=qa
      - location=tke  
    repo: tcr.tencentcloudcr.com/project/abc
    registry: tcr.tencentcloudcr.com
    tags:
    - latest
    - ${DRONE_COMMIT}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊使用的docker image 請參考 &lt;a href=&quot;http://plugins.drone.io/drone-plugins/drone-docker/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Docker&lt;/a&gt;&lt;br /&gt;
要注意的地方在，如果直接把username跟 password 打在上面的話，&lt;br /&gt;
會發生驗證失敗。&lt;br /&gt;
需要將帳號密碼放到drone裡面的 Secrets，&lt;br /&gt;
一開始也可以使用 command 直接看有沒有成功登入。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: push2TCR  
  image: plugins/docker
  commands:
    - docker login tcr.tencentcloudcr.com --username 123456789 --password token
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，當初在設定的時候，有限定ip才能連線，這部分記得要打開&lt;br /&gt;
，如果沒有就不用在意了。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/10.fig-1.jpg&quot; alt=&quot;10.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2.佈署到騰訊雲&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kind: pipeline
name: TKEPipeline(QA)

platform:
  os: linux
  arch: amd64

steps:

- name: deploy2TKE-QA
  image: danielgormly/drone-plugin-kube:0.0.2
  settings:
    template: tke.yml
    server: https://loud.com
    ca:
      from_secret: TKE_CA
    token:
      from_secret:  TKE_TOKEN
    namespace: demo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;server 跟  ca token，需看騰訊雲集群上的設定&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/10.fig-2.jpg&quot; alt=&quot;10.fig-2.jpg&quot; /&gt;&lt;br /&gt;
這個image不像GKE一樣有參數可以丟進去，只有固定的幾個參數&lt;br /&gt;
ref. &lt;a href=&quot;https://github.com/danielgormly/drone-plugin-kube&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;danielgormly/drone-plugin-kube&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所幸這個有放在github上，還能夠根據自己的需求更改內容，增加參數。&lt;br /&gt;
重新編譯後，如果不是上傳到公開的Container Registry ，而是傳到私有的CR就必須加上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;image_pull_secrets:
- TKE_LOGIN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這個與image 同樣的層級，不然會導致pull image失敗&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Drone/10.fig-3.jpg&quot; alt=&quot;10.fig-3.jpg&quot; /&gt;&lt;br /&gt;
ref.&lt;a href=&quot;https://discourse.drone.io/t/how-to-pull-private-images-with-1-0/3155&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to pull private images with 1.0&lt;/a&gt;，&lt;/p&gt;
&lt;p&gt;至於TKE_LOGIN的內容（這個也必須加在drone的Secrets內），&lt;br /&gt;
通常是在 $HOME/.docker/config.json 內，會長得像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
	&amp;quot;auths&amp;quot;: {
		&amp;quot;https://index.docker.io/v1/&amp;quot;: {
			&amp;quot;auth&amp;quot;: &amp;quot;YW11cmRhY2E6c3VwZXJzZWNyZXRwYXNzd29yZA==&amp;quot;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，我的只有&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
	&amp;quot;auths&amp;quot;: {
		&amp;quot;https://index.docker.io/v1/&amp;quot;: {}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以下面那個就必須自己產生了，&lt;br /&gt;
產生的方式如下&lt;br /&gt;
echo -n &#39;username:password&#39; | base64&lt;br /&gt;
把username與 password 輸入，轉成base64，再貼上去至程式碼內，並儲存至drone的Secrets&lt;br /&gt;
ref.&lt;a href=&quot;https://stackoverflow.com/questions/43441454/docker-login-auth-token&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Docker login auth token&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;至於修改這個image，要加入參數的話，&lt;br /&gt;
目前看應該是 增加 main.go 跟 plugin 的 Kubeconfig 參數，然後重新編譯(&lt;a href=&quot;http://build.sh/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;build.sh&lt;/a&gt;)即可&lt;/p&gt;
&lt;p&gt;p.s. 在騰訊雲的pod(Alpine Linux)內安裝軟體，需替換鏡像源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sed -i &#39;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&#39; /etc/apk/repositories
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
支援k8s的各種指令&lt;a href=&quot;https://github.com/Sh4d1/drone-kubernetes&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Sh4d1/drone-kubernetes&lt;/a&gt;&lt;br /&gt;
可直接在drone上下kubectl指令&lt;a href=&quot;https://github.com/sinlead/drone-kubectl&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;sinlead/drone-kubectl&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://containerization-automation.readthedocs.io/zh_CN/latest/docker/advanced/%5Balpine%5D%E6%BA%90%E9%85%8D%E7%BD%AE/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;alpine源配置&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Drone/10.drone 使用 騰訊雲 K8S及 容器鏡像服務/" />
        </entry>
        <entry>
            <title>
                0.Drone MOC
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Drone/0.Drone MOC/</id>
            <content type="html">
                &lt;h1 id=&quot;建置&quot; tabindex=&quot;-1&quot;&gt;建置&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Drone/72.%20drone%20on%20GKE%20%E5%BB%BA%E7%AB%8B/&quot;&gt;72. drone on GKE 建立&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Drone/10.drone%20%E4%BD%BF%E7%94%A8%20%E9%A8%B0%E8%A8%8A%E9%9B%B2%20K8S%E5%8F%8A%20%E5%AE%B9%E5%99%A8%E9%8F%A1%E5%83%8F%E6%9C%8D%E5%8B%99/&quot;&gt;10.drone 使用 騰訊雲 K8S及 容器鏡像服務&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Drone/77.%20drone%20build%20Open%20Source%20Edition/&quot;&gt;77. drone build Open Source Edition&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Drone/78.%20drone%20k8s-runner%20%E9%80%B2%E9%9A%8E%E8%A8%AD%E5%AE%9A/&quot;&gt;78. drone k8s-runner 進階設定&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;編寫&quot; tabindex=&quot;-1&quot;&gt;編寫&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.vercel.app/404&quot;&gt;3. 撰寫drone.yml 筆記篇&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Drone/109.%20drone%20jsonnet%20%E5%90%84%E7%A8%AE%E6%80%AA%E6%8B%9B/&quot;&gt;109. drone jsonnet 各種怪招&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Drone/119.%20Drone%20%20plugin-Drone-docker%20%E4%BF%AE%E6%94%B9%E5%8E%9F%E5%A7%8B%E6%AA%94/&quot;&gt;119. Drone  plugin-Drone-docker 修改原始檔&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Drone/0.Drone MOC/" />
        </entry>
        <entry>
            <title>
                32. nuxtJS 的 Dockerfile
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Container/32. nuxtJS 的 Dockerfile/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;又多了一個新的套件要做，這次用的是nuxt.js ，只知道是vue.js延伸出來的東西...&lt;br /&gt;
然後，上吧。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;因 nuxt.js ，跟go有點像都會自己啟動一個伺服器的服務，&lt;br /&gt;
走的是SSR（Server-Side Rendering），&lt;br /&gt;
不是卡牌遊戲的SSR阿。&lt;br /&gt;
SSR的意思是，頁面由後端渲染，HTML由後端產生（據說是要讓速度比較快）&lt;br /&gt;
ref.&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10202217&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;02. 講歷史，話說 SSR...&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因為nuxt.js會自己建立一個js，&lt;br /&gt;
所以有踩到一個坑，&lt;br /&gt;
在設定 nuxt.config.js的時候，&lt;br /&gt;
請確認好port 以及 是不是開了https 。&lt;br /&gt;
建議先查一下 nuxt.config.js 的內容屬性，再來打包及佈署。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10207002&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;16. Nuxt 全域設定檔 (nuxt.config.js)，可以吃嗎？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這是第一個版本，使用npm編譯。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM node:11.13.0
COPY . /usr/src/nuxt-app/

RUN npm install
RUN npm run build:qa

EXPOSE 80

ENV NUXT_HOST=0.0.0.0
ENV NUXT_PORT=80

CMD [ &amp;quot;npm&amp;quot;, &amp;quot;start&amp;quot; ]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二個版本，改使用yarn安裝，這邊要注意，node版本，請抓最新的，不然編譯的時候會出現python錯誤。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  FROM node:16.3.0-alpine
  WORKDIR /usr/src/app

  COPY . .
  RUN yarn install &amp;amp;&amp;amp; yarn cache clean
  RUN yarn build
  CMD [ &amp;quot;yarn&amp;quot;, &amp;quot;start&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊只寫 yarn build ，是因為在設定nuxt的時候，有寫 build:qa 跟 build。&lt;br /&gt;
因為是最後測試完的成果了，就改用yarn build ，做結束。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://twblog.hongjianching.com/2020/06/14/yarn-install-lock-version-by-yarn.lock/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 yarn install 指令安裝套件時鎖定 yarn.lock 版本&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://hub.docker.com/_/node?tab=description&amp;amp;page=1&amp;amp;ordering=last_updated&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;docker-hub node&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Container/32. nuxtJS 的 Dockerfile/" />
        </entry>
        <entry>
            <title>
                29.Dockerfile echo something
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Container/29.Dockerfile echo something/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;在幫人寫自動佈署的時候，發現以往的Docker會顯示畫面上的指令，&lt;br /&gt;
這次都沒有出來。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;解決方案，加上 --progress=plain&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  docker build --progress=plain -t ey:0.1 .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果沒有加的話，會像 (fig.1)，有加的話，則會像(fig.2)，將螢幕上的資料顯示出來&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  FROM gcr.io/cloud-builders/yarn:node-8.12.0 as build-env
  WORKDIR /app

  COPY . .
  RUN pwd
  RUN ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(fig.1)&lt;/p&gt;
&lt;p&gt;(fig.2)&lt;/p&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://stackoverflow.com/questions/64804749/docker-build-not-showing-any-output-from-commands&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Docker build not showing any output from commands&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Container/29.Dockerfile echo something/" />
        </entry>
        <entry>
            <title>
                170. Docker啓用GPU
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Container/170. Docker啓用GPU/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡唸&quot; tabindex=&quot;-1&quot;&gt;睡睡唸&lt;/h1&gt;
&lt;p&gt;上面&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Container/168.%20Docker%20build%E5%A4%B1%E6%95%97%E8%B7%B3%E5%87%BAkilled/&quot;&gt;168. Docker build失敗跳出killed&lt;/a&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Network/169.%20Nginx%E7%9A%84%E8%B2%A0%E8%BC%89%E5%B9%B3%E8%A1%A1/&quot;&gt;169. Nginx的負載平衡&lt;/a&gt;，&lt;br /&gt;
這兩篇都是為了要達到內部AI平臺再用，&lt;br /&gt;
不要讓每個人的電腦都自己裝一堆程式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;電腦裝完顯卡驅動後，要讓docker識別，&lt;br /&gt;
還需要額外裝  &lt;a href=&quot;https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;NVIDIA Container Toolkit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;照著官方文件來，挺快的。&lt;/p&gt;
&lt;p&gt;這邊記錄ubuntu的方法，其他的安裝方式，請參考上面文件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;更新&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg &#92;
  &amp;amp;&amp;amp; curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | &#92;
    sed &#39;s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g&#39; | &#92;
    sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list &#92;
  &amp;amp;&amp;amp; &#92;
    sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;安裝&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install -y nvidia-container-toolkit
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;docker設定 （containerd、CRI-O的話，參考上面連結）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo nvidia-ctk runtime configure --runtime=docker
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;重啓&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo systemctl restart containerd
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;驗證&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo docker run --rm --runtime=nvidia --gpus all ubuntu nvidia-smi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;顯示下面的資料就表示有了。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Container/170-fig.1.jpg&quot; alt=&quot;170-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;docker-compose&quot; tabindex=&quot;-1&quot;&gt;Docker-compose&lt;/h2&gt;
&lt;p&gt;如果使用docker compose的話，&lt;br /&gt;
須在yaml上面增加一些設定，command 到 capabilities&lt;br /&gt;
當然也可以指定此container要吃第幾個gpu，&lt;br /&gt;
更詳細說明請參考&lt;a href=&quot;https://docs.docker.com/compose/gpu-support/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Turn on GPU access with Docker Compose&lt;/a&gt;&lt;br /&gt;
提示：主要在count的設定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version: &#39;3.8&#39;
services:
  python-1:
    container_name: yolox-brand-1
    image: busybox
    command: nvidia-smi
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: all
              capabilities: [gpu]
    pull_policy: if_not_present
    restart: always
    networks:
      - internal
networks:
  internal:
    name: internal
    driver: bridge
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/Container/170. Docker啓用GPU/" />
        </entry>
        <entry>
            <title>
                168. Docker build失敗跳出killed
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Container/168. Docker build失敗跳出killed/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡唸&quot; tabindex=&quot;-1&quot;&gt;睡睡唸&lt;/h1&gt;
&lt;p&gt;內部要搞一個AI的開發平臺，&lt;br /&gt;
所以我負責python的負載平衡架構，&lt;br /&gt;
因爲他的程式開發好像有點困難，就用nginx的LB來做了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;驗證&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Network/169.%20Nginx%E7%9A%84%E8%B2%A0%E8%BC%89%E5%B9%B3%E8%A1%A1/&quot;&gt;169. Nginx的負載平衡&lt;/a&gt;時，需要讓範例程式顯示一下請求的資訊，&lt;br /&gt;
確認真的有做到這塊。&lt;/p&gt;
&lt;p&gt;打包以前的舊AI程式時就暴掉了，&lt;br /&gt;
出現 killed的error。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [6/8] RUN pip3 install torch torchvision torchaudio --index-url [https://download.pytorch.org/whl/cpu](https://download.pytorch.org/whl/cpu &amp;quot;https://download.pytorch.org/whl/cpu&amp;quot;):

1.293 Looking in indexes: [https://download.pytorch.org/whl/cpu](https://download.pytorch.org/whl/cpu &amp;quot;https://download.pytorch.org/whl/cpu&amp;quot;) 2.901 Collecting torch 2.917 Downloading [https://download.pytorch.org/whl/cpu/torch-2.0.1%2Bcpu-cp38-cp38-linux_x86_64.whl](https://download.pytorch.org/whl/cpu/torch-2.0.1%2Bcpu-cp38-cp38-linux_x86_64.whl &amp;quot;https://download.pytorch.org/whl/cpu/torch-2.0.1%2Bcpu-cp38-cp38-linux_x86_64.whl&amp;quot;) (195.4 MB) 11.30 Killed ------ Dockerfile:25 -------------------- 23 | RUN apt-get update &amp;amp;&amp;amp; apt-get install -y enchant &amp;amp;&amp;amp; apt-get install -y python3.7 python3-pip libgl1 &amp;amp;&amp;amp; apt-get clean &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/* 24 | RUN pip3 install --upgrade pip 25 | &amp;gt;&amp;gt;&amp;gt; RUN pip3 install torch torchvision torchaudio --index-url [https://download.pytorch.org/whl/cpu](https://download.pytorch.org/whl/cpu &amp;quot;https://download.pytorch.org/whl/cpu&amp;quot;) 26 | RUN pip3 install paddlepaddle==2.4.2 -i [https://mirror.baidu.com/pypi/simple](https://mirror.baidu.com/pypi/simple &amp;quot;https://mirror.baidu.com/pypi/simple&amp;quot;) 27 | RUN pip3 install --no-cache-dir -r requirements.txt -------------------- ERROR: failed to solve: process &amp;quot;/bin/sh -c pip3 install torch torchvision torchaudio --index-url [https://download.pytorch.org/whl/cpu](https://download.pytorch.org/whl/cpu &amp;quot;https://download.pytorch.org/whl/cpu&amp;quot;)&amp;quot; did not complete successfully: exit code: 137
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查了一下，說是因爲記憶體不足導致docker build的時候暴掉。&lt;br /&gt;
ref. &lt;a href=&quot;https://github.com/pytorch/pytorch/issues/6935&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;PyTorch Docker build error&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`Killed` means that the compiler was killed by the kernel because it used too much memory. There are a few workarounds:

- increase the memory limit for docker container
- limit the number of concurrent builds by changing the `Dockerfile` to include `MAX_JOBS=1` [here](https://github.com/pytorch/pytorch/blob/master/docker/pytorch/Dockerfile#L30)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把我的docker resource 的記憶體資源加大後就好了（我mac記憶體只有16G)。&lt;/p&gt;
&lt;p&gt;[[168-fig.1.jpg]]&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Container/168. Docker build失敗跳出killed/" />
        </entry>
        <entry>
            <title>
                157. Docker NGINX-Certbot 自動跟Let&#39;sEncrytp取得憑證
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Container/157. Docker NGINX-Certbot 自動跟Let&#39;sEncrytp取得憑證/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;前人很強，很厲害，喜歡自己動手，&lt;br /&gt;
所以他當初造的自動取得Let&#39;s Encrypt的程式，都是自己寫一整套來用。&lt;br /&gt;
然後，交接了整套，但程式沒人知道在幹嘛，只有每次出問題時，&lt;br /&gt;
會去翻API看是要先call哪個，再call哪個，然後再重開某些image&lt;br /&gt;
才能正確取得，身爲一個懶人，跟腦細胞容量過小的我，實在記不住阿，&lt;br /&gt;
只好改了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h2 id=&quot;docker-k8s-cert-manage&quot; tabindex=&quot;-1&quot;&gt;這個只適合Docker，k8s請改用cert-manage&lt;/h2&gt;
&lt;p&gt;使用說明&lt;/p&gt;
&lt;p&gt;我這邊是掛載user_conf.d 到 /etc/nginx/user_conf.d ，&lt;br /&gt;
user_conf.d就是設定檔存放的位置。&lt;/p&gt;
&lt;p&gt;docker-compose.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version: &#39;3&#39;

services:
  nginx:
    image: jonasal/nginx-certbot:latest
    container_name: nginx
    restart: unless-stopped
    networks:
      - cicd_net
    env_file:
      - ./nginx-certbot.env
    ports:
      - 80:80
      - 443:443
    volumes:
      - nginx_secrets:/etc/letsencrypt
      - ./user_conf.d:/etc/nginx/user_conf.d

volumes:
  nginx_secrets:

# 跟drone servere掛在同一層
networks:
  cicd_net:
    name: cicd_net
    driver: bridge  

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;記得更改email，不然啓動會失敗&lt;br /&gt;
nginx-certbot.env&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Required
CERTBOT_EMAIL=&amp;lt;email&amp;gt;

# Optional (Defaults)
DHPARAM_SIZE=2048
ELLIPTIC_CURVE=secp256r1
RENEWAL_INTERVAL=8d
RSA_KEY_SIZE=2048
STAGING=0
USE_ECDSA=1

# Advanced (Defaults)
CERTBOT_AUTHENTICATOR=webroot
CERTBOT_DNS_PROPAGATION_SECONDS=&amp;quot;&amp;quot;
DEBUG=0
USE_LOCAL_CA=0

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;user_conf.d資料夾內的檔案名稱&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
    # Listen to port 443 on both IPv4 and IPv6.
    listen 443 ssl http2;
    listen [::]:443 ssl http2;

    # Domain names this server should respond to.
    server_name otpat.domain.com;

    # Load the certificate files.
    ssl_certificate         /etc/letsencrypt/live/otpat-domain-com/fullchain.pem;
    ssl_certificate_key     /etc/letsencrypt/live/otpat-domain-com/privkey.pem;
    ssl_trusted_certificate /etc/letsencrypt/live/otpat-domain-com/chain.pem;

    ssl_protocols             TLSv1.3 TLSv1.2;
    ssl_prefer_server_ciphers on;
    ssl_ecdh_curve            X25519:secp521r1:secp384r1;
    ssl_ciphers               TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    ssl_session_cache         shared:TLS:2m;
    ssl_buffer_size           4k;

    # OCSP stapling
    ssl_stapling on;
    ssl_stapling_verify on;
    resolver 1.1.1.1 1.0.0.1 [2606:4700:4700::1111] [2606:4700:4700::1001]; # Cloudflare

   # return 200 &#39;Let&#92;&#39;s Encrypt certificate successfully installed!&#39;;
   # add_header Content-Type text/plain;

   location / {
        proxy_set_header X-Forwarded-For $remote_addr;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Host $http_host;

        proxy_pass http://totp-auth:9987;

        proxy_redirect off;
        proxy_http_version 1.1;
        proxy_buffering off;

        chunked_transfer_encoding off;
    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成品，因為要將proxy_pass導到服務上面，最好是設成同一個network，這邊設為 cicd_net&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Container/157-fig.1.jpg&quot; alt=&quot;157-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果啓動失敗的話，&lt;br /&gt;
可以查一下nginx裏面的錯誤訊息，上面通常寫的很清楚。&lt;/p&gt;
&lt;p&gt;建議可以先看看這兩篇&lt;br /&gt;
ref.&lt;br /&gt;
- &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10301801&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;D15 - NGINX-Certbot Image&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://github.com/JonasAlfredsson/docker-nginx-certbot/blob/master/docs/good_to_know.md&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;github_good_to_know&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Container/157. Docker NGINX-Certbot 自動跟Let&#39;sEncrytp取得憑證/" />
        </entry>
        <entry>
            <title>
                154. PaddlePaddle 打包image
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Container/154. PaddlePaddle 打包image/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;這次的AI程式又更特別了，&lt;br /&gt;
一堆不相容的套件，&lt;br /&gt;
RD是在windows上開發，要包成image一堆牆，嘖嘖。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;libGL.so.1&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;apt-get install libgl1
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;pycocotools&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這個好解決，直接在requirements.txt上面增加 pycocotools&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Paddle&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;pip3 install paddlepaddle==2.4.2 -i https://mirror.baidu.com/pypi/simple
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Paddle安裝失敗&lt;br /&gt;
這個就真的機車了，後來查是因爲paddle，不支援alpine linux，&lt;br /&gt;
最後只好裝在ubuntu上面。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://github.com/PaddlePaddle/Paddle/issues/30247&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;github issue&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;torch&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cpu
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-Dockerfile&quot;&gt;FROM ubuntu:20.04
ENV PATH &amp;quot;$PATH:/usr/local/bin&amp;quot;
WORKDIR /usr/local/app
COPY . /usr/local/app

RUN apt-get update &amp;amp;&amp;amp; apt-get install -y enchant &amp;amp;&amp;amp; apt-get install -y  python3.7 python3-pip libgl1 &amp;amp;&amp;amp; apt-get clean &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*
RUN pip3 install --upgrade pip
RUN pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cpu
RUN pip3 install paddlepaddle==2.4.2 -i https://mirror.baidu.com/pypi/simple
RUN pip3 install --no-cache-dir -r requirements.txt 
ENTRYPOINT [&amp;quot;gunicorn&amp;quot;,&amp;quot;-c&amp;quot; ,&amp;quot;gunicorn_config.py&amp;quot;,&amp;quot;wsgi:app&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/Container/154. PaddlePaddle 打包image/" />
        </entry>
        <entry>
            <title>
                152. 硬碟空間不足，無法進入容器
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Container/152. 硬碟空間不足，無法進入容器/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;上週同事問我怎麼連進去容器裏面，&lt;br /&gt;
我很順的回答指令，&lt;br /&gt;
然後他就跳出 這個錯誤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;failed to create runc console socket: mkdir /tmp/pty2070058578: no space left on device: unknown&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;處理問題&quot; tabindex=&quot;-1&quot;&gt;處理問題&lt;/h3&gt;
&lt;p&gt;從錯誤訊息看起來，就是空間不足。&lt;/p&gt;
&lt;p&gt;先看看是哪邊硬碟吃滿了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;df -h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後看到user 100%...然後掛載在 / 根目錄下。&lt;br /&gt;
再來檢查當前目錄，每個資料夾的大小&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;du -hcd 1 | sort -n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最後追阿追的，追到了container的目錄&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/var/lib/docker/&lt;br /&gt;
裏面有一些container容量吃得很多，&lt;br /&gt;
最後確認是該container的log，那就砍了吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;rm -rf &amp;lt;container_id&amp;gt;.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再請同事連線，還是出現同樣的錯誤，&lt;br /&gt;
是由於linux的特性，就算你砍了檔案，&lt;br /&gt;
此檔案還是被咬住沒有釋放開(window是連砍都不能砍)，&lt;br /&gt;
所以此時去查硬碟大小，還是100% used的狀態，&lt;br /&gt;
將docker重開後，就能釋放空間了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;解決問題&quot; tabindex=&quot;-1&quot;&gt;解決問題&lt;/h3&gt;
&lt;p&gt;現在知道是container的log會一直增長，&lt;br /&gt;
那就設個條件，讓他長到一定程度後就不能再長大了。&lt;/p&gt;
&lt;p&gt;如果此路徑沒檔案，則建立&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;vim /etc/docker/daemon.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;輸入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
    &amp;quot;log-driver&amp;quot;:&amp;quot;json-file&amp;quot;,
    &amp;quot;log-opts&amp;quot;:{
        &amp;quot;max-size&amp;quot; :&amp;quot;500m&amp;quot;,&amp;quot;max-file&amp;quot;:&amp;quot;3&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;max-size : 單個容器的單檔大小&lt;br /&gt;
max-file: log數量&lt;/p&gt;
&lt;p&gt;好了後，重啓服務&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;systemctl daemon-reload
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是：設定的日誌大小規則，只對新建的容器有效&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/sxdcgaq8080/p/10689223.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;【docker】docker限制記錄檔大小的方法+查看記錄檔的方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/594e0a2af6f2&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;docker 報錯： failed to create runc console socket: mkdir /tmp/pty328598598: no space left on device&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/Container/152. 硬碟空間不足，無法進入容器/" />
        </entry>
        <entry>
            <title>
                138. gerapy+scrapyd+mongo爬蟲整套流程
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Container/138. gerapy+scrapyd+mongo爬蟲整套流程/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;有一天突然發現，我的爬蟲不會動了，原因是網站改版，所以規則要改。&lt;br /&gt;
於是，既然都要改了，那就把很久以前沒有概念的docker都改一改吧，&lt;br /&gt;
順便改成docker compose一次解決。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;更新，後來也沒用這套了，他在排程執行時有點問題，&lt;br /&gt;
最後還是回本來的scrapyweb+scrapyd+mongoDB，&lt;br /&gt;
請見文章最後的Docker-compose.yaml&lt;/p&gt;
&lt;h2 id=&quot;架設服務&quot; tabindex=&quot;-1&quot;&gt;架設服務&lt;/h2&gt;
&lt;p&gt;docker-compose.yml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version: &#39;3&#39;
services:
  scrapyd:
    container_name: scrapyd
    image: vimagick/scrapyd
    volumes:
      - ./data:/var/lib/scrapyd
      - /usr/local/lib/python3.7/dist-packages
    restart: unless-stopped
    networks:
      - scrapy_net  
  gerapy:
    container_name: gerapy
    image: germey/gerapy
    volumes:
      - ./gerapy:/app/gerapy
    ports:
      - 8000:8000
    networks:
      - scrapy_net    
  mongo:
    container_name: mongo
    image: mongo:latest
    restart: always
    volumes:
      - ./mongodbdata:/data/db
    environment:
      MONGO_INITDB_ROOT_USERNAME: daimomadmin
      MONGO_INITDB_ROOT_PASSWORD: d@imom
    networks:
      - scrapy_net
    ports:
      - 27017:27017
  mongo-express:
      container_name: mongo-express
      image: mongo-express
      restart: always
      ports:
        - 8081:8081
      environment:
        ME_CONFIG_MONGODB_SERVER: 192.168.1.78
        ME_CONFIG_MONGODB_PORT: 27017
        ME_CONFIG_MONGODB_ADMINUSERNAME: daimomadmin
        ME_CONFIG_MONGODB_ADMINPASSWORD: d%40imom
      networks:
      - scrapy_net  
networks:
  scrapy_net:
    name: scrapy
    driver: bridge
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker compose up -d
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;注意事項&quot; tabindex=&quot;-1&quot;&gt;注意事項&lt;/h3&gt;
&lt;p&gt;mongo-express 底下的  ME_CONFIG_MONGODB_ADMINPASSWORD&lt;br /&gt;
為什麼會出現 %40？&lt;/p&gt;
&lt;p&gt;因為直接用@ 會出現錯誤。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;UnhandledPromiseRejectionWarning: MongoParseError: Unescaped at-sign in authority section&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是chatGPT的回答&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Container/138-fig.1.jpg&quot; alt=&quot;138-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;gerapy&quot; tabindex=&quot;-1&quot;&gt;設定gerapy&lt;/h2&gt;
&lt;p&gt;如果是根據上面的docker compose建立的話，&lt;br /&gt;
網址用 localhost:8000登入，&lt;br /&gt;
預設的帳密是 admin/admin，進去後最好改一下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;設定 scrapyd的位置，在同一個network裏面，&lt;br /&gt;
所以能這樣互打。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Container/138-fig.2.jpg&quot; alt=&quot;138-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;上傳專案&lt;br /&gt;
這邊要注意，上傳的壓縮檔案裏面要有『  .cfg』的檔案&lt;br /&gt;
檔案結構如下&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Container/138-fig.3.jpg&quot; alt=&quot;138-fig.3.jpg&quot; /&gt;&lt;br /&gt;
壓縮的時候，請針對上層目錄直接壓縮，以上圖來說就是壓縮TaazeSpider這個資料夾。&lt;br /&gt;
上傳完後，可以按Edit，可以看到程式。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Container/138-fig.4.jpg&quot; alt=&quot;138-fig.4.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;部署到主機上&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Container/138-fig.5.jpg&quot; alt=&quot;138-fig.5.jpg&quot; /&gt;&lt;br /&gt;
必須先build，然後才可以deploy到主機上&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Container/138-fig.6.jpg&quot; alt=&quot;138-fig.6.jpg&quot; /&gt;&lt;br /&gt;
如果碰到打包失敗或是部署失敗，可以到主機上看一下log。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker logs gerapy
docker logs scrapyd
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;測試運作&lt;br /&gt;
到主機的設定畫面，選擇schedule ，然後按下run 跑跑看有沒有正常。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Container/138-fig.7.jpg&quot; alt=&quot;138-fig.7.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Container/138-fig.9.jpg&quot; alt=&quot;138-fig.9.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;設定排程&lt;br /&gt;
Name : 隨意&lt;br /&gt;
Project ：projects的名稱&lt;br /&gt;
Spider：在Schedule的名稱，可參考上圖&lt;br /&gt;
Clients：主機名稱，可以用選的&lt;br /&gt;
Trigger：crontab 是固定的時間執行&lt;br /&gt;
interval 是 隔多久執行&lt;br /&gt;
date 是 特定日期&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Container/138-fig.8.jpg&quot; alt=&quot;138-fig.8.jpg&quot; /&gt;&lt;br /&gt;
好了後可以按下status，可以看到下次執行時間，從這看有沒有設定成功。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Container/138-fig.11.jpg&quot; alt=&quot;138-fig.11.jpg&quot; /&gt;&lt;br /&gt;
這邊可以看到 Next time的時間&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Container/138-fig.10.jpg&quot; alt=&quot;138-fig.10.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://github.com/Gerapy/Gerapy/issues/176&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;docker部署打包失敗&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://github.com/Gerapy/Gerapy&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gerapy&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://www.w3schools.com/cssref/css_selectors.php&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;CSS Selector Reference&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;scrapyweb-scrapyd&quot; tabindex=&quot;-1&quot;&gt;Scrapyweb+scrapyd&lt;/h2&gt;
&lt;p&gt;最後還是用回這套了，&lt;br /&gt;
穩定度大勝，db的帳號密碼，必須與爬蟲一致&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;
version: &#39;3&#39;
services:
  scrapyd:
    container_name: scrapyd
    image: germey/scrapyd
    volumes:
      - ./data:/var/lib/scrapyd
      - /usr/local/lib/python3.7/dist-packages
    restart: unless-stopped
    networks:
      - scrapy_net  
  scrapydweb:
      container_name: scrapydweb
      image: ryanvin/scrapydweb
      depends_on:
        - scrapyd
      ports:
        - 5000:5000
      environment:
        USERNAME: daiomom
        PASSWORD: password
        SCRAPYD_SERVERS: scrapyd
      volumes:
        - ./scrapydweb_data:/app
      networks:
        - scrapy_net            
  mongo:
    container_name: mongo
    image: mongo:latest
    restart: always
    volumes:
      - ./mongodbdata:/data/db
    environment:
      MONGO_INITDB_ROOT_USERNAME: daimomadmin
      MONGO_INITDB_ROOT_PASSWORD: password
    networks:
      - scrapy_net
    ports:
      - 27017:27017
  mongo-express:
      container_name: mongo-express
      image: mongo-express
      restart: always
      ports:
        - 8081:8081
      environment:
        ME_CONFIG_MONGODB_SERVER: 192.168.1.78
        ME_CONFIG_MONGODB_PORT: 27017
        ME_CONFIG_MONGODB_ADMINUSERNAME: daimomadmin
        ME_CONFIG_MONGODB_ADMINPASSWORD: password
      networks:
      - scrapy_net  
networks:
  scrapy_net:
    name: scrapy
    driver: bridge
    
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/Container/138. gerapy+scrapyd+mongo爬蟲整套流程/" />
        </entry>
        <entry>
            <title>
                115. .net core 打包dockerfile
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Container/115. .net core 打包dockerfile/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;今天才知道vistual studio 的神奇地方，&lt;br /&gt;
直接滑鼠按一按，dockerfile就自動產生了，&lt;br /&gt;
也不用寫，不過不是vs code的版本。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-dockerfile&quot;&gt;FROM mcr.microsoft.com/dotnet/aspnet:3.1 AS base
RUN apt-get update -y &amp;amp;&amp;amp; apt-get install -y libc6-dev libgdiplus libx11-dev &amp;amp;&amp;amp; apt-get clean &amp;amp;&amp;amp; ln -s /usr/lib/libgdiplus.so /usr/lib/gdiplus.dll
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/sdk:3.1 AS build
WORKDIR /src
COPY ./**/*.csproj ./
# RUN pwd &amp;amp;&amp;amp; ls -ahl
RUN for file in $(ls *.csproj); do mkdir -p ./${file%.*}/ &amp;amp;&amp;amp; mv $file ./${file%.*}/; done
# RUN pwd &amp;amp;&amp;amp; ls SystemManageService.Backend -ahl
RUN dotnet restore SystemManageService.Backend/SystemManageService.Backend.csproj

COPY . .
RUN dotnet build SystemManageService.Backend/SystemManageService.Backend.csproj -c Release -o /app/build



FROM build AS publish
RUN dotnet publish SystemManageService.Backend/SystemManageService.Backend.csproj -c Release -o /app/publish



FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
RUN ls

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊的重點在這兩段，取得專案內所有的csproj，然後丟進去build的image裏面。&lt;br /&gt;
但是，這樣並不會根據資料夾放到其他特定的地方，&lt;br /&gt;
所以才有for file建立資料夾跟移動檔案。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;COPY ./**/*.csproj ./
# RUN pwd &amp;amp;&amp;amp; ls -ahl
RUN for file in $(ls *.csproj); do mkdir -p ./${file%.*}/ &amp;amp;&amp;amp; mv $file ./${file%.*}/; done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一行重點，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM mcr.microsoft.com/dotnet/aspnet:3.1 AS base
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此image不能拿掉，一定要有一個base的，&lt;br /&gt;
不然在開發的時候，每次都會重build一次image&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.tencent.com/developer/article/1624727&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;.NET Core Docker 再也不用逐個 COPY csproj 檔案啦！&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Container/115. .net core 打包dockerfile/" />
        </entry>
        <entry>
            <title>
                112. pyenchant &amp; opencc error fix
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Container/112. pyenchant &amp; opencc error fix/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;新公司的第一個dockerfile就撞牆，&lt;br /&gt;
莫名的錯誤，裝了還是過不了，&lt;br /&gt;
寫這個程式的說也沒用過，他們都是用本機跑AI。&lt;br /&gt;
只好自己亂搞了..&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;debug方式，都是直接去翻python的程式碼看裏面的內容。&lt;br /&gt;
這兩個大部分都用 ctypes.util.find_library  去找library。&lt;br /&gt;
然後程式內都有寫額外條件，當find_library找不到時，&lt;br /&gt;
可以從環境變數取值。&lt;br /&gt;
所以下面都是使用環境變數的方式，讓package能夠取得library。&lt;/p&gt;
&lt;h3 id=&quot;python-debug&quot; tabindex=&quot;-1&quot;&gt;python debug時的備忘事項&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;python3 package 的位置在 /usr/local/lib/python3.10/site-packages&lt;/li&gt;
&lt;li&gt;find_library，根據同事的說法，應該是抓path的路徑下去做搜尋&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然後開始看code吧。&lt;/p&gt;
&lt;h3 id=&quot;alpine-linux-enchant&quot; tabindex=&quot;-1&quot;&gt;alpine linux安裝enchant&lt;/h3&gt;
&lt;p&gt;解決  &#39;enchant&#39; C library was not found&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ImportError: The &#39;enchant&#39; C library was not found and maybe needs to be installed.
See  https://pyenchant.github.io/pyenchant/install.html
for details

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其實有安裝 py3-enchant 就好了，&lt;br /&gt;
後續是因為找不到library才會噴錯。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apk add py3-enchant aspell aspell-en
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以設定一下環境變數，收工。&lt;br /&gt;
下面程式是dockerfile用的，如果要測試就把env改成export吧&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ENV PYENCHANT_LIBRARY_PATH=/usr/lib/libenchant-2.so.2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://github.com/pyenchant/pyenchant/issues/265&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Cannot find Enchant C library on Apple Silicon&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;alpine-linux-opencc&quot; tabindex=&quot;-1&quot;&gt;alpine linux 安裝opencc&lt;/h3&gt;
&lt;p&gt;解決 libopencc.so.1 : No such file&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Traceback (most recent call last):
  File &amp;quot;/usr/local/app/Speech_control.py&amp;quot;, line 3, in &amp;lt;module&amp;gt;
    from opencc import OpenCC
  File &amp;quot;/usr/local/lib/python3.10/site-packages/opencc.py&amp;quot;, line 24, in &amp;lt;module&amp;gt;
    libopencc = CDLL(&#39;libopencc.so.1&#39;, use_errno=True)
  File &amp;quot;/usr/local/lib/python3.10/ctypes/__init__.py&amp;quot;, line 374, in __init__
    self._handle = _dlopen(self._name, mode)
OSError: Error loading shared library libopencc.so.1: No such file or directory
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Container/blog.112.fig-1.jpg&quot; alt=&quot;blog.112.fig-1.jpg&quot; /&gt;&lt;br /&gt;
因為opencc在 repository的testing上面，&lt;br /&gt;
用下面的方法裝&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apk add opencc --repository=http://dl-cdn.alpinelinux.org/alpine/edge/testing/

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;好了後設定環境變數(這是dockerfile用的)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ENV LIBOPENCC=/usr/lib/libopencc.so.1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;dockerfile&quot; tabindex=&quot;-1&quot;&gt;完整dockerfile&lt;/h3&gt;
&lt;p&gt;這個alpine linux , build出來 181.73MB&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM python:alpine3.16
ENV PATH &amp;quot;$PATH:/usr/local/bin&amp;quot;
WORKDIR /usr/local/app
RUN apk update &amp;amp;&amp;amp; apk add py3-enchant aspell aspell-en  &amp;amp;&amp;amp; apk add opencc --repository=http://dl-cdn.alpinelinux.org/alpine/edge/testing/
ENV LIBOPENCC=/usr/lib/libopencc.so.1.1
ENV PYENCHANT_LIBRARY_PATH=/usr/lib/libenchant-2.so.2
COPY ./Chatbot_Speech /usr/local/app
RUN pip3 install --upgrade pip
RUN pip3 install --no-cache-dir -r requirements.txt
ENTRYPOINT [&amp;quot;python&amp;quot;, &amp;quot;Speech.py&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用ubuntu ,build 出來 511.74MB，&lt;br /&gt;
本來是6xx，後來清了一下cache，縮減一下步驟後，才變成511MB&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM ubuntu:20.04
ENV PATH &amp;quot;$PATH:/usr/local/bin&amp;quot;
WORKDIR /usr/local/app
COPY ./Chatbot_Speech /usr/local/app
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y enchant &amp;amp;&amp;amp; apt-get install -y  python3.6 python3-pip &amp;amp;&amp;amp; apt-get clean &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*
RUN pip3 install --upgrade pip
RUN pip3 install --no-cache-dir -r requirements.txt 
ENTRYPOINT [&amp;quot;python3&amp;quot;, &amp;quot;Speech.py&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10246952&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; 最佳化 Dockerfile - 精簡 image&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Container/112. pyenchant &amp; opencc error fix/" />
        </entry>
        <entry>
            <title>
                0.Container MOC
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Container/0.Container MOC/</id>
            <content type="html">
                &lt;h1 id=&quot;docker-debug&quot; tabindex=&quot;-1&quot;&gt;Docker Debug&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Container/29.Dockerfile%20echo%20something/&quot;&gt;29.Dockerfile echo something&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Container/152.%20%E7%A1%AC%E7%A2%9F%E7%A9%BA%E9%96%93%E4%B8%8D%E8%B6%B3%EF%BC%8C%E7%84%A1%E6%B3%95%E9%80%B2%E5%85%A5%E5%AE%B9%E5%99%A8/&quot;&gt;152. 硬碟空間不足，無法進入容器&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Container/168.%20Docker%20build%E5%A4%B1%E6%95%97%E8%B7%B3%E5%87%BAkilled/&quot;&gt;168. Docker build失敗跳出killed&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;dockerfile&quot; tabindex=&quot;-1&quot;&gt;Dockerfile&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Container/32.%20nuxtJS%20%E7%9A%84%20Dockerfile/&quot;&gt;32. nuxtJS 的 Dockerfile&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Container/112.%20pyenchant%20&amp;%20opencc%20error%20fix/&quot;&gt;112. pyenchant &amp;amp; opencc error fix&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Container/115.%20.net%20core%20%E6%89%93%E5%8C%85dockerfile/&quot;&gt;115. .net core 打包dockerfile&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Container/138.%20gerapy+scrapyd+mongo%E7%88%AC%E8%9F%B2%E6%95%B4%E5%A5%97%E6%B5%81%E7%A8%8B/&quot;&gt;138. gerapy+scrapyd+mongo爬蟲整套流程&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Container/170.%20Docker%E5%95%93%E7%94%A8GPU/&quot;&gt;170. Docker啓用GPU&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Container/0.Container MOC/" />
        </entry>
        <entry>
            <title>
                47. GO get 參數
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Code/Golang/47. GO get 參數/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;參數&lt;/p&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;p&gt;-d&lt;/p&gt;
&lt;p&gt;執行下載，但不執行安裝動作。&lt;/p&gt;
&lt;p&gt;-f&lt;/p&gt;
&lt;p&gt;只有在使用 -u 參數時，才會有效。可以忽略檢查以下載 package 的導入路徑。如果代碼是從其他項目 fork ，就可以採取這樣的做法。&lt;/p&gt;
&lt;p&gt;-fix&lt;/p&gt;
&lt;p&gt;下載 package 先執行修正在進行編譯安裝。&lt;/p&gt;
&lt;p&gt;-insecure&lt;/p&gt;
&lt;p&gt;允許使用 http (非安全) 來下載 package，通常是在內部開發環境使用。&lt;/p&gt;
&lt;p&gt;-t&lt;/p&gt;
&lt;p&gt;下載 package ，在安裝過程同時下載安裝相關依賴代碼包。&lt;/p&gt;
&lt;p&gt;-u&lt;/p&gt;
&lt;p&gt;強制更新已經下載的 package 以及依賴代碼包。（go get 預設指會不會更新已經下載的package)&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://hoohoo.top/blog/go-module-and-go-get-common-parameter-descriptions/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GO MODULE與 GO GET 常用參數說明&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Code/Golang/47. GO get 參數/" />
        </entry>
        <entry>
            <title>
                40. golang 重新讀取設定檔的方法
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Code/Golang/40. golang 重新讀取設定檔的方法/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;因為碰到一個奇怪的問題，需要一直去改golang的config檔，&lt;/p&gt;
&lt;p&gt;所以就再想了，能不能像以前的php或html，單純改config，重新整理就能抓到資料。&lt;/p&gt;
&lt;p&gt;結果.......&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;先說結論，直接修改config，然後強制關閉golang的process ，是行不通的。&lt;/p&gt;
&lt;p&gt;環境，golang   pod，執行程式的方式，&lt;br /&gt;
是先 打包成一個檔案，再放到alpine linux上面的pod直接執行。&lt;/p&gt;
&lt;h3 id=&quot;config&quot; tabindex=&quot;-1&quot;&gt;目標，不重新打包程式修改config&lt;/h3&gt;
&lt;p&gt;實驗的方法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先查詢是不是有golang的程式在執行&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	ps
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Code/Golang/40-fig.1.jpg&quot; alt=&quot;40-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;由於此程式是直接抓同資料夾的config&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Code/Golang/40-fig.2.jpg&quot; alt=&quot;40-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;悲劇得來了，修改完appsettings.json後，只要刪除/app/main ，就會直接跳出，pod自動重啟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	kill -s 26
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://blog.gtwang.org/linux/linux-kill-killall-xkill/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;在 Linux 中使用 kill、killall 與 xkill 等指令強迫關閉程式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後有幾個方案，golang有&lt;br /&gt;
&lt;a href=&quot;https://learnku.com/articles/33561&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;熱更新配置文件&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://studygolang.com/articles/5398&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Golang熱加載配置實踐&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不動程式的話，目前想到的是，直接重新打包，把config丟進去image裡面。&lt;/p&gt;
&lt;p&gt;來源的映像檔，直接改成本來的image，&lt;br /&gt;
然後copy 改完的appsetings.json到目的，&lt;br /&gt;
這樣程式不用重新編譯，但要重新打包image。&lt;br /&gt;
docker build&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM gcr.io/rproject/source:adminQA-0.0.27
ARG website
ARG location
ARG type
WORKDIR /app

COPY  appsettings.json /app/

EXPOSE 80
# 不更改權限會發生權限錯誤
RUN chmod +x /init.sh
RUN [&amp;quot;chmod&amp;quot;, &amp;quot;+x&amp;quot;, &amp;quot;/init.sh&amp;quot;]
ENTRYPOINT [&amp;quot;sh&amp;quot;,&amp;quot;-x&amp;quot;,&amp;quot;/init.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/Code/Golang/40. golang 重新讀取設定檔的方法/" />
        </entry>
        <entry>
            <title>
                155. scrapy爬暗黑編年史的世界王時間
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Code/Golang/155. scrapy爬暗黑編年史的世界王時間/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;好久沒寫爬蟲了，&lt;br /&gt;
最近玩暗黑IV，開始接觸到世界王的時候，時間很不固定，&lt;br /&gt;
然後隔了幾天發現&lt;a href=&quot;https://diablo4.cc/tw/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;暗黑編年史&lt;/a&gt;，&lt;br /&gt;
有世界王的通知時間倒數了。&lt;br /&gt;
有資料就好辦了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;開啓scrapy專案&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;scrapy start &amp;lt;project_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;初始化(在上一個步驟執行完後，就有相關指令會顯示在螢幕上)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;scrapy genspider d4spider https://diablo4.cc/tw/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;結構如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;├── LICENSE
├── README.md
├── d4notify
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-310.pyc
│   │   └── settings.cpython-310.pyc
│   ├── items.py
│   ├── middlewares.py
│   ├── pipelines.py
│   ├── settings.py
│   └── spiders
│       ├── __init__.py
│       ├── __pycache__
│       │   └── __init__.cpython-310.pyc
│       └── d4spider.py
└── scrapy.cfg
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;執行&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;scrapy crawl d4spider
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/daimom/d4notify&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GITHUB-D4Notfiy&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;取得屬性&lt;br /&gt;
碰到個奇怪的語法，div裏面有個自訂的屬性，&lt;br /&gt;
用scrapy要取值的話，&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div data-displaytime=&amp;quot;1687258903&amp;quot;&amp;gt;2023-06-20 19:01&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;div::attr(data-displaytime).get()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這樣會取得 1687258903 這個數字&lt;br /&gt;
ref. &lt;a href=&quot;https://stackoverflow.com/questions/53074642/scrapy-scraping-html-custom-attributes&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;scrapy-scraping-html-custom-attributes&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;extract_first() 跟 extract() ,可用get()跟getall()取代&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/selectors.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;選擇器(Selectors)&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Code/Golang/155. scrapy爬暗黑編年史的世界王時間/" />
        </entry>
        <entry>
            <title>
                59. git refs，branch 跟 tag是一樣的。
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Code/59. git refs，branch 跟 tag是一樣的。/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;git的主要架構其實都圍繞着 refs ，&lt;br /&gt;
branch 跟 tag 其實是一樣的東西，&lt;br /&gt;
直接去看 .git的資料夾，可以看到下面的架構。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	tree .git/refs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;├── heads&lt;br /&gt;
│   ├── apm2&lt;br /&gt;
│   └── testapmlog&lt;br /&gt;
├── remotes&lt;br /&gt;
│   └── origin&lt;br /&gt;
│       ├── HEAD&lt;br /&gt;
│       ├── apm2&lt;br /&gt;
│       ├── dev_spring20211027&lt;br /&gt;
└── tags&lt;/p&gt;
&lt;p&gt;heads 目錄，描述在本機上的所有分支，每一個檔案對應相應的目錄。&lt;br /&gt;
開啟檔案的話，會看到一個commit的雜湊值，&lt;br /&gt;
而不管是branch 或 tag 都是根據此雜湊值，來決定你程式目前是哪個版本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat .git/refs/heads/apm2

git log -1 apm2 
or
git show apm2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這兩個的雜湊值會一樣，&lt;br /&gt;
所以建立一個新的分支，對git來說，也只是將當下的雜湊值寫到一個檔案內。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://codertw.com/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC%E5%B7%A5%E5%85%B7/25108/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Git系列之Refs 與 Reflog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.atlassian.com/git/tutorials/refs-and-the-reflog&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;原文- Refs and the Reflog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/Code/59. git refs，branch 跟 tag是一樣的。/" />
        </entry>
        <entry>
            <title>
                38.正則取代，留下特定字串
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Code/38.正則取代，留下特定字串/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;懶人的方式又來了，&lt;br /&gt;
有一整批的資料，一個一個改我覺得好麻煩，&lt;br /&gt;
那就用正則整批修吧&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;先來看個範例，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;
	&amp;lt;field name=&amp;quot;videoId&amp;quot;&amp;gt;&amp;lt;![CDATA[28713]]&amp;gt;&amp;lt;/field&amp;gt;
	&amp;lt;field name=&amp;quot;code&amp;quot;&amp;gt;&amp;lt;![CDATA[CWPBD-62]]&amp;gt;&amp;lt;/field&amp;gt;
	&amp;lt;field name=&amp;quot;artistId&amp;quot;&amp;gt;&amp;lt;![CDATA[5005]]&amp;gt;&amp;lt;/field&amp;gt;
	&amp;lt;field name=&amp;quot;sort&amp;quot;&amp;gt;&amp;lt;![CDATA[9054]]&amp;gt;&amp;lt;/field&amp;gt;
	&amp;lt;field name=&amp;quot;views&amp;quot;&amp;gt;&amp;lt;![CDATA[23004]]&amp;gt;&amp;lt;/field&amp;gt;
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要將![CDATA[]] 中間的字串留下來，&lt;br /&gt;
這邊其實有兩種做法，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一種是用取代的，先把 ![CDATA[  刪除，再把 ]] 刪除&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;還有另一種就是下面的範例，直接用正則取代，留下中間的字串。&lt;/p&gt;
&lt;p&gt;先寫好一個正則，可以抓到 CDATA的資料&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(&#92;!&#92;[CDATA&#92;[)(.*)(&#92;]&#92;])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以到  &lt;a href=&quot;https://coding.tools/tw/regex-tester&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;正則在線測試&lt;/a&gt; 測試&lt;/p&gt;
&lt;p&gt;在 ATOM的話，於取代的位置寫上$2 ，這樣就會 留下中間的字了。(fig.1)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Code/38-fig.1.jpg&quot; alt=&quot;38-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果是在微軟的excel，則是使用 &#92;2 ，這樣才會留下中間的字。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;chrome-extension://bocbaocobfecmglnmeaeppambideimao/pdf/viewer.html?file=http%3A%2F%2Fwww.tpqri.org.tw%3A8080%2FFileUpload%2FActivity%2FActivity51%2FRegularExpressionTutorialVer350.pdf&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Regular Expression（正則表達式）&lt;br /&gt;
入門修練 Ver3.50&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Code/38.正則取代，留下特定字串/" />
        </entry>
        <entry>
            <title>
                22.telegram api使用
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Code/22.telegram api使用/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;上一篇寫到用flagger，建立webhook發送通知。&lt;br /&gt;
公司有在用的就skype跟 telegram，所以就....開始吧&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先你要有telegram帳號 XDDD&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加入 @BotFather ，輸入指令 /newBot，開始命名，注意機器人名稱可以不用bot結尾，但@帳號最後一定是Bot結尾&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/Code/22.fig-1.jpg&quot; alt=&quot;22.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立好了後，會有一組token，請不要隨意給人，因為只要有這組就能發送訊息出去了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Code/22.fig-2.jpg&quot; alt=&quot;22.fig-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;到此已經完成一半了，再來是使用取得channel的id，先將channel的頻道設公開，並把機器人加入到channel裡面。&lt;br /&gt;
這邊需要記得你的chatid，不能跟其他人的重複，所以需要自己試試。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Code/22.fig-3.jpg&quot; alt=&quot;22.fig-3.jpg&quot; /&gt;&lt;br /&gt;
ezioflaggernotfiy就是我的chatid，&lt;br /&gt;
然後組合一下api，送出去就能取得channel的id，請先將機器人加入到channel裡面。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://api.telegram.org/bot{token}/sendMessage?chat_id={chatid}&amp;amp;text=Hello,world
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;{token} 在 step.3，前面記得加bot&lt;br /&gt;
{chatid} 在step.4 ，記得前面要加 &lt;code&gt;@&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;送出去後，回傳的資料上面會顯示 &lt;a href=&quot;http://chat.id/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;chat.id&lt;/a&gt;，此時就能把channel 設成 private了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Code/22.fig-4.jpg&quot; alt=&quot;22.fig-4.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;如果是公開的channel，就到第四步就結束了。&lt;br /&gt;
如果是私人的話，將chatid改成 ，上面step.4拿到的 &lt;a href=&quot;http://chat.id/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;chat.id&lt;/a&gt; ，即可。&lt;br /&gt;
不用再加@ 在chat_id前面了。此時所用的已是唯一的channel sn。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;https://api.telegram.org/bot1234:JMwL6qw/sendMessage&#92;?chat_id&#92;=-12345&#92;&amp;amp;text&#92;=hello,telegram
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;如果訊息太長，想要有明顯一點的訊息，可加上parse_mode=html&lt;br /&gt;
並在字的前後加上&lt;code&gt;abc&lt;/code&gt;，在電腦上看到的字會明顯許多。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Code/22.fig-5.jpg&quot; alt=&quot;22.fig-5.jpg&quot; /&gt;&lt;br /&gt;
(fig.5)&lt;br /&gt;
但在手機上的telegram，看不到此特效。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://slashview.com/archive2020/20200319.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Telegram Bot機器人申請與Webhook指令全紀錄&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/ask/146200&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;如何獲得正確的telegram channel id?？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://core.telegram.org/bots#botfather&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; An introduction for developers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://core.telegram.org/bots/api#sendmessage&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;telegram-sendMessage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rdrr.io/cran/telegram.bot/man/sendMessage.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;sendMessage: Send text messages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tgtw.cc/post-about-parse-mode-of-telegram&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;關於 Telegram 上的解析模式（Markdown、HTML）、文字格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/Code/22.telegram api使用/" />
        </entry>
        <entry>
            <title>
                145. git submodule 下載失敗
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Code/145. git submodule 下載失敗/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;因為他們的新專案有用到 git的submodule，&lt;br /&gt;
之前也用過一次了，想說應該還好，&lt;br /&gt;
但這次就是怎麼驗證，怎麼不過。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;都是出現這個錯誤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cloning into &#39;/drone/src/BackendSharedLib&#39;...&lt;br /&gt;
Host key verification failed.&lt;br /&gt;
fatal: Could not read from remote repository.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Code/145-fig.1.jpg&quot; alt=&quot;145-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;但之前寫的專案就沒這個問題，找阿找，最後終於發現，&lt;br /&gt;
差異在 建立 submodule的時候。&lt;/p&gt;
&lt;p&gt;打開 .gitmodules 上面會寫 url的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[submodule &amp;quot;SMSBackendSharedLib&amp;quot;]
	path = SMSBackendSharedLib
	url = git@github.com:ABC/sms-backend-sharedlib.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本來是上面這種寫法，他會用ssh的方式去抓submodule的檔案。&lt;/p&gt;
&lt;p&gt;所以要把url改成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[submodule &amp;quot;SMSBackendSharedLib&amp;quot;]
	path = SMSBackendSharedLib
	url = https://github.com/ABC/sms-backend-sharedlib.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再來用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git submodule update --init --recursive
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本機也可以下載了。&lt;/p&gt;
&lt;p&gt;本來還懷疑是不是drone clone submodule的時候，用到錯誤的使用者。&lt;br /&gt;
結果一查根本沒有使用者。&lt;br /&gt;
可以用下面的指令查查&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --list

git config user.name
git config user.email
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;簡單解釋一下 submodule，&lt;br /&gt;
以下從chatGPT抄來的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Git 中，Submodule 是一個允許您在 Git 倉庫中包含另一個 Git 倉庫的機制。通過使用 Submodule，您可以將一個 Git 倉庫作為另一個 Git 倉庫的子目錄進行管理。這對於管理大型專案或共享程式庫非常有用。&lt;/p&gt;
&lt;p&gt;當您在 Git 倉庫中新增 Submodule 時，它實際上是包含另一個 Git 倉庫的指向。當您 clone 或 pull 主倉庫時，Git 只會下載 Submodule 的指向，而不會將 Submodule 的內容一併下載。這樣可以節省空間和時間，同時還可以使主倉庫更加輕便。&lt;/p&gt;
&lt;p&gt;如果您想要更新 Submodule 的內容，可以使用 &lt;code&gt;git submodule update&lt;/code&gt; 命令來下載 Submodule 的內容。當您修改 Submodule 的內容時，您需要先進入 Submodule 的目錄，對其進行 commit 和 push，然後返回主倉庫，對 Submodule 的指向進行 commit 和 push。這樣可以確保 Submodule 的指向指向正確的 commit。&lt;/p&gt;
&lt;p&gt;總之，Submodule 是一個非常有用的機制，可以使 Git 倉庫管理更加靈活和有效。&lt;/p&gt;
&lt;/blockquote&gt;

            </content>
            <link href="https://daimom.vercel.app/Code/145. git submodule 下載失敗/" />
        </entry>
        <entry>
            <title>
                110.github action pipeline筆記
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Code/110.github action pipeline筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;因為之前用的巴哈自動簽到，那個github被封了，&lt;br /&gt;
說違反服務條款，還好我主程式有下載下來過。&lt;br /&gt;
未來把他打包成image後在本機跑了吧，&lt;br /&gt;
不過要先解析github的workflow看是怎麼打包成image的&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;    name: Publish
    
    on:
        push:
            branches:
                - main
            paths-ignore:
                - &amp;quot;**.md&amp;quot;
        workflow_dispatch:
    
    jobs:
    
        publish_docker:
            runs-on: ubuntu-latest
            steps:
                - name: Checkout Source Code
                  uses: actions/checkout@v3
    
                - name: Install PNPM
                  uses: pnpm/action-setup@v2.2.2
                  with:
                      version: latest
                      run_install: true
    
                - name: Build Package
                  run: pnpm build:package
    
                - name: Set up QEMU
                  uses: docker/setup-qemu-action@v2
    
                - name: Set up Docker Buildx
                  uses: docker/setup-buildx-action@v2
    
                - name: Login to Docker Hub
                  uses: docker/login-action@v2
                  with:
                      username: $
                      password: $
    
                - name: Build Image and Push
                  run: |
                      pnpm build:package
                      pnpm build:docker
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;name : action的名稱&lt;/li&gt;
&lt;li&gt;on ：什麼時候觸發&lt;/li&gt;
&lt;li&gt;job: 要執行的動作&lt;/li&gt;
&lt;li&gt;publish_docker : 作業的名稱&lt;/li&gt;
&lt;li&gt;runs-on: 執行的os&lt;/li&gt;
&lt;li&gt;steps：執行的步驟&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h1&gt;
&lt;p&gt;用了一陣子以後，&lt;br /&gt;
那個專案被github封掉了，&lt;br /&gt;
最後改用chrome 的外掛 &lt;img src=&quot;https://chrome.google.com/webstore/detail/%E5%B7%B4%E5%93%88%E8%87%AA%E5%8B%95%E7%B0%BD%E5%88%B0/nlcekebohjbgnfgjicklnjbnefmmgggk&quot; alt=&quot;巴哈自動簽到&quot; /&gt; ，&lt;br /&gt;
缺點就是電腦要一直開著，反正我電腦也一直開着所以沒關係&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Code/110.github action pipeline筆記/" />
        </entry>
        <entry>
            <title>
                107. vscode 忽略設定同步
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Code/107. vscode 忽略設定同步/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;公司一臺電腦，我自己帶了一臺mac過去，&lt;br /&gt;
因為我已經linux用習慣了（X）&lt;br /&gt;
不得不說mac用習慣真的好順...&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Code/107.fig-1.jpg&quot; alt=&quot;107.fig-1.jpg&quot; /&gt;&lt;br /&gt;
應該都知道linux的檔案系統跟windows的檔案系統不一樣。&lt;br /&gt;
前者沒有C、D、E的概念，&lt;br /&gt;
所以vscode的  &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=shalldie.background&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;background&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在圖片路徑的設定上會不一樣，mac是使用下麵這種方式設定vscode的背景&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;file:///Users/daimom/Pictures/1275337.jpeg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;windows則是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;file://c:&#92;Users&#92;user&#92;Pictures&#92;1275337.jpeg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一旦同步的話，兩邊的路徑就會衝突，導致一邊沒圖片。&lt;/p&gt;
&lt;p&gt;所以現在要設定，忽略vscode的同步設定，讓他不要把圖片設定的地方也同步。&lt;/p&gt;
&lt;p&gt;在設定的查詢欄位，輸入 『同步』，&lt;br /&gt;
選擇忽略的設定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/Code/107.fig-2.jpg&quot; alt=&quot;107.fig-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;應該會看到 settingsSync.ignoredSettings ，&lt;br /&gt;
底下輸入background.customImages&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;settingsSync.ignoredSettings&amp;quot;: [

&amp;quot;background.customImages&amp;quot;

],
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.vercel.app/Code/107. vscode 忽略設定同步/" />
        </entry>
        <entry>
            <title>
                0.Code MOC
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/Code/0.Code MOC/</id>
            <content type="html">
                &lt;h2 id=&quot;api&quot; tabindex=&quot;-1&quot;&gt;API串接&lt;/h2&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Code/22.telegram%20api%E4%BD%BF%E7%94%A8/&quot;&gt;22.telegram api使用&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;golang&quot; tabindex=&quot;-1&quot;&gt;Golang&lt;/h2&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Code/Golang/40.%20golang%20%E9%87%8D%E6%96%B0%E8%AE%80%E5%8F%96%E8%A8%AD%E5%AE%9A%E6%AA%94%E7%9A%84%E6%96%B9%E6%B3%95/&quot;&gt;40. golang 重新讀取設定檔的方法&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Code/Golang/47.%20GO%20get%20%E5%8F%83%E6%95%B8/&quot;&gt;47. GO get 參數&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Code/Golang/155.%20scrapy%E7%88%AC%E6%9A%97%E9%BB%91%E7%B7%A8%E5%B9%B4%E5%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C%E7%8E%8B%E6%99%82%E9%96%93/&quot;&gt;155. scrapy爬暗黑編年史的世界王時間&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.vercel.app/404&quot;&gt;156. Golang簡略筆記（一）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;正則表達式&quot; tabindex=&quot;-1&quot;&gt;正則表達式&lt;/h2&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Code/38.%E6%AD%A3%E5%89%87%E5%8F%96%E4%BB%A3%EF%BC%8C%E7%95%99%E4%B8%8B%E7%89%B9%E5%AE%9A%E5%AD%97%E4%B8%B2/&quot;&gt;38.正則取代，留下特定字串&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;git&quot; tabindex=&quot;-1&quot;&gt;Git&lt;/h2&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Code/59.%20git%20refs%EF%BC%8Cbranch%20%E8%B7%9F%20tag%E6%98%AF%E4%B8%80%E6%A8%A3%E7%9A%84%E3%80%82/&quot;&gt;59. git refs，branch 跟 tag是一樣的。&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Code/110.github%20action%20pipeline%E7%AD%86%E8%A8%98/&quot;&gt;110.github action pipeline筆記&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Code/145.%20git%20submodule%20%E4%B8%8B%E8%BC%89%E5%A4%B1%E6%95%97/&quot;&gt;145. git submodule 下載失敗&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;ide&quot; tabindex=&quot;-1&quot;&gt;IDE&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Code/107.%20vscode%20%E5%BF%BD%E7%95%A5%E8%A8%AD%E5%AE%9A%E5%90%8C%E6%AD%A5/&quot;&gt;107. vscode 忽略設定同步&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/Code/0.Code MOC/" />
        </entry>
        <entry>
            <title>
                193. Obsidian發佈到github.io
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/193. Obsidian發佈到github.io/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;前陣子弄好了Obsidian自動發佈到&lt;a href=&quot;https://daimom.vercel.app/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;vercel&lt;/a&gt;，&lt;br /&gt;
成果也還不錯，但就是偶爾有點問題，&lt;br /&gt;
因為是免費用戶，所以會碰到無法更新。&lt;br /&gt;
有天一怒之下，就自己改成用github了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;首先前面還是一樣&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/SideProject/160.Obsidian%E7%99%BC%E4%BD%88%E7%B6%B2%E7%AB%99/&quot;&gt;160.Obsidian發佈網站&lt;/a&gt;，&lt;br /&gt;
步驟要先設定好從Obsidiant傳到你的github。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/193-fig.1.png&quot; alt=&quot;193-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;當你在Obsidian選擇publish時，會將內容傳到public_vercel 這個repository。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/193-fig.2.jpg&quot; alt=&quot;193-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以，接下來的流程是，在public_vercel 使用github action，&lt;br /&gt;
將obsidian的內容編譯成html，再轉到github的網站上面。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;到github建立個人網頁&lt;br /&gt;
到github，建立一個自己使用者的子網域，&lt;br /&gt;
repository的名稱會是 &lt;code&gt;user.github.io&lt;/code&gt; 這種名稱，&lt;br /&gt;
只有&lt;code&gt;user&lt;/code&gt;這個字可以改。&lt;br /&gt;
建立完後，可以先弄個index.html到github裏面，&lt;br /&gt;
然後訪問剛剛建立的網址，&lt;br /&gt;
我建立的名稱為&lt;code&gt;daimom.github.io&lt;/code&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/193-fig.3.jpg&quot; alt=&quot;193-fig.3.jpg&quot; /&gt;&lt;br /&gt;
所以網址就是 &lt;a href=&quot;https://daimom.github.io/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;daimom.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;github_page&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;將npm轉成pnpm&lt;br /&gt;
其實這一步也可以不做，&lt;br /&gt;
那就是寫github action的時候，不能用pnpm只能用npm，&lt;br /&gt;
程式應該也要小改一下，&lt;br /&gt;
但pnpm會比較快，我就順便改一改了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到 public_vercel的資料夾底下，執行下面三行，參考&lt;a href=&quot;https://booop.net/migrate-from-npm-to-pnpm/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;從 npm 遷移到 pnpm&lt;/a&gt;，&lt;br /&gt;
有些步驟我測試是不需要，&lt;br /&gt;
重點是 &lt;code&gt;pnpm import&lt;/code&gt;，要將&lt;code&gt;package-lock.json&lt;/code&gt; 轉成 &lt;code&gt;pnpm-lock.yaml&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 刪除npm package
rm -rf node_modules 
# 安裝pnpm
npm install -g pnpm
# 轉換相關檔案
pnpm import
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成後，上傳到github。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;建立github action&lt;br /&gt;
資料夾結構如下&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/193-fig.4.jpg&quot; alt=&quot;193-fig.4.jpg&quot; /&gt;&lt;br /&gt;
能改檔案名稱的只有&lt;code&gt;build-site.yaml&lt;/code&gt;以及 &lt;code&gt;install-pnpm&lt;/code&gt;，&lt;br /&gt;
但後者要改的話，程式內容也需要改，不熟的話不建議更改。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;build-site.yaml的程式如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;name: &#39;Build Sites&#39;

on:
  workflow_dispatch:
    inputs:
      deployment-version:
        description: 指定版本
        required: false
  schedule:
    - cron: &#39;0 10 * * *&#39;
jobs:
  build-site-test:
    runs-on: ubuntu-latest
    steps:
      # [Checkout]
      - name: Checkout code repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # [執行腳本] 構建 pnpm 及 Node 環境
      - name: &#39;[Macro] Prepare environment&#39;
        uses: ./.github/actions/install-pnpm

      # [執行腳本] 構建html
      - name: &#39;[Macro] Build sites &#39;
        shell: bash
        run: pnpm build

      - name: Push to HTML Repository
        run: |
          git config --global user.email $
          git config --global user.name &amp;quot;daimom&amp;quot;
          git config --list
          git clone https://$@github.com/daimom/daimom.github.io.git temp-html-repo
          cp -r dist/. temp-html-repo/
          
          cd temp-html-repo
          git add .
          git commit -m &amp;quot;Update from Build Repository&amp;quot;
          git remote -v
          git push origin main

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;install-pnpm/action.yaml的程式如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;name: &#39;prepare&#39;
description: &#39;Prepare environment&#39;

runs:
  using: &#39;composite&#39;
  steps:
    - name: Setup pnpm
      uses: pnpm/action-setup@v2
      with:
        version: 8
    - name: Setup node.js
      uses: actions/setup-node@v4
      with:
        node-version: 20
        cache: &#39;pnpm&#39;

    - name: Install dependencies
      shell: bash
      run: pnpm install

&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&quot;簡易說明&quot; tabindex=&quot;-1&quot;&gt;簡易說明&lt;/h5&gt;
&lt;p&gt;這邊的設定是每天的UTC 10:00 執行一次，&lt;br /&gt;
如果要自定時間的話，可以參考&lt;a href=&quot;https://crontab.informaship.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Crontab 中文線上 編輯器&lt;/a&gt;&lt;br /&gt;
測試的時候可以先把&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  schedule:
    - cron: &#39;0 10 * * *&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push:
  branches:
	- &#39;main&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這樣只要推上去main就會觸發動作了(注意排版)。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://gugod.org/2021/02/run-twitter-bot-with-github-actions/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;以 GitHub Action 來發推文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;程式裏面的 &lt;code&gt;$ &lt;/code&gt; 是要到repository裏面設定。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/193-fig.5.jpg&quot; alt=&quot;193-fig.5.jpg&quot; /&gt;&lt;br /&gt;
也可以直接輸入你的email，反正email這東西應該已經...。&lt;br /&gt;
但重點是底下的 &lt;code&gt;$&lt;/code&gt; ，&lt;br /&gt;
這個一定要用secret隱藏，而且不能外流。&lt;br /&gt;
產生的方式，詳閱， &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/SideProject/160.Obsidian%E7%99%BC%E4%BD%88%E7%B6%B2%E7%AB%99/#github-token&quot;&gt;160.Obsidian發佈網站#建立github token&lt;/a&gt;&lt;br /&gt;
再來將產生的token，新增到sercret裏面。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.github.com/zh/actions&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GitHub Actions 文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/Code/110.github%20action%20pipeline%E7%AD%86%E8%A8%98/&quot;&gt;110.github action pipeline筆記&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/193. Obsidian發佈到github.io/" />
        </entry>
        <entry>
            <title>
                191. Steam deck安裝除錯記
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/191. Steam deck安裝除錯記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;好久沒買聖誕禮物了，&lt;br /&gt;
前陣子又有人說steam deck oled很推，&lt;br /&gt;
看了幾次都沒現貨，&lt;br /&gt;
上週五，剛好喵到pchome有貨，下訂隔天到。&lt;br /&gt;
禮拜六吃喜酒，又逛了一下lalaport，&lt;br /&gt;
禮拜天中午跟朋友吃飯，才開始動工，&lt;br /&gt;
然後就是一整個踩坑記。&lt;/p&gt;
&lt;p&gt;禮拜天開始安裝，第一次搞steam一堆問題。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;1&quot; tabindex=&quot;-1&quot;&gt;安裝時，一直卡在安裝剩餘1秒&lt;/h3&gt;
&lt;p&gt;我試了幾種方法，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;重開機（沒用），重開了五六次，還是卡住&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;看&lt;a href=&quot;https://www.reddit.com/r/SteamDeck/comments/t4x2q6/steamdeck_setup_stuck_at_1_second_remaining_for/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;redit&lt;/a&gt;說 不要連2.4g的wifi，重開機安裝，一樣卡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不斷關閉wifi後，重連我也試過，沒用(設定開關在右下方的那三個點）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最後改連手機的熱點分享，終於過了&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;外掛推薦(不裝也可以）&quot; tabindex=&quot;-1&quot;&gt;外掛推薦(不裝也可以）&lt;/h3&gt;
&lt;p&gt;目前看到的都是一些比較個人化的東西，&lt;/p&gt;
&lt;p&gt;也可能我遊戲玩不多，&lt;/p&gt;
&lt;p&gt;之前主要都在玩p4&lt;/p&gt;
&lt;p&gt;第一步先安裝 &lt;a href=&quot;https://github.com/SteamDeckHomebrew/decky-loader&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Decky loader&lt;/a&gt;，可以參考 版上的 &lt;a href=&quot;https://forum.gamer.com.tw/C.php?bsn=60599&amp;amp;snA=39936&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;這篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（桌面模式，按左下的steam按鈕-&amp;gt;電源-&amp;gt;切換至桌面）&lt;/p&gt;
&lt;p&gt;（沒外接鍵盤的話，需按下 steam按鈕+X ，開啓螢幕小鍵盤)&lt;/p&gt;
&lt;p&gt;前面的設定先改好，後面安裝不需要輸入指令，在&lt;a href=&quot;https://github.com/SteamDeckHomebrew/decky-loader&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;網站&lt;/a&gt;上點擊即可下載，&lt;/p&gt;
&lt;p&gt;然後對着下載下來的檔案，點兩下安裝，&lt;/p&gt;
&lt;p&gt;最後從桌面上的 圖示，回到掌機畫面。&lt;/p&gt;
&lt;p&gt;目前我裝的有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Bluetooth ： 據說是能讓藍牙耳機自動連線&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Animation Changer：關機(長按電源）、暫停（短按電源）的畫面修改&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ProtonDB Badges：判斷遊戲在裝置上的可玩性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SteamGridDB：修改掌機模式下遊戲的圖片，裝這個是掌機模式下的Chrome沒圖案真的太醜了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CSS-Loader：桌面佈景，可以到&lt;a href=&quot;https://deckthemes.com/themes?filters=&amp;amp;order=Most+Downloaded&amp;amp;type=CSS&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;官網&lt;/a&gt;看有哪些&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;animation-changer&quot; tabindex=&quot;-1&quot;&gt;Animation Changer ，影片放大&lt;/h4&gt;
&lt;p&gt;安裝CSS-Loader，然後搜尋  Full Suspend ，安裝完後即可。&lt;/p&gt;
&lt;h4 id=&quot;補丁安裝&quot; tabindex=&quot;-1&quot;&gt;補丁安裝&lt;/h4&gt;
&lt;p&gt;前面步驟，請看這一篇&lt;a href=&quot;https://forum.gamer.com.tw/C.php?bsn=60599&amp;amp;snA=40118&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;steam deck夏日狂想曲中文18+補丁&lt;/a&gt;，如果你bottle無法建立的話再回來。&lt;/p&gt;
&lt;p&gt;同事一直推坑我夏日狂想曲，然後bottle的bottles無法建立，一直卡在Arial font的字體安裝失敗，&lt;/p&gt;
&lt;p&gt;查&lt;a href=&quot;https://steamcommunity.com/sharedfiles/filedetails/?id=2802396237&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;原文&lt;/a&gt;有人推薦用Q4wine，就試試看了。&lt;/p&gt;
&lt;p&gt;但在flatsel需將Q4wine底下的Filesystem中的All system files打開，&lt;/p&gt;
&lt;p&gt;安裝時才能夠讀取到&lt;a href=&quot;https://forum.gamer.com.tw/C.php?bsn=60599&amp;amp;snA=40118&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;steam deck夏日狂想曲中文18+補丁&lt;/a&gt; 這邊說的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Z:&#92;home&#92;deck&#92;Summer Memories
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;額外補充&quot; tabindex=&quot;-1&quot;&gt;額外補充&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.protondb.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;protonDB&lt;/a&gt; ：查遊戲相容性的網站，不同獎牌代表的意思&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;白金：完美執行。&lt;br /&gt;
金：調整後完美執行。&lt;br /&gt;
銀：有小問題，但可玩。&lt;br /&gt;
銅：可玩，但經常遇到遊戲崩潰等問題。&lt;br /&gt;
無法執行：如題。&lt;/p&gt;
&lt;h4 id=&quot;oled&quot; tabindex=&quot;-1&quot;&gt;Oled燈號閃爍意思&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;狀態&lt;/th&gt;
&lt;th&gt;說明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;三閃紅燈&lt;/td&gt;
&lt;td&gt;電池電力不足無法開機&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;啟動中(綠燈)&lt;/td&gt;
&lt;td&gt;主機在PSU連接狀態且電池已經充滿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;啟動中(白燈)&lt;/td&gt;
&lt;td&gt;主機在PSU連接狀態且充電功率與PD協定有成功辨識並在電量達到觸發閾值後進入旁路充電&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;啟動中(橘燈)&lt;/td&gt;
&lt;td&gt;主機在PSU連接狀態且充電功率不足或PD協定無法辨識,簡單說就是以低功率充電&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;啟動中(紅燈)&lt;/td&gt;
&lt;td&gt;偵測到主機溫度高於95度C,無法開機&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;呼吸白燈&lt;/td&gt;
&lt;td&gt;主機開機中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;呼吸藍燈&lt;/td&gt;
&lt;td&gt;主機更新韌體或系統中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;無亮燈&lt;/td&gt;
&lt;td&gt;主機關機,且沒有偵測到PSU連接&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href=&quot;https://steamdb.info/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;steamdb&lt;/a&gt;：查遊戲特價歷史價格&lt;/p&gt;
&lt;h4 id=&quot;sudo&quot; tabindex=&quot;-1&quot;&gt;重置sudo 密碼&lt;/h4&gt;
&lt;p&gt;如果你忘記密碼（因爲我就忘了），&lt;/p&gt;
&lt;p&gt;只剩下重刷這一條路了。&lt;/p&gt;
&lt;p&gt;將steam deck關機，按住右下方的『...』與開機按鈕開機，&lt;/p&gt;
&lt;p&gt;然後清除資料吧。&lt;/p&gt;
&lt;h3 id=&quot;組合鍵&quot; tabindex=&quot;-1&quot;&gt;組合鍵&lt;/h3&gt;
&lt;p&gt;長按Steam按鈕，有快速鍵列表&lt;/p&gt;
&lt;p&gt;steam + R1 ： 截圖&lt;/p&gt;
&lt;p&gt;steam +X ： 開啓螢幕鍵盤&lt;/p&gt;
&lt;p&gt;『 ... 』+類比上下：調整螢幕亮度&lt;/p&gt;
&lt;p&gt;『 ... 』+電源： Recovery Manager&lt;/p&gt;
&lt;p&gt;音量『 - 』+電源 ：Boot Manager&lt;/p&gt;
&lt;p&gt;音量『 + 』+電源  ：BiOS&lt;/p&gt;
&lt;h3 id=&quot;配件&quot; tabindex=&quot;-1&quot;&gt;配件&lt;/h3&gt;
&lt;p&gt;未來應該再來下面幾個東西，再觀察看看需不需要了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tomtoc  Steam Deck硬殼收納包 ：看起來跟steam deck很合&lt;/li&gt;
&lt;li&gt;Innergie C6 Duo 63瓦 USB-C 雙孔：臺達的充電器，現在有一個單孔的，但有時要拔來拔去不方便。&lt;/li&gt;
&lt;li&gt;type c hub：感覺還是頗需要，如果要用桌面模式接鍵盤、滑鼠或外接螢幕的話，這個要再找找看了。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;目前應該就這樣，&lt;/p&gt;
&lt;p&gt;剩下的等有碰到再研究。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://forum.gamer.com.tw/C.php?page=1&amp;amp;bsn=60599&amp;amp;snA=39919&amp;amp;tnum=460&amp;amp;bPage=2&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Steam Deck 大樓！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/SteamDeck/comments/yb96pf/suspend_animations_are_extremely_small_using_deck/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Suspend animations are extremely small using Deck Loader&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ptt.cc/bbs/Steam/M.1672478420.A.6FC.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[閒聊] SteamDeck兩周心得(配件、調校、套件)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/191. Steam deck安裝除錯記/" />
        </entry>
        <entry>
            <title>
                190. cert-manager安裝
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/190. cert-manager安裝/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;上次開新專案的延伸，&lt;br /&gt;
設定domain時，對於cloudflare不夠熟，&lt;br /&gt;
還好有個前端同事，熟此門路，因爲他也踩過。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h2 id=&quot;cert-manager&quot; tabindex=&quot;-1&quot;&gt;安裝cert-manager&lt;/h2&gt;
&lt;p&gt;參照&lt;a href=&quot;https://cert-manager.io/docs/installation/kubectl/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;官網&lt;/a&gt;說明。&lt;/p&gt;
&lt;p&gt;下面語法不一定是最新的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.3/cert-manager.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再來就是建立  &lt;code&gt;ClusterIssuer&lt;/code&gt; 跟 &lt;code&gt;Certificate&lt;/code&gt;&lt;br /&gt;
在此之前，要先到cloudflare產生一組token，&lt;br /&gt;
才有權限對這個domain做驗證。&lt;/p&gt;
&lt;p&gt;我的domain是在cloud domain購買，然後再cloudflare託管。&lt;br /&gt;
為什麼不直接在google cloud託管，我也不知道，之前就這樣了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;User Profile &amp;gt; API Tokens &amp;gt; API Tokens&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/190-fig.1.jpg&quot; alt=&quot;190-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/190-fig.2.jpg&quot; alt=&quot;190-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;參照官方文件，設定權限，取得token&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/190-fig.3.jpg&quot; alt=&quot;190-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;將token存到 secret&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: Secret
metadata:
  name: cloudflare-api-token-ezio-com
  namespace: cert-manager
type: Opaque
stringData:
  api-token: &amp;lt;token&amp;gt;
---
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: cloudflare-issuer-ezio-com
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    privateKeySecretRef:
      name: cloudflare-issuer-ezio-com
    solvers:
    - dns01:
        cloudflare:
          email: ezio@abc.com
          apiTokenSecretRef:
            name: cloudflare-api-token-ezio-com
            key: api-token
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: ezio-com-tls
  namespace: istio-system
spec:
  secretName: ezio-com-tls
  issuerRef:
    name: cloudflare-issuer-ezio-com
    kind: ClusterIssuer
  commonName: &amp;quot;*.ezio.com&amp;quot;
  dnsNames:
    - &amp;quot;*.ezio.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊注意一下，檔案之間的關聯性。&lt;br /&gt;
上面寫的範例domain是 &lt;code&gt;*.ezio.com&lt;/code&gt; ，請改爲自己實際使用的。&lt;/p&gt;
&lt;p&gt;部署上去後，檢查狀態，有沒有Ready，通常不會超過5分鐘。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get certificate -A
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/190-fig.4.jpg&quot; alt=&quot;190-fig.4.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果啓動失敗的話，使用下面指令檢查log&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl describe certificate ezio-com-tls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是下面這個失敗訊息，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Found no Zones for domain _acme-challenge.aplusmanagex.com. (neither in the sub-domain nor in the SLD) please make sure your domain-entries in the config are correct and the API key is correctly setup with Zone.read rights.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;表示你的token沒有相關權限，這個坑我踩完了orz。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cert-manager.io/docs/configuration/acme/dns01/cloudflare/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Cloudflare&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cert-manager.io/docs/installation/kubectl/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kubectl apply&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/190. cert-manager安裝/" />
        </entry>
        <entry>
            <title>
                189. 導入Terraform
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/189. 導入Terraform/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;前面有稍微提到幾篇是terraform的使用方式，&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Terraform/148.%20Terraform%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/&quot;&gt;148. Terraform的基本概念&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Terraform/149.%20terraform%20%E9%83%A8%E7%BD%B2VM%EF%BC%8C%E5%95%93%E5%8B%95docker%E5%AE%89%E8%A3%9Dmetadata_startup_script/&quot;&gt;149. terraform 部署VM，啓動docker安裝metadata_startup_script&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.vercel.app/k8s/Terraform/183.%20Terrafrom%20%E5%BB%BA%E7%AB%8Bprivate%20cluster/&quot;&gt;183. Terrafrom 建立private cluster&lt;/a&gt;&lt;br /&gt;
再來把剩下碰到的補一補了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;建立完了private cluster，後續要建立SQL 跟 redis的話，該怎麼建？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外開一個資料夾，重新&lt;code&gt;terraform init&lt;/code&gt;，但要注意，&lt;br /&gt;
你的backend.hcl是怎麼寫的。&lt;/p&gt;
&lt;p&gt;舉例來說，&lt;br /&gt;
private cluster的bucket.hcl是這樣&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   bucket  = &amp;quot;terraform-devops&amp;quot;
   prefix  = &amp;quot;terraform/state&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果，另一個資料夾裏面的bucket.hcl也相同，&lt;br /&gt;
那在產生計劃時，就會把你剛剛建好的private cluster給刪除，&lt;br /&gt;
因爲他檢查的是tfstate跟你目前計劃有哪些差別。&lt;/p&gt;
&lt;p&gt;所以，需要更改prefix&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   bucket  = &amp;quot;terraform-devops&amp;quot;
   prefix  = &amp;quot;terraform/other&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這樣在bucket裏面，就會存成兩個不同的tfstate&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/189-fig.1.jpg&quot; alt=&quot;189-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;terrafrom使用迴圈，減少重複的程式碼&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;建立兩個bucket，並開啓allUser read&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;variable &amp;quot;bucket_names&amp;quot; {
  type    = list(string)
  default = [&amp;quot;A-legacy&amp;quot;, &amp;quot;B-legacy&amp;quot;]
}
resource &amp;quot;google_storage_bucket&amp;quot; &amp;quot;frontend_bucket&amp;quot; {
  uniform_bucket_level_access = true
  for_each = { for name in toset(var.bucket_names) : name =&amp;gt; name }
  name          = each.value
  force_destroy = false
  location      = &amp;quot;asia-east1&amp;quot;
  storage_class = &amp;quot;STANDARD&amp;quot;
  # public_access_prevention = &amp;quot;inherited&amp;quot;  

  //物件版本管理
  versioning {  
    enabled = false
  }
}
resource &amp;quot;google_storage_bucket_iam_binding&amp;quot; &amp;quot;binding&amp;quot; {
  for_each = google_storage_bucket.frontend_bucket

  bucket = each.value.name
  role = &amp;quot;roles/storage.legacyObjectReader&amp;quot;
  members = [
    &amp;quot;allUsers&amp;quot;,
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.hashicorp.com/terraform/language/meta-arguments/for_each&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;The for_each Meta-Argument&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/storage/docs/public-access-prevention?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;禁止公開訪問&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/storage_bucket_iam&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;IAM policy for Cloud Storage Bucket&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;讀取之前的設定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在建立private cluster的時候，就已經建好了vpc ，&lt;br /&gt;
相同的網路，我想在建立mssql 時使用，&lt;/p&gt;
&lt;p&gt;使用data呼叫這個VPC。&lt;br /&gt;
這個範例是拿來建立vpc裏面的私人服務連線的位置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data &amp;quot;google_compute_network&amp;quot; &amp;quot;private-network&amp;quot; {
  name = &amp;quot;basic&amp;quot;
}

resource &amp;quot;google_compute_global_address&amp;quot; &amp;quot;private_ip_address&amp;quot; {
  depends_on = [ google_project_service.project ]
  name          = &amp;quot;private-ip-address&amp;quot;
  purpose       = &amp;quot;VPC_PEERING&amp;quot;
  address_type  = &amp;quot;INTERNAL&amp;quot;
  prefix_length = 16
  network       = data.google_compute_network.private-network.id
}
resource &amp;quot;google_service_networking_connection&amp;quot; &amp;quot;private_vpc_connection&amp;quot; {

  network                 = data.google_compute_network.private-network.id
  service                 = &amp;quot;servicenetworking.googleapis.com&amp;quot;
  reserved_peering_ranges = [google_compute_global_address.private_ip_address.name]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/189-fig.2.jpg&quot; alt=&quot;189-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;設定.gitignore&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;
# Local .terraform directories
**/.terraform/*

# .tfstate files
*.tfstate
*.tfstate.*

# Crash log files
crash.log
crash.*.log

# Exclude all .tfvars files, which are likely to contain sensitive data, such as
# password, private keys, and other secrets. These should not be part of version 
# control as they are data points which are potentially sensitive and subject 
# to change depending on the environment.
# *.tfvars
# *.tfvars.json

# Ignore override files as they are usually used to override resources locally and so
# are not checked in
override.tf
override.tf.json
*_override.tf
*_override.tf.json

# Include override files you do wish to add to version control using negated pattern
# !example_override.tf

# Include tfplan files to ignore the plan output of command: terraform plan -out=tfplan
# example: *tfplan*

# Ignore CLI configuration files
.terraformrc
terraform.rc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.  &lt;a href=&quot;https://github.com/github/gitignore&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gitignore&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;結尾&quot; tabindex=&quot;-1&quot;&gt;結尾&lt;/h4&gt;
&lt;p&gt;基礎概念介紹&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://lonegunmanb.github.io/introduction-terraform/2.1.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E2%80%94%E2%80%94Provider.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Terraform基礎概念——Provider&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/docs/terraform/best-practices-for-terraform?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GCP-使用 Terraform 的最佳實踐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://heretse.medium.com/%E5%A4%A7%E5%AE%B6%E9%83%BD%E5%9C%A8%E7%94%A8-terraform-%E5%AF%A6%E4%BD%9C-iac-%E7%82%BA%E4%BB%80%E9%BA%BC%E4%B8%8D%E5%B0%87%E7%A8%8B%E5%BC%8F%E5%AF%AB%E5%BE%97%E6%9B%B4%E7%B0%A1%E6%BD%94%E6%98%93%E8%AE%80%E5%91%A2-a736db1f6ef2&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;大家都在用 Terraform 實作 IaC 為什麼不將程式寫得更簡潔易讀呢？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://shazi7804.github.io/terraform-manage-guide/basic/locals.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Locals&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.vercel.app/189. 導入Terraform/" />
        </entry>
        <entry>
            <title>
                188. CloudSQL server 查詢記憶體
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/188. CloudSQL server 查詢記憶體/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;週五碰到sql server的記憶體飆漲到90%，&lt;br /&gt;
找後端看了一下，看不出個所以然。&lt;br /&gt;
很不幸的，禮拜六又衝到95%，&lt;br /&gt;
只好緊急維護重開了，&lt;br /&gt;
禮拜一開始找問題。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;實際上要把記憶體操到100%，還真的很難。&lt;br /&gt;
試了好幾天，最多只能到97%。&lt;/p&gt;
&lt;p&gt;然後服務都沒什麼症狀，&lt;br /&gt;
讓我們開始想，是不是cloudSQL真的強，&lt;br /&gt;
這要操下去都沒事。&lt;/p&gt;
&lt;p&gt;再來查到cloudSQL的一篇文章，&lt;/p&gt;
&lt;p&gt;CloudSQL的記憶體分成下面幾種&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sql/docs/sqlserver/optimize-high-memory-usage#cache&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Caches  快取&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sql/docs/sqlserver/optimize-high-memory-usage#fixed-memory&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Fixed memory  固定記憶體&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sql/docs/sqlserver/optimize-high-memory-usage#sql-server-overhead&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SQL Server overhead  SQL Server 開銷&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sql/docs/sqlserver/optimize-high-memory-usage#oltp&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;In-Memory online transactional processing (OLTP)&lt;br /&gt;
記憶體中線上事務處理 (OLTP)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然後，我們得知可以更改 &lt;code&gt;max server memory&lt;/code&gt;，&lt;br /&gt;
強迫SQL不要使用那麼多的記憶體。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.vercel.app/img/user/188-fig.1.jpg&quot; alt=&quot;188-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然後，再照之前的壓測方式打下去，暴了。&lt;br /&gt;
確定會影響服務。&lt;/p&gt;
&lt;p&gt;再針對 &lt;code&gt;max server memory&lt;/code&gt; ，增加容量測試，&lt;br /&gt;
我們得到下面的結論。&lt;/p&gt;
&lt;p&gt;當 &lt;code&gt;Page life expectancy&lt;/code&gt; 這個值只要&amp;lt;300，&lt;br /&gt;
就有可能造成服務的延遲。&lt;br /&gt;
當掉的當下，這個值都是處於0。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Page life expectancy&lt;/code&gt; 表示最舊的頁面在緩衝池中停留的時間（以秒為單位），微軟建議這個值再300以上。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT   [object_name],  [counter_name],  [cntr_value] FROM   sys.dm_os_performance_countersWHERE   [object_name] LIKE   &#39;%Manager%&#39;AND   [counter_name] = &#39;Page life expectancy&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我們可以同時看一下有沒有SQL處於pending狀態。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT  @@SERVERNAME AS [Server Name],  RTRIM([object_name]) AS [Object Name],  cntr_value AS [Memory Grants Pending]FROM   sys.dm_os_performance_counters WITH(NOLOCK)WHERE  [object_name] LIKE   N&#39;%Memory Manager%&#39;  -- Handles named instancesAND   counter_name = N&#39;Memory Grants Pending&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;當這個值&amp;gt;0時，表示sql服務已經面臨崩潰邊緣，&lt;br /&gt;
該準備重啓資料庫了。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/sql/docs/sqlserver/optimize-high-memory-usage&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Optimize high memory consumption in instances&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/188. CloudSQL server 查詢記憶體/" />
        </entry>
        <entry>
            <title>
                187. ECK的filebeat
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/187. ECK的filebeat/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;一般filebeat，我之前都是做成daemonset，&lt;br /&gt;
直接抓標準輸出，傳去elasticserach裏面。&lt;br /&gt;
但目前，他們還是習慣寫文字檔到特定目錄，&lt;br /&gt;
filebeat再去那個目錄抓資料寫入，&lt;br /&gt;
所以變成也要掛載一個readwritemany的nfs。&lt;br /&gt;
那邊設定我還有點困惑，還需要測試。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;Elasticsearch 8.* 版本後，都要求加密憑證，&lt;br /&gt;
所以要用http傳很麻煩，&lt;br /&gt;
可能還要限定版本，最後我也放棄了。&lt;/p&gt;
&lt;p&gt;使用ECK的好處是不用特別設定ca，&lt;br /&gt;
但filebeat這邊的設定就要指定kibana跟elasticsearch了&lt;br /&gt;
但在不同的ns，故需特別指定ns。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: beat.k8s.elastic.co/v1beta1
kind: Beat
metadata:
  name: filebeat
spec:
  type: filebeat
  version: 8.11.0
  elasticsearchRef:
    name: fixed
    namespace: elastic-system
  kibanaRef:
    name: fixed
    namespace: elastic-system
  config:
    filebeat.inputs:
      &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#websocketclient&quot;&gt;#websocketclient&lt;/a&gt;
      - type: log
        ignore_older: 24h
        enabled: true
        paths:
          - /var/log/app-logs/websocketclient/*.log
        json.keys_under_root: true
        json.add_error_key: true
        fields_under_root: true
        tags: [&amp;quot;prod-sms-back-websocketclient&amp;quot;]
      &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#filebeat_self&quot;&gt;#filebeat_self&lt;/a&gt;
      - type: log
        ignore_older: 24h
        enabled: true
        paths:
          - /var/log/filebeat/*.ndjson
        json.keys_under_root: true
        json.add_error_key: true
        fields_under_root: true
        tags: [&amp;quot;filebeat_self&amp;quot;]
    processors:
      - timestamp:
          field: LoggingTime
          layouts:
            - &#39;2006-01-02T15:04:05Z&#39;
            - &#39;2006-01-02T15:04:05.999Z&#39;
            - &#39;2006-01-02T15:04:05.999-07:00&#39;
          test:
            - &#39;2019-06-22T16:33:51Z&#39;
            - &#39;2019-11-18T04:59:51.123Z&#39;
            - &#39;2020-08-03T07:10:20.123456+02:00&#39;
      - add_locale:
          format: offset
      - drop_fields:
          fields: [&amp;quot;agent&amp;quot;, &amp;quot;input&amp;quot;, &amp;quot;host&amp;quot;, &amp;quot;log&amp;quot;, &amp;quot;ecs&amp;quot;, &amp;quot;data_stream&amp;quot;, &amp;quot;event.timezone&amp;quot;, &amp;quot;LoggingTime&amp;quot;]
    output.elasticsearch:
      username: &amp;quot;elastic&amp;quot;
      password: &amp;quot;abc&amp;quot;      
      indices:
      &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#websocketclient&quot;&gt;#websocketclient&lt;/a&gt;
      - index: &amp;quot;prod-sms-back-websocketclient-%{+yyyy.MM.dd}&amp;quot;
        when.contains:
            tags: &amp;quot;prod-sms-back-websocketclient&amp;quot;
      &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#filebeat_self&quot;&gt;#filebeat_self&lt;/a&gt;
      - index: &amp;quot;filebeat_self-%{+yyyy.MM.dd}&amp;quot;
        when.contains:
          tags: &amp;quot;filebeat_self&amp;quot;
    logging:
      metrics.enabled: false
      level: info
      to_files: true
      files:
        path: /var/log/filebeat
        name: filebeat
        keepfiles: 7
        permissions: 0644          
  deployment:
    podTemplate:
      spec:
        automountServiceAccountToken: true
        terminationGracePeriodSeconds: 30
        dnsPolicy: ClusterFirstWithHostNet
        hostNetwork: true # Allows to provide richer host metadata
        containers:
        - name: filebeat
          securityContext:
            runAsUser: 0
            # If using Red Hat OpenShift uncomment this:
            &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#privileged&quot;&gt;#privileged&lt;/a&gt;: true
          volumeMounts:
          - name: applog
            mountPath: /var/log/app-logs            
        volumes:
        - name: applog
          persistentVolumeClaim:
            claimName: logs-nfs-test-pvc 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;備註一下，完整ECK安裝的yaml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# 1. setup eck operator and crd
# kubectl create -f https://download.elastic.co/downloads/eck/2.10.0/crds.yaml
# kubectl apply -f https://download.elastic.co/downloads/eck/2.10.0/operator.yaml


apiVersion: elasticsearch.k8s.elastic.co/v1
kind: Elasticsearch
metadata:
  name: fixed
  # name: yabo
  namespace: elastic-system
spec:  
  version: 8.11.0
  nodeSets:
  - name: all
    count: 1
    podTemplate:      
      spec:  
        containers:
        - name: elasticsearch
          env:
          - name: ES_JAVA_OPTS
            value: -Xms2g -Xmx2g
          resources:
            requests:
              memory: 4Gi
            limits:
              memory: 4Gi  
    config:
      node.roles:
          - master
          - data
          - ingest
      node.attr.attr_name: attr_value
      node.store.allow_mmap: false   
    volumeClaimTemplates:
    - metadata:
        name: elasticsearch-data # Do not change this name unless you set up a volume mount for the data path.
      spec:
        accessModes:
        - ReadWriteOnce
        resources:
          requests:
            storage: 100Gi
        storageClassName: standard        
# 儲存空間需要加大，預設只有1G 不夠

---

apiVersion: kibana.k8s.elastic.co/v1
kind: Kibana
metadata:
  name: fixed
  namespace: elastic-system
spec:
  version: 8.11.0
  count: 1
  elasticsearchRef:
    name: fixed    
  http:
    tls:
      selfSignedCertificate:
        disabled: true
    service:
      spec:
        ports:
          - name: http
            port: 5601
            targetPort: 5601        

---

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.cnblogs.com/jatq/articles/14651723.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ECK部署&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/187. ECK的filebeat/" />
        </entry>
        <entry>
            <title>
                186. istio的Authorization policy(白名單)
                
            </title>
            <updated>2024-02-13T10:17:57Z</updated>
            <id>https://daimom.vercel.app/186. istio的Authorization policy(白名單)/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;經過一個月的搬家事宜，&lt;br /&gt;
這篇應該是第一篇，之後還有許多東西，&lt;br /&gt;
都是這個月搬project碰到的。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h4 id=&quot;目的&quot; tabindex=&quot;-1&quot;&gt;目的&lt;/h4&gt;
&lt;p&gt;只要設定白名單，限制某些ip能進入就好，&lt;br /&gt;
其他不用。&lt;/p&gt;
&lt;h4 id=&quot;network&quot; tabindex=&quot;-1&quot;&gt;實作-Network&lt;/h4&gt;
&lt;p&gt;這邊使用istio 1.20 版本，雖然gateway API 剛出爐，&lt;br /&gt;
但我還沒去研究，所以下面用的都還是 istio API&lt;/p&gt;
&lt;p&gt;首先確認你的LB類型，&lt;br /&gt;
直連（Network)的話，基本上沒太大問題，白名單很好設定。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;開啓 &lt;code&gt;externalTrafficPolicy&amp;quot;:&amp;quot;Local&amp;quot;&lt;/code&gt;，&lt;br /&gt;
兩種方法&lt;/p&gt;
&lt;p&gt;a. 手動改service&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;   kubectl patch svc istio-ingressgateway -n istio-system -p &#39;{&amp;quot;spec&amp;quot;:{&amp;quot;externalTrafficPolicy&amp;quot;:&amp;quot;Local&amp;quot;}}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;b. 加在istioOperator上面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ingressGateways:
    - name: istio-ingressgateway    
      enabled: true
      k8s: 
        service:
          externalTrafficPolicy: Local
          loadBalancerSourceRanges:
              - 10.0.0.0/8
              - 172.16.0.0/12
              - 192.168.0.0/16
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Authorization設定&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: manage-ingress-policy
  namespace: istio-system
spec:
  selector:
    matchLabels:
      istio: ingressgateway
  action: ALLOW
  rules:
  - from:
    - source:
        ipBlocks:: 
          - &amp;quot;10.0.0.0/8&amp;quot;
          - &amp;quot;172.16.0.0/12&amp;quot;
          - &amp;quot;192.168.0.0/16&amp;quot;   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（注意，這邊的Load Balancer Type指的是Network，沒透過proxy的，&lt;br /&gt;
如果有開CDN，那就是istio說明上面的Load Balancer Type 是TCP Proxy)&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://istio.io/latest/docs/tasks/security/authorization/authz-ingress/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Ingress Access Control&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;proxy&quot; tabindex=&quot;-1&quot;&gt;實作-Proxy&lt;/h4&gt;
&lt;p&gt;這邊的網路走法是，有透過CDN，或是其他的prxoy代理連過來的服務。&lt;br /&gt;
numTrustedProxies 這個的值，取決於你的走法過了幾層的proxy，&lt;br /&gt;
我只有cdn轉島到gke上面的istio LB&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;設定方式&lt;/p&gt;
&lt;p&gt;a. 在pod上面新增 anntations&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;  metadata:
    annotations:
      &amp;quot;proxy.istio.io/config&amp;quot;: &#39;{&amp;quot;gatewayTopology&amp;quot; : { &amp;quot;numTrustedProxies&amp;quot;: 1 } }&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;b. 在istioOperator新增&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
spec:
  meshConfig:
    defaultConfig:
      gatewayTopology:
        numTrustedProxies: 1	
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Authorization設定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這邊有點坑，搞了一天才搞清楚。&lt;br /&gt;
強烈建議把istio的&lt;a href=&quot;https://istio.io/latest/docs/ops/configuration/traffic-management/network-topologies/#example-using-x-forwarded-for-capability-with-httpbin&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;httpbin&lt;/a&gt;裝起來，實際去打，&lt;br /&gt;
然後一邊查看ingressgateway的deployment的log。&lt;/p&gt;
&lt;p&gt;a. 限制全部&lt;/p&gt;
&lt;p&gt;這是第一種方法，但這個只能針對『入口』的ingress做白名單驗證。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
 name: frontend-ingress-policy
 namespace: istio-system
spec:
 selector:
   matchLabels:
     app: ingressgateway-external
 action: ALLOW
 rules:
 - from:
   - source:
       remoteIpBlocks: 
         - &amp;quot;10.0.0.0/8&amp;quot;
         - &amp;quot;172.16.0.0/12&amp;quot;
         - &amp;quot;192.168.0.0/16&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;b. 針對單個&lt;br /&gt;
假如沒有在入口的話，無法照上面a.的方式抓到資料，&lt;br /&gt;
所以只能強制指定判斷header。&lt;br /&gt;
ref. &lt;a href=&quot;https://github.com/istio/istio/issues/30166&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Incorrect RemoteIP when Authorization Policy is applied to Injected Istio Proxy&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: frontend-ingress-policy
spec:
  selector:
    matchLabels:
      group: frontend
  action: ALLOW
  rules:
    - when:
        - key: request.headers[X-Envoy-External-Address]
          values:
            - &amp;quot;10.0.0.0/8&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://istio.io/latest/docs/ops/configuration/traffic-management/network-topologies/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Configuring Gateway Network Topology&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h4&gt;
&lt;h6 id=&quot;istio-operator-log&quot; tabindex=&quot;-1&quot;&gt;istioOperator增加log 閱讀性&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;spec:
  meshConfig:
    accessLogFile: /dev/stdout
    accessLogEncoding: JSON
    accessLogFormat: |
      {
        &amp;quot;protocol&amp;quot;: &amp;quot;%PROTOCOL%&amp;quot;,
        &amp;quot;upstream_service_time&amp;quot;: &amp;quot;%REQ(X-ENVOY-UPSTREAM_SERVICE_TIME)%&amp;quot;,
        &amp;quot;upstream_local_address&amp;quot;: &amp;quot;%UPSTREAM_LOCAL_ADDRESS%&amp;quot;,
        &amp;quot;duration&amp;quot;: &amp;quot;%DURATION%&amp;quot;,
        &amp;quot;upstream_transport_failure_reason&amp;quot;: &amp;quot;%UPSTREAM_TRANSPORT_FAILURE_REASON%&amp;quot;,
        &amp;quot;route_name&amp;quot;: &amp;quot;%ROUTE_NAME%&amp;quot;,
        &amp;quot;downstream_local_address&amp;quot;: &amp;quot;%DOWNSTREAM_LOCAL_ADDRESS%&amp;quot;,
        &amp;quot;user_agent&amp;quot;: &amp;quot;%REQ(USER-AGENT)%&amp;quot;,
        &amp;quot;response_code&amp;quot;: &amp;quot;%RESPONSE_CODE%&amp;quot;,
        &amp;quot;response_flags&amp;quot;: &amp;quot;%RESPONSE_FLAGS%&amp;quot;,
        &amp;quot;start_time&amp;quot;: &amp;quot;%START_TIME%&amp;quot;,
        &amp;quot;method&amp;quot;: &amp;quot;%REQ(:METHOD)%&amp;quot;,
        &amp;quot;request_id&amp;quot;: &amp;quot;%REQ(X-REQUEST-ID)%&amp;quot;,
        &amp;quot;upstream_host&amp;quot;: &amp;quot;%UPSTREAM_HOST%&amp;quot;,
        &amp;quot;x_forwarded_for&amp;quot;: &amp;quot;%REQ(X-FORWARDED-FOR)%&amp;quot;,
        &amp;quot;client_ip&amp;quot;: &amp;quot;%REQ(TRUE-Client-IP)%&amp;quot;,
        &amp;quot;requested_server_name&amp;quot;: &amp;quot;%REQUESTED_SERVER_NAME%&amp;quot;,
        &amp;quot;bytes_received&amp;quot;: &amp;quot;%BYTES_RECEIVED%&amp;quot;,
        &amp;quot;bytes_sent&amp;quot;: &amp;quot;%BYTES_SENT%&amp;quot;,
        &amp;quot;upstream_cluster&amp;quot;: &amp;quot;%UPSTREAM_CLUSTER%&amp;quot;,
        &amp;quot;downstream_remote_address&amp;quot;: &amp;quot;%DOWNSTREAM_REMOTE_ADDRESS%&amp;quot;,
        &amp;quot;authority&amp;quot;: &amp;quot;%REQ(:AUTHORITY)%&amp;quot;,
        &amp;quot;path&amp;quot;: &amp;quot;%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%&amp;quot;,
        &amp;quot;response_code_details&amp;quot;: &amp;quot;%RESPONSE_CODE_DETAILS%&amp;quot;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://dev.to/aws-builders/understanding-istio-access-logs-2k5o&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Understanding Istio Access Logs&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;authorization-policy&quot; tabindex=&quot;-1&quot;&gt;Authorization Policy規則&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;If there are any CUSTOM policies that match the request, evaluate and deny the request if the evaluation result is deny.
&lt;blockquote&gt;
&lt;p&gt;如果有任何符合請求的自訂策略，則評估並拒絕請求，若評估結果為拒絕。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;If there are any DENY policies that match the request, deny the request.
&lt;blockquote&gt;
&lt;p&gt;如果有符合請求的任何拒絕策略，則拒絕該請求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;If there are no ALLOW policies for the workload, allow the request.
&lt;blockquote&gt;
&lt;p&gt;如果工作負載沒有任何允許策略，則允許該請求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;If any of the ALLOW policies match the request, allow the request.
&lt;blockquote&gt;
&lt;p&gt;如果有任何允許策略符合該請求，則允許該請求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Deny the request.
&lt;blockquote&gt;
&lt;p&gt;拒絕該請求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://istio.io/latest/docs/reference/config/security/authorization-policy/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Authorization Policy&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;cloudflare&quot; tabindex=&quot;-1&quot;&gt;cloudflare轉發&lt;/h4&gt;
&lt;p&gt;上面有提到用cloudflare的CDN時，白名單會跟着變，&lt;br /&gt;
但在那之前還有個東西要注意，CDN轉發時，&lt;br /&gt;
cloudflare可以指定走http還是走https&lt;br /&gt;
這個會影響到istio的gateway，是開80還是443。&lt;br /&gt;
&lt;img src=&quot;https://daimom.vercel.app/img/user/186-fig.1.jpg&quot; alt=&quot;186-fig.1.jpg&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.vercel.app/186. istio的Authorization policy(白名單)/" />
        </entry>
</feed>
