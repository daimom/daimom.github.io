<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:base="https://daimom.github.io">
    <title>度估筆記本</title>
    <link href="https://daimom.github.io/feed.xml" rel="self" />
    <link href="https://daimom.github.io" />
    <updated>2025-07-08T10:28:18Z</updated>
    <id>https://daimom.github.io</id>
        <entry>
            <title>
                91. elasticsearch ingest processor補充
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗒 EFK/91. elasticsearch ingest processor補充/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;補充ingest 的 processor&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;上篇提到，正常要等ILM跑完後，所設定的default_pipeline才會寫入。&lt;br /&gt;
但今天是可以提早讓他跑ILM，這樣就會把預設的default_pipeline寫進去了。&lt;/p&gt;
&lt;p&gt;而只要在default_pipeline 設定好，後續再改pipeline的設定時，都會直接影響當下的設定。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在index template設定pipeline&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/90-fig.10.jpg&quot; alt=&quot;90-fig.10.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;到 Devtools 執行下面指令&lt;br /&gt;
強制datastream執行ILM&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;POST /filebeat-8.1.0/_rollover
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/data-streams.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;DataStream&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://www.gushiciku.cn/pl/gtvK/zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elasticsearch 7.X data stream 深入詳解&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;ingest&quot; tabindex=&quot;-1&quot;&gt;ingest 補充&lt;/h1&gt;
&lt;p&gt;processor分成好幾個類型&lt;/p&gt;
&lt;p&gt;上一篇是使用grok(這個是使用正則去篩選字串)，&lt;br /&gt;
有人建議使用Dissect，速度比grok快，但只適用於有固定分隔字串的message。&lt;/p&gt;
&lt;p&gt;下面簡單敘述用途，詳細就點連結過去看了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/append-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Append&lt;/a&gt;&lt;br /&gt;
在現有的字串內增加值&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/bytes-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Bytes&lt;/a&gt;&lt;br /&gt;
把空間計算方式(kb,mb,gb...)轉成byte&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/ingest-circle-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Circle&lt;/a&gt;&lt;br /&gt;
把圓形轉爲近似他們的規則多邊形（我也不知道這能做啥）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/community-id-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Community ID&lt;/a&gt;&lt;br /&gt;
計算網路資料流的id，能透過此id關聯相關的網路事件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/convert-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Convert&lt;/a&gt;&lt;br /&gt;
將欄位內容轉爲integer、long、float、double、string、boolean、ip&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/csv-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;CSV&lt;/a&gt;&lt;br /&gt;
將欄位中的的資料當作csv去辨別&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/date-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Date&lt;/a&gt;&lt;br /&gt;
將欄位內容轉爲日期格式&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/date-index-name-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Date index name&lt;/a&gt;&lt;br /&gt;
將日期取出作爲index的名稱&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/dissect-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Dissect&lt;/a&gt;&lt;br /&gt;
與grok相似，但不使用正則作爲結構化欄位&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/dot-expand-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Dot expander&lt;/a&gt;&lt;br /&gt;
會將 . 視爲一個物件的名稱，&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;  foo.bar :value
  foo : { 
	bar: value
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/drop-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Drop&lt;/a&gt;&lt;br /&gt;
根據條件刪除document&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/enrich-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Enrich&lt;/a&gt;&lt;br /&gt;
根據欄位規則，自動新增資料&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/fail-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Fail&lt;/a&gt;&lt;br /&gt;
當錯誤時，傳送訊息&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/fingerprint-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Fingerprint&lt;/a&gt;&lt;br /&gt;
計算document的hash值&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/foreach-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Foreach&lt;/a&gt;&lt;br /&gt;
當元素數量不確定時使用&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/geoip-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GeoIP&lt;/a&gt;&lt;br /&gt;
根據地理位置提供更多資訊&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/grok-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Grok&lt;/a&gt;&lt;br /&gt;
從document中截取結構化的字串出來(正則)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/gsub-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Gsub&lt;/a&gt;&lt;br /&gt;
使用正則或取代來轉換字串&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/htmlstrip-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;HTML strip&lt;/a&gt;&lt;br /&gt;
從欄位中移除html的tag&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/inference-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Inference&lt;/a&gt;&lt;br /&gt;
Uses a pre-trained data frame analytics model to infer against the data that is being ingested in the pipeline.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/join-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Join&lt;/a&gt;&lt;br /&gt;
將欄位中的array值用分隔符串起來&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/json-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;JSON&lt;/a&gt;&lt;br /&gt;
將json字串轉成json格式&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/kv-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;KV&lt;/a&gt;&lt;br /&gt;
指定欄位自動解析訊息&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/lowercase-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Lowercase&lt;/a&gt;&lt;br /&gt;
將字串轉成小寫&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/network-direction-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Network direction&lt;/a&gt;&lt;br /&gt;
根據來源IP及目的IP計算是 inbound或 outbonud&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/pipeline-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Pipeline&lt;/a&gt;&lt;br /&gt;
在pipeline內執行其他的pipeline&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/registered-domain-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Registered domain&lt;/a&gt;&lt;br /&gt;
解析domain，區分出 sub-doamin、top-level domain&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/remove-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Remove&lt;/a&gt;&lt;br /&gt;
移除欄位&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/rename-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Rename&lt;/a&gt;&lt;br /&gt;
更改欄位名稱&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/script-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Script&lt;/a&gt;&lt;br /&gt;
執行script&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/set-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Set&lt;/a&gt;&lt;br /&gt;
指令欄位寫值&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/ingest-node-set-security-user-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Set security user&lt;/a&gt;&lt;br /&gt;
通過預處理程序，從目前驗證的使用者截取資料&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/sort-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Sort&lt;/a&gt;&lt;br /&gt;
對欄位內的array做排序&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/split-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Split&lt;/a&gt;&lt;br /&gt;
使用分隔符號，將字串切成array&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/trim-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Trim&lt;/a&gt;&lt;br /&gt;
移除欄位空白&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/uppercase-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Uppercase&lt;/a&gt;&lt;br /&gt;
將字串轉成大寫&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/urldecode-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;URL decode&lt;/a&gt;&lt;br /&gt;
將URL網址解碼&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/uri-parts-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;URI parts&lt;/a&gt;&lt;br /&gt;
將URL請求拆開成URI object&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/user-agent-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;User agent&lt;/a&gt;&lt;br /&gt;
解析user_agent&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🗒 EFK/91. elasticsearch ingest processor補充/" />
        </entry>
        <entry>
            <title>
                90. elasticsearch ingest pipeline
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗒 EFK/90. elasticsearch ingest pipeline/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;用filebeat 蒐集 nginx的資料，取得的Nginx資料沒再經過分解，&lt;br /&gt;
導致沒辦法運用在efk上面。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/90-fig.1.jpg&quot; alt=&quot;90-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;ui&quot; tabindex=&quot;-1&quot;&gt;先用UI講解步驟。&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先來看一下nginx的message，然後再分析裡面的欄位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;127.0.0.1 - - [06/May/2022:06:44:01 +0000] , http-host: &#92;&amp;quot;abc.boxing.com&#92;&amp;quot; , URL: &#92;&amp;quot;GET /static/tpl/analytics/index.html?v=51817715.1 HTTP/1.1&#92;&amp;quot;  , request-status : &#92;&amp;quot;200&#92;&amp;quot;  ,   body-byte: 0  ,http-referer: &#92;&amp;quot;https://abc.boxing.com/mobile&#92;&amp;quot;  ,user-agent: &#92;&amp;quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&#92;&amp;quot; , X-Forwarded-For : &#92;&amp;quot;132.235.211.18,10.107.10.14&#92;&amp;quot; ,   request-time: &#92;&amp;quot;0.000&#92;&amp;quot;  , response_time : &#92;&amp;quot;-&#92;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊的格式有特別去調整過，詳情可參考，&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/GKE/56.%20GKE%E8%A8%98%E9%8C%84%20nginx%20log/&quot;&gt;56. GKE記錄 nginx log&lt;/a&gt;。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;ingest pipeline&lt;br /&gt;
UI畫面，Stack Management -&amp;gt; Ingest Pipelines-&amp;gt; Create pipeline&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/90-fig.2.jpg&quot; alt=&quot;90-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Add a processor&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/90-fig.3.jpg&quot; alt=&quot;90-fig.3.jpg&quot; /&gt;&lt;br /&gt;
Processor ： Grok&lt;br /&gt;
Field ： message&lt;br /&gt;
patterns:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;%{IPORHOST:nginx.source.ip} %{USER:nginx.user.id} %{USER:nginx.user.name} &#92;&#92;[%{HTTPDATE:nginx.@timestamp}&#92;&#92;] , http-host: &#92;&amp;quot;%{DATA:nginx.url.host}&#92;&amp;quot; , URL: &#92;&amp;quot;%{WORD:nginx.http.request.method} %{DATA:nginx.url.path} HTTP/%{NUMBER:nginx.http.version}&#92;&amp;quot;  , request-status : &#92;&amp;quot;%{NUMBER:nginx.http.response.status_code:int}&#92;&amp;quot;  ,   body-byte: %{NUMBER:nginx.http.response.body.bytes:int}  ,http-referer: &#92;&amp;quot;%{DATA:nginx.http.request.referer}&#92;&amp;quot;  ,user-agent: %{QS:nginx.user_agent} , X-Forwarded-For : &#92;&amp;quot;%{DATA:nginx.http.request.xff}&#92;&amp;quot; ,   request-time: &#92;&amp;quot;%{NUMBER:nginx.http.request.time}&#92;&amp;quot;  , response_time : &#92;&amp;quot;(?:-|%{NUMBER:nginx.http.request.time:int})&#92;&amp;quot;    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此處的patterns是符合我上面(1)的訊息，所產生的。&lt;/p&gt;
&lt;p&gt;ps. Grok Debugger 記得要8.1後才有，如果版本過低，可以參考下方，用DevTools下指令的方式除錯。&lt;/p&gt;
&lt;p&gt;Grok簡單說，&lt;/p&gt;
&lt;blockquote 型態：要存的欄位名稱=&quot;&quot;&gt;
&lt;p&gt;%&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;型態有哪些，參考連結『 grok-patterns』&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/8.1/xpack-grokdebugger.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Grok Debugger&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/8.1/grok-processor.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Grok processor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/grok.html#grok-syntax&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Grokking grok&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/elastic/elasticsearch/blob/master/libs/grok/src/main/resources/patterns/legacy/grok-patterns&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;grok-patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;測試&lt;br /&gt;
寫好了後，不測試一下也不知道是對或錯，&lt;br /&gt;
到新建的畫面，右邊的中間，有Add Document的選項。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/90-fig.4.jpg&quot; alt=&quot;90-fig.4.jpg&quot; /&gt;&lt;br /&gt;
之後輸入要測試的範例&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/90-fig.5.jpg&quot; alt=&quot;90-fig.5.jpg&quot; /&gt;&lt;br /&gt;
內容為：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;    {
      &amp;quot;_source&amp;quot;: {
        &amp;quot;message&amp;quot;: &amp;quot;127.0.0.1 - - [06/May/2022:06:44:01 +0000] , http-host: &#92;&amp;quot;abc.boxing.com&#92;&amp;quot; , URL: &#92;&amp;quot;GET /static/tpl/analytics/index.html?v=51817715.1 HTTP/1.1&#92;&amp;quot;  , request-status : &#92;&amp;quot;200&#92;&amp;quot;  ,   body-byte: 0  ,http-referer: &#92;&amp;quot;https://abc.boxing.com/mobile&#92;&amp;quot;  ,user-agent: &#92;&amp;quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&#92;&amp;quot; , X-Forwarded-For : &#92;&amp;quot;132.235.211.18,10.107.10.14&#92;&amp;quot; ,   request-time: &#92;&amp;quot;0.000&#92;&amp;quot;  , response_time : &#92;&amp;quot;-&#92;&amp;quot;&amp;quot;
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;按下 Run the pipeline，有成功就會跑結果出來了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/90-fig.6.jpg&quot; alt=&quot;90-fig.6.jpg&quot; /&gt;&lt;br /&gt;
失敗的話，會變成下面的圖。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/90-fig.7.jpg&quot; alt=&quot;90-fig.7.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;此處皆參考官方範例&lt;br /&gt;
ref. &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/common-log-format-example.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Example: Parse logs in the Common Log Format&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;api&quot; tabindex=&quot;-1&quot;&gt;使用api測試&lt;/h3&gt;
&lt;p&gt;在UI上面測試 Grok實在很累，除了用剛剛提到的 Grok Debug以外。&lt;br /&gt;
就是直接用api方式直接驗證了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note,  8.1 我用Grok Debugger 有些特殊字元會無法match ，但用API沒問題。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Nginx 為 ingest Pipeline Name&lt;/p&gt;
&lt;p&gt;以下API 皆在 DevTools驗證&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/90-fig.8.jpg&quot; alt=&quot;90-fig.8.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;驗證Document&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;POST _ingest/pipeline/Nginx/_simulate
{
  &amp;quot;docs&amp;quot;: [
    {
      &amp;quot;_source&amp;quot;: {
        &amp;quot;message&amp;quot;: &amp;quot;127.0.0.1 - - [06/May/2022:06:44:01 +0000] , http-host: &#92;&amp;quot;abc.boxing.com&#92;&amp;quot; , URL: &#92;&amp;quot;GET /static/tpl/analytics/index.html?v=51817715.1 HTTP/1.1&#92;&amp;quot;  , request-status : &#92;&amp;quot;200&#92;&amp;quot;  ,   body-byte: 0  ,http-referer: &#92;&amp;quot;https://abc.boxing.com/mobile&#92;&amp;quot;  ,user-agent: &#92;&amp;quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&#92;&amp;quot; , X-Forwarded-For : &#92;&amp;quot;132.235.211.18,10.107.10.14&#92;&amp;quot; ,   request-time: &#92;&amp;quot;0.000&#92;&amp;quot;  , response_time : &#92;&amp;quot;-&#92;&amp;quot;&amp;quot;
      }
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;修改grok&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;
PUT _ingest/pipeline/Nginx
{
  &amp;quot;description&amp;quot;: &amp;quot;My optional pipeline description&amp;quot;,
  &amp;quot;processors&amp;quot;: [
    {
      &amp;quot;grok&amp;quot;: {
        &amp;quot;description&amp;quot;: &amp;quot;Extract fields from &#39;message&#39;&amp;quot;,
        &amp;quot;field&amp;quot;: &amp;quot;message&amp;quot;,
        &amp;quot;patterns&amp;quot;: [&amp;quot;%{IPORHOST:nginx.source.ip} %{USER:nginx.user.id} %{USER:nginx.user.name} &#92;&#92;[%{HTTPDATE:nginx.@timestamp}&#92;&#92;] , http-host: &#92;&amp;quot;%{DATA:nginx.url.host}&#92;&amp;quot; , URL: &#92;&amp;quot;%{WORD:nginx.http.request.method} %{DATA:nginx.url.path} HTTP/%{NUMBER:nginx.http.version}&#92;&amp;quot;  , request-status : &#92;&amp;quot;%{NUMBER:nginx.http.response.status_code:int}&#92;&amp;quot;  ,   body-byte: %{NUMBER:nginx.http.response.body.bytes:int}  ,http-referer: &#92;&amp;quot;%{DATA:nginx.http.request.referer}&#92;&amp;quot;  ,user-agent: %{QS:nginx.user_agent} , X-Forwarded-For : &#92;&amp;quot;%{DATA:nginx.http.request.xff}&#92;&amp;quot; ,   request-time: &#92;&amp;quot;%{NUMBER:nginx.http.request.time}&#92;&amp;quot;  , response_time : &#92;&amp;quot;(?:-|%{NUMBER:nginx.http.request.time:int})&#92;&amp;quot;&amp;quot;],
         &amp;quot;ignore_failure&amp;quot;: false
      }
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ignore_failure 為忽略錯誤，false的話，只要有一個沒過，&lt;br /&gt;
ingest pipeline就會停止。&lt;/p&gt;
&lt;h3 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h3&gt;
&lt;p&gt;上述兩種方法，都可以建立且測試，就看哪種習慣。&lt;br /&gt;
但要將ingest 套用到data stream 或 index的話，&lt;br /&gt;
又是另一篇了....。&lt;/p&gt;
&lt;p&gt;不趕時間的方法，到  Index Managemenet 修改 Index  Templates&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/90-fig.9.jpg&quot; alt=&quot;90-fig.9.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;到 index settings 將 default_pipeline 修改為你的 ingest pipeline name&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/90-fig.10.jpg&quot; alt=&quot;90-fig.10.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然後就等 lifecycle條件達到時，建立新的index，就會套用上去了。&lt;/p&gt;
&lt;p&gt;趕時間的話，請看下一篇。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/ingest.html#set-default-pipeline&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;set-default-pipeline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.16/index-modules.html#index-default-pipeline&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;index.default_pipeline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://elasticstack.blog.csdn.net/article/details/105790798&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elasticsearch：Elastic可觀測性 - 運用 pipeline 使數據結構化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🗒 EFK/90. elasticsearch ingest pipeline/" />
        </entry>
        <entry>
            <title>
                84.Elasticsearch筆記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗒 EFK/84.Elasticsearch筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;上一篇是拿來修正目前版本與2.x版本的差異&lt;br /&gt;
這篇是拿來當筆記&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&quot;兩種查詢方式&quot; tabindex=&quot;-1&quot;&gt;兩種查詢方式&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;GET /megacorp/_search?q=last_name:Smith
GET /megacorp/_search
{
    &amp;quot;query&amp;quot; : {
        &amp;quot;match&amp;quot; : {
            &amp;quot;last_name&amp;quot; : &amp;quot;Smith&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&quot;搜尋方式&quot; tabindex=&quot;-1&quot;&gt;搜尋方式&lt;/h3&gt;
如果用kibana搜尋的話，差異就在一個有加 &amp;quot;&amp;quot;(雙引號)，另一個沒有&lt;br /&gt;
match_phrase ： 是有加雙引號的短句搜尋&lt;br /&gt;
match ： 是全文搜尋，分數越高的表示關連度越高&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/84-fig.1.jpg&quot; alt=&quot;84-fig.1.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&quot;aggreations&quot; tabindex=&quot;-1&quot;&gt;aggreations(聚合)&lt;/h3&gt;
類似sql的 group by 功能&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&quot;叢集健康度&quot; tabindex=&quot;-1&quot;&gt;叢集健康度&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;  GET _cluster/health/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;status 的狀態&lt;/p&gt;
&lt;p&gt;green：所有的主分片和副本分片都正常運行。&lt;br /&gt;
yellow：所有的主分片都正常運行，但不是所有的副本分片都正常運行。&lt;br /&gt;
red：有主分片沒能正常運行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&quot;node&quot; tabindex=&quot;-1&quot;&gt;集群node配對方式&lt;/h3&gt;
cluster.name相同，就會自動發現集群並加入。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🗒 EFK/84.Elasticsearch筆記/" />
        </entry>
        <entry>
            <title>
                80. ECK 8.1 ,APM intergration安裝方式
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗒 EFK/80. ECK 8.1 ,APM intergration安裝方式/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;一兩個月沒看，沒想到版本就衝到8.1了，&lt;br /&gt;
照以前的做法，發現一堆錯誤，&lt;br /&gt;
precondition &#39;apm integration installed&#39; failed: error querying Elasticsearch for integration index templates: unexpected HTTP status: 404 Not Found..&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;版本升級後，架構變成下圖(1)&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/80-fig.0.png&quot; alt=&quot;80-fig.0.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以才導致下圖的錯誤發生，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/80-fig.1.jpg&quot; alt=&quot;80-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;原因是，ECK升級，&lt;br /&gt;
所以統一要先在kibana上面先安裝 APM intergration。&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;If you install version 8.2.0 of APM Server before installing the APM integration, you will see error logs similar to the following. You must go back and install the APM integration before data can be ingested into Elasticsearch.&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.elastic.co/guide/en/apm/guide/master/upgrade-8.0-self-standalone.html#_upgrade_steps&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Upgrade a self-installation of APM Server standalone to 8.2.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Step 1.&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/80-fig.2.jpg&quot; alt=&quot;80-fig.2.jpg&quot; /&gt;&lt;br /&gt;
Step 2.&lt;/p&gt;
&lt;p&gt;安裝APM server即可，安裝完後，&lt;br /&gt;
選擇 『Add Elastic Agent later』。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/80-fig.3.jpg&quot; alt=&quot;80-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
1. &lt;a href=&quot;https://www.elastic.co/guide/en/apm/guide/current/upgrade-to-apm-integration.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Upgrade to the Elastic APM integration&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🗒 EFK/80. ECK 8.1 ,APM intergration安裝方式/" />
        </entry>
        <entry>
            <title>
                69. kibana錯誤解法 , parent Data too large...
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗒 EFK/69. kibana錯誤解法 , parent Data too large.../</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;最近用kibana做查詢或任何的API取資料時，&lt;br /&gt;
有機率會發生下列的錯誤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[parent] Data too large, data for [&amp;lt;http_request&amp;gt;] would be [1054296800/1005.4mb],&lt;br /&gt;
which is larger than the limit of [1020054732/972.7mb],&lt;br /&gt;
real usage: [1054296800/1005.4mb],&lt;br /&gt;
new bytes reserved: [0/0b], usages [request=83853312/79.9mb,&lt;br /&gt;
fielddata=0/0b, in_flight_requests=0/0b, model_inference=0/0b,&lt;br /&gt;
eql_sequence=0/0b, accounting=23686052/22.5mb]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;雖然說很偶發，但最近有越來越嚴重的趨勢。&lt;/p&gt;
&lt;p&gt;所以，鼻子摸一摸，來解決吧。&lt;/p&gt;
&lt;p&gt;首先看到這一篇  &lt;a href=&quot;https://discuss.elastic.co/t/what-does-this-error-mean-data-too-large-data-for-transport-request/209345&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;What does this error mean - Data too large, data for [&amp;lt;transport_request&amp;gt;]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這邊有很好的解釋，發生的原因。&lt;/p&gt;
&lt;p&gt;簡單說就是ES本身的斷路器發生作用，&lt;br /&gt;
導致請求失敗。&lt;/p&gt;
&lt;p&gt;斷路器的文章可參考下面&lt;br /&gt;
ref .&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/circuit-breaker.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;circuit breaker 斷路器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面的錯誤的意思表示，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[&amp;lt;http_request&amp;gt;] would be [1054296800/1005.4mb],&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;http_request的請求需要 1005.4 mb&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;which is larger than the limit of [1020054732/972.7mb],&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;請求的上限是 972.7mb&lt;/p&gt;
&lt;p&gt;此時可以到 DevTools ，輸入下面指令[1]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET _cat/nodes?v=true&amp;amp;h=name,node*,heap*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/69-fig.1.jpg&quot; alt=&quot;69-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到目前的記憶體使用量（注意，此圖並不是事發當下的記憶體使用量）&lt;/p&gt;
&lt;p&gt;解決方式[2]：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;當下查看heap.max 只有1G ，故先加大記憶體到2G。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: elasticsearch.k8s.elastic.co/v1
kind: Elasticsearch
metadata:
  name: yabo
  namespace: elastic-system
spec:
  version: 7.16.2
  nodeSets:
  - name: all
    count: 3
    podTemplate:
      spec:
        containers:
        - name: elasticsearch
          env:
          - name: ES_JAVA_OPTS
            value: -Xms2g -Xmx2g
          resources:
            requests:
              memory: 4Gi
            limits:
              memory: 4Gi  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-managing-compute-resources.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Manage compute resources&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;shards數量太多&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同樣50G的檔案，5個10G，跟1個50G  shards，&lt;br /&gt;
前者的ram使用量會比較多。&lt;br /&gt;
但shards設太高，當node 掛掉時，&lt;br /&gt;
回復的時間會變長。&lt;/p&gt;
&lt;p&gt;修改ILM的shard大小，建議範圍是在 10G~50G 之間，&lt;br /&gt;
但仍要視情況而定。&lt;br /&gt;
ref. &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/size-your-shards.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Size your shards&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
[1] : &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/68.ECK%20,%20api%E7%AD%86%E8%A8%98/&quot;&gt;68.ECK , api筆記&lt;/a&gt;&lt;br /&gt;
[2] : &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.14/fix-common-cluster-issues.html#high-jvm-memory-pressure&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; Fix common cluster issues&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🗒 EFK/69. kibana錯誤解法 , parent Data too large.../" />
        </entry>
        <entry>
            <title>
                68.ECK , api筆記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗒 EFK/68.ECK , api筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;在所有的api後面，加上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;v=true     顯示標題
sort=column name    排序
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查詢目前的es記憶體使用量&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;GET _cat/nodes?v=true&amp;amp;h=name,node*,heap*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;詳細的資料&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET _nodes/stats?filter_path=nodes.*.jvm.mem.pools.old
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/7.14/fix-common-cluster-issues.html#circuit-breaker-errors&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Fix common cluster issues&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顯示cluster狀態&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;GET _cluster/health/
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;顯示shard 明細&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;GET _cat/shards/filebeat*?v=true&amp;amp;s=index
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;顯示index明細&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;GET _cat/indices/filebeat*?v=true&amp;amp;s=index
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/🗒 EFK/68.ECK , api筆記/" />
        </entry>
        <entry>
            <title>
                67. ECK，filebeat LOG蒐集遺失
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗒 EFK/67. ECK，filebeat LOG蒐集遺失/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;最近同事回報說，pod 有些log沒有進到ECK裏面去，&lt;br /&gt;
一查還真的是這樣，&lt;br /&gt;
但QA環境沒問題，&lt;br /&gt;
偏偏Prod就炸了。&lt;/p&gt;
&lt;p&gt;本來也有想說是不是真的沒有log，&lt;br /&gt;
到filebeat的pod去查，那些沒進去的pod log也都是存在。&lt;/p&gt;
&lt;p&gt;log路徑&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/var/log/containers/
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;故先排除，服務沒有寫入log的可能性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;會不會是filebeat在讀取log時的暫存空間不足。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但如果是此情況的話，應該是全部的filebeat都會有log遺失，這次的情況是在某些node上的服務 log都有進到ES，&lt;br /&gt;
其他的node都沒有。但也是有此可能性。&lt;/p&gt;
&lt;p&gt;調整filebeat內部資源&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/ninjavan-tech/logging-with-efk-in-gke-e11676f781e6&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Logging with EFK in GKE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/configuring-internal-queue.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Configure the internal queue&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;filebeat一直重啟&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之後跑去看filebeat的pod狀態，&lt;br /&gt;
發現有很多個pod常常不斷的重新啟動，&lt;br /&gt;
再到裡面去看詳細內容，&lt;br /&gt;
發現cpu跟 記憶體的使用量很高，&lt;br /&gt;
推測可能是由於資源不足導致。&lt;/p&gt;
&lt;p&gt;查詢filebeat官方建議的使用資源是多少。&lt;/p&gt;
&lt;p&gt;filebeat建議使用&lt;br /&gt;
cpu : 500Mi&lt;br /&gt;
memory: 500Mi&lt;/p&gt;
&lt;p&gt;改完後，觀察了約一個禮拜，lod都有持續進去，應該是沒問題，但容量也因此爆增了。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-managing-compute-resources.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Manage compute resources&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🗒 EFK/67. ECK，filebeat LOG蒐集遺失/" />
        </entry>
        <entry>
            <title>
                61. kibana 查詢語法
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗒 EFK/61. kibana 查詢語法/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;KQL其實沒很複雜，&lt;br /&gt;
建議把介紹&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/7.15/kuery-query.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kibana Query Language&lt;/a&gt;看完後基本上就會了。&lt;/p&gt;
&lt;p&gt;主要常用的是，使用 特定欄位搜尋，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;萬用字元 *&lt;/p&gt;
&lt;p&gt;例如，&lt;br /&gt;
今天要搜尋一個 pod Name 叫 grafana&lt;br /&gt;
那KQL 可輸入&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubernetes.pod.name: *grafana*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;搜尋出來的名稱，只要是 中間有 grafana的通通會列出。&lt;/p&gt;
&lt;p&gt;覺得前面名稱太長的話，&lt;a href=&quot;http://xn--pod-0v1e893z.name/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;輸入pod.name&lt;/a&gt;，用下拉選擇就好。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;引號使用&amp;quot; &amp;quot;&lt;br /&gt;
將裡面的字變成一個詞搜尋&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	message: &amp;quot;hello world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;不使用引號&lt;br /&gt;
裡面的字都會分別搜尋，已下面來說就是 會搜尋 hello 跟 world&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubernetes.pod.name: hello world
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;and 跟 or 條件&lt;br /&gt;
多條件查詢&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	message: &amp;quot;hello world&amp;quot; and kubernetes.pod.name:*grafana*
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;not 否定&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	not (kubernetes.pod.name: *grafana*)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;大於 小於 等於 判斷式  &amp;gt;, &amp;gt;= , &amp;lt;,&amp;lt;=&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	@timestamp &amp;lt; &amp;quot;2021-01-30&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;
&lt;p&gt;還有一種不使用KQL的查詢，Lucene&lt;br /&gt;
這種語法可支援正則表達式，但KQL不支援。&lt;br /&gt;
ref.&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/7.15/lucene-query.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Lucene query syntax&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nested fields 看來是可以查詢整串的json&lt;br /&gt;
但我想不到可以運用在哪&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜尋x-forward-for ip&lt;br /&gt;
有一個log如下圖，這個特別奇怪，不能加雙引號，&lt;br /&gt;
『.』 在kibana裡面似乎有特殊的用法，&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/61-fig.1.jpg&quot; alt=&quot;61-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubernetes.namespace: istio-sigua and message: 103.170.26.90*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要加雙引號的話，就必須搜尋完整的ip。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubernetes.namespace: istio-sigua and message: &amp;quot;221.210.89.170,10.120.17.1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;追根究底，還是要把message對應到欄位...&lt;br /&gt;
沒時間用阿QQ...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;搜尋url path&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubernetes.namespace: istio-sigua and message: &amp;quot;img/huawei_ans02.c7bcdbdf.jpg&amp;quot;
kubernetes.namespace: istio-sigua and message: &amp;quot;img*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;11&quot;&gt;
&lt;li&gt;特殊字元&lt;br /&gt;
如果要用特殊字元查詢的話，要加上 &#92; ，&lt;br /&gt;
但只限於下列這些關鍵字&lt;pre&gt;&lt;code&gt;+ - &amp;amp;&amp;amp; || ! ( ) { } [ ] ^ &amp;quot; ~ * ? : &#92; /
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/7.15/kuery-query.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kibana Query Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codingnote.cc/zh-hk/p/289218/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kibana查詢語言（KQL）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/cjfeii/article/details/79771399&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kibana查詢語法詳解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jesse.top/2020/08/25/elk/kibana%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kibana查詢語法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.aliyun.com/article/770157&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;大神都這麼做，讓 Kibana 搜索語法 query string 也能輕松上手&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🗒 EFK/61. kibana 查詢語法/" />
        </entry>
        <entry>
            <title>
                60. ECK的 kibana 警告， server.publicBaseUrl is missing
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗒 EFK/60. ECK的 kibana 警告， server.publicBaseUrl is missing/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;kibana時常這個警告出來，&lt;br /&gt;
但我一直找不到config要在哪設定。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/60-fig.1.png&quot; alt=&quot;60-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;之後問了另外一組的大大，他之前也在弄ECK，&lt;br /&gt;
給了我這段。&lt;br /&gt;
加一個config在yaml裡面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: kibana.k8s.elastic.co/v1
kind: Kibana
metadata:
  name: yabo
  namespace: elastic-system
spec:
  version: 7.15.0
  count: 1
  config:
    server.publicBaseUrl: http://123.232.162/
  elasticsearchRef:
    name: yabo
  http:
    tls:
      selfSignedCertificate:
        disabled: true
    service:
      spec:
        ports:
          - name: http
            port: 5601
            targetPort: 5601    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://debugah.com/solved-kibana-7-14-0-error-server-publicbaseurl-is-missing-and-should-be-configured-when-running-in-a-production-environment-18768/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [Solved] Kibana 7.14.0 error: server.publicBaseUrl is missing and should be configured when running in a production environment.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/current/settings.html#server-basePath&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Configure Kibana&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🗒 EFK/60. ECK的 kibana 警告， server.publicBaseUrl is missing/" />
        </entry>
        <entry>
            <title>
                58. 除錯用的ECK API
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗒 EFK/58. 除錯用的ECK API/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;很久之前要寫一直沒寫，&lt;br /&gt;
最近碰到問題，來還了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h2 id=&quot;primary-shard&quot; tabindex=&quot;-1&quot;&gt;Primary Shard (提昇系統儲存容量)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;shard 是 Elasticsearch 分散式儲存的基礎，包含 primary shard &amp;amp; replica shard&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每一個 shard 就是一個 Lucene instance&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;primary shard 功能是將一份被索引後的資料，分散到多個 data node 上存放，實現儲存方面的水平擴展&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;primary shard 的數量在建立 index 時就會指定，後續是無法修改的，若要修改就必須要進行 reindex&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;replica-shard&quot; tabindex=&quot;-1&quot;&gt;Replica Shard (提高資料可用性)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;replica shard 用來提供資料高可用性，當 primary shard 遺失時，replica shard 就可以被 promote 成 primary shard 來保持資料完整性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;replica shard 數量可以動態調整，讓每個 data node 上都有完整的資料&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;replica shard 可以一定程度的提高讀取(查詢)的效能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若不設定 replica shard，一旦有 data node 故障導致 primary shard 遺失，資料可能就無法恢復了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ES 7.0 開始，primary shard 預設為 &lt;code&gt;1&lt;/code&gt;，replica shard 預設為 &lt;code&gt;0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://godleon.github.io/blog/Elasticsearch/Elasticsearch-distributed-mechanism/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [Elasticsearch] 分散式特性 &amp;amp; 分散式搜尋的機制&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;shard-and-amp&quot; tabindex=&quot;-1&quot;&gt;Shard 的規劃 &amp;amp; 設定&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;primary shard 數量設定太小會遇到以下問題：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 index 資料增加很快時，cluster 無法通過增加 node 數量對 index 進行資料擴展&lt;/li&gt;
&lt;li&gt;單一 shard 資料太大，導致資料重新分配耗時&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;primary shard 數量設定太大會遇到以下問題：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;導致每個 shard 容量很小，讓一個 data node 上有過多 shard 而影響效能&lt;/li&gt;
&lt;li&gt;影響搜尋時的相關性算分，會讓統計結果失準&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;replica shard 若設定過多，會降低 cluster 整體的寫入效能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# 查node的狀態
GET _cluster/health/

# 取得目前所有的shard，加上?v 可顯示欄位名稱
GET _cat/shards?v

# 取得目前的shard設定數量（好幾次都是這個值暴了，導致log無法寫入)
GET /_cluster/settings

# 設定node的shard最大數量
PUT /_cluster/settings
{
  &amp;quot;persistent&amp;quot;: {
    &amp;quot;cluster.max_shards_per_node&amp;quot;: 1000
  }
}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-shards.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;cat shards API欄位介紹&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🗒 EFK/58. 除錯用的ECK API/" />
        </entry>
        <entry>
            <title>
                57.filebeat 補充說明
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗒 EFK/57.filebeat 補充說明/</id>
            <content type="html">
                &lt;h1 id=&quot;內容&quot; tabindex=&quot;-1&quot;&gt;內容&lt;/h1&gt;
&lt;h3 id=&quot;efk-57-filebeat-2024-05-28-2024-05-28&quot; tabindex=&quot;-1&quot;&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/57.filebeat%20%E8%A3%9C%E5%85%85%E8%AA%AA%E6%98%8E/#2024-05-28&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#2024/05/28補充&quot;&gt;#2024/05/28補充&lt;/a&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;filebeat&quot; tabindex=&quot;-1&quot;&gt;filebeat抓資料的方式&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;autodiscover&lt;/li&gt;
&lt;li&gt;without autodiscover&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要注意的是，如果用(2) 的方式，在GKE上面，你要使用 add_kubernetes_metadata，去取得pod name,namespace..等，&lt;br /&gt;
通通抓不到。&lt;/p&gt;
&lt;p&gt;因為(2)是直接去node的log裡面抓資料，並沒有透過api的方式，&lt;br /&gt;
所以如果要取得 pod name的話，可能要從log path着手。&lt;br /&gt;
應該是可以從ingest 去處理。&lt;/p&gt;
&lt;p&gt;但用(1)，資料就通通進來了。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/57.fig-1.jpg&quot; alt=&quot;57.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以還是用(1)吧。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-beat-configuration-examples.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Configuration Examples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/add-kubernetes-metadata.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Add Kubernetes metadata&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;排除資料的方式&quot; tabindex=&quot;-1&quot;&gt;排除資料的方式&lt;/h2&gt;
&lt;p&gt;沒有記錄log不知道，一記錄了才知道。&lt;br /&gt;
資料有夠肥。&lt;/p&gt;
&lt;p&gt;開始跟同仁說，沒有必要的不要留。&lt;br /&gt;
但有些是先天限制，就是會拼命印，那該怎麼解決。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;排除訊息內的特定文字，通通不收&lt;br /&gt;
在autodiscover 底下使用 exclude_lines&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;autodiscover:
  providers:
  - type: kubernetes
    node: ${NODE_NAME}                                              
    hints:
      enabled: true
      default_config:
        type: container
        paths:
        - /var/log/containers/*${data.kubernetes.container.id}.log
        exclude_lines: 
        - &amp;quot;.*(NAT rule custom-iptables|unknown operand).*&amp;quot;  # 排除 k8s-custom-iptables
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-input-log.html#filebeat-input-log-exclude-lines&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Log input&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;排除特定namespace&lt;br /&gt;
在  processors 底下加 drop_event，這邊有用到condition的條件，建議看一下文件比較清楚。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;processors:
- add_cloud_metadata: {}
- drop_event.when:
    or:
    - equals:
        kubernetes.namespace: &amp;quot;kube-system&amp;quot;
    - equals:
        kubernetes.namespace: &amp;quot;elastic-system&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/drop-event.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Drop events&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/60566173/how-we-can-filter-namespace-in-filebeat-kubernetes&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;how-we-can-filter-namespace-in-filebeat-kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/defining-processors.html#conditions&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;conditions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;移除特定欄位&quot; tabindex=&quot;-1&quot;&gt;移除特定欄位&lt;/h2&gt;
&lt;p&gt;有些欄位得到的值是重複的，&lt;br /&gt;
所以這些也都可以砍掉。&lt;br /&gt;
processors 底下加  drop_fields&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;processors:
- drop_fields:
      fields: 
        - &#39;kubernetes.node&#39;
        - &#39;kubernetes.namespace_uid&#39;
        - &#39;agent.hostname&#39;
        - &#39;cloud.account&#39;
        - &#39;cloud.provider&#39;
        - &#39;cloud.instance.name&#39;
        - &#39;container.id&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/drop-fields.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Drop fields from events&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;詳細參數說明&quot; tabindex=&quot;-1&quot;&gt;詳細參數說明&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type: log &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#input類型為log&quot;&gt;#input類型為log&lt;/a&gt;
enable: true &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#表示是該log類型配置生效&quot;&gt;#表示是該log類型配置生效&lt;/a&gt;
paths：     &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#指定要監控的日誌，目前按照Go語言的glob函數處理。沒有對配置目錄做遞歸處理，比如配置的如果是：&quot;&gt;#指定要監控的日誌，目前按照Go語言的glob函數處理。沒有對配置目錄做遞歸處理，比如配置的如果是：&lt;/a&gt;
- /var/log/* /*.log  &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#則只會去/var/log目錄的所有子目錄中尋找以&quot;&gt;#則只會去/var/log目錄的所有子目錄中尋找以&lt;/a&gt;&amp;quot;.log&amp;quot;結尾的文件，而不會尋找/var/log目錄下以&amp;quot;.log&amp;quot;結尾的文件。
recursive_glob.enabled: &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#啟用全局遞歸模式，例如/foo/&quot;&gt;#啟用全局遞歸模式，例如/foo/&lt;/a&gt;**包括/foo, /foo/*, /foo/*/*
encoding：#指定被監控的文件的編碼類型，使用plain和utf-8都是可以處理中文日誌的
exclude_lines: [&#39;^DBG&#39;] &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#不包含匹配正則的行&quot;&gt;#不包含匹配正則的行&lt;/a&gt;
include_lines: [&#39;^ERR&#39;, &#39;^WARN&#39;]  &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#包含匹配正則的行&quot;&gt;#包含匹配正則的行&lt;/a&gt;
harvester_buffer_size: 16384 &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#每個harvester在獲取文件時使用的緩沖區的字節大小&quot;&gt;#每個harvester在獲取文件時使用的緩沖區的字節大小&lt;/a&gt;
max_bytes: 10485760 &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#單個日誌消息可以擁有的最大字節數。max_bytes之後的所有字節都被丟棄而不發送。默認值為10MB&quot;&gt;#單個日誌消息可以擁有的最大字節數。max_bytes之後的所有字節都被丟棄而不發送。默認值為10MB&lt;/a&gt; (10485760)
exclude_files: [&#39;&#92;.gz$&#39;]  &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#用於匹配希望Filebeat忽略的文件的正則表達式列表&quot;&gt;#用於匹配希望Filebeat忽略的文件的正則表達式列表&lt;/a&gt;
ingore_older: 0 &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#默認為0，表示禁用，可以配置2h，2m等，注意ignore_older必須大於close_inactive的值&quot;&gt;#默認為0，表示禁用，可以配置2h，2m等，注意ignore_older必須大於close_inactive的值&lt;/a&gt;.表示忽略超過設置值未更新的
文件或者文件從來沒有被harvester收集
close_* &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#close_&quot;&gt;#close_&lt;/a&gt; *配置選項用於在特定標准或時間之後關閉harvester。 關閉harvester意味著關閉文件處理程序。 如果在harvester關閉
後文件被更新，則在scan_frequency過後，文件將被重新拾取。 但是，如果在harvester關閉時移動或刪除文件，Filebeat將無法再次接收文件
，並且harvester未讀取的任何數據都將丟失。
close_inactive  &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#啟動選項時，如果在制定時間沒有被讀取，將關閉文件句柄&quot;&gt;#啟動選項時，如果在制定時間沒有被讀取，將關閉文件句柄&lt;/a&gt;
讀取的最後一條日誌定義為下一次讀取的起始點，而不是基於文件的修改時間
如果關閉的文件發生變化，一個新的harverster將在scan_frequency運行後被啟動
建議至少設置一個大於讀取日誌頻率的值，配置多個prospector來實現針對不同更新速度的日誌文件
使用內部時間戳機制，來反映記錄日誌的讀取，每次讀取到最後一行日誌時開始倒計時使用2h 5m 來表示
close_rename &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#當選項啟動，如果文件被重命名和移動，filebeat關閉文件的處理讀取&quot;&gt;#當選項啟動，如果文件被重命名和移動，filebeat關閉文件的處理讀取&lt;/a&gt;
close_removed &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#當選項啟動，文件被刪除時，filebeat關閉文件的處理讀取這個選項啟動後，必須啟動clean_removed&quot;&gt;#當選項啟動，文件被刪除時，filebeat關閉文件的處理讀取這個選項啟動後，必須啟動clean_removed&lt;/a&gt;
close_eof &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#適合只寫一次日誌的文件，然後filebeat關閉文件的處理讀取&quot;&gt;#適合只寫一次日誌的文件，然後filebeat關閉文件的處理讀取&lt;/a&gt;
close_timeout &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#當選項啟動時，filebeat會給每個harvester設置預定義時間，不管這個文件是否被讀取，達到設定時間後，將被關閉&quot;&gt;#當選項啟動時，filebeat會給每個harvester設置預定義時間，不管這個文件是否被讀取，達到設定時間後，將被關閉&lt;/a&gt;
close_timeout 不能等於ignore_older,會導致文件更新時，不會被讀取如果output一直沒有輸出日誌事件，這個timeout是不會被啟動的，
至少要要有一個事件發送，然後haverter將被關閉
設置0 表示不啟動
clean_inactived &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#從注冊表文件中刪除先前收獲的文件的狀態&quot;&gt;#從注冊表文件中刪除先前收獲的文件的狀態&lt;/a&gt;
設置必須大於ignore_older+scan_frequency，以確保在文件仍在收集時沒有刪除任何狀態
配置選項有助於減小注冊表文件的大小，特別是如果每天都生成大量的新文件
此配置選項也可用於防止在Linux上重用inode的Filebeat問題
clean_removed &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#啟動選項後，如果文件在磁盤上找不到，將從注冊表中清除filebeat&quot;&gt;#啟動選項後，如果文件在磁盤上找不到，將從注冊表中清除filebeat&lt;/a&gt;
如果關閉close removed 必須關閉clean removed
scan_frequency &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#prospector檢查指定用於收獲的路徑中的新文件的頻率&quot;&gt;#prospector檢查指定用於收獲的路徑中的新文件的頻率&lt;/a&gt;,默認10s
tail_files：#如果設置為true，Filebeat從文件尾開始監控文件新增內容，把新增的每一行文件作為一個事件依次發送，
而不是從文件開始處重新發送所有內容。
symlinks：#符號鏈接選項允許Filebeat除常規文件外,可以收集符號鏈接。收集符號鏈接時，即使報告了符號鏈接的路徑，
Filebeat也會打開並讀取原始文件。
backoff： &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#backoff選項指定Filebeat如何積極地抓取新文件進行更新。默認1s，backoff選項定義Filebeat在達到EOF之後&quot;&gt;#backoff選項指定Filebeat如何積極地抓取新文件進行更新。默認1s，backoff選項定義Filebeat在達到EOF之後&lt;/a&gt;
再次檢查文件之間等待的時間。
max_backoff： &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#在達到EOF之後再次檢查文件之前Filebeat等待的最長時間&quot;&gt;#在達到EOF之後再次檢查文件之前Filebeat等待的最長時間&lt;/a&gt;
backoff_factor： &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#指定backoff嘗試等待時間幾次，默認是2&quot;&gt;#指定backoff嘗試等待時間幾次，默認是2&lt;/a&gt;
harvester_limit：#harvester_limit選項限制一個prospector並行啟動的harvester數量，直接影響文件打開數

tags &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#列表中添加標簽，用過過濾，例如：tags&quot;&gt;#列表中添加標簽，用過過濾，例如：tags&lt;/a&gt;: [&amp;quot;json&amp;quot;]
fields &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#可選字段，選擇額外的字段進行輸出可以是標量值，元組，字典等嵌套類型&quot;&gt;#可選字段，選擇額外的字段進行輸出可以是標量值，元組，字典等嵌套類型&lt;/a&gt;
默認在sub-dictionary位置
filebeat.inputs:
fields:
app_id: query_engine_12
fields_under_root &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#如果值為ture，那麼fields存儲在輸出文檔的頂級位置&quot;&gt;#如果值為ture，那麼fields存儲在輸出文檔的頂級位置&lt;/a&gt;

multiline.pattern &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#必須匹配的regexp模式&quot;&gt;#必須匹配的regexp模式&lt;/a&gt;
multiline.negate &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#定義上面的模式匹配條件的動作是&quot;&gt;#定義上面的模式匹配條件的動作是&lt;/a&gt; 否定的，默認是false
假如模式匹配條件&#39;^b&#39;，默認是false模式，表示講按照模式匹配進行匹配 將不是以b開頭的日誌行進行合並
如果是true，表示將不以b開頭的日誌行進行合並
multiline.match # 指定Filebeat如何將匹配行組合成事件,在之前或者之後，取決於上面所指定的negate
multiline.max_lines &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#可以組合成一個事件的最大行數，超過將丟棄，默認500&quot;&gt;#可以組合成一個事件的最大行數，超過將丟棄，默認500&lt;/a&gt;
multiline.timeout &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#定義超時時間，如果開始一個新的事件在超時時間內沒有發現匹配，也將發送日誌，默認是5smax_procs&quot;&gt;#定義超時時間，如果開始一個新的事件在超時時間內沒有發現匹配，也將發送日誌，默認是5smax_procs&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#設置可以同時執行的最大CPU數。默認值為系統中可用的邏輯CPU的數量。name&quot;&gt;#設置可以同時執行的最大CPU數。默認值為系統中可用的邏輯CPU的數量。name&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#為該filebeat指定名字，默認為主機的hostname&quot;&gt;#為該filebeat指定名字，默認為主機的hostname&lt;/a&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/zsql/p/13137833.htmll&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;一篇文章搞懂filebeat（ELK）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;filebeat-log&quot; tabindex=&quot;-1&quot;&gt;filebeat log寫入到檔案&lt;/h2&gt;
&lt;p&gt;filebeat在運作時，會產生一堆log，這些我原本都不想讓他輸出，直接寫在自己的檔案就好。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/57.fig-2.jpg&quot; alt=&quot;57.fig-2.jpg&quot; /&gt;&lt;br /&gt;
但沒測試成功，最後只好採用治標不治本的方式，&lt;br /&gt;
在該namespace底下的log通通不進ES。&lt;/p&gt;
&lt;p&gt;留一下查到的資料。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;logging:
    to_files: true
    metrics.enabled: false 
    files:
      path: &#39;/usr/share/filebeat/logs&#39;
      name: &#39;filebeat&#39;
      rotateeverybytes: 10485760 # = 10MB
      keepfiles: 7
      permission: &#39;0640&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/configuration-logging.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Configure logging&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;yaml-operator&quot; tabindex=&quot;-1&quot;&gt;完整yaml，使用operator&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: beat.k8s.elastic.co/v1beta1
kind: Beat
metadata:
  name: yabo
  namespace: elastic-system
spec:
  type: filebeat
  version: 7.15.0
  elasticsearchRef:
    name: yabo
  kibanaRef:
    name: yabo
  config:
    filebeat:
      autodiscover:
        providers:
        - type: kubernetes
          node: ${NODE_NAME}    
          hints:
            enabled: true
            default_config:
              type: container
              paths:
              - /var/log/containers/*${data.kubernetes.container.id}.log
              exclude_lines: 
              - &amp;quot;.*(NAT rule custom-iptables|unknown operand).*&amp;quot;  # 排除 k8s-custom-iptables
              - &amp;quot;.*(YABO_WS.Services.PromoWebSocketService|YABO_WS.BLL.ActivityEventLogic).*&amp;quot;      
    processors:
    - add_cloud_metadata: {}
    # - add_host_metadata: {}
    - drop_event.when:
        or:
        - equals:
            kubernetes.namespace: &amp;quot;kube-system&amp;quot;
        - equals:
            kubernetes.namespace: &amp;quot;elastic-system&amp;quot;
    - drop_fields:
          fields: 
            - &#39;kubernetes.node&#39;
            - &#39;kubernetes.namespace_uid&#39;
            - &#39;agent.hostname&#39;
            - &#39;cloud.account&#39;
            - &#39;cloud.provider&#39;
            - &#39;cloud.instance.name&#39;
            - &#39;container.id&#39;
    - decode_json_fields:
          fields: [&amp;quot;message&amp;quot;]
          target: &amp;quot;&amp;quot;
          overwrite_keys: true   
    # 測試沒用，無法寫到 
    # logging:
    #   to_files: true
    #   metrics.enabled: false 
    #   files:
    #     path: &#39;/usr/share/filebeat/logs&#39;
    #     name: &#39;filebeat&#39;
    #     rotateeverybytes: 10485760 # = 10MB
    #     keepfiles: 7
    #     permission: &#39;0644&#39;
  daemonSet:
    podTemplate:
      spec:
        serviceAccountName: filebeat
        automountServiceAccountToken: true
        terminationGracePeriodSeconds: 30
        dnsPolicy: ClusterFirstWithHostNet
        hostNetwork: true # Allows to provide richer host metadata
        containers:
        - name: filebeat
          securityContext:
            runAsUser: 0
            # If using Red Hat OpenShift uncomment this:
            &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#privileged&quot;&gt;#privileged&lt;/a&gt;: true
          volumeMounts:
          - name: varlogcontainers
            mountPath: /var/log/containers
          - name: varlogpods
            mountPath: /var/log/pods
          - name: varlibdockercontainers
            mountPath: /var/lib/docker/containers
          env:
            - name: NODE_NAME
              valueFrom:
                fieldRef:
                  fieldPath: spec.nodeName
        volumes:
        - name: varlogcontainers
          hostPath:
            path: /var/log/containers
        - name: varlogpods
          hostPath:
            path: /var/log/pods
        - name: varlibdockercontainers
          hostPath:
            path: /var/lib/docker/containers
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: filebeat
rules:
- apiGroups: [&amp;quot;&amp;quot;] # &amp;quot;&amp;quot; indicates the core API group
  resources:
  - namespaces
  - pods
  - nodes
  verbs:
  - get
  - watch
  - list
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: filebeat
  namespace: elastic-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: filebeat
subjects:
- kind: ServiceAccount
  name: filebeat
  namespace: elastic-system
roleRef:
  kind: ClusterRole
  name: filebeat
  apiGroup: rbac.authorization.k8s.io

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/jatq/articles/14651723.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ECK部署&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://arch-long.cn/articles/elasticsearch/FileBeat.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;FileBeat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.codeless.me/posts/elastic-beats-on-google-kubernetes-engine-gke/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elastic Beats on Google Kubernetes Engine (GKE)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/DanRoscigno/GKE-on-Prem-logging-and-metrics/blob/master/filebeat-kubernetes.yaml&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;filebeat-kubernetes.yaml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.deepnetwork.com/blog/2020/01/27/ELK-stack-filebeat-k8s-deployment.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to Setup an ELK Stack and Filebeat on Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;2024-05-28&quot; tabindex=&quot;-1&quot;&gt;2024/05/28補充&lt;/h2&gt;
&lt;h3 id=&quot;autodiscover-log-indices&quot; tabindex=&quot;-1&quot;&gt;使用autodiscover，拆分兩個log indices&lt;/h3&gt;
&lt;p&gt;以下程式碼為『片段』。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: beat.k8s.elastic.co/v1beta1
kind: Beat
metadata:
  name: prod
  namespace: elastic-system
spec:
  type: filebeat
  version: 8.13.2
  elasticsearchRef:
    name: prod
    namespace: elastic-system
  kibanaRef:
    name: prod
    namespace: elastic-system
  config:     
    filebeat:
      autodiscover:
        providers:
        - type: kubernetes
          node: ${NODE_NAME} 
          templates:
            - condition:
                equals:
                  kubernetes.labels.app: &amp;quot;video&amp;quot;
              config:
                - type: container
                  paths:
                    - /var/log/containers/*${data.kubernetes.container.id}.log
                  processors:
                    - add_kubernetes_metadata:
                        host: ${NODE_NAME}                                                       
            - condition:
                equals:
                  kubernetes.labels.app: &amp;quot;auth&amp;quot;
              config:
                - type: container
                  paths:
                    - /var/log/containers/*${data.kubernetes.container.id}.log
                  processors:
                    - add_kubernetes_metadata:
                        host: ${NODE_NAME}                                                       
    processors:
    - add_cloud_metadata: {} 
    output.elasticsearch:
      username: &amp;quot;elastic&amp;quot;
      password: &amp;quot;password&amp;quot;  
      index: &amp;quot;logs-%{[kubernetes.labels.app]}-%{+yyyy.MM.dd}&amp;quot;
      indices:
        - index: &amp;quot;videoworker-%{+yyyy.MM.dd}&amp;quot;
          when.equals:
            kubernetes.labels.app: &amp;quot;videoworker&amp;quot;
        - index: &amp;quot;authcontrol-%{+yyyy.MM.dd}&amp;quot;
          when.equals:
            kubernetes.labels.app: &amp;quot;authcontrol&amp;quot; 
    setup.template.enabled: true
    setup.template.name: &amp;quot;filebeat-8.13.2&amp;quot;
    setup.template.pattern: &amp;quot;filebeat-8.13.2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;說明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;config.filebeat.autodiscover.providers ：底下使用template，作為拆分的範本，原先是使用hints機制，使用關鍵label作為擷取的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;output.elasticsearch: 輸出到elasticsearch ，預設的index使用 logs作為datastream，底下的indices則是再細分規則， 如果符合規則，則使用其他的datastream名稱。&lt;/p&gt;
&lt;p&gt;官方文件，是不用寫output.elasticsearch，但我搞不出來。&lt;br /&gt;
改天在繼續追了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/configuration-autodiscover-hints.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Hints based autodiscover&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-beat-configuration-examples.html#k8s-beat-configuration-examples&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Filebeat example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🗒 EFK/57.filebeat 補充說明/" />
        </entry>
        <entry>
            <title>
                55. es基本概念篇
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗒 EFK/55. es基本概念篇/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;先來個比較容易對比的表格，但不完全一樣，&lt;br /&gt;
有幾個是我自己加上去的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;RDBMS&lt;/th&gt;
&lt;th&gt;Elasticsearch&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;VM&lt;/td&gt;
&lt;td&gt;Node&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Table&lt;/td&gt;
&lt;td&gt;Index&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Row&lt;/td&gt;
&lt;td&gt;Document&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Column&lt;/td&gt;
&lt;td&gt;Field&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Schema&lt;/td&gt;
&lt;td&gt;Mapping&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SQL&lt;/td&gt;
&lt;td&gt;DSL&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://godleon.github.io/blog/Elasticsearch/Elasticsearch-getting-started/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Elasticsearch] 基本概念 &amp;amp; 搜尋入門&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;摘要&quot; tabindex=&quot;-1&quot;&gt;摘要&lt;/h2&gt;
&lt;h4 id=&quot;node&quot; tabindex=&quot;-1&quot;&gt;Node&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Master Node&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;處理建立/刪除 index 的 request，並實際執行&lt;/li&gt;
&lt;li&gt;決定每個 shard 要被分配到哪個 data node 上&lt;/li&gt;
&lt;li&gt;維護 &amp;amp; 更新 cluster state&lt;/li&gt;
&lt;li&gt;當 master node出問題，master eligible node（從cluster設定多個）會開始選舉，選出下一個 master node&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Coordinating Node(協調節點)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有node預設都是 Coordinating Node&lt;/li&gt;
&lt;li&gt;處理request的node 以及 最後進行結果的彙整&lt;/li&gt;
&lt;li&gt;coordinating node 可以直接接收 search request 並處理，不需要透過 master node 轉過來&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Data Node&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以保存資料的 node，每個 node 啟動後都會預設是 data node，可以透過設定 &lt;code&gt;node.data: false&lt;/code&gt; 停用 data node 功能&lt;/li&gt;
&lt;li&gt;透過增加 data node 可以解決資料水平擴展 &amp;amp; 解決單點故障導致資料遺失的問題&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cluster State（集群狀態)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包含所有node資訊&lt;/li&gt;
&lt;li&gt;包含所有index 及 相對應的 mapping/setting配置&lt;/li&gt;
&lt;li&gt;shard的路由資訊&lt;/li&gt;
&lt;li&gt;每個node上都有Cluster State，只有master 可修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;shard&quot; tabindex=&quot;-1&quot;&gt;Shard&lt;/h4&gt;
&lt;h6 id=&quot;shard-1&quot; tabindex=&quot;-1&quot;&gt;將索引劃分成多份的能力，這些份就叫做分片（shard）&lt;/h6&gt;
&lt;p&gt;例如你有一個index （1T) ，要怎麼存到不同的Node，&lt;br /&gt;
此時就需要使用(shard)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;shard 是 ES分散式儲存的基礎，包含 primary shard 及 replica shard&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每一個shard 就是一個  Lucene instance(用於全文檢索和搜尋 e.g. Solr,Elasticsearch...)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Primary Shard(提升系統儲存容量)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將一份被索引後的資料，分散到多個data node上存放&lt;/li&gt;
&lt;li&gt;primary shard 的數量在建立 index時就會指定，無法後續修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Replica Shard（提高資料可用性)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當primary shard遺失，Replica shard可以被推成 primary shard&lt;/li&gt;
&lt;li&gt;replica shard數量可動態調整，讓每個data node上都有完整資料&lt;/li&gt;
&lt;li&gt;可一定程度提高查詢的效能&lt;/li&gt;
&lt;li&gt;ES7.0開始，primary shard 預設為1 ,replica shard預設 為0&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如不設定replica shard，一旦data node 故障導致 primary shard遺失，資料無法復原&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shard設定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;replica shard設定過多，會降低clsuter整體的寫入效能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;replica shard 必須和 primary shard 被分配在不同的 data node 上；但所有的 primary shard 可以在同一個 data node 上&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;command&quot; tabindex=&quot;-1&quot;&gt;Command&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;取得Cluster 健康狀態&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	GET _cluster/health/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Status&lt;br /&gt;
- Green ：表示 Primary shard &amp;amp; Replica Shard可正常分配&lt;br /&gt;
- Yellow：表示 Primay shard可正常分配，但Replica shard 分配有問題&lt;br /&gt;
- Red：有Primary shard 無法正常分配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;取得 Shard狀態&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	GET _cat/shards
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/55.fig-1.jpg&quot; alt=&quot;55.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;p ：代表 primary shard&lt;br /&gt;
r  ：代表 replica shard&lt;br /&gt;
2. shard的分佈情形，在哪個node上&lt;br /&gt;
3. 每個shard包含的document數量 &amp;amp; 空間&lt;/p&gt;
&lt;h4 id=&quot;情境&quot; tabindex=&quot;-1&quot;&gt;情境&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;如果cluster 只有一個node ，全部會被 primary shard佔據，導致 replica shard 無法被分配，因此cluster健康狀態為 yellow&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;資料寫入&quot; tabindex=&quot;-1&quot;&gt;資料寫入&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;cache&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;資料寫入後無法變動，避免lock機制所帶來的效能問題&lt;/li&gt;
&lt;li&gt;因不可變動，若要讓新的document 可被搜尋，需要重建index&lt;/li&gt;
&lt;li&gt;寫入document前，會先寫到 Index Buffer的儲存空間&lt;/li&gt;
&lt;li&gt;滿足條件(Index Buffer佔滿) or 特定時間(預設一秒一次)，會將 Buffer 寫入 Segment 。寫入的過程叫Refresh。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;transaction log&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每個shard都有對應的transaction log&lt;/li&gt;
&lt;li&gt;寫入document的時候，同時也會寫入 transaction log&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://godleon.github.io/blog/Elasticsearch/Elasticsearch-distributed-mechanism/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Elasticsearch] 分散式特性 &amp;amp; 分散式搜尋的機制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/UbuntuTouch/article/details/99443042&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elasticsearch 中的一些重要概念: cluster, node, index, document, shards 及 replica&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jeff-yen.medium.com/elasticsearch-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E8%A6%8F%E5%8A%83-e1763b856a08&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elasticsearch 基本原理及規劃&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🗒 EFK/55. es基本概念篇/" />
        </entry>
        <entry>
            <title>
                53. apm error
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗒 EFK/53. apm error/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;錯誤訊息&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There are no ingest nodes in this cluster, unable to forward request to an ingest node.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ES的yaml&lt;br /&gt;
增加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;node.roles:
- ingest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Node&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/UbuntuTouch/article/details/99702199&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;如何在 Elasticsearch 中使用 pipeline API 來對事件進行處理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://discuss.elastic.co/t/there-are-no-ingest-nodes-in-this-cluster-unable-to-forward-request-to-an-ingest-node/279740&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;There are no ingest nodes in this cluster, unable to forward request to an ingest node&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🗒 EFK/53. apm error/" />
        </entry>
        <entry>
            <title>
                52. ILM 設定
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗒 EFK/52. ILM 設定/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;使用預設的filebeat.yaml設定，&lt;br /&gt;
導致現在elasticsearch的log爆炸了。&lt;br /&gt;
連開都開不起來。&lt;br /&gt;
所以這次要解決兩個問題，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自動刪除舊的log&lt;/li&gt;
&lt;li&gt;將log根據日期分配&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;經過一早上的研究，發現我想得跟我要解決的問題不一樣XDDD&lt;/p&gt;
&lt;p&gt;所以本文會在探討ILM的設定&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;有些觀念跟我想得不一樣，&lt;br /&gt;
下圖看到的 indices，是在elasticSearch（簡稱ES）上，&lt;br /&gt;
所建立的。&lt;/p&gt;
&lt;p&gt;ES上的indices會長這樣&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/52-fig.1.jpg&quot; alt=&quot;52-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以跟fileBeat沒有關係，fileBeat只負責把資料丟過去ES上。&lt;/p&gt;
&lt;p&gt;當然裡面也有一些設定，等以後有空再來研究。&lt;/p&gt;
&lt;p&gt;首先到 kibana的畫面，&lt;br /&gt;
到 Management 中去設定ILM&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/52-fig.2.jpg&quot; alt=&quot;52-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;裡面的設定，請參考下面文章，&lt;br /&gt;
或是直接看英文也可以懂。&lt;/p&gt;
&lt;p&gt;但最好先看一下文章，es的 indices 區分成三個階段，&lt;br /&gt;
改完設定後，並不會立即生效，只有當過度到下一個階段的時候，配置才會生效。&lt;/p&gt;
&lt;p&gt;也就是說，如果你一直在 Hot phase，&lt;br /&gt;
那永遠不會執行你剛設定的參數。&lt;/p&gt;
&lt;p&gt;但一當你進入Warm phase時，&lt;br /&gt;
你剛剛設定的參數就都會執行了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/52-fig.3.jpg&quot; alt=&quot;52-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;另外在各個 phase ，能做的事情也都不一樣。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Index Lifecycle Management 的階段&lt;/th&gt;
&lt;th&gt;此階段中可以執行的操作有什麼&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Hot&lt;/td&gt;
&lt;td&gt;Force merge, Rollover, Set priority, Unfollow&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Warm&lt;/td&gt;
&lt;td&gt;Allocate, Force merge, Read only, Set priority, Shrink, Unfollow&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cold&lt;/td&gt;
&lt;td&gt;Allocate, Freeze, Set priority, Unfollow&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Delete&lt;/td&gt;
&lt;td&gt;Delete, Wait for snapshot&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;像要刪除 indices 的話，就必須要到 Delete phase的階段才可以。&lt;/p&gt;
&lt;p&gt;ps. 如果發現沒有看到 delete phase，&lt;br /&gt;
要先把下圖的開關切換過去，delete phase 才會出現。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/52-fig.4.jpg&quot; alt=&quot;52-fig.4.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;設定完後，可以到 Dev Tools ，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查詢有哪些 indices&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;GET /_cat/indices

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/52-fig.5.jpg&quot; alt=&quot;52-fig.5.jpg&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查indices狀態&lt;br /&gt;
將右邊的 indics，取代下面的url 。&lt;br /&gt;
這邊使用的 indices 名稱為 filebeat-7.15.0-2021.10.07-000001 ，如果要知道json內的內容意義，請參考下面連結『Explain lifecycle API』。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;GET filebeat-7.15.0-2021.10.07-000001/_ilm/explain
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/52-fig.6.jpg&quot; alt=&quot;52-fig.6.jpg&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;啟動 ILM&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;POST /_ilm/start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10244575&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;喬叔教 Elastic - 11 - 管理 Index 的 Best Practices (3/7) - Index Lifecycle Management (ILM)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/cn/blog/implementing-hot-warm-cold-in-elasticsearch-with-index-lifecycle-management&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用索引生命週期管理實現熱溫冷架構&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.7/ilm-explain-lifecycle.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Explain lifecycle API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://discuss.elastic.co/t/automatically-delete-old-indices/190276&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Automatically delete old indices&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;跟這次的問題沒關係，但還是留個連結&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://shazi.info/filebeat-harvester-%E7%9A%84-file-handler-close-%E8%88%87-clean-%E6%A9%9F%E5%88%B6/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Filebeat harvester 的 file handler close 與 clean 機制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.51cto.com/u_10120275/2132800&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;filebeat進程寫滿磁盤的情況處理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codingnote.cc/zh-tw/p/134769/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;一篇文章搞懂filebeat（ELK）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/whych/p/9958188.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Filebeat配置參考手冊&lt;/a&gt;]&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;curator&quot; tabindex=&quot;-1&quot;&gt;curator&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.twblogs.net/a/5e511223bd9eee21167f04b2&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;elasticsearch curator安裝及應用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@vidyasonawane20/install-and-configure-elasticsearch-curator-to-delete-the-old-indices-acee09344852&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Install and configure Elasticsearch Curator to delete the old indices.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.johnwu.cc/article/elk-purge-elasticsearch-index.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ELK 教學 - 定期清除 Elasticsearch 資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🗒 EFK/52. ILM 設定/" />
        </entry>
        <entry>
            <title>
                43.自建ECK on GKE
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗒 EFK/43.自建ECK on GKE/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;Elastic Cloud on Kubernetes 簡化了在 Kubernetes 中運行 Elasticsearch 和 Kibana 的作業，包括設置、升級、快照、擴展、高可用性、安全性等&lt;/p&gt;
&lt;p&gt;istio 安裝時，開log&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;istioctl manifest install -f loadBalancerSourceRange.yaml --set meshConfig.accessLogFile=/dev/stdout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或是更改yaml ，加上 meshConfig這段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kind: IstioOperator
apiVersion: install.istio.io/v1alpha1
metadata:
  annotations:
    install.istio.io/ignoreReconcile: &#39;true&#39;
  name: istio-external
  namespace: istio-system
spec:
  meshConfig:
    accessLogFile: /dev/stdout
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ECK&lt;/p&gt;
&lt;p&gt;Kubernetes before 1.16以上版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl create -f https://download.elastic.co/downloads/eck/2.1.0/crds.yaml
kubectl apply -f https://download.elastic.co/downloads/eck/2.1.0/operator.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需先安裝 elasticsearch Operator&lt;br /&gt;
ref.&lt;a href=&quot;https://operatorhub.io/operator/elastic-cloud-eck&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elasticsearch (ECK) Operator&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;佈署 elasticsearch&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
apiVersion: elasticsearch.k8s.elastic.co/v1
kind: Elasticsearch
metadata:
  name: quickstart
spec:
  version: 7.15.0
  nodeSets:
  - name: default
    count: 1
    config:
      node.store.allow_mmap: false
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;檢查狀態&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	kubectl get elasticsearch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到pod裡面測試elastic是否正常&lt;br /&gt;
密碼需使用 kubectl get secret  取得，&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/43.%E8%87%AA%E5%BB%BAECK%20on%20GKE/#%E5%8F%96%E5%BE%97%E5%AF%86%E7%A2%BC%EF%BC%9A&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#取得密碼：&quot;&gt;#取得密碼：&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl https://10.107.201.126:9200 -u &#39;elastic:J1fO9bu8adfsepYK8rIu91a73o&#39; -k
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正常的話，會顯示&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/43-fig.0.jpg&quot; alt=&quot;43-fig.0.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;佈署kibana&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
apiVersion: kibana.k8s.elastic.co/v1
kind: Kibana
metadata:
  name: quickstart
spec:
  version: 7.15.0
  count: 1
  elasticsearchRef:
    name: quickstart
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;檢查狀態&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	kubectl get kibana
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;登入&lt;/p&gt;
&lt;p&gt;帳號：elastic&lt;/p&gt;
&lt;h4 id=&quot;取得密碼：&quot; tabindex=&quot;-1&quot;&gt;取得密碼：&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;kubectl get secret quickstart-es-elastic-user -o=jsonpath=&#39;{.data.elastic}&#39; | base64 --decode; echo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;轉port&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl port-forward service/quickstart-kb-http 5601
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;url : &lt;a href=&quot;https://localhost:5601/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://localhost:5601&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;beat&quot; tabindex=&quot;-1&quot;&gt;beat&lt;/h1&gt;
&lt;p&gt;Beats 其實是一系列工具的總稱，可以解決下列的問題：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;讀取檔案&lt;/li&gt;
&lt;li&gt;提取指標&lt;/li&gt;
&lt;li&gt;提取網路資料&lt;/li&gt;
&lt;li&gt;測試服務可用性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有這些 Filebeat, Metricbeat,Heartbeat,Packetbeat...等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/GeZmgxJ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;查詢目前有哪些index了&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/43-fig.1.jpg&quot; alt=&quot;43-fig.1.jpg&quot; /&gt;&lt;br /&gt;
到DevTools執行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET _cat/indices?s=index
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://www.elastic.co/beats/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Beats&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10235198&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;【ES新手，破門而入！】Day9 - 我見故我在！Observability 基礎之趴特睡&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10236378&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;【ES新手，破門而入！】Day13 - 關於 Metrics 的 23456 事&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;filebeat&quot; tabindex=&quot;-1&quot;&gt;Filebeat&lt;/h2&gt;
&lt;p&gt;日誌處理工具，只要會產生日誌的地方都可以使用它，它可以幫助你將日誌傳送到 Elasticsearch 或其他的系統。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Bj8v2F5.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
log 位置&lt;br /&gt;
/var/log/containers&lt;/p&gt;
&lt;p&gt;查詢傳了哪些資料到elastic search裡面。&lt;br /&gt;
同樣使用 Devtools&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET filebeat-*/_search
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/43-fig.2.jpg&quot; alt=&quot;43-fig.2.jpg&quot; /&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/57.filebeat%20%E8%A3%9C%E5%85%85%E8%AA%AA%E6%98%8E/&quot;&gt;57.filebeat 補充說明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://linyencheng.github.io/2020/09/09/elastic-observability-logging-introduction/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elastic Logging X Filebeat 深入理解&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;metricsbeat&quot; tabindex=&quot;-1&quot;&gt;Metricsbeat&lt;/h2&gt;
&lt;p&gt;將指標傳送到 Elasticsearch 分析，並搭配 Kibana 做視覺化。&lt;/p&gt;
&lt;p&gt;指標著重在資訊的週期性測量，讓我們可以瞭解系統的狀態如硬碟空間、CPU使用率等等。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10235524&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ES新手，破門而入！】Day10 - 眼見為憑！Observability 基礎之趴特佛&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;apm&quot; tabindex=&quot;-1&quot;&gt;APM&lt;/h2&gt;
&lt;p&gt;APM 的全名是 Application Performance Monitoring（應用程式效能監控），是用來回答下面兩個主要的問題：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;應用程式要花多久時間來答覆請求（request）？&lt;/li&gt;
&lt;li&gt;應用程式遇到什麼種類的錯誤？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Elastic APM 是由下列 4 個組件所構成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;APM Agents&lt;/li&gt;
&lt;li&gt;APM Server&lt;/li&gt;
&lt;li&gt;Elasticsearch&lt;/li&gt;
&lt;li&gt;Kibana&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/kyuDM8Q.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;apm-server&quot; tabindex=&quot;-1&quot;&gt;佈署APM server&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
apiVersion: apm.k8s.elastic.co/v1
kind: ApmServer
metadata:
  name: apm-server-quickstart
  namespace: default
spec:
  version: 7.15.0
  count: 1
  elasticsearchRef:
    name: quickstart
  kibanaRef:
    name: quickstart
  config:
    output:
      elasticsearch:
        host: [quickstart-es-http.default:9200]
        username: elastic
        password: &amp;quot;E1R10XXXXXXfr40&amp;quot;
        protocol: &amp;quot;http&amp;quot;
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊的password要直接下指令查詢，這個是前面登入kibana的密碼。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get secret quickstart-es-elastic-user -o=jsonpath=&#39;{.data.elastic}&#39; | base64 --decode; echo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;為了環境單純，所以只使用http，要用https請參考連結 &lt;a href=&quot;https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-apm-advanced-configuration.html#k8s-apm-existing-es&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Reference an existing Elasticsearch cluster&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://linyencheng.github.io/2020/09/12/elastic-apm-fundamentals/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elastic APM 基礎教學&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10235524&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ES新手，破門而入！】Day10 - 眼見為憑！Observability 基礎之趴特佛&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-apm-server.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Run APM Server on ECK&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;go-apm-agent&quot; tabindex=&quot;-1&quot;&gt;GO-APM agent&lt;/h2&gt;
&lt;p&gt;在建立 apm-server的時候，&lt;br /&gt;
會同時建立好 secret token ，這個同樣需要下指令取得，&lt;br /&gt;
之後在 agent上面設定完，才能將資料傳到 APM server上面。&lt;/p&gt;
&lt;p&gt;這邊取config  name為 ( [apm name]apm-token )&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  kubectl get secret apm-server-quickstart-apm-token -o=jsonpath=&#39;{.data.secret-token}&#39; | base64 --decode; echo
  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;設定APM server環境變數，由於我的服務都是docker image，&lt;br /&gt;
所以要把變數寫在Dockerfile裡面，當打包時，一併設定好&lt;a href=&quot;https://www.elastic.co/guide/en/apm/agent/go/current/configuration.html#config-server-url&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;環境變數&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
...
ENV ELASTIC_APM_SERVER_URL=https://apm-server-quickstart-apm-http.default:8200
ENV ELASTIC_APM_SERVICE_NAME=webhook
ENV ELASTIC_APM_SECRET_TOKEN=9m9XXXXXXGjwdIk41
ENV ELASTIC_APM_VERIFY_SERVER_CERT=false
ENV ELASTIC_APM_ENVIRONMENT=qa
...

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後再 main.go ，加上下面幾行。&lt;br /&gt;
這份go的程式，本身使用了 &lt;a href=&quot;https://www.elastic.co/guide/en/apm/agent/go/current/builtin-modules.html#builtin-modules-apmgorilla&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gorilla/mux&lt;/a&gt;的web框架&lt;/p&gt;
&lt;p&gt;所以照官方文件的說明，加上下面幾行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import (
	&amp;quot;github.com/gorilla/mux&amp;quot;

	&amp;quot;go.elastic.co/apm/module/apmgorilla&amp;quot;
)

func main() {
	router := mux.NewRouter()
	apmgorilla.Instrument(router)
	http.ListenAndServe(&amp;quot;:80&amp;quot;, router)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要只有  apmgorilla.Instrument(router) 這行，&lt;br /&gt;
然後只要有經過80 port的資料就通通都會進入到APM裡面了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/43-fig.3.jpg&quot; alt=&quot;43-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;這張圖裡面的TPS意思，可參考 &lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.github.io/404&quot;&gt;blog.45.網站效能指標一覽（未）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://www.elastic.co/guide/en/cloud-on-k8s/master/k8s-apm-connecting.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;APM Server secret token&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.elastic.co/cn/blog/how-to-instrument-your-go-app-with-the-elastic-apm-go-agent&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;如何使用 Elastic APM Go 代理為 Go 應用裝載測量工具&lt;/a&gt;&lt;br /&gt;
[&lt;a href=&quot;https://myapollo.com.tw/zh-tw/docker-env/&quot; title=&quot;Docker 環境變數使用筆記&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Docker 環境變數使用筆記&lt;/a&gt;](&lt;a href=&quot;https://myapollo.com.tw/zh-tw/docker-env/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://myapollo.com.tw/zh-tw/docker-env/&lt;/a&gt;)&lt;br /&gt;
&lt;a href=&quot;https://www.gushiciku.cn/pl/pYOg/zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elastic APM-Go Agent介紹(中文翻譯)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.elastic.co/guide/en/cloud-on-k8s/master/k8s-apm-connecting.html#k8s-apm-secret-token&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;connect to the APM Server&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/UbuntuTouch/article/details/105527468&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Solutions：安全的APM服務器訪問&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;vue-apm-agent&quot; tabindex=&quot;-1&quot;&gt;vue-APM agent&lt;/h2&gt;
&lt;p&gt;安裝依賴套件&lt;/p&gt;
&lt;h2 id=&quot;kibana&quot; tabindex=&quot;-1&quot;&gt;Kibana&lt;/h2&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/61.%20kibana%20%E6%9F%A5%E8%A9%A2%E8%AA%9E%E6%B3%95/&quot;&gt;61. kibana 查詢語法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/7.15/kuery-query.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kibana Query Language&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🗒 EFK/43.自建ECK on GKE/" />
        </entry>
        <entry>
            <title>
                187. ECK的filebeat
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗒 EFK/187. ECK的filebeat/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;一般filebeat，我之前都是做成daemonset，&lt;br /&gt;
直接抓標準輸出，傳去elasticserach裏面。&lt;br /&gt;
但目前，他們還是習慣寫文字檔到特定目錄，&lt;br /&gt;
filebeat再去那個目錄抓資料寫入，&lt;br /&gt;
所以變成也要掛載一個readwritemany的nfs。&lt;br /&gt;
那邊設定我還有點困惑，還需要測試。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;Elasticsearch 8.* 版本後，都要求加密憑證，&lt;br /&gt;
所以要用http傳很麻煩，&lt;br /&gt;
可能還要限定版本，最後我也放棄了。&lt;/p&gt;
&lt;p&gt;使用ECK的好處是不用特別設定ca，&lt;br /&gt;
但filebeat這邊的設定就要指定kibana跟elasticsearch了&lt;br /&gt;
但在不同的ns，故需特別指定ns。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: beat.k8s.elastic.co/v1beta1
kind: Beat
metadata:
  name: filebeat
spec:
  type: filebeat
  version: 8.11.0
  elasticsearchRef:
    name: fixed
    namespace: elastic-system
  kibanaRef:
    name: fixed
    namespace: elastic-system
  config:
    filebeat.inputs:
      &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#websocketclient&quot;&gt;#websocketclient&lt;/a&gt;
      - type: log
        ignore_older: 24h
        enabled: true
        paths:
          - /var/log/app-logs/websocketclient/*.log
        json.keys_under_root: true
        json.add_error_key: true
        fields_under_root: true
        tags: [&amp;quot;prod-sms-back-websocketclient&amp;quot;]
      &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#filebeat_self&quot;&gt;#filebeat_self&lt;/a&gt;
      - type: log
        ignore_older: 24h
        enabled: true
        paths:
          - /var/log/filebeat/*.ndjson
        json.keys_under_root: true
        json.add_error_key: true
        fields_under_root: true
        tags: [&amp;quot;filebeat_self&amp;quot;]
    processors:
      - timestamp:
          field: LoggingTime
          layouts:
            - &#39;2006-01-02T15:04:05Z&#39;
            - &#39;2006-01-02T15:04:05.999Z&#39;
            - &#39;2006-01-02T15:04:05.999-07:00&#39;
          test:
            - &#39;2019-06-22T16:33:51Z&#39;
            - &#39;2019-11-18T04:59:51.123Z&#39;
            - &#39;2020-08-03T07:10:20.123456+02:00&#39;
      - add_locale:
          format: offset
      - drop_fields:
          fields: [&amp;quot;agent&amp;quot;, &amp;quot;input&amp;quot;, &amp;quot;host&amp;quot;, &amp;quot;log&amp;quot;, &amp;quot;ecs&amp;quot;, &amp;quot;data_stream&amp;quot;, &amp;quot;event.timezone&amp;quot;, &amp;quot;LoggingTime&amp;quot;]
    output.elasticsearch:
      username: &amp;quot;elastic&amp;quot;
      password: &amp;quot;abc&amp;quot;      
      indices:
      &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#websocketclient&quot;&gt;#websocketclient&lt;/a&gt;
      - index: &amp;quot;prod-sms-back-websocketclient-%{+yyyy.MM.dd}&amp;quot;
        when.contains:
            tags: &amp;quot;prod-sms-back-websocketclient&amp;quot;
      &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#filebeat_self&quot;&gt;#filebeat_self&lt;/a&gt;
      - index: &amp;quot;filebeat_self-%{+yyyy.MM.dd}&amp;quot;
        when.contains:
          tags: &amp;quot;filebeat_self&amp;quot;
    logging:
      metrics.enabled: false
      level: info
      to_files: true
      files:
        path: /var/log/filebeat
        name: filebeat
        keepfiles: 7
        permissions: 0644          
  deployment:
    podTemplate:
      spec:
        automountServiceAccountToken: true
        terminationGracePeriodSeconds: 30
        dnsPolicy: ClusterFirstWithHostNet
        hostNetwork: true # Allows to provide richer host metadata
        containers:
        - name: filebeat
          securityContext:
            runAsUser: 0
            # If using Red Hat OpenShift uncomment this:
            &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#privileged&quot;&gt;#privileged&lt;/a&gt;: true
          volumeMounts:
          - name: applog
            mountPath: /var/log/app-logs            
        volumes:
        - name: applog
          persistentVolumeClaim:
            claimName: logs-nfs-test-pvc 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;備註一下，完整ECK安裝的yaml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# 1. setup eck operator and crd
# kubectl create -f https://download.elastic.co/downloads/eck/2.10.0/crds.yaml
# kubectl apply -f https://download.elastic.co/downloads/eck/2.10.0/operator.yaml


apiVersion: elasticsearch.k8s.elastic.co/v1
kind: Elasticsearch
metadata:
  name: fixed
  # name: yabo
  namespace: elastic-system
spec:  
  version: 8.11.0
  nodeSets:
  - name: all
    count: 1
    podTemplate:      
      spec:  
        containers:
        - name: elasticsearch
          env:
          - name: ES_JAVA_OPTS
            value: -Xms2g -Xmx2g
          resources:
            requests:
              memory: 4Gi
            limits:
              memory: 4Gi  
    config:
      node.roles:
          - master
          - data
          - ingest
      node.attr.attr_name: attr_value
      node.store.allow_mmap: false   
    volumeClaimTemplates:
    - metadata:
        name: elasticsearch-data # Do not change this name unless you set up a volume mount for the data path.
      spec:
        accessModes:
        - ReadWriteOnce
        resources:
          requests:
            storage: 100Gi
        storageClassName: standard        
# 儲存空間需要加大，預設只有1G 不夠

---

apiVersion: kibana.k8s.elastic.co/v1
kind: Kibana
metadata:
  name: fixed
  namespace: elastic-system
spec:
  version: 8.11.0
  count: 1
  elasticsearchRef:
    name: fixed    
  http:
    tls:
      selfSignedCertificate:
        disabled: true
    service:
      spec:
        ports:
          - name: http
            port: 5601
            targetPort: 5601        

---

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.cnblogs.com/jatq/articles/14651723.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ECK部署&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🗒 EFK/187. ECK的filebeat/" />
        </entry>
        <entry>
            <title>
                111. filebeat error
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗒 EFK/111. filebeat error/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;禮拜一上班就聽同事再說，filebeat stage環境有問題，&lt;br /&gt;
我還在禮拜一症候群阿~~&lt;br /&gt;
哎～SRE的宿命，先修吧&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;一開始的問題很簡單，就output service設定錯誤，&lt;br /&gt;
無法連線。&lt;/p&gt;
&lt;p&gt;改完後，換另一個錯誤。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Validation Failed: 1: this action would add [2] total shards, but this cluster currently has [1000]/[1000] maximum shards open&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%92%20EFK/111.fig-1.jpg&quot; alt=&quot;111.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;google一下，就看到&lt;a href=&quot;https://shazi.info/elasticsearch-7-x-node-%E9%96%8B%E6%94%BE-1000-%E5%80%8B-shards-%E9%99%90%E5%88%B6/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Elasticsearch 7.x node 開放 1000 個 shards 限制&lt;/a&gt;了。&lt;br /&gt;
上面連結是用curl 打網址直接改，下面是到dev Tools下指令，&lt;br /&gt;
所以有點不一樣。&lt;br /&gt;
到kibana上的dev tools加上這段，把1000的上限拉大。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PUT _cluster/settings
{
  &amp;quot;persistent&amp;quot;: { 
    &amp;quot;cluster.max_shards_per_node&amp;quot;: &amp;quot;3000&amp;quot; 
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-update-settings.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;cluster-update-settings&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;non-zero-metrics-in-the-last-30s&quot; tabindex=&quot;-1&quot;&gt;Non-zero metrics in the last 30s&lt;/h3&gt;
&lt;p&gt;看filebeat裏面的訊息，一直出現這串。&lt;br /&gt;
關掉吧。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# If enabled, filebeat periodically logs its internal metrics that have changed
# in the last period. For each metric that changed, the delta from the value at
# the beginning of the period is logged. Also, the total values for
# all non-zero internal metrics are logged on shutdown. The default is true.
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#logging&quot;&gt;#logging&lt;/a&gt;.metrics.enabled: true

# The period after which to log the internal metrics. The default is 30s.
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#logging&quot;&gt;#logging&lt;/a&gt;.metrics.period: 30s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但在filebeat yaml中，是這樣的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;logging:
  metrics.enabled: false
  level: info
  to_files: true
  files:
    path: /var/log/filebeat
    name: filebeat
    keepfiles: 7
    permissions: 0644   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.  &lt;a href=&quot;https://discuss.elastic.co/t/non-zero-metrics-in-the-last-30s-meaning/173970&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Non-zero metrics in the last 30s: meaning&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🗒 EFK/111. filebeat error/" />
        </entry>
        <entry>
            <title>
                0.EFK MOC
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗒 EFK/0.EFK MOC/</id>
            <content type="html">
                &lt;h1 id=&quot;概念&quot; tabindex=&quot;-1&quot;&gt;概念&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/55.%20es%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E7%AF%87/&quot;&gt;55. es基本概念篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.github.io/404&quot;&gt;81. Beat vs elastic agent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.github.io/404&quot;&gt;83. Elasticsearch 權威指南 修正&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/84.Elasticsearch%E7%AD%86%E8%A8%98/&quot;&gt;84.Elasticsearch筆記&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;建置&quot; tabindex=&quot;-1&quot;&gt;建置&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/43.%E8%87%AA%E5%BB%BAECK%20on%20GKE/&quot;&gt;43.自建ECK on GKE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;設定&quot; tabindex=&quot;-1&quot;&gt;設定&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/54.%20istio%20%E6%8E%9B%E8%BC%89ECK%20kibana/&quot;&gt;54. istio 掛載ECK kibana&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/52.%20ILM%20%E8%A8%AD%E5%AE%9A/&quot;&gt;52. ILM 設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/57.filebeat%20%E8%A3%9C%E5%85%85%E8%AA%AA%E6%98%8E/&quot;&gt;57.filebeat 補充說明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/80.%20ECK%208.1%20,APM%20intergration%E5%AE%89%E8%A3%9D%E6%96%B9%E5%BC%8F/&quot;&gt;80. ECK 8.1 ,APM intergration安裝方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/90.%20elasticsearch%20ingest%20pipeline/&quot;&gt;90. elasticsearch ingest pipeline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/91.%20elasticsearch%20ingest%20processor%E8%A3%9C%E5%85%85/&quot;&gt;91. elasticsearch ingest processor補充&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;usage&quot; tabindex=&quot;-1&quot;&gt;Usage&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/68.ECK%20,%20api%E7%AD%86%E8%A8%98/&quot;&gt;68.ECK , api筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/61.%20kibana%20%E6%9F%A5%E8%A9%A2%E8%AA%9E%E6%B3%95/&quot;&gt;Kibana一般使用者查詢語法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.github.io/404&quot;&gt;86. efk apm圖表&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/53.%20apm%20error/&quot;&gt;53. apm error&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/60.%20ECK%E7%9A%84%20kibana%20%E8%AD%A6%E5%91%8A%EF%BC%8C%20server.publicBaseUrl%20is%20missing/&quot;&gt;60. ECK的 kibana 警告， server.publicBaseUrl is missing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/67.%20ECK%EF%BC%8Cfilebeat%20LOG%E8%92%90%E9%9B%86%E9%81%BA%E5%A4%B1/&quot;&gt;67. ECK，filebeat LOG蒐集遺失&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/69.%20kibana%E9%8C%AF%E8%AA%A4%E8%A7%A3%E6%B3%95%20,%20parent%20Data%20too%20large.../&quot;&gt;69. kibana錯誤解法 , parent Data too large...&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/111.%20filebeat%20error/&quot;&gt;111. filebeat error&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🗒 EFK/0.EFK MOC/" />
        </entry>
        <entry>
            <title>
                188. CloudSQL server 查詢記憶體
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗄 Database/188. CloudSQL server 查詢記憶體/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;週五碰到sql server的記憶體飆漲到90%，&lt;br /&gt;
找後端看了一下，看不出個所以然。&lt;br /&gt;
很不幸的，禮拜六又衝到95%，&lt;br /&gt;
只好緊急維護重開了，&lt;br /&gt;
禮拜一開始找問題。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;實際上要把記憶體操到100%，還真的很難。&lt;br /&gt;
試了好幾天，最多只能到97%。&lt;/p&gt;
&lt;p&gt;然後服務都沒什麼症狀，&lt;br /&gt;
讓我們開始想，是不是cloudSQL真的強，&lt;br /&gt;
這要操下去都沒事。&lt;/p&gt;
&lt;p&gt;再來查到cloudSQL的一篇文章，&lt;/p&gt;
&lt;p&gt;CloudSQL的記憶體分成下面幾種&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sql/docs/sqlserver/optimize-high-memory-usage#cache&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Caches  快取&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sql/docs/sqlserver/optimize-high-memory-usage#fixed-memory&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Fixed memory  固定記憶體&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sql/docs/sqlserver/optimize-high-memory-usage#sql-server-overhead&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SQL Server overhead  SQL Server 開銷&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sql/docs/sqlserver/optimize-high-memory-usage#oltp&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;In-Memory online transactional processing (OLTP)&lt;br /&gt;
記憶體中線上事務處理 (OLTP)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然後，我們得知可以更改 &lt;code&gt;max server memory&lt;/code&gt;，&lt;br /&gt;
強迫SQL不要使用那麼多的記憶體。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%84%20Database/188-fig.1.jpg&quot; alt=&quot;188-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然後，再照之前的壓測方式打下去，暴了。&lt;br /&gt;
確定會影響服務。&lt;/p&gt;
&lt;p&gt;再針對 &lt;code&gt;max server memory&lt;/code&gt; ，增加容量測試，&lt;br /&gt;
我們得到下面的結論。&lt;/p&gt;
&lt;p&gt;當 &lt;code&gt;Page life expectancy&lt;/code&gt; 這個值只要&amp;lt;300，&lt;br /&gt;
就有可能造成服務的延遲。&lt;br /&gt;
當掉的當下，這個值都是處於0。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Page life expectancy&lt;/code&gt; 表示最舊的頁面在緩衝池中停留的時間（以秒為單位），微軟建議這個值再300以上。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT   [object_name],  [counter_name],  [cntr_value] FROM   sys.dm_os_performance_countersWHERE   [object_name] LIKE   &#39;%Manager%&#39;AND   [counter_name] = &#39;Page life expectancy&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我們可以同時看一下有沒有SQL處於pending狀態。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT  @@SERVERNAME AS [Server Name],  RTRIM([object_name]) AS [Object Name],  cntr_value AS [Memory Grants Pending]FROM   sys.dm_os_performance_counters WITH(NOLOCK)WHERE  [object_name] LIKE   N&#39;%Memory Manager%&#39;  -- Handles named instancesAND   counter_name = N&#39;Memory Grants Pending&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;當這個值&amp;gt;0時，表示sql服務已經面臨崩潰邊緣，&lt;br /&gt;
該準備重啓資料庫了。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/sql/docs/sqlserver/optimize-high-memory-usage&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Optimize high memory consumption in instances&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🗄 Database/188. CloudSQL server 查詢記憶體/" />
        </entry>
        <entry>
            <title>
                166. MSSQL 2017版本差異
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗄 Database/166. MSSQL 2017版本差異/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;今天在查linux的MSSQL是什麼版本，才發現預設是開發版。&lt;br /&gt;
又延伸一個問題，開發板的上限到哪？&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;因為微軟的網站，連結常死掉，就先節錄過來了，&lt;br /&gt;
在linux上面安裝的是Developer開發者版本，&lt;br /&gt;
功能跟Enterprise一致。&lt;/p&gt;
&lt;h3 id=&quot;差異&quot; tabindex=&quot;-1&quot;&gt;差異&lt;/h3&gt;
&lt;p&gt;指列出資源使用的比較，其他細部功能，請參考下面網址&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;Enterprise&lt;/th&gt;
&lt;th&gt;標準&lt;/th&gt;
&lt;th&gt;Web&lt;/th&gt;
&lt;th&gt;Express&lt;/th&gt;
&lt;th&gt;快速&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;單一執行個體所使用的計算容量上限 - SQL Server 資料庫引擎1&lt;/td&gt;
&lt;td&gt;作業系統最大值&lt;/td&gt;
&lt;td&gt;限制為 4 個插槽或 24 個核心的較小者&lt;/td&gt;
&lt;td&gt;限制為 4 個插槽或 16 個核心的較小者&lt;/td&gt;
&lt;td&gt;限制為 1 個插槽或 4 個核心的較小者&lt;/td&gt;
&lt;td&gt;限制為 1 個插槽或 4 個核心的較小者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;單一執行個體所使用的計算容量上限 - Analysis Services 或 Reporting Services&lt;/td&gt;
&lt;td&gt;作業系統最大值&lt;/td&gt;
&lt;td&gt;限制為 4 個插槽或 24 個核心的較小者&lt;/td&gt;
&lt;td&gt;限制為 4 個插槽或 16 個核心的較小者&lt;/td&gt;
&lt;td&gt;限制為 1 個插槽或 4 個核心的較小者&lt;/td&gt;
&lt;td&gt;限制為 1 個插槽或 4 個核心的較小者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每個 SQL Server 資料庫引擎執行個體的緩衝集區記憶體上限&lt;/td&gt;
&lt;td&gt;作業系統最大值&lt;/td&gt;
&lt;td&gt;128 GB&lt;/td&gt;
&lt;td&gt;64 GB&lt;/td&gt;
&lt;td&gt;1410 MB&lt;/td&gt;
&lt;td&gt;1410 MB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每個 SQL Server 資料庫引擎執行個體的緩衝集區延伸容量上限&lt;/td&gt;
&lt;td&gt;32 * (最大伺服器記憶體設定)&lt;/td&gt;
&lt;td&gt;4 * (最大伺服器記憶體設定)&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每個 SQL Server 資料庫引擎執行個體的資料行存放區區段快取的記憶體上限&lt;/td&gt;
&lt;td&gt;無限制的記憶體&lt;/td&gt;
&lt;td&gt;32 GB&lt;/td&gt;
&lt;td&gt;16 GB&lt;/td&gt;
&lt;td&gt;352 MB&lt;/td&gt;
&lt;td&gt;352 MB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SQL Server 資料庫引擎中每個資料庫的記憶體最佳化資料大小上限&lt;/td&gt;
&lt;td&gt;無限制的記憶體&lt;/td&gt;
&lt;td&gt;32 GB&lt;/td&gt;
&lt;td&gt;16 GB&lt;/td&gt;
&lt;td&gt;352 MB&lt;/td&gt;
&lt;td&gt;352 MB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每個 Analysis Services 執行個體使用的記憶體上限&lt;/td&gt;
&lt;td&gt;作業系統最大值&lt;/td&gt;
&lt;td&gt;表格式：16 GB MOLAP：64 GB&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;每個 Reporting Services 執行個體使用的記憶體上限&lt;/td&gt;
&lt;td&gt;作業系統最大值&lt;/td&gt;
&lt;td&gt;64 GB&lt;/td&gt;
&lt;td&gt;64 GB&lt;/td&gt;
&lt;td&gt;4 GB&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;關聯式資料庫大小上限&lt;/td&gt;
&lt;td&gt;524 PB&lt;/td&gt;
&lt;td&gt;524 PB&lt;/td&gt;
&lt;td&gt;524 PB&lt;/td&gt;
&lt;td&gt;10 GB&lt;/td&gt;
&lt;td&gt;10 GB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;訂價&quot; tabindex=&quot;-1&quot;&gt;訂價&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;SQL Server 2017 版本&lt;/th&gt;
&lt;th&gt;適合...&lt;/th&gt;
&lt;th&gt;授權模型&lt;/th&gt;
&lt;th&gt;通路供應情況&lt;/th&gt;
&lt;th&gt;公開無級別價格 (美元)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Enterprise&lt;/td&gt;
&lt;td&gt;全方位的任務關鍵性效能，可滿足嚴苛的資料庫和商業智慧需求。提供最高級的服務和效能，足以應付第 1 層工作負載。[7]&lt;/td&gt;
&lt;td&gt;每個核心[8]&lt;/td&gt;
&lt;td&gt;大量授權、代管&lt;/td&gt;
&lt;td&gt;14,256 美元[9]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Standard - 每一核心&lt;/td&gt;
&lt;td&gt;核心資料管理和商業智慧功能，能以最少的 IT 資源來處理非關鍵的工作負載。&lt;/td&gt;
&lt;td&gt;每個核心[8]&lt;/td&gt;
&lt;td&gt;大量授權、代管&lt;/td&gt;
&lt;td&gt;3,717 美元[9]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Standard - 伺服器 + CAL&lt;/td&gt;
&lt;td&gt;核心資料管理和商業智慧功能，能以最少的 IT 資源來處理非關鍵的工作負載。&lt;/td&gt;
&lt;td&gt;伺服器 + CAL[10]&lt;/td&gt;
&lt;td&gt;大量授權、代管、零售 FPP&lt;/td&gt;
&lt;td&gt;931 美元[9]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Developer&lt;/td&gt;
&lt;td&gt;具有完整功能的 SQL Server 軟體版本，可讓開發人員以符合成本效益的方式建置、測試和展示以 SQL Server 軟體為基礎的應用程式。&lt;/td&gt;
&lt;td&gt;每個使用者&lt;/td&gt;
&lt;td&gt;免費下載&lt;/td&gt;
&lt;td&gt;免費&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Web&lt;/td&gt;
&lt;td&gt;安全、符合成本效益且可高度調整的資料平台，可用來打造公用網站。僅供第三方軟體服務提供者使用。&lt;/td&gt;
&lt;td&gt;不適用&lt;/td&gt;
&lt;td&gt;僅提供代管&lt;/td&gt;
&lt;td&gt;請參閱代管合作夥伴的定價&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Express&lt;/td&gt;
&lt;td&gt;免費的入門級的資料庫，非常適合用來學習和建置最多 10 GB 的桌面與小型伺服器資料驅動應用程式。&lt;/td&gt;
&lt;td&gt;不適用&lt;/td&gt;
&lt;td&gt;免費下載&lt;/td&gt;
&lt;td&gt;免費&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://www.microsoft.com/zh-tw/sql-server/sql-server-2017?rtc=1&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SQLServer 2017&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://learn.microsoft.com/zh-TW/sql/sql-server/editions-and-components-of-sql-server-2017?view=sql-server-ver16#Cross-BoxScaleLimits&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SQL Server 2017 的版本及支援功能&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🗄 Database/166. MSSQL 2017版本差異/" />
        </entry>
        <entry>
            <title>
                153. CloudSQL MSSQL減少資料庫大小
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗄 Database/153. CloudSQL MSSQL減少資料庫大小/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;也不知道我怎麼也兼DBA了，有種MIS的感覺，啥都管。&lt;br /&gt;
如果資料量太多，刪除資料後，是不會把空間釋放的，&lt;br /&gt;
需要對資料庫做壓縮，容量才會還出來。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;順便說一下查容量的步驟&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查資料庫的容量&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT DB_NAME(database_id) N&#39;資料庫&#39;, physical_name N&#39;實體檔案&#39;, type_desc N&#39;檔案類型&#39;, state_desc N&#39;檔案狀態&#39;, size*8.0/1024 N&#39;檔案大小(MB)&#39;
FROM sys.master_files
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;查詢資料表大小&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT 
    t.NAME AS TableName,
    s.Name AS SchemaName,
    p.rows,
    SUM(a.total_pages) * 8 AS TotalSpaceKB, 
    CAST(ROUND(((SUM(a.total_pages) * 8) / 1024.00), 2) AS NUMERIC(36, 2)) AS TotalSpaceMB,
    SUM(a.used_pages) * 8 AS UsedSpaceKB, 
    CAST(ROUND(((SUM(a.used_pages) * 8) / 1024.00), 2) AS NUMERIC(36, 2)) AS UsedSpaceMB, 
    (SUM(a.total_pages) - SUM(a.used_pages)) * 8 AS UnusedSpaceKB,
    CAST(ROUND(((SUM(a.total_pages) - SUM(a.used_pages)) * 8) / 1024.00, 2) AS NUMERIC(36, 2)) AS UnusedSpaceMB
FROM 
    sys.tables t
INNER JOIN
    sys.indexes i ON t.OBJECT_ID = i.object_id
INNER JOIN 
    sys.partitions p ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id
INNER JOIN 
    sys.allocation_units a ON p.partition_id = a.container_id
LEFT OUTER JOIN 
    sys.schemas s ON t.schema_id = s.schema_id
WHERE 
    t.NAME NOT LIKE &#39;dt%&#39; 
    AND t.is_ms_shipped = 0
    AND i.OBJECT_ID &amp;gt; 255 
GROUP BY 
    t.Name, s.Name, p.Rows
ORDER BY 
    TotalSpaceMB DESC, t.Name
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;刪除完後，可以先做交易記錄檔壓縮&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;ALTER DATABASE DB_name SET RECOVERY simple
use DB_name
go
dbcc shrinkfile(&#39;DB_name_log&#39;,2)

ALTER DATABASE table_name SET RECOVERY FULL
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;壓縮DB，將空間釋放，可以用指令，也可以直接用SSMS操作&lt;br /&gt;
指令，可以跟step 3 一起動作&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;1.  DBCC SHRINKDATABASE(N&#39;DB_name&#39; )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或是直接照圖操作&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%84%20Database/153-fig.1.jpg&quot; alt=&quot;153-fig.1.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%97%84%20Database/153-fig.2.jpg&quot; alt=&quot;153-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ithelp.ithome.com.tw/questions/10209350&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SQL SERVER 壓縮資料庫後MDF沒變小&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hackmd.io/@ab-5tCCfRu2OkxqJptnkGg/BJFBvHD2w&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;MsSql 壓縮資料庫(含修復資料庫)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dotblogs.com.tw/jamesfu/2014/02/23/compression&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[SQL]斯斯有三種，SQL Server 上資料庫的「壓縮」也有三種喔 !&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/zh-tw/sql/t-sql/database-console-commands/dbcc-shrinkdatabase-transact-sql?view=sql-server-ver16&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;DBCC SHRINKDATABASE (Transact-SQL)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hackmd.io/@Not/H1YBRk6qw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;清除SQL Server Log檔 (交易紀錄)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dotblogs.com.tw/jamesfu/2015/05/16/deleterecords&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;解決大量資料刪除，造成資料庫交易紀錄檔案容量過大且耗費時間之處理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🗄 Database/153. CloudSQL MSSQL減少資料庫大小/" />
        </entry>
        <entry>
            <title>
                150. mysql備份還原指令
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗄 Database/150. mysql備份還原指令/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;h2 id=&quot;lets-encript-br-server&quot; tabindex=&quot;-1&quot;&gt;調整自動取得letsEncript的架構，&lt;br /&gt;
所以就獨立開了一個server，要把服務移過去。&lt;/h2&gt;
&lt;p&gt;然後才發現，我的上一任是個很成熟的工程師，最愛造輪子&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;以下都是由docker建立，也有其他方式可以做。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;備份全部db的指令&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;docker exec percona sh -c &amp;quot;mysqldump -u root -p&amp;lt;password&amp;gt; -A --opt&amp;quot; &amp;gt; backup.sql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;當然，也可以選擇進入到container裏面，執行指令，再用docker cp的方式把檔案拉出來。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;還原DB的指令&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;docker exec -i mysql sh -c &amp;quot;mysql -u root -p&amp;lt;password&amp;gt;&amp;quot; &amp;lt; backup.sql  
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;連線至mysql&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;mysql -uroot -p&amp;lt;password&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;顯示全部DB&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;show databases;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;顯示全部table&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;show tables;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;建立使用者&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;CREATE USER &#39;totp-auth&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊注意，如果使用者是從非本地連過來資料庫的話，不要使用localhost。我忘了這點。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改使用者&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;RENAME USER &#39;totp-auth&#39;@&#39;localhost&#39; TO &#39;totp-auth&#39;@&#39;%&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;承接上一段語法，如果已經新增的話，用此方式修改。&lt;br /&gt;
%為任意ip，或者可以改成192.168.1.% 諸如此類的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;授予使用者DB權限&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;GRANT ALL PRIVILEGES ON db.* TO &#39;totp-auth&#39;@&#39;localhost&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://hub.docker.com/_/percona&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;percona(dockerhub)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.vixual.net/blog/archives/53&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[MySQL]資料庫的備份與還原&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ltsplus.com/mysql/mysql-add-new-users-databases-privileges&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;MySQL 新增使用者及建立資料庫權限&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://serverfault.com/questions/329795/mysql-users-changed-their-ip-address-whats-the-best-way-to-deal-with-this&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;MySQL users changed their IP address. What&#39;s the best way to deal with this?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://klab.tw/2022/08/daily-automatic-backup-of-mysql-mariadb-and-mongodb-in-docker/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;每天定時自動備份Docker內的MySQL、MariaDB與MongoDB，Linux、macOS與Windows都可用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🗄 Database/150. mysql備份還原指令/" />
        </entry>
        <entry>
            <title>
                0.Database MOC
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🗄 Database/0.Database MOC/</id>
            <content type="html">
                &lt;h1 id=&quot;my-sql&quot; tabindex=&quot;-1&quot;&gt;MySQL&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%84%20Database/150.%20mysql%E5%82%99%E4%BB%BD%E9%82%84%E5%8E%9F%E6%8C%87%E4%BB%A4/&quot;&gt;150. mysql備份還原指令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;mssql&quot; tabindex=&quot;-1&quot;&gt;MSSQL&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%84%20Database/153.%20CloudSQL%20MSSQL%E6%B8%9B%E5%B0%91%E8%B3%87%E6%96%99%E5%BA%AB%E5%A4%A7%E5%B0%8F/&quot;&gt;153. CloudSQL MSSQL減少資料庫大小&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/120.%20%E6%8C%87%E4%BB%A4%E5%82%99%E4%BB%BDcloudSQL%E5%8F%8A%E4%B8%8B%E8%BC%89/&quot;&gt;120. 指令備份cloudSQL及下載&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%84%20Database/188.%20CloudSQL%20server%20%E6%9F%A5%E8%A9%A2%E8%A8%98%E6%86%B6%E9%AB%94/&quot;&gt;188. CloudSQL server 查詢記憶體&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🗄 Database/0.Database MOC/" />
        </entry>
        <entry>
            <title>
                174. win10 下載Microsoft Store的檔案
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🖼 Window/174. win10 下載Microsoft Store的檔案/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡唸&quot; tabindex=&quot;-1&quot;&gt;睡睡唸&lt;/h1&gt;
&lt;p&gt;看到XDM有新版的，因爲舊版只要下載有中文字的檔案，&lt;br /&gt;
檔案名稱就是亂碼，但是新版又只能從微軟商店下載...&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;找到網址&lt;br /&gt;
首先你要知道你要的程式的微軟官方商店網址。&lt;br /&gt;
直接用google搜尋即可。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%96%BC%20Window/174-fig.1.jpg&quot; alt=&quot;174-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到&lt;a href=&quot;https://store.rg-adguard.net/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;網站&lt;/a&gt; ，貼上你的網址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;選擇副檔名為 『appxbundle』 下載&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%96%BC%20Window/174-fig.2.jpg&quot; alt=&quot;174-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://adersaytech.com/tutorial/kb-article/download-ms-store-offline-package.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Win10/Win11 如何下載 Microsoft Store 離線安裝檔？&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🖼 Window/174. win10 下載Microsoft Store的檔案/" />
        </entry>
        <entry>
            <title>
                113. 微軟官方office 大量授權
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🖼 Window/113. 微軟官方office 大量授權/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;YT亂看的時候，看到有一個影片，再講如何獲取免費的office，&lt;br /&gt;
這其實不是新聞，但有問題的通常都是再破解上面，&lt;br /&gt;
可能被人惡意亂塞間諜程式或木馬。&lt;br /&gt;
但現在驗證直接從官方來了&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;微軟官方SN：&lt;br /&gt;
&lt;a href=&quot;https://learn.microsoft.com/zh-tw/DeployOffice/vlactivation/gvlks&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;以 KMS 和 Active Directory 為基礎的 Office、Project 和 Visio 啟用 GVLK&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不想看圖片的，請直接看影片&lt;br /&gt;
&lt;a href=&quot;https://www.youtube.com/watch?v=VSjRx7Hoa60&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;如何免費獲取Office軟件？這是最強的安裝教學！ | 零度解說&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面快速說明過程，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先到 微軟官方下載 &lt;a href=&quot;https://www.microsoft.com/en-us/download/details.aspx?id=49117&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Office Deployment Tool&lt;/a&gt;，然後安裝到新的資料夾，這邊指定安裝到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; D:&#92;office  
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然後開啓 &lt;a href=&quot;https://config.office.com/deploymentsettings&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;office 自訂工具&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;選擇你要的產品、項目&lt;br /&gt;
（附註，LTSC代表的是Long Time Service Channel，長期服務通道)&lt;br /&gt;
產品版本：自行挑選&lt;br /&gt;
語言：繁體中文&lt;br /&gt;
授權與啓用：確認是KMS&lt;br /&gt;
其他預設即可。&lt;br /&gt;
好了後，按右上匯出，然後存到剛剛 1. 的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;D:&#92;office 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%B3%20Container/blog.113-fig.1.jpg&quot; alt=&quot;blog.113-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以最高權限開啓命令提示字元，切換目錄到 剛剛下載的位置，然後下載office，下載完後安裝。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd D:&#92;office 
setup /download config.xml
setup /configure config.xml
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝完成後應該就會啓動了，如果沒有啓動，到剛剛office安裝的位置，通常在 下面位置，版本不同，後面的數字也會不同。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:&#92;Program Files&#92;Microsoft Office&#92;Office16
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以最高權限開啓命令提示字元，切換目錄到 5. 的位置，然後依序執行指令，完成後『重開電腦』。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;cd C:&#92;Program Files&#92;Microsoft Office&#92;Office16
slmgr /skms kms.03k.org
slmgr /ato
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%B3%20Container/blog.113-fig.2.jpg&quot; alt=&quot;blog.113-fig.2.jpg&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🖼 Window/113. 微軟官方office 大量授權/" />
        </entry>
        <entry>
            <title>
                47. GO get 參數
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/💻 Code/Golang/47. GO get 參數/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;參數&lt;/p&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;p&gt;-d&lt;/p&gt;
&lt;p&gt;執行下載，但不執行安裝動作。&lt;/p&gt;
&lt;p&gt;-f&lt;/p&gt;
&lt;p&gt;只有在使用 -u 參數時，才會有效。可以忽略檢查以下載 package 的導入路徑。如果代碼是從其他項目 fork ，就可以採取這樣的做法。&lt;/p&gt;
&lt;p&gt;-fix&lt;/p&gt;
&lt;p&gt;下載 package 先執行修正在進行編譯安裝。&lt;/p&gt;
&lt;p&gt;-insecure&lt;/p&gt;
&lt;p&gt;允許使用 http (非安全) 來下載 package，通常是在內部開發環境使用。&lt;/p&gt;
&lt;p&gt;-t&lt;/p&gt;
&lt;p&gt;下載 package ，在安裝過程同時下載安裝相關依賴代碼包。&lt;/p&gt;
&lt;p&gt;-u&lt;/p&gt;
&lt;p&gt;強制更新已經下載的 package 以及依賴代碼包。（go get 預設指會不會更新已經下載的package)&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://hoohoo.top/blog/go-module-and-go-get-common-parameter-descriptions/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GO MODULE與 GO GET 常用參數說明&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/💻 Code/Golang/47. GO get 參數/" />
        </entry>
        <entry>
            <title>
                40. golang 重新讀取設定檔的方法
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/💻 Code/Golang/40. golang 重新讀取設定檔的方法/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;因為碰到一個奇怪的問題，需要一直去改golang的config檔，&lt;/p&gt;
&lt;p&gt;所以就再想了，能不能像以前的php或html，單純改config，重新整理就能抓到資料。&lt;/p&gt;
&lt;p&gt;結果.......&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;先說結論，直接修改config，然後強制關閉golang的process ，是行不通的。&lt;/p&gt;
&lt;p&gt;環境，golang   pod，執行程式的方式，&lt;br /&gt;
是先 打包成一個檔案，再放到alpine linux上面的pod直接執行。&lt;/p&gt;
&lt;h3 id=&quot;config&quot; tabindex=&quot;-1&quot;&gt;目標，不重新打包程式修改config&lt;/h3&gt;
&lt;p&gt;實驗的方法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先查詢是不是有golang的程式在執行&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	ps
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%92%BB%20Code/Golang/40-fig.1.jpg&quot; alt=&quot;40-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;由於此程式是直接抓同資料夾的config&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%92%BB%20Code/Golang/40-fig.2.jpg&quot; alt=&quot;40-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;悲劇得來了，修改完appsettings.json後，只要刪除/app/main ，就會直接跳出，pod自動重啟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	kill -s 26
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://blog.gtwang.org/linux/linux-kill-killall-xkill/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;在 Linux 中使用 kill、killall 與 xkill 等指令強迫關閉程式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後有幾個方案，golang有&lt;br /&gt;
&lt;a href=&quot;https://learnku.com/articles/33561&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;熱更新配置文件&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://studygolang.com/articles/5398&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Golang熱加載配置實踐&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不動程式的話，目前想到的是，直接重新打包，把config丟進去image裡面。&lt;/p&gt;
&lt;p&gt;來源的映像檔，直接改成本來的image，&lt;br /&gt;
然後copy 改完的appsetings.json到目的，&lt;br /&gt;
這樣程式不用重新編譯，但要重新打包image。&lt;br /&gt;
docker build&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM gcr.io/rproject/source:adminQA-0.0.27
ARG website
ARG location
ARG type
WORKDIR /app

COPY  appsettings.json /app/

EXPOSE 80
# 不更改權限會發生權限錯誤
RUN chmod +x /init.sh
RUN [&amp;quot;chmod&amp;quot;, &amp;quot;+x&amp;quot;, &amp;quot;/init.sh&amp;quot;]
ENTRYPOINT [&amp;quot;sh&amp;quot;,&amp;quot;-x&amp;quot;,&amp;quot;/init.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/💻 Code/Golang/40. golang 重新讀取設定檔的方法/" />
        </entry>
        <entry>
            <title>
                156. Golang簡略筆記（一）
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/💻 Code/Golang/156. Golang簡略筆記（一）/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;科技始終來自於人類的惰性，&lt;br /&gt;
入坑暗黑後，前些日子終於打到了世界三，&lt;br /&gt;
要打世界王，每次都要去網站看，好麻煩。&lt;br /&gt;
所以，先爬蟲，然後再設個30分鐘倒數計時通知該打王了。&lt;br /&gt;
scrapy+Golang&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%92%BB%20Code/Golang/156-fig.0.jpg&quot; alt=&quot;156-fig.0.jpg&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;github-a-href-https-github-com-daimom-d4countdowntimer-target-blank-class-external-link-d4countdowntimer-a&quot; tabindex=&quot;-1&quot;&gt;Github: &lt;a href=&quot;https://github.com/daimom/d4countdowntimer&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;d4countdowntimer&lt;/a&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;私有函數，開頭是小寫，只能在同一個檔案裏面使用，&lt;br /&gt;
公開函數，開頭要大寫，能給其他檔案使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ioutil 已在bo 1.16棄用，改用 io&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;ioutil.ReadAll -&amp;gt; io.ReadAll
ioutil.ReadFile -&amp;gt; os.ReadFile
ioutil.ReadDir -&amp;gt; os.ReadDir
// others
ioutil.NopCloser -&amp;gt; io.NopCloser
ioutil.TempDir -&amp;gt; os.MkdirTemp
ioutil.TempFile -&amp;gt; os.CreateTemp
ioutil.WriteFile -&amp;gt; os.WriteFile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://stackoverflow.com/questions/75206234/for-go-ioutil-readall-ioutil-readfile-ioutil-readdir-deprecated&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;for-go-ioutil-readall-ioutil-readfile-ioutil-readdir-deprecated&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轉換unix time&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;location, err := time.LoadLocation(&amp;quot;Asia/Taipei&amp;quot;)
if err != nil {
  panic(err)
}

unixtime, err := strconv.ParseInt(d4event[&amp;quot;unixtime&amp;quot;], 10, 64)
if err != nil {
  fmt.Println(&amp;quot;轉換失敗:&amp;quot;, err)
  return
}
t := time.Unix(unixtime, 0)
fmt.Println(t.In(location))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://stackoverflow.com/questions/43915900/how-to-convert-unix-time-to-time-time-in-golang&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;how-to-convert-unix-time-to-time-time-in-golang&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;import 後面加上 _&lt;br /&gt;
使用【import _&amp;quot;&lt;a href=&quot;http://github.com/gorilla/mux&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;github.com/gorilla/mux&lt;/a&gt;&amp;quot; 】只是引用該package，僅僅是為了呼叫init()函數，所以無法通過package名稱，來呼叫package裏面的其他函數&lt;br /&gt;
re. &lt;a href=&quot;https://blog.csdn.net/972301/article/details/49127821&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Golang import 三種特殊形式：下劃線、點、別名&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/spf13/viper&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;github.com/spf13/viper&lt;/a&gt; 設定檔解決方案&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-golang&quot;&gt;token :=viper.GetStringSlice(&amp;quot;Line.Token&amp;quot;) # 有資料
tokens :=viper.GetStringMapStringSlice(&amp;quot;Line&amp;quot;)
token := tokens[&amp;quot;Token&amp;quot;]  # 無資料（因為轉成小寫了）
token := tokens[&amp;quot;token&amp;quot;]  # 有資料
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%92%BB%20Code/Golang/156-fig.1.jpg&quot; alt=&quot;156-fig.1.jpg&quot; /&gt;&lt;br /&gt;
看github 就有人有討論到這個&lt;a href=&quot;https://github.com/spf13/viper/issues/1014&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;問題&lt;/a&gt;，但到現在還是無解，&lt;br /&gt;
有人建議改用go-yaml/yaml來做 config檔的讀取&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;時間處理&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-golang&quot;&gt;//現在時間
now := time.Now()
//時間格式
fmt.Println(&amp;quot;now :&amp;quot; + now.Format(&amp;quot;2006-01-02 15:04:05&amp;quot;)) 
//日期相加
t2 := now.Add(5 * time.Minute)  
//日期相減
subMin := t2.Sub(now)  
//日期相減的時間，以分鐘顯示
fmt.Println(subMin.Minutes()) 
//日期相減的時間，四捨五入顯示到分
fmt.Println(subMin.Round(time.Minute))
//日期相減的時間，四捨五入顯示到分，再以分鐘顯示轉int
fmt.Println(int(subMin.Round(time.Minute).Minutes()))


//日期相加
firstStopTime := t.Add(-35 * time.Minute)
//判斷now 是否在 firstStopTime之後
if now.After(firstStopTime) {}
//判斷now 是否在 firstStopTime之前
if now.Before(firstStopTime){}
//判斷now是否跟firstStopTime一樣
if now.Equal(firstStopTime){}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
-&lt;a href=&quot;https://matthung0807.blogspot.com/2022/01/go-compare-datetime.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Golang 日期時間比較 compare datetime&lt;/a&gt;&lt;br /&gt;
-&lt;a href=&quot;https://www.zhangbj.com/p/652.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Go 時間加減、計算方法耗、毫秒轉 Time&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;switch用法&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-golang&quot;&gt;subMin := 132
//一般用法
switch subMin {
case 0, 2, 3, 1:
    fmt.Println(&amp;quot;LineNotify&amp;quot;)
default:
    fmt.Println(&amp;quot;Error&amp;quot;)
}

//不指定變數
switch {
case subMin%10 == 0, subMin%10 == 2:
    fmt.Println(&amp;quot;LineNotify&amp;quot;)
default:
    fmt.Println(subMin)
}


&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;cron 簡易用法&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-golang&quot;&gt;c := cron.New()

//* 每分鐘執行一次
c.AddFunc(&amp;quot;* * * * *&amp;quot;, func() {
  if &amp;lt;condition&amp;gt; {
  c.Stop()
  }
})
c.Start()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://eddycjy.gitbook.io/golang/di-3-ke-gin/cron&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;跟煎魚學GO-Cron定時任務&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://www.readfog.com/a/1637371620314157056&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;golang cron v3 定時任務&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/💻 Code/Golang/156. Golang簡略筆記（一）/" />
        </entry>
        <entry>
            <title>
                155. scrapy爬暗黑編年史的世界王時間
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/💻 Code/Golang/155. scrapy爬暗黑編年史的世界王時間/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;好久沒寫爬蟲了，&lt;br /&gt;
最近玩暗黑IV，開始接觸到世界王的時候，時間很不固定，&lt;br /&gt;
然後隔了幾天發現&lt;a href=&quot;https://diablo4.cc/tw/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;暗黑編年史&lt;/a&gt;，&lt;br /&gt;
有世界王的通知時間倒數了。&lt;br /&gt;
有資料就好辦了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;開啓scrapy專案&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;scrapy start &amp;lt;project_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;初始化(在上一個步驟執行完後，就有相關指令會顯示在螢幕上)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;scrapy genspider d4spider https://diablo4.cc/tw/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;結構如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;├── LICENSE
├── README.md
├── d4notify
│   ├── __init__.py
│   ├── __pycache__
│   │   ├── __init__.cpython-310.pyc
│   │   └── settings.cpython-310.pyc
│   ├── items.py
│   ├── middlewares.py
│   ├── pipelines.py
│   ├── settings.py
│   └── spiders
│       ├── __init__.py
│       ├── __pycache__
│       │   └── __init__.cpython-310.pyc
│       └── d4spider.py
└── scrapy.cfg
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;執行&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;scrapy crawl d4spider
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/daimom/d4notify&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GITHUB-D4Notfiy&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;取得屬性&lt;br /&gt;
碰到個奇怪的語法，div裏面有個自訂的屬性，&lt;br /&gt;
用scrapy要取值的話，&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div data-displaytime=&amp;quot;1687258903&amp;quot;&amp;gt;2023-06-20 19:01&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;div::attr(data-displaytime).get()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這樣會取得 1687258903 這個數字&lt;br /&gt;
ref. &lt;a href=&quot;https://stackoverflow.com/questions/53074642/scrapy-scraping-html-custom-attributes&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;scrapy-scraping-html-custom-attributes&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;extract_first() 跟 extract() ,可用get()跟getall()取代&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/selectors.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;選擇器(Selectors)&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/💻 Code/Golang/155. scrapy爬暗黑編年史的世界王時間/" />
        </entry>
        <entry>
            <title>
                59. git refs，branch 跟 tag是一樣的。
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/💻 Code/59. git refs，branch 跟 tag是一樣的。/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;git的主要架構其實都圍繞着 refs ，&lt;br /&gt;
branch 跟 tag 其實是一樣的東西，&lt;br /&gt;
直接去看 .git的資料夾，可以看到下面的架構。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	tree .git/refs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;├── heads&lt;br /&gt;
│   ├── apm2&lt;br /&gt;
│   └── testapmlog&lt;br /&gt;
├── remotes&lt;br /&gt;
│   └── origin&lt;br /&gt;
│       ├── HEAD&lt;br /&gt;
│       ├── apm2&lt;br /&gt;
│       ├── dev_spring20211027&lt;br /&gt;
└── tags&lt;/p&gt;
&lt;p&gt;heads 目錄，描述在本機上的所有分支，每一個檔案對應相應的目錄。&lt;br /&gt;
開啟檔案的話，會看到一個commit的雜湊值，&lt;br /&gt;
而不管是branch 或 tag 都是根據此雜湊值，來決定你程式目前是哪個版本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat .git/refs/heads/apm2

git log -1 apm2 
or
git show apm2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這兩個的雜湊值會一樣，&lt;br /&gt;
所以建立一個新的分支，對git來說，也只是將當下的雜湊值寫到一個檔案內。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://codertw.com/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC%E5%B7%A5%E5%85%B7/25108/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Git系列之Refs 與 Reflog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.atlassian.com/git/tutorials/refs-and-the-reflog&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;原文- Refs and the Reflog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/💻 Code/59. git refs，branch 跟 tag是一樣的。/" />
        </entry>
        <entry>
            <title>
                38.正則取代，留下特定字串
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/💻 Code/38.正則取代，留下特定字串/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;懶人的方式又來了，&lt;br /&gt;
有一整批的資料，一個一個改我覺得好麻煩，&lt;br /&gt;
那就用正則整批修吧&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;先來看個範例，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;code&amp;gt;
	&amp;lt;field name=&amp;quot;videoId&amp;quot;&amp;gt;&amp;lt;![CDATA[28713]]&amp;gt;&amp;lt;/field&amp;gt;
	&amp;lt;field name=&amp;quot;code&amp;quot;&amp;gt;&amp;lt;![CDATA[CWPBD-62]]&amp;gt;&amp;lt;/field&amp;gt;
	&amp;lt;field name=&amp;quot;artistId&amp;quot;&amp;gt;&amp;lt;![CDATA[5005]]&amp;gt;&amp;lt;/field&amp;gt;
	&amp;lt;field name=&amp;quot;sort&amp;quot;&amp;gt;&amp;lt;![CDATA[9054]]&amp;gt;&amp;lt;/field&amp;gt;
	&amp;lt;field name=&amp;quot;views&amp;quot;&amp;gt;&amp;lt;![CDATA[23004]]&amp;gt;&amp;lt;/field&amp;gt;
&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要將![CDATA[]] 中間的字串留下來，&lt;br /&gt;
這邊其實有兩種做法，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一種是用取代的，先把 ![CDATA[  刪除，再把 ]] 刪除&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;還有另一種就是下面的範例，直接用正則取代，留下中間的字串。&lt;/p&gt;
&lt;p&gt;先寫好一個正則，可以抓到 CDATA的資料&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(&#92;!&#92;[CDATA&#92;[)(.*)(&#92;]&#92;])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以到  &lt;a href=&quot;https://coding.tools/tw/regex-tester&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;正則在線測試&lt;/a&gt; 測試&lt;/p&gt;
&lt;p&gt;在 ATOM的話，於取代的位置寫上$2 ，這樣就會 留下中間的字了。(fig.1)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%92%BB%20Code/38-fig.1.jpg&quot; alt=&quot;38-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果是在微軟的excel，則是使用 &#92;2 ，這樣才會留下中間的字。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;chrome-extension://bocbaocobfecmglnmeaeppambideimao/pdf/viewer.html?file=http%3A%2F%2Fwww.tpqri.org.tw%3A8080%2FFileUpload%2FActivity%2FActivity51%2FRegularExpressionTutorialVer350.pdf&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Regular Expression（正則表達式）&lt;br /&gt;
入門修練 Ver3.50&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/💻 Code/38.正則取代，留下特定字串/" />
        </entry>
        <entry>
            <title>
                22.telegram api使用
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/💻 Code/22.telegram api使用/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;上一篇寫到用flagger，建立webhook發送通知。&lt;br /&gt;
公司有在用的就skype跟 telegram，所以就....開始吧&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先你要有telegram帳號 XDDD&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加入 @BotFather ，輸入指令 /newBot，開始命名，注意機器人名稱可以不用bot結尾，但@帳號最後一定是Bot結尾&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%92%BB%20Code/22.fig-1.jpg&quot; alt=&quot;22.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立好了後，會有一組token，請不要隨意給人，因為只要有這組就能發送訊息出去了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%92%BB%20Code/22.fig-2.jpg&quot; alt=&quot;22.fig-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;到此已經完成一半了，再來是使用取得channel的id，先將channel的頻道設公開，並把機器人加入到channel裡面。&lt;br /&gt;
這邊需要記得你的chatid，不能跟其他人的重複，所以需要自己試試。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%92%BB%20Code/22.fig-3.jpg&quot; alt=&quot;22.fig-3.jpg&quot; /&gt;&lt;br /&gt;
ezioflaggernotfiy就是我的chatid，&lt;br /&gt;
然後組合一下api，送出去就能取得channel的id，請先將機器人加入到channel裡面。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://api.telegram.org/bot{token}/sendMessage?chat_id={chatid}&amp;amp;text=Hello,world
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;{token} 在 step.3，前面記得加bot&lt;br /&gt;
{chatid} 在step.4 ，記得前面要加 &lt;code&gt;@&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;送出去後，回傳的資料上面會顯示 &lt;a href=&quot;http://chat.id/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;chat.id&lt;/a&gt;，此時就能把channel 設成 private了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%92%BB%20Code/22.fig-4.jpg&quot; alt=&quot;22.fig-4.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;如果是公開的channel，就到第四步就結束了。&lt;br /&gt;
如果是私人的話，將chatid改成 ，上面step.4拿到的 &lt;a href=&quot;http://chat.id/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;chat.id&lt;/a&gt; ，即可。&lt;br /&gt;
不用再加@ 在chat_id前面了。此時所用的已是唯一的channel sn。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;https://api.telegram.org/bot1234:JMwL6qw/sendMessage&#92;?chat_id&#92;=-12345&#92;&amp;amp;text&#92;=hello,telegram
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;如果訊息太長，想要有明顯一點的訊息，可加上parse_mode=html&lt;br /&gt;
並在字的前後加上&lt;code&gt;abc&lt;/code&gt;，在電腦上看到的字會明顯許多。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%92%BB%20Code/22.fig-5.jpg&quot; alt=&quot;22.fig-5.jpg&quot; /&gt;&lt;br /&gt;
(fig.5)&lt;br /&gt;
但在手機上的telegram，看不到此特效。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://slashview.com/archive2020/20200319.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Telegram Bot機器人申請與Webhook指令全紀錄&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/ask/146200&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;如何獲得正確的telegram channel id?？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://core.telegram.org/bots#botfather&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; An introduction for developers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://core.telegram.org/bots/api#sendmessage&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;telegram-sendMessage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rdrr.io/cran/telegram.bot/man/sendMessage.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;sendMessage: Send text messages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tgtw.cc/post-about-parse-mode-of-telegram&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;關於 Telegram 上的解析模式（Markdown、HTML）、文字格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/💻 Code/22.telegram api使用/" />
        </entry>
        <entry>
            <title>
                145. git submodule 下載失敗
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/💻 Code/145. git submodule 下載失敗/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;因為他們的新專案有用到 git的submodule，&lt;br /&gt;
之前也用過一次了，想說應該還好，&lt;br /&gt;
但這次就是怎麼驗證，怎麼不過。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;都是出現這個錯誤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Cloning into &#39;/drone/src/BackendSharedLib&#39;...&lt;br /&gt;
Host key verification failed.&lt;br /&gt;
fatal: Could not read from remote repository.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%92%BB%20Code/145-fig.1.jpg&quot; alt=&quot;145-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;但之前寫的專案就沒這個問題，找阿找，最後終於發現，&lt;br /&gt;
差異在 建立 submodule的時候。&lt;/p&gt;
&lt;p&gt;打開 .gitmodules 上面會寫 url的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[submodule &amp;quot;SMSBackendSharedLib&amp;quot;]
	path = SMSBackendSharedLib
	url = git@github.com:ABC/sms-backend-sharedlib.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本來是上面這種寫法，他會用ssh的方式去抓submodule的檔案。&lt;/p&gt;
&lt;p&gt;所以要把url改成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[submodule &amp;quot;SMSBackendSharedLib&amp;quot;]
	path = SMSBackendSharedLib
	url = https://github.com/ABC/sms-backend-sharedlib.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再來用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git submodule update --init --recursive
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本機也可以下載了。&lt;/p&gt;
&lt;p&gt;本來還懷疑是不是drone clone submodule的時候，用到錯誤的使用者。&lt;br /&gt;
結果一查根本沒有使用者。&lt;br /&gt;
可以用下面的指令查查&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --list

git config user.name
git config user.email
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;簡單解釋一下 submodule，&lt;br /&gt;
以下從chatGPT抄來的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Git 中，Submodule 是一個允許您在 Git 倉庫中包含另一個 Git 倉庫的機制。通過使用 Submodule，您可以將一個 Git 倉庫作為另一個 Git 倉庫的子目錄進行管理。這對於管理大型專案或共享程式庫非常有用。&lt;/p&gt;
&lt;p&gt;當您在 Git 倉庫中新增 Submodule 時，它實際上是包含另一個 Git 倉庫的指向。當您 clone 或 pull 主倉庫時，Git 只會下載 Submodule 的指向，而不會將 Submodule 的內容一併下載。這樣可以節省空間和時間，同時還可以使主倉庫更加輕便。&lt;/p&gt;
&lt;p&gt;如果您想要更新 Submodule 的內容，可以使用 &lt;code&gt;git submodule update&lt;/code&gt; 命令來下載 Submodule 的內容。當您修改 Submodule 的內容時，您需要先進入 Submodule 的目錄，對其進行 commit 和 push，然後返回主倉庫，對 Submodule 的指向進行 commit 和 push。這樣可以確保 Submodule 的指向指向正確的 commit。&lt;/p&gt;
&lt;p&gt;總之，Submodule 是一個非常有用的機制，可以使 Git 倉庫管理更加靈活和有效。&lt;/p&gt;
&lt;/blockquote&gt;

            </content>
            <link href="https://daimom.github.io/💻 Code/145. git submodule 下載失敗/" />
        </entry>
        <entry>
            <title>
                110.github action pipeline筆記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/💻 Code/110.github action pipeline筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;因為之前用的巴哈自動簽到，那個github被封了，&lt;br /&gt;
說違反服務條款，還好我主程式有下載下來過。&lt;br /&gt;
未來把他打包成image後在本機跑了吧，&lt;br /&gt;
不過要先解析github的workflow看是怎麼打包成image的&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;    name: Publish
    
    on:
        push:
            branches:
                - main
            paths-ignore:
                - &amp;quot;**.md&amp;quot;
        workflow_dispatch:
    
    jobs:
    
        publish_docker:
            runs-on: ubuntu-latest
            steps:
                - name: Checkout Source Code
                  uses: actions/checkout@v3
    
                - name: Install PNPM
                  uses: pnpm/action-setup@v2.2.2
                  with:
                      version: latest
                      run_install: true
    
                - name: Build Package
                  run: pnpm build:package
    
                - name: Set up QEMU
                  uses: docker/setup-qemu-action@v2
    
                - name: Set up Docker Buildx
                  uses: docker/setup-buildx-action@v2
    
                - name: Login to Docker Hub
                  uses: docker/login-action@v2
                  with:
                      username: $
                      password: $
    
                - name: Build Image and Push
                  run: |
                      pnpm build:package
                      pnpm build:docker
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;name : action的名稱&lt;/li&gt;
&lt;li&gt;on ：什麼時候觸發&lt;/li&gt;
&lt;li&gt;job: 要執行的動作&lt;/li&gt;
&lt;li&gt;publish_docker : 作業的名稱&lt;/li&gt;
&lt;li&gt;runs-on: 執行的os&lt;/li&gt;
&lt;li&gt;steps：執行的步驟&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h1&gt;
&lt;p&gt;用了一陣子以後，&lt;br /&gt;
那個專案被github封掉了，&lt;br /&gt;
最後改用chrome 的外掛 &lt;img src=&quot;https://chrome.google.com/webstore/detail/%E5%B7%B4%E5%93%88%E8%87%AA%E5%8B%95%E7%B0%BD%E5%88%B0/nlcekebohjbgnfgjicklnjbnefmmgggk&quot; alt=&quot;巴哈自動簽到&quot; /&gt; ，&lt;br /&gt;
缺點就是電腦要一直開著，反正我電腦也一直開着所以沒關係&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/💻 Code/110.github action pipeline筆記/" />
        </entry>
        <entry>
            <title>
                107. vscode 忽略設定同步
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/💻 Code/107. vscode 忽略設定同步/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;公司一臺電腦，我自己帶了一臺mac過去，&lt;br /&gt;
因為我已經linux用習慣了（X）&lt;br /&gt;
不得不說mac用習慣真的好順...&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%92%BB%20Code/107.fig-1.jpg&quot; alt=&quot;107.fig-1.jpg&quot; /&gt;&lt;br /&gt;
應該都知道linux的檔案系統跟windows的檔案系統不一樣。&lt;br /&gt;
前者沒有C、D、E的概念，&lt;br /&gt;
所以vscode的  &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=shalldie.background&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;background&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在圖片路徑的設定上會不一樣，mac是使用下麵這種方式設定vscode的背景&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;file:///Users/daimom/Pictures/1275337.jpeg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;windows則是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;file://c:&#92;Users&#92;user&#92;Pictures&#92;1275337.jpeg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一旦同步的話，兩邊的路徑就會衝突，導致一邊沒圖片。&lt;/p&gt;
&lt;p&gt;所以現在要設定，忽略vscode的同步設定，讓他不要把圖片設定的地方也同步。&lt;/p&gt;
&lt;p&gt;在設定的查詢欄位，輸入 『同步』，&lt;br /&gt;
選擇忽略的設定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%92%BB%20Code/107.fig-2.jpg&quot; alt=&quot;107.fig-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;應該會看到 settingsSync.ignoredSettings ，&lt;br /&gt;
底下輸入background.customImages&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;settingsSync.ignoredSettings&amp;quot;: [

&amp;quot;background.customImages&amp;quot;

],
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/💻 Code/107. vscode 忽略設定同步/" />
        </entry>
        <entry>
            <title>
                0.Code MOC
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/💻 Code/0.Code MOC/</id>
            <content type="html">
                &lt;h2 id=&quot;api&quot; tabindex=&quot;-1&quot;&gt;API串接&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%92%BB%20Code/22.telegram%20api%E4%BD%BF%E7%94%A8/&quot;&gt;22.telegram api使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;golang&quot; tabindex=&quot;-1&quot;&gt;Golang&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%92%BB%20Code/Golang/40.%20golang%20%E9%87%8D%E6%96%B0%E8%AE%80%E5%8F%96%E8%A8%AD%E5%AE%9A%E6%AA%94%E7%9A%84%E6%96%B9%E6%B3%95/&quot;&gt;40. golang 重新讀取設定檔的方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%92%BB%20Code/Golang/47.%20GO%20get%20%E5%8F%83%E6%95%B8/&quot;&gt;47. GO get 參數&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%92%BB%20Code/Golang/155.%20scrapy%E7%88%AC%E6%9A%97%E9%BB%91%E7%B7%A8%E5%B9%B4%E5%8F%B2%E7%9A%84%E4%B8%96%E7%95%8C%E7%8E%8B%E6%99%82%E9%96%93/&quot;&gt;155. scrapy爬暗黑編年史的世界王時間&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%92%BB%20Code/Golang/156.%20Golang%E7%B0%A1%E7%95%A5%E7%AD%86%E8%A8%98%EF%BC%88%E4%B8%80%EF%BC%89/&quot;&gt;156. Golang簡略筆記（一）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;正則表達式&quot; tabindex=&quot;-1&quot;&gt;正則表達式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%92%BB%20Code/38.%E6%AD%A3%E5%89%87%E5%8F%96%E4%BB%A3%EF%BC%8C%E7%95%99%E4%B8%8B%E7%89%B9%E5%AE%9A%E5%AD%97%E4%B8%B2/&quot;&gt;38.正則取代，留下特定字串&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;git&quot; tabindex=&quot;-1&quot;&gt;Git&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%92%BB%20Code/59.%20git%20refs%EF%BC%8Cbranch%20%E8%B7%9F%20tag%E6%98%AF%E4%B8%80%E6%A8%A3%E7%9A%84%E3%80%82/&quot;&gt;59. git refs，branch 跟 tag是一樣的。&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%92%BB%20Code/110.github%20action%20pipeline%E7%AD%86%E8%A8%98/&quot;&gt;110.github action pipeline筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%92%BB%20Code/145.%20git%20submodule%20%E4%B8%8B%E8%BC%89%E5%A4%B1%E6%95%97/&quot;&gt;145. git submodule 下載失敗&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;ide&quot; tabindex=&quot;-1&quot;&gt;IDE&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%92%BB%20Code/107.%20vscode%20%E5%BF%BD%E7%95%A5%E8%A8%AD%E5%AE%9A%E5%90%8C%E6%AD%A5/&quot;&gt;107. vscode 忽略設定同步&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/💻 Code/0.Code MOC/" />
        </entry>
        <entry>
            <title>
                28.Prometheus的專用語言promQL
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/👁 Observability/28.Prometheus的專用語言promQL/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;在寫監控告警的時候，看別人寫好的dashboard裡面有一堆函數，&lt;br /&gt;
但卻偏偏不知道該怎麼使用，後來才知道這是 Prometheus的語言 PromQL，&lt;br /&gt;
這邊會將寫監控時用到的東西記下，基本上都是針對metrics做的處理。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h2 id=&quot;聚合函數&quot; tabindex=&quot;-1&quot;&gt;聚合函數&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;sum (求和)&lt;/li&gt;
&lt;li&gt;min (最小值)&lt;/li&gt;
&lt;li&gt;max (最大值)&lt;/li&gt;
&lt;li&gt;avg (平均值)&lt;/li&gt;
&lt;li&gt;stddev (標准差)&lt;/li&gt;
&lt;li&gt;stdvar (標准差異)&lt;/li&gt;
&lt;li&gt;count (計數)&lt;/li&gt;
&lt;li&gt;count_values (對value進行計數)&lt;/li&gt;
&lt;li&gt;bottomk (後n條時序)&lt;/li&gt;
&lt;li&gt;topk (前n條時序)&lt;br /&gt;
topk(10,prometheus_http_requests_total) ：前10筆資料&lt;/li&gt;
&lt;li&gt;quantile (分佈統計)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;聚合函數可與by 或 without共同使用 ，可取得metrics裡的欄位名稱&lt;br /&gt;
例：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sum(rate(istio_requests_total{reporter=&amp;quot;destination&amp;quot;}[1m])) by (destination_workload)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;內建函數&quot; tabindex=&quot;-1&quot;&gt;內建函數&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;abs(絕對值)&lt;/li&gt;
&lt;li&gt;absent(判斷指標名稱或標籤是否有值)&lt;/li&gt;
&lt;li&gt;absent_over_time(同上，多了時間範圍)&lt;/li&gt;
&lt;li&gt;ceil(四捨五入)&lt;/li&gt;
&lt;li&gt;changes(返回區間變數每個樣本值變化的次數)&lt;/li&gt;
&lt;li&gt;delta(計算區間向量第一個值和最後一個值的差值)&lt;/li&gt;
&lt;li&gt;floor(取整數)&lt;/li&gt;
&lt;li&gt;increase(返回區間向量第一個和最後一個樣本的增加值)&lt;/li&gt;
&lt;li&gt;rate(計算區間向量 v 在時間視窗內平均每時間增長速率)&lt;br /&gt;
rate(prometheus_http_requests_total[5m])  ： HTTP請求量的增長率&lt;/li&gt;
&lt;li&gt;irate(計算區間向量的增長率，但是它反應的是瞬時增長率)&lt;/li&gt;
&lt;li&gt;deriv(計算樣本的線性回歸模型)&lt;/li&gt;
&lt;li&gt;predict_linear(預測時間序列在n秒後的值)&lt;/li&gt;
&lt;li&gt;sort(對向量按元素的值進行升序排序)&lt;/li&gt;
&lt;li&gt;sort_desc(對向量按元素的值進行降序排序)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;實際演練&quot; tabindex=&quot;-1&quot;&gt;實際演練&lt;/h2&gt;
&lt;p&gt;可以先在prometheus上面測試語法，當測試完成後，再放到grafana上面看實際的圖表。&lt;br /&gt;
也可透過現有的grafana的dashboard裡面的Query Inspect 將Metric撈出來（這邊可以直接將變數取出）(fig.1)&lt;br /&gt;
撈出來的資料要再經過 &lt;a href=&quot;https://www.urldecoder.org/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;urldecode&lt;/a&gt; 將符號轉成正常的符號&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/28-fig.1.jpg&quot; alt=&quot;28-fig.1.jpg&quot; /&gt;&lt;br /&gt;
(fig.1)&lt;/p&gt;
&lt;p&gt;所有的Metric格式如下，&lt;br /&gt;
指標名稱只能由ASCII字符、數字、下劃線以及冒號組成並必須符合正則表達式[a-zA-Z_:][a-zA-Z0-9_:]*&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;metric name&amp;gt;{&amp;lt;label name&amp;gt;=&amp;lt;label value&amp;gt;, ...}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匹配函數&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;=   等於&lt;/li&gt;
&lt;li&gt;!=  不等於&lt;/li&gt;
&lt;li&gt;=~  開頭等於&lt;/li&gt;
&lt;li&gt;!~  開頭不等於&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有時也會在label name上面使用 正規表示法，這邊使用的是&lt;a href=&quot;https://github.com/google/re2/wiki/Syntax&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;RE2語法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;例如，我們要取得memory的資料，其中的image的開頭只要包含 &lt;a href=&quot;http://gcr.io/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcr.io&lt;/a&gt; 跟 istio。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  container_memory_working_set_bytes{id!=&amp;quot;/&amp;quot;,pod=~&amp;quot;.*&amp;quot;,image=~&amp;quot;[gcr.io | istio].*&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;變數設定&lt;/p&gt;
&lt;p&gt;在grafana上面通常會設定一些參數，這是為了看指定的指標&lt;br /&gt;
有四種可選，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;label_values(label) :&lt;br /&gt;
返回Promthues所有監控指標中，標籤稱為label的所有可選值&lt;/li&gt;
&lt;li&gt;label_values(metric, label) :&lt;br /&gt;
返回Promthues所有監控指標metric中，標籤稱為label的所有可選值&lt;/li&gt;
&lt;li&gt;metrics(metric) :&lt;br /&gt;
返回所有指標名稱滿足metric定義正則表達式的指標名稱&lt;/li&gt;
&lt;li&gt;query_result(query) :&lt;br /&gt;
返回prometheus查詢語句的查詢結果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常用的label_value&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  $Node       label_values(kubernetes_io_hostname)
  $Pod        label_values(kube_pod_info, pod)
  $Pod_ip     label_values(kube_pod_info, pod_ip)
  $phase      label_values(kube_pod_status_phase, phase)
  $container  label_values(kube_pod_container_info, container)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;query_result範例，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;query_result(kube_deployment_status_replicas{namespace !~ &amp;quot;istio-system|kube-system&amp;quot;}&amp;gt;0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解釋：排除Deployment裡面的namespace 不是 istio-system或 kube-system，並且value&amp;gt;0的metrics。&lt;br /&gt;
這邊會顯示全部的資料，故在regex要再指定抓取 deployment的資料&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/.*deployment=&amp;quot;(.*?)&amp;quot;.*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://banzaicloud.com/blog/grafana-templating/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Grafana templating with Prometheus labels&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://yunlzheng.gitbook.io/prometheus-book/part-ii-prometheus-jin-jie/grafana/templating&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;模板化Dashboard&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.mdeditor.tw/pl/g0OB/zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;PromQL的簡單使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://zhuanlan.zhihu.com/p/121104877&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Prometheus-基礎系列-(四)-PromQL語句實踐-2&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://prometheus.fuckcloudnative.io/di-san-zhang-prometheus/di-4-jie-cha-xun/functions&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;PromQL 內置函數&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-promql-operators-v2&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;PromQL操作符&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/👁 Observability/28.Prometheus的專用語言promQL/" />
        </entry>
        <entry>
            <title>
                26.grafana alert message parameters傳入
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/👁 Observability/26.grafana alert message parameters傳入/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;在設計grafana alert message的時候，&lt;br /&gt;
一直想傳參數進去，看官方文章顯示是可行的，&lt;br /&gt;
但是不知道是我理解能力太爛還是文章寫的太簡單...弄了半天才生出來。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;先決條件， Grafana v7.4 以上，才能夠使用 Notification templating 。&lt;br /&gt;
ref. &lt;a href=&quot;https://grafana.com/docs/grafana/latest/alerting/notifications/#notification-templating&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Notification templating&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這邊的parameters只限定於 圖表上的 Legend 的value&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/26-fig.1.jpg&quot; alt=&quot;26-fig.1.jpg&quot; /&gt;&lt;br /&gt;
(fig.1)，&lt;br /&gt;
需使用 ，將值顯示在上面。&lt;br /&gt;
所以這上面沒有資料，就無法傳過去給alert message。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/26-fig.1.jpg&quot; alt=&quot;26-fig.1.jpg&quot; /&gt;&lt;br /&gt;
(fig.1)&lt;/p&gt;
&lt;p&gt;之後在alert上面則可以使用 ${label}，將值傳入。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/26-fig.2.jpg&quot; alt=&quot;26-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;telegram 呈現&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/26-fig.3.jpg&quot; alt=&quot;26-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;缺點是告警訊息的Metrics上面的數值，我目前還找不到方式可以自定。&lt;br /&gt;
所以長的不怎麼討喜。&lt;br /&gt;
另外可以在圖表上直接將Legend隱藏，這樣至少畫面會好看許多。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://grafana.com/docs/grafana/latest/alerting/add-notification-template/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Alert notification templating&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/👁 Observability/26.grafana alert message parameters傳入/" />
        </entry>
        <entry>
            <title>
                25.在GKE上的grafana上安裝grafana-image-renderer
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/👁 Observability/25.在GKE上的grafana上安裝grafana-image-renderer/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;在寫grafana的時候，才發現告警的圖片無法寄出，&lt;br /&gt;
必須要額外安裝plugin : grafana-image-renderer ，&lt;br /&gt;
然後，我又卡住了...&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;如果你看到這張圖(fig.1)，就表示你該裝&lt;a href=&quot;https://grafana.com/grafana/plugins/grafana-image-renderer/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Grafana Image Renderer&lt;/a&gt;了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/25-fig.1.jpg&quot; alt=&quot;25-fig.1.jpg&quot; /&gt;&lt;br /&gt;
(fig.1)&lt;/p&gt;
&lt;p&gt;先說結論，我測過『在pod裡面利用grafana-cli 安裝』、『改成使用ubuntu的image預先安裝plugin』，都失敗，最後只能建立 grafana-image-renderer的 服務，透過這個服務，負責宣染當下的告警圖，再隨着telegram送出。&lt;/p&gt;
&lt;p&gt;佈署的yaml， grafana-image-render.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment

metadata:
namespace: istio-system
name: grafana-image-renderer
labels:
  app: grafana-image-renderer
  version: v1
spec:
replicas: 1
selector:
  matchLabels:
    app: grafana-image-renderer
    version: v1
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 1
template:
  metadata:
    labels:
      app: grafana-image-renderer
      version: v1
  spec:
    containers:
      - image: grafana/grafana-image-renderer:latest
        imagePullPolicy: &amp;quot;Always&amp;quot;
        name: renderer
        ports:
          - containerPort: 80
        env:
          - name: &amp;quot;RENDERING_VERBOSE_LOGGING&amp;quot;
            value: &amp;quot;true&amp;quot;
        resources:
          requests:
            memory: &amp;quot;30Mi&amp;quot;
            cpu: &amp;quot;30m&amp;quot;
    restartPolicy: Always
    serviceAccountName: &amp;quot;&amp;quot;
---
apiVersion: v1
kind: Service
metadata:
namespace: istio-system
labels:
  app: grafana-image-renderer
name: grafana-image-renderer
spec:
ports:
  - name: &amp;quot;http&amp;quot;
    port: 8081
selector:
  app:  grafana-image-renderer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後在佈署 grafana的yaml上面，增加環境參數&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: &amp;quot;GF_RENDERING_SERVER_URL&amp;quot;
  value: &amp;quot;http://grafana-image-renderer.istio-system:8081/render&amp;quot;
- name: &amp;quot;GF_RENDERING_CALLBACK_URL&amp;quot;
  value: &amp;quot;http://grafana.istio-system:3000/grafana/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要開啟debug的話，加上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: &amp;quot;GF_LOG_FILTERS&amp;quot;
  value: &amp;quot;rendering:debug&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果需要更多的log訊息，可參考 &lt;a href=&quot;https://github.com/grafana/grafana-image-renderer/blob/master/docs/remote_rendering_using_docker.md&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;grafana-image-renderer&lt;/a&gt;，這邊就是改加至grafana-image-renderer上面了。&lt;/p&gt;
&lt;p&gt;一開始在測試的時候有碰到一個問題，&lt;br /&gt;
那就是抓圖的時候，一直抓到grafana的首頁(Fig.2)&lt;/p&gt;
&lt;p&gt;[[25-fig.2.jpg]]&lt;br /&gt;
(Fig.2)&lt;/p&gt;
&lt;p&gt;後來才發現是 GF_RENDERING_CALLBACK_URL 錯誤，由於我的grafana.ini 的 root_url 是 &lt;a href=&quot;http://localhost/grafana%EF%BC%8C&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;http://localhost/grafana，&lt;/a&gt;&lt;br /&gt;
所以 我的網址後面也要加上grafana，但是，如果在grafana.ini上面 的 root_url 寫 &lt;a href=&quot;http://localhost/grafana&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;http://localhost/grafana&lt;/a&gt;&lt;br /&gt;
那telegram的告警，顯示的url也會變成localhost (fig.3)&lt;/p&gt;
&lt;p&gt;[[25-fig.3.jpg]]&lt;br /&gt;
(Fig.3)&lt;/p&gt;
&lt;p&gt;所以，grafana.ini的root_url 最好還是寫實際的ip位置。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/👁 Observability/25.在GKE上的grafana上安裝grafana-image-renderer/" />
        </entry>
        <entry>
            <title>
                24.grafana設計篇-第二個Y軸
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/👁 Observability/24.grafana設計篇-第二個Y軸/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;應該是個很常見的功能，但是我卻找了很久，一直找不到。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;要做出來的東西像（Fig.1) 一樣，左右都各有一個Y軸數值。&lt;/p&gt;
&lt;p&gt;(Fig.1)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先要先在右邊的圖表將show打開，，這裡分成左右兩邊的Y軸&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/24-fig.2.jpg&quot; alt=&quot;24-fig.2.jpg&quot; /&gt;&lt;br /&gt;
(Fig.2)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;點一下label的標籤，選擇 Y-Axis ，將 use y-axis 打開&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/24-fig.3.jpg&quot; alt=&quot;24-fig.3.jpg&quot; /&gt;&lt;br /&gt;
(Fig.3)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://grafana.com/blog/2020/03/10/learn-grafana-how-to-use-dual-axis-graphs/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Learn Grafana: How to use dual axis graphs&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/👁 Observability/24.grafana設計篇-第二個Y軸/" />
        </entry>
        <entry>
            <title>
                198. SRE好文連結
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/👁 Observability/198. SRE好文連結/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;看別人SRE的文章，感覺這個需要記錄一下。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.kawabangga.com/posts/4294&quot; title=&quot;Permalink to 最近的工作感悟&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;卡瓦邦噶-最近的工作感悟&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這篇主要介紹，他是怎麼解決一直報錯的方法。&lt;br /&gt;
當告警太多，只會麻痹而已。&lt;/p&gt;
&lt;p&gt;我目前把通知分成兩種，第三種，工單我還沒有碰到這個案例。&lt;/p&gt;
&lt;p&gt;通知：一般訊息，不重要，但必須要知道（朕，知道了）這種感覺。&lt;br /&gt;
緊急：現在、立刻、馬上處理（護駕！！）這種感覺&lt;br /&gt;
工單：需要人力介入的操作（還沒用過這種）&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://www.kawabangga.com/posts/4481&quot; title=&quot;Permalink to SRE 的工作介紹&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SRE 的工作介紹&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;跟上一篇同一個作者，講SRE的工作內容，不同公司會有不同的權重。&lt;br /&gt;
但臺灣應該都是跟DevOps混在一起。可能要更大的公司才有差？&lt;br /&gt;
但我能力不足沒去過大公司😢&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;CNCF簡易分類&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/198-fig.1.png&quot; alt=&quot;198-fig.1.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/👁 Observability/198. SRE好文連結/" />
        </entry>
        <entry>
            <title>
                197. Grafana 以及Prometheus 除錯方式
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/👁 Observability/197. Grafana 以及Prometheus 除錯方式/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近在查個問題，然後就碰到grafana的圖表產不出來，&lt;br /&gt;
要撈出每個pod目前的記憶體使用量百分比是多少。&lt;br /&gt;
每個pod的記憶體使用量是多個，但總記憶體只有一個，&lt;br /&gt;
就開始找問題了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;這個圖來自 &lt;a href=&quot;https://www.kawabangga.com/posts/5745&quot; title=&quot;Permalink to Prometheus &amp;amp; Grafana No Data 排查手冊&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Prometheus &amp;amp; Grafana No Data 排查手冊&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/197-fig.1.jpeg&quot; alt=&quot;197-fig.1.jpeg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我目前的排查方式，&lt;br /&gt;
通常都是先開prometheus，看指令有沒有資料，沒資料就表示寫錯。&lt;br /&gt;
有資料，在grafana 無法顯示，那就是grafana的問題。&lt;/p&gt;
&lt;p&gt;目前碰到的問題是單個query都有資料，但湊在一起就沒了。&lt;br /&gt;
後來有問了一下GPT，&lt;br /&gt;
發現相除的話，要符合一些條件。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;在 Grafana 中進行查詢的相除，需要確保以下條件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;兩個查詢的時間戳匹配：&lt;/strong&gt; 確保兩個查詢的時間戳是對應的。如果時間戳不匹配，則查詢結果無法正確進行相除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;標籤匹配：&lt;/strong&gt; 確保兩個查詢的標籤匹配。這包括時間戳的標籤，以及在使用 &lt;code&gt;by()&lt;/code&gt; 子句進行分組時的標籤。如果標籤不匹配，查詢結果可能無法正確合併。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用 &lt;code&gt;ignoring()&lt;/code&gt; 或 &lt;code&gt;on()&lt;/code&gt; 子句：&lt;/strong&gt; 如果有一些標籤不需要匹配，可以使用 &lt;code&gt;ignoring()&lt;/code&gt; 或 &lt;code&gt;on()&lt;/code&gt; 子句。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-plaintext&quot;&gt;A / ignoring(label_name) B
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用 &lt;code&gt;group_left&lt;/code&gt; 或 &lt;code&gt;group_right&lt;/code&gt; 子句：&lt;/strong&gt; 如果需要在查詢中保留某些標籤，可以使用 &lt;code&gt;group_left&lt;/code&gt; 或 &lt;code&gt;group_right&lt;/code&gt; 以確保這些標籤在合併時保持一致。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-plaintext&quot;&gt;A / B on(label_name) group_left(label_name)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;確保查詢結果是數值：&lt;/strong&gt; 確保兩個查詢返回的結果是數值，並且支持相除操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下是一個簡單的例子，假設你有兩個查詢 A 和 B，要計算 A 中每個時間戳的值除以 B 中對應時間戳的值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-plaintext&quot;&gt;A / B
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根據你的數據源和具體的需求，可能需要根據上述條件進行調整。這些條件有助於確保查詢結果的正確性。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/👁 Observability/197. Grafana 以及Prometheus 除錯方式/" />
        </entry>
        <entry>
            <title>
                195. SRE可觀測性三大支柱
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/👁 Observability/195. SRE可觀測性三大支柱/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;去年底看google的研討會就有講到OpenTelemetry，&lt;br /&gt;
今天又剛好碰到有人在講這個東西，&lt;br /&gt;
挑個時間把它弄出來了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;Logs, Tracing, Metrics&lt;br /&gt;
OpenTelemetry  推動可觀測性三大支柱W3C數據採集的標準化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/195-fig.1.png&quot; alt=&quot;195-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/195-fig.2.png&quot; alt=&quot;195-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;範例&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/195-fig.3.png&quot; alt=&quot;195-fig.3.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://itplus.ithome.com.tw/vod-page/770&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;微服務在雲原生環境的可觀測性應用&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/👁 Observability/195. SRE可觀測性三大支柱/" />
        </entry>
        <entry>
            <title>
                184. grafana error  reverse proxy settings on istio
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/👁 Observability/184. grafana error  reverse proxy settings on istio/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;搬project，就想乾脆上istio了，&lt;br /&gt;
然後就卡到怎麼以前的grafana開的起來，現在的開不起來。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;照以前的方式設定完 root_url，&lt;br /&gt;
還是出現相同錯誤&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/184-fig.1.jpg&quot; alt=&quot;184-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;查文件後才發現，&lt;br /&gt;
應該是新版(9.5.5)需要加上&lt;code&gt;serve_from_sub_path&lt;/code&gt;的參數，&lt;br /&gt;
如果碰到只加了root_url也是看到錯誤，就再加個參數吧。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;grafana.ini&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[server]
root_url = &amp;quot;http://&amp;lt;ip&amp;gt;/grafana/&amp;quot;
serve_from_sub_path = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;virtualservice.yaml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: istio-virtualservice
  namespace: istio-system
spec:
  hosts:
  - &amp;quot;&amp;lt;ip&amp;gt;&amp;quot;
  gateways:
    - istio-system/istio-gateway
  http: 
  - name: &amp;quot;grafana&amp;quot;
    match:
      - uri:
          prefix: /grafana/
      - uri:
          exact: /grafana
    route:
      - destination:
          port:
            number: 3000
          host:  grafana.istio-system.svc.cluster.local  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://grafana.com/tutorials/run-grafana-behind-a-proxy/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Run Grafana behind a reverse proxy&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/👁 Observability/184. grafana error  reverse proxy settings on istio/" />
        </entry>
        <entry>
            <title>
                179.  install Bindplane
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/👁 Observability/179.  install Bindplane/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近看完2023 Google  Cloud summit ，&lt;br /&gt;
看到一個新東西，OpenTelemetry，可以不用埋程式用sidecar的方式，&lt;br /&gt;
就能做到Observability的trace，&lt;br /&gt;
一開始安裝OpenTelemetry，後來發現，&lt;br /&gt;
他好肥（測試cluster空間不足），之後還搞錯了一件事情。&lt;br /&gt;
後來改測試Bindplane。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;what-is-bindplane&quot; tabindex=&quot;-1&quot;&gt;What is Bindplane?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Bindplane is an open source solution utilizing the OpAMP protocol to configure, monitor, and deploy various collectors.&lt;br /&gt;
Bindplane 是一個開源解決方案，利用 OpAMP 協定來設定、監控和部署各種收集器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;他是一個監控跟log的收集器，他並不是像efk或google cloud那樣的東西。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://isitobservable.io/open-telemetry/what-is-bindplane-and-what-does-it-do&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;What is OpAMP? And what is Bindplane?&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;安裝&quot; tabindex=&quot;-1&quot;&gt;安裝&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Helm add source&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-ssh&quot;&gt;helm repo add &amp;quot;bindplane&amp;quot; &#92; &amp;quot;https://observiq.github.io/bindplane-op-helm&amp;quot;
helm repo update
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;建立組態 values.yaml&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;config:
  username: &amp;quot;admin&amp;quot;
  password: &amp;quot;admin&amp;quot;
  secret_key: &amp;quot;13c15d7c-233e-49e3-bef4-f7498f33518f&amp;quot;
  sessions_secret: &amp;quot;a4e5aa85-5df4-4edd-8cfe-d8a7257d09dd&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/observIQ/bindplane-op-helm/tree/main/charts/bindplane&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;完整設定參數&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;安裝&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;helm upgrade --install &amp;quot;bindplane&amp;quot; &#92;
  --values &amp;quot;values.yaml&amp;quot; &#92;
  --namespace bindplane &#92;
  --create-namespace &#92;
  bindplane/bindplane
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://docs.bindplane.observiq.com/docs/kubernetes-deploy-bindplane-op-server&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Deploy BindPlane OP Server on K8s&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;設定&quot; tabindex=&quot;-1&quot;&gt;設定&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;設定port forward轉過去服務上&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kubectl port-forward -n bindplane svc/bindplane 3001
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/👁 Observability/179.  install Bindplane/" />
        </entry>
        <entry>
            <title>
                178. Install Prometheus Operator
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/👁 Observability/178. Install Prometheus Operator/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近看完2023 Google  Cloud summit ，&lt;br /&gt;
看到一個新東西，OpenTelemetry，可以不用埋程式用sidecar的方式，&lt;br /&gt;
就能做到Observability的trace，&lt;br /&gt;
但在那之前，我要先在測試叢集裝一下Prometheus Operator，&lt;br /&gt;
不然資料傳不過去。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;git clone&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/prometheus-operator/kube-prometheus
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;install&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kubectl apply --server-side -f manifests/setup
kubectl wait &#92;
	--for condition=Established &#92;
	--all CustomResourceDefinition &#92;
	--namespace=monitoring
kubectl apply -f manifests/
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;刪除&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubectl delete --ignore-not-found=true -f manifests/ -f manifests/setup
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不過這個安裝方式，會包含&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href=&quot;https://github.com/prometheus-operator/prometheus-operator&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Prometheus Operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Highly available &lt;a href=&quot;https://prometheus.io/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Prometheus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Highly available &lt;a href=&quot;https://github.com/prometheus/alertmanager&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Alertmanager&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/prometheus/node_exporter&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Prometheus node-exporter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kubernetes-sigs/prometheus-adapter&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Prometheus Adapter for Kubernetes Metrics APIs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kubernetes/kube-state-metrics&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kube-state-metrics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://grafana.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Grafana&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自定安裝的話，也可以利用helm&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自訂安裝,&lt;a href=&quot;https://github.com/prometheus-community/helm-charts/blob/main/charts/kube-prometheus-stack/values.yaml&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;設定參考&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm install test prometheus-community/kube-prometheus-stack --namespace monitoring --create-namespace --values values.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/178-fig.1.jpg&quot; alt=&quot;178-fig.1.jpg&quot; /&gt;&lt;br /&gt;
上面指令使用test當關鍵字，所以部署時也會在上面增加&lt;/p&gt;
&lt;h1 id=&quot;補充&quot; tabindex=&quot;-1&quot;&gt;補充&lt;/h1&gt;
&lt;p&gt;如果不想自己架Prometheus，也不想用Google Cloud Monitor，&lt;br /&gt;
可以考慮Google自己出的 &lt;a href=&quot;https://cloud.google.com/stackdriver/docs/managed-prometheus?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Google Managed Prometheus 官方文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/prometheus-operator/kube-prometheus&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Github- kube-prometheus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.amis.com/kubernetes-operators-prometheus-3584edd72275&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Helm安裝 Prometheus Operator — 為 Kubernetes 設定及管理 Prometheus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/%E8%BC%95%E9%AC%86%E5%B0%8F%E5%93%81-pks%E8%88%87k8s%E7%9A%84%E9%BB%9E%E6%BB%B4/google-managed-prometheus-gmp-522a25572e35&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Google Managed Prometheus (GMP)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/👁 Observability/178. Install Prometheus Operator/" />
        </entry>
        <entry>
            <title>
                131. rabbitMQ on Prometheus
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/👁 Observability/131. rabbitMQ on Prometheus/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;最近demo環境發生問題，初步懷疑是MQ因為訊息量太大掛了。&lt;br /&gt;
但沒有證據，因為MQ的管理介面只能看到一小時的資料。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;本來用operator安裝完後，看了一些介紹都說要額外啓動外掛，&lt;br /&gt;
但operator要怎麼啓動外掛，我就兩眼一抹黑了。&lt;/p&gt;
&lt;p&gt;看到 &lt;a href=&quot;https://blog.csdn.net/yaomingyang/article/details/104037083&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;RabbitMQ學習筆記：內建Prometheus支援rabbit_prometheus外掛&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原來，我的MQ的15692 port 已經開了，prometheus已經設定好。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/131-fig.1.jpg&quot; alt=&quot;131-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;用curl去抓資料也有metrics，看來沒問題了。&lt;/p&gt;
&lt;p&gt;想說可以結案了，但是（就怕這個但是），裏面沒有queue的資料，&lt;br /&gt;
所以看不到每個queue的message rate&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/131-fig.2.jpg&quot; alt=&quot;131-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;撈了相關的metric裏面也沒有Queue的名稱，可供filter&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rabbitmq/rabbitmq-prometheus/blob/master/metrics.md&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;metrics說明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以，rabitMQ on k8s建好後，只要在prometheus寫個job就能去撈資料了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; - job_name: &#39;rabbitmq&#39;
   scrape_interval: 30s
   static_configs:
     - targets:
       - &#39;prod-rabbitmq.rabbitmq-system.svc.cluster.local:15692&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;prod-rabbitmq&lt;/code&gt; 指的是service name.&lt;/p&gt;
&lt;p&gt;然後，grafana dashboard可以用 &lt;a href=&quot;https://grafana.com/grafana/dashboards/10991-rabbitmq-overview/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;# RabbitMQ-Overview&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/131-fig.3.png&quot; alt=&quot;131-fig.3.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/👁 Observability/131. rabbitMQ on Prometheus/" />
        </entry>
        <entry>
            <title>
                124. grafana alert每四小時重發一次
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/👁 Observability/124. grafana alert每四小時重發一次/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;新的Grafana alert manage ，可調整的地方還真多阿..&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;告警上線後，只要告警狀態沒解除的話，他每4小時會重發一次。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/124-fig.1.jpg&quot; alt=&quot;124-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;到 Alerting 的 Notification policies ，設定Root policy&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/124-fig.2.jpg&quot; alt=&quot;124-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;展開 Timing options，設定 Repeat interval&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/124-fig.3.jpg&quot; alt=&quot;124-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref&lt;br /&gt;
- &lt;a href=&quot;https://community.grafana.com/t/unified-alerting-alert-triggers-every-4-hours/55053&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Unified Alerting: alert triggers every 4 hours&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/👁 Observability/124. grafana alert每四小時重發一次/" />
        </entry>
        <entry>
            <title>
                122. Grafana 8.X以後的alert 參數
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/👁 Observability/122. Grafana 8.X以後的alert 參數/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;新版的Grafana換了alert ,&lt;br /&gt;
現在把alert通通整合在一起了，&lt;/p&gt;
&lt;p&gt;然後我以前用的傳參數方法不能用了，&lt;br /&gt;
最近都在測試這個東西&lt;/p&gt;
&lt;h2 id=&quot;print-labels&quot; tabindex=&quot;-1&quot;&gt;Print Labels&lt;/h2&gt;
&lt;p&gt;如果在summary上面寫&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/122-fig.1.jpg&quot; alt=&quot;122-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;會印出此alert上面的預設labels標籤，&lt;/p&gt;
&lt;p&gt;下圖，是我自訂的標籤&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/122-fig.2.jpg&quot; alt=&quot;122-fig.2.jpg&quot; /&gt;&lt;br /&gt;
但實際印出來的都沒有出現&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/122-fig.3.jpg&quot; alt=&quot;122-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;陣列印出來後，就能夠指定名稱顯示了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/122-fig.4.jpg&quot; alt=&quot;122-fig.4.jpg&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;print-value&quot; tabindex=&quot;-1&quot;&gt;Print Value&lt;/h2&gt;
&lt;p&gt;這次改使用這個參數&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;會顯示 三個值。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/122-fig.5.jpg&quot; alt=&quot;122-fig.5.jpg&quot; /&gt;&lt;br /&gt;
設定所用的條件有兩個，&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%91%81%20Observability/122-fig.6.jpg&quot; alt=&quot;122-fig.6.jpg&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h2&gt;
&lt;p&gt;基本使用變數的方法，&lt;br /&gt;
如果要進階點，可能就需要改用alert template了。&lt;/p&gt;
&lt;p&gt;alert template參考下面網址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://community.grafana.com/t/how-to-use-alert-message-templates-in-grafana/67537&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How To Use Alert Message Templates in Grafana&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://grafana.com/docs/grafana/latest/alerting/manage-notifications/create-message-template/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Create and edit message templates&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;參考來源&quot; tabindex=&quot;-1&quot;&gt;參考來源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://grafana.com/docs/grafana/latest/alerting/fundamentals/annotation-label/variables-label-annotation/#templating-labels-and-annotations&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Templating labels and annotations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://grafana.com/docs/grafana/latest/alerting/fundamentals/annotation-label/how-to-use-labels/#grafana-reserved-labels&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Labels in Grafana Alerting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/👁 Observability/122. Grafana 8.X以後的alert 參數/" />
        </entry>
        <entry>
            <title>
                0.Observability MOC
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/👁 Observability/0.Observability MOC/</id>
            <content type="html">
                &lt;h1 id=&quot;概念&quot; tabindex=&quot;-1&quot;&gt;概念&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.github.io/404&quot;&gt;blog.45.網站效能指標一覽（未）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.github.io/404&quot;&gt;96. SRE監控的四大指標及SLI、SLO、SLA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%91%81%20Observability/195.%20SRE%E5%8F%AF%E8%A7%80%E6%B8%AC%E6%80%A7%E4%B8%89%E5%A4%A7%E6%94%AF%E6%9F%B1/&quot;&gt;195. SRE可觀測性三大支柱&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%91%81%20Observability/198.%20SRE%E5%A5%BD%E6%96%87%E9%80%A3%E7%B5%90/&quot;&gt;198. SRE好文連結&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;grafana&quot; tabindex=&quot;-1&quot;&gt;Grafana&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%91%81%20Observability/24.grafana%E8%A8%AD%E8%A8%88%E7%AF%87-%E7%AC%AC%E4%BA%8C%E5%80%8BY%E8%BB%B8/&quot;&gt;24.grafana設計篇-第二個Y軸&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%91%81%20Observability/25.%E5%9C%A8GKE%E4%B8%8A%E7%9A%84grafana%E4%B8%8A%E5%AE%89%E8%A3%9Dgrafana-image-renderer/&quot;&gt;25.在GKE上的grafana上安裝grafana-image-renderer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%91%81%20Observability/26.grafana%20alert%20message%20parameters%E5%82%B3%E5%85%A5/&quot;&gt;26.grafana alert message parameters傳入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%91%81%20Observability/28.Prometheus%E7%9A%84%E5%B0%88%E7%94%A8%E8%AA%9E%E8%A8%80promQL/&quot;&gt;28.Prometheus的專用語言promQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%91%81%20Observability/122.%20Grafana%208.X%E4%BB%A5%E5%BE%8C%E7%9A%84alert%20%E5%8F%83%E6%95%B8/&quot;&gt;122. Grafana 8.X以後的alert 參數&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%91%81%20Observability/124.%20grafana%20alert%E6%AF%8F%E5%9B%9B%E5%B0%8F%E6%99%82%E9%87%8D%E7%99%BC%E4%B8%80%E6%AC%A1/&quot;&gt;124. grafana alert每四小時重發一次&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%91%81%20Observability/184.%20grafana%20error%20%20reverse%20proxy%20settings%20on%20istio/&quot;&gt;184. grafana error  reverse proxy settings on istio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%91%81%20Observability/197.%20Grafana%20%E4%BB%A5%E5%8F%8APrometheus%20%E9%99%A4%E9%8C%AF%E6%96%B9%E5%BC%8F/&quot;&gt;197. Grafana 以及Prometheus 除錯方式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;prometheus&quot; tabindex=&quot;-1&quot;&gt;Prometheus&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%91%81%20Observability/131.%20rabbitMQ%20on%20Prometheus/&quot;&gt;131. rabbitMQ on Prometheus&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%91%81%20Observability/178.%20Install%20Prometheus%20Operator/&quot;&gt;178. Install Prometheus Operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%91%81%20Observability/179.%20%20install%20Bindplane/&quot;&gt;179.  install Bindplane&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/👁 Observability/0.Observability MOC/" />
        </entry>
        <entry>
            <title>
                32. nuxtJS 的 Dockerfile
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐳 Container/32. nuxtJS 的 Dockerfile/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;又多了一個新的套件要做，這次用的是nuxt.js ，只知道是vue.js延伸出來的東西...&lt;br /&gt;
然後，上吧。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;因 nuxt.js ，跟go有點像都會自己啟動一個伺服器的服務，&lt;br /&gt;
走的是SSR（Server-Side Rendering），&lt;br /&gt;
不是卡牌遊戲的SSR阿。&lt;br /&gt;
SSR的意思是，頁面由後端渲染，HTML由後端產生（據說是要讓速度比較快）&lt;br /&gt;
ref.&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10202217&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;02. 講歷史，話說 SSR...&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因為nuxt.js會自己建立一個js，&lt;br /&gt;
所以有踩到一個坑，&lt;br /&gt;
在設定 nuxt.config.js的時候，&lt;br /&gt;
請確認好port 以及 是不是開了https 。&lt;br /&gt;
建議先查一下 nuxt.config.js 的內容屬性，再來打包及佈署。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10207002&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;16. Nuxt 全域設定檔 (nuxt.config.js)，可以吃嗎？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這是第一個版本，使用npm編譯。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM node:11.13.0
COPY . /usr/src/nuxt-app/

RUN npm install
RUN npm run build:qa

EXPOSE 80

ENV NUXT_HOST=0.0.0.0
ENV NUXT_PORT=80

CMD [ &amp;quot;npm&amp;quot;, &amp;quot;start&amp;quot; ]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二個版本，改使用yarn安裝，這邊要注意，node版本，請抓最新的，不然編譯的時候會出現python錯誤。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  FROM node:16.3.0-alpine
  WORKDIR /usr/src/app

  COPY . .
  RUN yarn install &amp;amp;&amp;amp; yarn cache clean
  RUN yarn build
  CMD [ &amp;quot;yarn&amp;quot;, &amp;quot;start&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊只寫 yarn build ，是因為在設定nuxt的時候，有寫 build:qa 跟 build。&lt;br /&gt;
因為是最後測試完的成果了，就改用yarn build ，做結束。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://twblog.hongjianching.com/2020/06/14/yarn-install-lock-version-by-yarn.lock/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 yarn install 指令安裝套件時鎖定 yarn.lock 版本&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://hub.docker.com/_/node?tab=description&amp;amp;page=1&amp;amp;ordering=last_updated&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;docker-hub node&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🐳 Container/32. nuxtJS 的 Dockerfile/" />
        </entry>
        <entry>
            <title>
                29.Dockerfile echo something
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐳 Container/29.Dockerfile echo something/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;在幫人寫自動佈署的時候，發現以往的Docker會顯示畫面上的指令，&lt;br /&gt;
這次都沒有出來。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;解決方案，加上 --progress=plain&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  docker build --progress=plain -t ey:0.1 .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果沒有加的話，會像 (fig.1)，有加的話，則會像(fig.2)，將螢幕上的資料顯示出來&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  FROM gcr.io/cloud-builders/yarn:node-8.12.0 as build-env
  WORKDIR /app

  COPY . .
  RUN pwd
  RUN ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(fig.1)&lt;/p&gt;
&lt;p&gt;(fig.2)&lt;/p&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://stackoverflow.com/questions/64804749/docker-build-not-showing-any-output-from-commands&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Docker build not showing any output from commands&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🐳 Container/29.Dockerfile echo something/" />
        </entry>
        <entry>
            <title>
                170. Docker啓用GPU
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐳 Container/170. Docker啓用GPU/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡唸&quot; tabindex=&quot;-1&quot;&gt;睡睡唸&lt;/h1&gt;
&lt;p&gt;上面&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%B3%20Container/168.%20Docker%20build%E5%A4%B1%E6%95%97%E8%B7%B3%E5%87%BAkilled/&quot;&gt;168. Docker build失敗跳出killed&lt;/a&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%8C%90%20Network/169.%20Nginx%E7%9A%84%E8%B2%A0%E8%BC%89%E5%B9%B3%E8%A1%A1/&quot;&gt;169. Nginx的負載平衡&lt;/a&gt;，&lt;br /&gt;
這兩篇都是為了要達到內部AI平臺再用，&lt;br /&gt;
不要讓每個人的電腦都自己裝一堆程式。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;電腦裝完顯卡驅動後，要讓docker識別，&lt;br /&gt;
還需要額外裝  &lt;a href=&quot;https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;NVIDIA Container Toolkit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;照著官方文件來，挺快的。&lt;/p&gt;
&lt;p&gt;這邊記錄ubuntu的方法，其他的安裝方式，請參考上面文件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;更新&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg &#92;
  &amp;amp;&amp;amp; curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | &#92;
    sed &#39;s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g&#39; | &#92;
    sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list &#92;
  &amp;amp;&amp;amp; &#92;
    sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;安裝&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install -y nvidia-container-toolkit
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;docker設定 （containerd、CRI-O的話，參考上面連結）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo nvidia-ctk runtime configure --runtime=docker
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;重啓&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo systemctl restart containerd
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;驗證&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo docker run --rm --runtime=nvidia --gpus all ubuntu nvidia-smi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;顯示下面的資料就表示有了。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%B3%20Container/170-fig.1.jpg&quot; alt=&quot;170-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;docker-compose&quot; tabindex=&quot;-1&quot;&gt;Docker-compose&lt;/h2&gt;
&lt;p&gt;如果使用docker compose的話，&lt;br /&gt;
須在yaml上面增加一些設定，command 到 capabilities&lt;br /&gt;
當然也可以指定此container要吃第幾個gpu，&lt;br /&gt;
更詳細說明請參考&lt;a href=&quot;https://docs.docker.com/compose/gpu-support/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Turn on GPU access with Docker Compose&lt;/a&gt;&lt;br /&gt;
提示：主要在count的設定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version: &#39;3.8&#39;
services:
  python-1:
    container_name: yolox-brand-1
    image: busybox
    command: nvidia-smi
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: all
              capabilities: [gpu]
    pull_policy: if_not_present
    restart: always
    networks:
      - internal
networks:
  internal:
    name: internal
    driver: bridge
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/🐳 Container/170. Docker啓用GPU/" />
        </entry>
        <entry>
            <title>
                168. Docker build失敗跳出killed
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐳 Container/168. Docker build失敗跳出killed/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡唸&quot; tabindex=&quot;-1&quot;&gt;睡睡唸&lt;/h1&gt;
&lt;p&gt;內部要搞一個AI的開發平臺，&lt;br /&gt;
所以我負責python的負載平衡架構，&lt;br /&gt;
因爲他的程式開發好像有點困難，就用nginx的LB來做了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;驗證&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%8C%90%20Network/169.%20Nginx%E7%9A%84%E8%B2%A0%E8%BC%89%E5%B9%B3%E8%A1%A1/&quot;&gt;169. Nginx的負載平衡&lt;/a&gt;時，需要讓範例程式顯示一下請求的資訊，&lt;br /&gt;
確認真的有做到這塊。&lt;/p&gt;
&lt;p&gt;打包以前的舊AI程式時就暴掉了，&lt;br /&gt;
出現 killed的error。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; [6/8] RUN pip3 install torch torchvision torchaudio --index-url [https://download.pytorch.org/whl/cpu](https://download.pytorch.org/whl/cpu &amp;quot;https://download.pytorch.org/whl/cpu&amp;quot;):

1.293 Looking in indexes: [https://download.pytorch.org/whl/cpu](https://download.pytorch.org/whl/cpu &amp;quot;https://download.pytorch.org/whl/cpu&amp;quot;) 2.901 Collecting torch 2.917 Downloading [https://download.pytorch.org/whl/cpu/torch-2.0.1%2Bcpu-cp38-cp38-linux_x86_64.whl](https://download.pytorch.org/whl/cpu/torch-2.0.1%2Bcpu-cp38-cp38-linux_x86_64.whl &amp;quot;https://download.pytorch.org/whl/cpu/torch-2.0.1%2Bcpu-cp38-cp38-linux_x86_64.whl&amp;quot;) (195.4 MB) 11.30 Killed ------ Dockerfile:25 -------------------- 23 | RUN apt-get update &amp;amp;&amp;amp; apt-get install -y enchant &amp;amp;&amp;amp; apt-get install -y python3.7 python3-pip libgl1 &amp;amp;&amp;amp; apt-get clean &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/* 24 | RUN pip3 install --upgrade pip 25 | &amp;gt;&amp;gt;&amp;gt; RUN pip3 install torch torchvision torchaudio --index-url [https://download.pytorch.org/whl/cpu](https://download.pytorch.org/whl/cpu &amp;quot;https://download.pytorch.org/whl/cpu&amp;quot;) 26 | RUN pip3 install paddlepaddle==2.4.2 -i [https://mirror.baidu.com/pypi/simple](https://mirror.baidu.com/pypi/simple &amp;quot;https://mirror.baidu.com/pypi/simple&amp;quot;) 27 | RUN pip3 install --no-cache-dir -r requirements.txt -------------------- ERROR: failed to solve: process &amp;quot;/bin/sh -c pip3 install torch torchvision torchaudio --index-url [https://download.pytorch.org/whl/cpu](https://download.pytorch.org/whl/cpu &amp;quot;https://download.pytorch.org/whl/cpu&amp;quot;)&amp;quot; did not complete successfully: exit code: 137
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查了一下，說是因爲記憶體不足導致docker build的時候暴掉。&lt;br /&gt;
ref. &lt;a href=&quot;https://github.com/pytorch/pytorch/issues/6935&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;PyTorch Docker build error&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`Killed` means that the compiler was killed by the kernel because it used too much memory. There are a few workarounds:

- increase the memory limit for docker container
- limit the number of concurrent builds by changing the `Dockerfile` to include `MAX_JOBS=1` [here](https://github.com/pytorch/pytorch/blob/master/docker/pytorch/Dockerfile#L30)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把我的docker resource 的記憶體資源加大後就好了（我mac記憶體只有16G)。&lt;/p&gt;
&lt;p&gt;[[168-fig.1.jpg]]&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🐳 Container/168. Docker build失敗跳出killed/" />
        </entry>
        <entry>
            <title>
                157. Docker NGINX-Certbot 自動跟Let&#39;sEncrytp取得憑證
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐳 Container/157. Docker NGINX-Certbot 自動跟Let&#39;sEncrytp取得憑證/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;前人很強，很厲害，喜歡自己動手，&lt;br /&gt;
所以他當初造的自動取得Let&#39;s Encrypt的程式，都是自己寫一整套來用。&lt;br /&gt;
然後，交接了整套，但程式沒人知道在幹嘛，只有每次出問題時，&lt;br /&gt;
會去翻API看是要先call哪個，再call哪個，然後再重開某些image&lt;br /&gt;
才能正確取得，身爲一個懶人，跟腦細胞容量過小的我，實在記不住阿，&lt;br /&gt;
只好改了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h2 id=&quot;docker-k8s-cert-manage&quot; tabindex=&quot;-1&quot;&gt;這個只適合Docker，k8s請改用cert-manage&lt;/h2&gt;
&lt;p&gt;使用說明&lt;/p&gt;
&lt;p&gt;我這邊是掛載user_conf.d 到 /etc/nginx/user_conf.d ，&lt;br /&gt;
user_conf.d就是設定檔存放的位置。&lt;/p&gt;
&lt;p&gt;docker-compose.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version: &#39;3&#39;

services:
  nginx:
    image: jonasal/nginx-certbot:latest
    container_name: nginx
    restart: unless-stopped
    networks:
      - cicd_net
    env_file:
      - ./nginx-certbot.env
    ports:
      - 80:80
      - 443:443
    volumes:
      - nginx_secrets:/etc/letsencrypt
      - ./user_conf.d:/etc/nginx/user_conf.d

volumes:
  nginx_secrets:

# 跟drone servere掛在同一層
networks:
  cicd_net:
    name: cicd_net
    driver: bridge  

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;記得更改email，不然啓動會失敗&lt;br /&gt;
nginx-certbot.env&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Required
CERTBOT_EMAIL=&amp;lt;email&amp;gt;

# Optional (Defaults)
DHPARAM_SIZE=2048
ELLIPTIC_CURVE=secp256r1
RENEWAL_INTERVAL=8d
RSA_KEY_SIZE=2048
STAGING=0
USE_ECDSA=1

# Advanced (Defaults)
CERTBOT_AUTHENTICATOR=webroot
CERTBOT_DNS_PROPAGATION_SECONDS=&amp;quot;&amp;quot;
DEBUG=0
USE_LOCAL_CA=0

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;user_conf.d資料夾內的檔案名稱&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
    # Listen to port 443 on both IPv4 and IPv6.
    listen 443 ssl http2;
    listen [::]:443 ssl http2;

    # Domain names this server should respond to.
    server_name otpat.domain.com;

    # Load the certificate files.
    ssl_certificate         /etc/letsencrypt/live/otpat-domain-com/fullchain.pem;
    ssl_certificate_key     /etc/letsencrypt/live/otpat-domain-com/privkey.pem;
    ssl_trusted_certificate /etc/letsencrypt/live/otpat-domain-com/chain.pem;

    ssl_protocols             TLSv1.3 TLSv1.2;
    ssl_prefer_server_ciphers on;
    ssl_ecdh_curve            X25519:secp521r1:secp384r1;
    ssl_ciphers               TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    ssl_session_cache         shared:TLS:2m;
    ssl_buffer_size           4k;

    # OCSP stapling
    ssl_stapling on;
    ssl_stapling_verify on;
    resolver 1.1.1.1 1.0.0.1 [2606:4700:4700::1111] [2606:4700:4700::1001]; # Cloudflare

   # return 200 &#39;Let&#92;&#39;s Encrypt certificate successfully installed!&#39;;
   # add_header Content-Type text/plain;

   location / {
        proxy_set_header X-Forwarded-For $remote_addr;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Host $http_host;

        proxy_pass http://totp-auth:9987;

        proxy_redirect off;
        proxy_http_version 1.1;
        proxy_buffering off;

        chunked_transfer_encoding off;
    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成品，因為要將proxy_pass導到服務上面，最好是設成同一個network，這邊設為 cicd_net&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%B3%20Container/157-fig.1.jpg&quot; alt=&quot;157-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果啓動失敗的話，&lt;br /&gt;
可以查一下nginx裏面的錯誤訊息，上面通常寫的很清楚。&lt;/p&gt;
&lt;p&gt;建議可以先看看這兩篇&lt;br /&gt;
ref.&lt;br /&gt;
- &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10301801&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;D15 - NGINX-Certbot Image&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://github.com/JonasAlfredsson/docker-nginx-certbot/blob/master/docs/good_to_know.md&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;github_good_to_know&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🐳 Container/157. Docker NGINX-Certbot 自動跟Let&#39;sEncrytp取得憑證/" />
        </entry>
        <entry>
            <title>
                154. PaddlePaddle 打包image
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐳 Container/154. PaddlePaddle 打包image/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;這次的AI程式又更特別了，&lt;br /&gt;
一堆不相容的套件，&lt;br /&gt;
RD是在windows上開發，要包成image一堆牆，嘖嘖。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;libGL.so.1&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;apt-get install libgl1
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;pycocotools&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這個好解決，直接在requirements.txt上面增加 pycocotools&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Paddle&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;pip3 install paddlepaddle==2.4.2 -i https://mirror.baidu.com/pypi/simple
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Paddle安裝失敗&lt;br /&gt;
這個就真的機車了，後來查是因爲paddle，不支援alpine linux，&lt;br /&gt;
最後只好裝在ubuntu上面。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://github.com/PaddlePaddle/Paddle/issues/30247&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;github issue&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;torch&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cpu
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-Dockerfile&quot;&gt;FROM ubuntu:20.04
ENV PATH &amp;quot;$PATH:/usr/local/bin&amp;quot;
WORKDIR /usr/local/app
COPY . /usr/local/app

RUN apt-get update &amp;amp;&amp;amp; apt-get install -y enchant &amp;amp;&amp;amp; apt-get install -y  python3.7 python3-pip libgl1 &amp;amp;&amp;amp; apt-get clean &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*
RUN pip3 install --upgrade pip
RUN pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cpu
RUN pip3 install paddlepaddle==2.4.2 -i https://mirror.baidu.com/pypi/simple
RUN pip3 install --no-cache-dir -r requirements.txt 
ENTRYPOINT [&amp;quot;gunicorn&amp;quot;,&amp;quot;-c&amp;quot; ,&amp;quot;gunicorn_config.py&amp;quot;,&amp;quot;wsgi:app&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/🐳 Container/154. PaddlePaddle 打包image/" />
        </entry>
        <entry>
            <title>
                152. 硬碟空間不足，無法進入容器
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐳 Container/152. 硬碟空間不足，無法進入容器/</id>
            <content type="html">
                &lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%B3%20Container/152.%20%E7%A1%AC%E7%A2%9F%E7%A9%BA%E9%96%93%E4%B8%8D%E8%B6%B3%EF%BC%8C%E7%84%A1%E6%B3%95%E9%80%B2%E5%85%A5%E5%AE%B9%E5%99%A8/#2024-07-16-docker-compose&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#2024/07/16，docker&quot;&gt;#2024/07/16，docker&lt;/a&gt; compose設定方法&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;上週同事問我怎麼連進去容器裏面，&lt;br /&gt;
我很順的回答指令，&lt;br /&gt;
然後他就跳出 這個錯誤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;failed to create runc console socket: mkdir /tmp/pty2070058578: no space left on device: unknown&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;處理問題&quot; tabindex=&quot;-1&quot;&gt;處理問題&lt;/h3&gt;
&lt;p&gt;從錯誤訊息看起來，就是空間不足。&lt;/p&gt;
&lt;p&gt;先看看是哪邊硬碟吃滿了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;df -h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後看到user 100%...然後掛載在 / 根目錄下。&lt;br /&gt;
再來檢查當前目錄，每個資料夾的大小&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;du -hcd 1 | sort -n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最後追阿追的，追到了container的目錄&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/var/lib/docker/&lt;br /&gt;
裏面有一些container容量吃得很多，&lt;br /&gt;
最後確認是該container的log，那就砍了吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;rm -rf &amp;lt;container_id&amp;gt;.log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再請同事連線，還是出現同樣的錯誤，&lt;br /&gt;
是由於linux的特性，就算你砍了檔案，&lt;br /&gt;
此檔案還是被咬住沒有釋放開(window是連砍都不能砍)，&lt;br /&gt;
所以此時去查硬碟大小，還是100% used的狀態，&lt;br /&gt;
將docker重開後，就能釋放空間了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;解決問題&quot; tabindex=&quot;-1&quot;&gt;解決問題&lt;/h3&gt;
&lt;p&gt;現在知道是container的log會一直增長，&lt;br /&gt;
那就設個條件，讓他長到一定程度後就不能再長大了。&lt;/p&gt;
&lt;p&gt;如果此路徑沒檔案，則建立&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;vim /etc/docker/daemon.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;輸入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
    &amp;quot;log-driver&amp;quot;:&amp;quot;json-file&amp;quot;,
    &amp;quot;log-opts&amp;quot;:{
        &amp;quot;max-size&amp;quot; :&amp;quot;500m&amp;quot;,&amp;quot;max-file&amp;quot;:&amp;quot;3&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;max-size : 單個容器的單檔大小&lt;br /&gt;
max-file: log數量&lt;/p&gt;
&lt;p&gt;好了後，重啓服務&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;systemctl daemon-reload
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是：設定的日誌大小規則，只對新建的容器有效&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/sxdcgaq8080/p/10689223.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;【docker】docker限制記錄檔大小的方法+查看記錄檔的方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/594e0a2af6f2&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;docker 報錯： failed to create runc console socket: mkdir /tmp/pty328598598: no space left on device&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2024-07-16-docker-compose&quot; tabindex=&quot;-1&quot;&gt;2024/07/16，docker compose設定方法&lt;/h3&gt;
&lt;p&gt;在docker compose 增加下面語法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;services:
  srs:
    container_name: srs
    logging:
      driver: &amp;quot;json-file&amp;quot;
      options:
        max-size: &amp;quot;300m&amp;quot;
        max-file: &amp;quot;3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/🐳 Container/152. 硬碟空間不足，無法進入容器/" />
        </entry>
        <entry>
            <title>
                138. gerapy+scrapyd+mongo爬蟲整套流程
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐳 Container/138. gerapy+scrapyd+mongo爬蟲整套流程/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;有一天突然發現，我的爬蟲不會動了，原因是網站改版，所以規則要改。&lt;br /&gt;
於是，既然都要改了，那就把很久以前沒有概念的docker都改一改吧，&lt;br /&gt;
順便改成docker compose一次解決。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;更新，後來也沒用這套了，他在排程執行時有點問題，&lt;br /&gt;
最後還是回本來的scrapyweb+scrapyd+mongoDB，&lt;br /&gt;
請見文章最後的Docker-compose.yaml&lt;/p&gt;
&lt;h2 id=&quot;架設服務&quot; tabindex=&quot;-1&quot;&gt;架設服務&lt;/h2&gt;
&lt;p&gt;docker-compose.yml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version: &#39;3&#39;
services:
  scrapyd:
    container_name: scrapyd
    image: vimagick/scrapyd
    volumes:
      - ./data:/var/lib/scrapyd
      - /usr/local/lib/python3.7/dist-packages
    restart: unless-stopped
    networks:
      - scrapy_net  
  gerapy:
    container_name: gerapy
    image: germey/gerapy
    volumes:
      - ./gerapy:/app/gerapy
    ports:
      - 8000:8000
    networks:
      - scrapy_net    
  mongo:
    container_name: mongo
    image: mongo:latest
    restart: always
    volumes:
      - ./mongodbdata:/data/db
    environment:
      MONGO_INITDB_ROOT_USERNAME: daimomadmin
      MONGO_INITDB_ROOT_PASSWORD: d@imom
    networks:
      - scrapy_net
    ports:
      - 27017:27017
  mongo-express:
      container_name: mongo-express
      image: mongo-express
      restart: always
      ports:
        - 8081:8081
      environment:
        ME_CONFIG_MONGODB_SERVER: 192.168.1.78
        ME_CONFIG_MONGODB_PORT: 27017
        ME_CONFIG_MONGODB_ADMINUSERNAME: daimomadmin
        ME_CONFIG_MONGODB_ADMINPASSWORD: d%40imom
      networks:
      - scrapy_net  
networks:
  scrapy_net:
    name: scrapy
    driver: bridge
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker compose up -d
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;注意事項&quot; tabindex=&quot;-1&quot;&gt;注意事項&lt;/h3&gt;
&lt;p&gt;mongo-express 底下的  ME_CONFIG_MONGODB_ADMINPASSWORD&lt;br /&gt;
為什麼會出現 %40？&lt;/p&gt;
&lt;p&gt;因為直接用@ 會出現錯誤。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;UnhandledPromiseRejectionWarning: MongoParseError: Unescaped at-sign in authority section&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是chatGPT的回答&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%B3%20Container/138-fig.1.jpg&quot; alt=&quot;138-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;gerapy&quot; tabindex=&quot;-1&quot;&gt;設定gerapy&lt;/h2&gt;
&lt;p&gt;如果是根據上面的docker compose建立的話，&lt;br /&gt;
網址用 localhost:8000登入，&lt;br /&gt;
預設的帳密是 admin/admin，進去後最好改一下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;設定 scrapyd的位置，在同一個network裏面，&lt;br /&gt;
所以能這樣互打。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%B3%20Container/138-fig.2.jpg&quot; alt=&quot;138-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;上傳專案&lt;br /&gt;
這邊要注意，上傳的壓縮檔案裏面要有『  .cfg』的檔案&lt;br /&gt;
檔案結構如下&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%B3%20Container/138-fig.3.jpg&quot; alt=&quot;138-fig.3.jpg&quot; /&gt;&lt;br /&gt;
壓縮的時候，請針對上層目錄直接壓縮，以上圖來說就是壓縮TaazeSpider這個資料夾。&lt;br /&gt;
上傳完後，可以按Edit，可以看到程式。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%B3%20Container/138-fig.4.jpg&quot; alt=&quot;138-fig.4.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;部署到主機上&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%B3%20Container/138-fig.5.jpg&quot; alt=&quot;138-fig.5.jpg&quot; /&gt;&lt;br /&gt;
必須先build，然後才可以deploy到主機上&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%B3%20Container/138-fig.6.jpg&quot; alt=&quot;138-fig.6.jpg&quot; /&gt;&lt;br /&gt;
如果碰到打包失敗或是部署失敗，可以到主機上看一下log。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker logs gerapy
docker logs scrapyd
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;測試運作&lt;br /&gt;
到主機的設定畫面，選擇schedule ，然後按下run 跑跑看有沒有正常。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%B3%20Container/138-fig.7.jpg&quot; alt=&quot;138-fig.7.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%B3%20Container/138-fig.9.jpg&quot; alt=&quot;138-fig.9.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;設定排程&lt;br /&gt;
Name : 隨意&lt;br /&gt;
Project ：projects的名稱&lt;br /&gt;
Spider：在Schedule的名稱，可參考上圖&lt;br /&gt;
Clients：主機名稱，可以用選的&lt;br /&gt;
Trigger：crontab 是固定的時間執行&lt;br /&gt;
interval 是 隔多久執行&lt;br /&gt;
date 是 特定日期&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%B3%20Container/138-fig.8.jpg&quot; alt=&quot;138-fig.8.jpg&quot; /&gt;&lt;br /&gt;
好了後可以按下status，可以看到下次執行時間，從這看有沒有設定成功。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%B3%20Container/138-fig.11.jpg&quot; alt=&quot;138-fig.11.jpg&quot; /&gt;&lt;br /&gt;
這邊可以看到 Next time的時間&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%B3%20Container/138-fig.10.jpg&quot; alt=&quot;138-fig.10.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://github.com/Gerapy/Gerapy/issues/176&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;docker部署打包失敗&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://github.com/Gerapy/Gerapy&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gerapy&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://www.w3schools.com/cssref/css_selectors.php&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;CSS Selector Reference&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;scrapyweb-scrapyd&quot; tabindex=&quot;-1&quot;&gt;Scrapyweb+scrapyd&lt;/h2&gt;
&lt;p&gt;最後還是用回這套了，&lt;br /&gt;
穩定度大勝，db的帳號密碼，必須與爬蟲一致&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;
version: &#39;3&#39;
services:
  scrapyd:
    container_name: scrapyd
    image: germey/scrapyd
    volumes:
      - ./data:/var/lib/scrapyd
      - /usr/local/lib/python3.7/dist-packages
    restart: unless-stopped
    networks:
      - scrapy_net  
  scrapydweb:
      container_name: scrapydweb
      image: ryanvin/scrapydweb
      depends_on:
        - scrapyd
      ports:
        - 5000:5000
      environment:
        USERNAME: daiomom
        PASSWORD: password
        SCRAPYD_SERVERS: scrapyd
      volumes:
        - ./scrapydweb_data:/app
      networks:
        - scrapy_net            
  mongo:
    container_name: mongo
    image: mongo:latest
    restart: always
    volumes:
      - ./mongodbdata:/data/db
    environment:
      MONGO_INITDB_ROOT_USERNAME: daimomadmin
      MONGO_INITDB_ROOT_PASSWORD: password
    networks:
      - scrapy_net
    ports:
      - 27017:27017
  mongo-express:
      container_name: mongo-express
      image: mongo-express
      restart: always
      ports:
        - 8081:8081
      environment:
        ME_CONFIG_MONGODB_SERVER: 192.168.1.78
        ME_CONFIG_MONGODB_PORT: 27017
        ME_CONFIG_MONGODB_ADMINUSERNAME: daimomadmin
        ME_CONFIG_MONGODB_ADMINPASSWORD: password
      networks:
      - scrapy_net  
networks:
  scrapy_net:
    name: scrapy
    driver: bridge
    
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/🐳 Container/138. gerapy+scrapyd+mongo爬蟲整套流程/" />
        </entry>
        <entry>
            <title>
                115. .net core 打包dockerfile
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐳 Container/115. .net core 打包dockerfile/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;今天才知道vistual studio 的神奇地方，&lt;br /&gt;
直接滑鼠按一按，dockerfile就自動產生了，&lt;br /&gt;
也不用寫，不過不是vs code的版本。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-dockerfile&quot;&gt;FROM mcr.microsoft.com/dotnet/aspnet:3.1 AS base
RUN apt-get update -y &amp;amp;&amp;amp; apt-get install -y libc6-dev libgdiplus libx11-dev &amp;amp;&amp;amp; apt-get clean &amp;amp;&amp;amp; ln -s /usr/lib/libgdiplus.so /usr/lib/gdiplus.dll
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/sdk:3.1 AS build
WORKDIR /src
COPY ./**/*.csproj ./
# RUN pwd &amp;amp;&amp;amp; ls -ahl
RUN for file in $(ls *.csproj); do mkdir -p ./${file%.*}/ &amp;amp;&amp;amp; mv $file ./${file%.*}/; done
# RUN pwd &amp;amp;&amp;amp; ls SystemManageService.Backend -ahl
RUN dotnet restore SystemManageService.Backend/SystemManageService.Backend.csproj

COPY . .
RUN dotnet build SystemManageService.Backend/SystemManageService.Backend.csproj -c Release -o /app/build



FROM build AS publish
RUN dotnet publish SystemManageService.Backend/SystemManageService.Backend.csproj -c Release -o /app/publish



FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
RUN ls

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊的重點在這兩段，取得專案內所有的csproj，然後丟進去build的image裏面。&lt;br /&gt;
但是，這樣並不會根據資料夾放到其他特定的地方，&lt;br /&gt;
所以才有for file建立資料夾跟移動檔案。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;COPY ./**/*.csproj ./
# RUN pwd &amp;amp;&amp;amp; ls -ahl
RUN for file in $(ls *.csproj); do mkdir -p ./${file%.*}/ &amp;amp;&amp;amp; mv $file ./${file%.*}/; done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一行重點，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM mcr.microsoft.com/dotnet/aspnet:3.1 AS base
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此image不能拿掉，一定要有一個base的，&lt;br /&gt;
不然在開發的時候，每次都會重build一次image&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.tencent.com/developer/article/1624727&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;.NET Core Docker 再也不用逐個 COPY csproj 檔案啦！&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🐳 Container/115. .net core 打包dockerfile/" />
        </entry>
        <entry>
            <title>
                112. pyenchant &amp; opencc error fix
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐳 Container/112. pyenchant &amp; opencc error fix/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;新公司的第一個dockerfile就撞牆，&lt;br /&gt;
莫名的錯誤，裝了還是過不了，&lt;br /&gt;
寫這個程式的說也沒用過，他們都是用本機跑AI。&lt;br /&gt;
只好自己亂搞了..&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;debug方式，都是直接去翻python的程式碼看裏面的內容。&lt;br /&gt;
這兩個大部分都用 ctypes.util.find_library  去找library。&lt;br /&gt;
然後程式內都有寫額外條件，當find_library找不到時，&lt;br /&gt;
可以從環境變數取值。&lt;br /&gt;
所以下面都是使用環境變數的方式，讓package能夠取得library。&lt;/p&gt;
&lt;h3 id=&quot;python-debug&quot; tabindex=&quot;-1&quot;&gt;python debug時的備忘事項&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;python3 package 的位置在 /usr/local/lib/python3.10/site-packages&lt;/li&gt;
&lt;li&gt;find_library，根據同事的說法，應該是抓path的路徑下去做搜尋&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然後開始看code吧。&lt;/p&gt;
&lt;h3 id=&quot;alpine-linux-enchant&quot; tabindex=&quot;-1&quot;&gt;alpine linux安裝enchant&lt;/h3&gt;
&lt;p&gt;解決  &#39;enchant&#39; C library was not found&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ImportError: The &#39;enchant&#39; C library was not found and maybe needs to be installed.
See  https://pyenchant.github.io/pyenchant/install.html
for details

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其實有安裝 py3-enchant 就好了，&lt;br /&gt;
後續是因為找不到library才會噴錯。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apk add py3-enchant aspell aspell-en
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以設定一下環境變數，收工。&lt;br /&gt;
下面程式是dockerfile用的，如果要測試就把env改成export吧&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ENV PYENCHANT_LIBRARY_PATH=/usr/lib/libenchant-2.so.2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://github.com/pyenchant/pyenchant/issues/265&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Cannot find Enchant C library on Apple Silicon&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;alpine-linux-opencc&quot; tabindex=&quot;-1&quot;&gt;alpine linux 安裝opencc&lt;/h3&gt;
&lt;p&gt;解決 libopencc.so.1 : No such file&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Traceback (most recent call last):
  File &amp;quot;/usr/local/app/Speech_control.py&amp;quot;, line 3, in &amp;lt;module&amp;gt;
    from opencc import OpenCC
  File &amp;quot;/usr/local/lib/python3.10/site-packages/opencc.py&amp;quot;, line 24, in &amp;lt;module&amp;gt;
    libopencc = CDLL(&#39;libopencc.so.1&#39;, use_errno=True)
  File &amp;quot;/usr/local/lib/python3.10/ctypes/__init__.py&amp;quot;, line 374, in __init__
    self._handle = _dlopen(self._name, mode)
OSError: Error loading shared library libopencc.so.1: No such file or directory
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%B3%20Container/blog.112.fig-1.jpg&quot; alt=&quot;blog.112.fig-1.jpg&quot; /&gt;&lt;br /&gt;
因為opencc在 repository的testing上面，&lt;br /&gt;
用下面的方法裝&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apk add opencc --repository=http://dl-cdn.alpinelinux.org/alpine/edge/testing/

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;好了後設定環境變數(這是dockerfile用的)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ENV LIBOPENCC=/usr/lib/libopencc.so.1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;dockerfile&quot; tabindex=&quot;-1&quot;&gt;完整dockerfile&lt;/h3&gt;
&lt;p&gt;這個alpine linux , build出來 181.73MB&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM python:alpine3.16
ENV PATH &amp;quot;$PATH:/usr/local/bin&amp;quot;
WORKDIR /usr/local/app
RUN apk update &amp;amp;&amp;amp; apk add py3-enchant aspell aspell-en  &amp;amp;&amp;amp; apk add opencc --repository=http://dl-cdn.alpinelinux.org/alpine/edge/testing/
ENV LIBOPENCC=/usr/lib/libopencc.so.1.1
ENV PYENCHANT_LIBRARY_PATH=/usr/lib/libenchant-2.so.2
COPY ./Chatbot_Speech /usr/local/app
RUN pip3 install --upgrade pip
RUN pip3 install --no-cache-dir -r requirements.txt
ENTRYPOINT [&amp;quot;python&amp;quot;, &amp;quot;Speech.py&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用ubuntu ,build 出來 511.74MB，&lt;br /&gt;
本來是6xx，後來清了一下cache，縮減一下步驟後，才變成511MB&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM ubuntu:20.04
ENV PATH &amp;quot;$PATH:/usr/local/bin&amp;quot;
WORKDIR /usr/local/app
COPY ./Chatbot_Speech /usr/local/app
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y enchant &amp;amp;&amp;amp; apt-get install -y  python3.6 python3-pip &amp;amp;&amp;amp; apt-get clean &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*
RUN pip3 install --upgrade pip
RUN pip3 install --no-cache-dir -r requirements.txt 
ENTRYPOINT [&amp;quot;python3&amp;quot;, &amp;quot;Speech.py&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10246952&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; 最佳化 Dockerfile - 精簡 image&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🐳 Container/112. pyenchant &amp; opencc error fix/" />
        </entry>
        <entry>
            <title>
                0.Container MOC
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐳 Container/0.Container MOC/</id>
            <content type="html">
                &lt;h1 id=&quot;docker-debug&quot; tabindex=&quot;-1&quot;&gt;Docker Debug&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%B3%20Container/29.Dockerfile%20echo%20something/&quot;&gt;29.Dockerfile echo something&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%B3%20Container/152.%20%E7%A1%AC%E7%A2%9F%E7%A9%BA%E9%96%93%E4%B8%8D%E8%B6%B3%EF%BC%8C%E7%84%A1%E6%B3%95%E9%80%B2%E5%85%A5%E5%AE%B9%E5%99%A8/&quot;&gt;152. 硬碟空間不足，無法進入容器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%B3%20Container/168.%20Docker%20build%E5%A4%B1%E6%95%97%E8%B7%B3%E5%87%BAkilled/&quot;&gt;168. Docker build失敗跳出killed&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;dockerfile&quot; tabindex=&quot;-1&quot;&gt;Dockerfile&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%B3%20Container/32.%20nuxtJS%20%E7%9A%84%20Dockerfile/&quot;&gt;32. nuxtJS 的 Dockerfile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%B3%20Container/112.%20pyenchant%20&amp;%20opencc%20error%20fix/&quot;&gt;112. pyenchant &amp;amp; opencc error fix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%B3%20Container/115.%20.net%20core%20%E6%89%93%E5%8C%85dockerfile/&quot;&gt;115. .net core 打包dockerfile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%B3%20Container/138.%20gerapy+scrapyd+mongo%E7%88%AC%E8%9F%B2%E6%95%B4%E5%A5%97%E6%B5%81%E7%A8%8B/&quot;&gt;138. gerapy+scrapyd+mongo爬蟲整套流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%B3%20Container/170.%20Docker%E5%95%93%E7%94%A8GPU/&quot;&gt;170. Docker啓用GPU&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🐳 Container/0.Container MOC/" />
        </entry>
        <entry>
            <title>
                php exec ssh 發生 Host key verification failed 錯誤
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/php exec ssh 發生 Host key verification failed 錯誤/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;前幾天一直在找php的exec坑，&lt;br /&gt;
最後終於解了，&lt;br /&gt;
記錄一下。&lt;/p&gt;
&lt;p&gt;正文&lt;br /&gt;
首先來段code，&lt;br /&gt;
這段的用途是要把 檔案從A 複製到 B ，&lt;br /&gt;
如果直接在A執行 scp 的指令，是正常的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
exec(&amp;quot;scp -i /var/www/.ssh/id_rsa -r /var/www/html/WebService/upload/tmp/fe8abe8e88fb3a2d88cc17a45a7575b1.png www-data@10.7.0.17:/var/www/html/tmp/ 2&amp;gt;&amp;amp;1&amp;quot;, $output, $return_var);
print_r($output);
echo &amp;quot;return&amp;quot; .$return_var;
echo &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
exec(&amp;quot;ssh -i /var/www/.ssh/id_rsa www-data@10.7.0.17 2&amp;gt;&amp;amp;1&amp;quot;, $output,$return_var);
print_r($output);
echo &amp;quot;return:&amp;quot;.$return_var;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這段程式，有額外加上 2&amp;gt;&amp;amp;1  這是將錯誤印出來的方式&lt;/p&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;使用 2&amp;gt;&amp;amp;1, 命令就會輸出shell執行時的錯誤到$output變量, 輸出該變量即可分析。&lt;br /&gt;
備註: exec有3個參數，第一個是要執行的命令，第二個是參數是一個數組，數組的值是由第一個命令執行後生成的，第三個參數執行的狀態，0表示成功，其他都表示失敗。&lt;/p&gt;
&lt;p&gt;(ref. &lt;a href=&quot;https://blog.csdn.net/zy112289/article/details/52671373&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://blog.csdn.net/zy112289/article/details/52671373&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;然後終於有錯誤訊息了，這個錯誤卻讓我很慌....&lt;br /&gt;
Host key verification failed&lt;/p&gt;
&lt;p&gt;查了一下是驗證的錯誤，都說基本上就是刪除 known_host 就好了。&lt;br /&gt;
但刪了主機、本機都一樣&lt;br /&gt;
(ref. &lt;a href=&quot;https://blog.csdn.net/iteye_19045/article/details/103704924&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://blog.csdn.net/iteye_19045/article/details/103704924&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;使用find 去尋找所有的*.pub檔案，根據裡面的內容做修改，並在主機及本機加上權限&lt;br /&gt;
(ref. &lt;a href=&quot;https://xenby.com/b/220-%E6%95%99%E5%AD%B8-%E7%94%A2%E7%94%9Fssh-key%E4%B8%A6%E4%B8%94%E9%80%8F%E9%81%8Ekey%E9%80%B2%E8%A1%8C%E5%85%8D%E5%AF%86%E7%A2%BC%E7%99%BB%E5%85%A5&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://xenby.com/b/220-教學-產生ssh-key並且透過key進行免密碼登入&lt;/a&gt;)&lt;br /&gt;
/var/www/.ssh/id_rsa，有參照之前主機設定，權限設定成 www-data（此時我沒注意到，另一個關鍵點）。&lt;/p&gt;
&lt;p&gt;解決方案&lt;br /&gt;
1.先登入最高權限&lt;br /&gt;
sudo -i&lt;br /&gt;
2.切換成www-data&lt;br /&gt;
su www-data&lt;br /&gt;
3.先連線&lt;br /&gt;
ssh 10.7.0.17&lt;/p&gt;
&lt;p&gt;釐清原因&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一開始我以為只要是使用者帳號，都應該會在 home底下有使用者的資料夾，但不知道www-data，&lt;br /&gt;
不會建立這個資料夾，預設截取 /var/www/.ssh的 id_rsa&lt;/li&gt;
&lt;li&gt;exec 可能讀不到 /var/www/.ssh/id_rsa 的檔案&lt;/li&gt;
&lt;li&gt;ssh的機制是這樣的，假設A要連線到B，要連線的話，須將 A的 .pub 金鑰，複製到B的 authorized_keys。&lt;br /&gt;
第一次進入時，會將A金鑰記憶再B的known_host上，讓日後A可以快速連線。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，只要連線過一次，就會記憶目前的金鑰到主機上，日後就能夠直接使用IP連線&lt;br /&gt;
程式會像以下，不再需要-i ，預設就會抓id_rsa來使用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&amp;lt;?php
exec(&amp;quot;scp -r /var/www/html/WebService/upload/tmp/fe8abe8e88fb3a2d88cc17a45a7575b1.png 10.7.0.17:/var/www/html/tmp/ 2&amp;gt;&amp;amp;1&amp;quot;, $output, $return_var);
print_r($output);
echo &amp;quot;return&amp;quot; .$return_var;
echo &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
exec(&amp;quot;ssh  10.7.0.17 2&amp;gt;&amp;amp;1&amp;quot;, $output,$return_var);
print_r($output);
echo &amp;quot;return:&amp;quot;.$return_var;
?&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/php exec ssh 發生 Host key verification failed 錯誤/" />
        </entry>
        <entry>
            <title>
                93. shellscript解析
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/93. shellscript解析/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
F=&amp;quot;proxy-linux-amd64.tar.gz&amp;quot;
set -e
if [ -e /tmp/proxy ]; then
    rm -rf /tmp/proxy
fi
mkdir /tmp/proxy
cd /tmp/proxy

echo -e &amp;quot;&#92;n&amp;gt;&amp;gt;&amp;gt; downloading ... $F&#92;n&amp;quot;
manual=&amp;quot;https://snail.gitee.io/proxy/manual/&amp;quot;
LAST_VERSION=$(curl --silent &amp;quot;https://mirrors.host900.com/https://api.github.com/repos/snail007/goproxy/releases/latest&amp;quot; | grep -Po &#39;&amp;quot;tag_name&amp;quot;:&amp;quot;&#92;K.*?(?=&amp;quot;)&#39;)
wget  -t 1 &amp;quot;https://mirrors.host900.com/https://github.com/snail007/goproxy/releases/download/${LAST_VERSION}/$F&amp;quot;

echo -e &amp;quot;&amp;gt;&amp;gt;&amp;gt; installing ... &#92;n&amp;quot;
# &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#install&quot;&gt;#install&lt;/a&gt; proxy
tar zxvf $F &amp;gt;/dev/null
set +e
killall -9 proxy &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
set -e
cp -f proxy /usr/bin/
chmod +x /usr/bin/proxy
if [ ! -e /etc/proxy ]; then
    mkdir /etc/proxy
    cp blocked /etc/proxy
    cp direct  /etc/proxy
fi
if [ ! -e /etc/proxy/proxy.crt ]; then
    cd /etc/proxy/
    proxy keygen -C proxy &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 
fi
rm -rf /tmp/proxy
version=`proxy --version 2&amp;gt;&amp;amp;1`
echo  -e &amp;quot;&amp;gt;&amp;gt;&amp;gt; install done, thanks for using snail007/goproxy $version&#92;n&amp;quot;
echo  -e &amp;quot;&amp;gt;&amp;gt;&amp;gt; install path /usr/bin/proxy&#92;n&amp;quot;
echo  -e &amp;quot;&amp;gt;&amp;gt;&amp;gt; configuration path /etc/proxy&#92;n&amp;quot;
echo  -e &amp;quot;&amp;gt;&amp;gt;&amp;gt; uninstall just exec : rm /usr/bin/proxy &amp;amp;&amp;amp; rm -rf /etc/proxy&#92;n&amp;quot;
echo  -e &amp;quot;&amp;gt;&amp;gt;&amp;gt; How to using? Please visit : $manual&#92;n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;幾個不常用到的指令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;tar :解壓縮&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;/dev/null    ，這個在linux上面表示 黑洞，不做任何處理。&lt;br /&gt;
所以 tar zxvf &lt;mjx-container class=&quot;MathJax&quot; jax=&quot;SVG&quot; style=&quot;direction: ltr; position: relative;&quot;&gt;&lt;svg style=&quot;overflow: visible; min-height: 1px; min-width: 1px; vertical-align: -0.566ex;&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;30.139ex&quot; height=&quot;2.262ex&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewBox=&quot;0 -750 13321.6 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;scale(1,-1)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;1D439&quot; d=&quot;M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1026.8,0)&quot;&gt;&lt;path data-c=&quot;3E&quot; d=&quot;M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot; transform=&quot;translate(2082.6,0)&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;2F&quot; d=&quot;M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2582.6,0)&quot;&gt;&lt;path data-c=&quot;1D451&quot; d=&quot;M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3102.6,0)&quot;&gt;&lt;path data-c=&quot;1D452&quot; d=&quot;M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3568.6,0)&quot;&gt;&lt;path data-c=&quot;1D463&quot; d=&quot;M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot; transform=&quot;translate(4053.6,0)&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;2F&quot; d=&quot;M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(4553.6,0)&quot;&gt;&lt;path data-c=&quot;1D45B&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(5153.6,0)&quot;&gt;&lt;path data-c=&quot;1D462&quot; d=&quot;M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(5725.6,0)&quot;&gt;&lt;path data-c=&quot;1D459&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(6023.6,0)&quot;&gt;&lt;path data-c=&quot;1D459&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(6321.6,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;表&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(7321.6,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;示&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(8321.6,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;說&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(9321.6,0)&quot;&gt;&lt;text data-variant=&quot;italic&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot; font-style=&quot;italic&quot;&gt;，&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(10321.6,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;解&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(11321.6,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;壓&lt;/text&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(12321.6,0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;scale(1,-1)&quot; font-size=&quot;884px&quot; font-family=&quot;serif&quot;&gt;縮&lt;/text&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;mjx-assistive-mml unselectable=&quot;on&quot; display=&quot;inline&quot; style=&quot;top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; position: absolute; padding: 1px 0px 0px 0px; border: 0px; display: block; width: auto; overflow: hidden;&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mo&gt;&amp;gt;&lt;/mo&gt;&lt;mrow data-mjx-texclass=&quot;ORD&quot;&gt;&lt;mo&gt;/&lt;/mo&gt;&lt;/mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mrow data-mjx-texclass=&quot;ORD&quot;&gt;&lt;mo&gt;/&lt;/mo&gt;&lt;/mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;表&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;示&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;說&lt;/mi&gt;&lt;mi&gt;，&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;解&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;壓&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;縮&lt;/mi&gt;&lt;/math&gt;&lt;/mjx-assistive-mml&gt;&lt;/mjx-container&gt;F的檔案，但不印出任何的訊息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;set -e  在 &amp;quot;set -e&amp;quot;之後出現的代碼，一旦出現了返回值非零，整個腳本就會立即退出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;set +e 在 &amp;quot;set +e&amp;quot;之後出現的代碼，一旦出現了返回值非0，腳本還是會繼續執行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;if -e ...判斷此目標是否存在，存在回true&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://www.ltsplus.com/linux/dev-null-2-and-1-meanning&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;“&amp;gt; /dev/null 2&amp;gt;&amp;amp;1” 的意思&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://blog.csdn.net/xiaofei125145/article/details/39345331&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; 學習筆記： shell 中的 set -e ， set +e 用法&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://unix.stackexchange.com/questions/127743/what-does-if-e-name-mean-where-name-is-a-path-to-a-directory&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;What does &amp;quot;if [ -e $name ]&amp;quot; mean? Where $name is a path to a directory&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/93. shellscript解析/" />
        </entry>
        <entry>
            <title>
                65. Linux command - grep
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/65. Linux command - grep/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;用途&quot; tabindex=&quot;-1&quot;&gt;用途&lt;/h3&gt;
&lt;p&gt;通常是用在某些指令後的處理上。&lt;/p&gt;
&lt;p&gt;以前的話，通常是把指令執行完後，&lt;br /&gt;
再將內容貼去excel做處理&lt;/p&gt;
&lt;p&gt;這邊也很常用到pipe  ，&lt;/p&gt;
&lt;p&gt;簡單的例子，要找出這個資料夾內有多少檔案。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls | wc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;會有三個值， 換行數、字數、字元數&lt;/p&gt;
&lt;p&gt;但如果要針對 副檔名是 jpg的話，&lt;br /&gt;
就必須要用grep 在做加總&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls | grep -c &#92;.jpg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果只單純做加總的話，後面必須給個要加總的東西。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls | grep -c .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;後面的參數為 正則表示法&lt;/p&gt;
&lt;p&gt;擷取時，無視大小寫&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;grep -i &amp;quot;Abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.gtwang.org/linux/linux-io-input-output-redirection-operators/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux I/O 輸入與輸出重新導向，基礎概念教學&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.gtwang.org/linux/linux-wc-command-tutorial-examples/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux 使用 wc 指令計算字數、行數教學與範例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.runoob.com/linux/linux-comm-grep.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux grep 命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.gtwang.org/linux/linux-grep-command-tutorial-examples/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux 匹配文字 grep 指令用法教學與範例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/65. Linux command - grep/" />
        </entry>
        <entry>
            <title>
                63.alpine linux apk ERROR unable to select packages
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/63.alpine linux apk ERROR unable to select packages/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;這好像是在查問題的時候碰到的，&lt;br /&gt;
因為某些奇怪的網路問題，&lt;br /&gt;
導致必須抓封包查詢，然後又因為在GKE的內網，&lt;br /&gt;
不能在本機撈.&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;要安裝一個linux類似fiddler的軟體，&lt;br /&gt;
搜尋alpine liunx 的 repository有找到，&lt;br /&gt;
但一直無法安裝。&lt;br /&gt;
會出現&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ERROR: unable to select packages:
  mitmproxy (no such package):
    required by: world[mitmproxy]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;後來才發現，他的repository是 測試的&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%A7%20Linux/63.fig-1.jpg&quot; alt=&quot;63.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以安裝時，要指定 repository的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apk add mitmproxy --repository=http://dl-cdn.alpinelinux.org/alpine/edge/testing/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hasanaltin.com/error-unable-to-select-packages-error-on-alpine-linux/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ERROR: unable to select packages error on Alpine Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/62218240/how-to-add-a-edge-testing-package-to-alpine-linux&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to add a edge/testing package to Alpine Linux?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pkgs.alpinelinux.org/packages&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;alpine Linux - package search&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wiki.alpinelinux.org/wiki/Enable_Community_Repository&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;alpine Linux - Enable Community Repository&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/63.alpine linux apk ERROR unable to select packages/" />
        </entry>
        <entry>
            <title>
                6. 編譯ffmpeg 硬體加速的坑
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/6. 編譯ffmpeg 硬體加速的坑/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近的案子..要幫同仁搞ffmpeg的機器，如果沒有使用顯卡加速是個很愉快的事情&lt;br /&gt;
但扯到顯卡就滿滿的坑了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;環境：GKE，開啟GPU節點，詳細的使用方法可參考之前寫過的 GKE使用GPU&lt;br /&gt;
環境設定那部分，有開工單去問google，他們有說要改文件。&lt;/p&gt;
&lt;p&gt;1.編譯時找不到 libnpp&lt;br /&gt;
ERROR: libnpp not found&lt;/p&gt;
&lt;p&gt;安裝 CUDA Toolkit&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://www.pugetsystems.com/labs/hpc/How-to-install-CUDA-9-2-on-Ubuntu-18-04-1184/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to install CUDA 9.2 on Ubuntu 18.04&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;amp;target_arch=x86_64&amp;amp;target_distro=Ubuntu&amp;amp;target_version=1804&amp;amp;target_type=runfilelocal&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;CUDA Toolkit 11.2 Downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;wget &lt;a href=&quot;https://developer.download.nvidia.com/compute/cuda/11.2.0/local_installers/cuda_11.2.0_460.27.04_linux.run&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://developer.download.nvidia.com/compute/cuda/11.2.0/local_installers/cuda_11.2.0_460.27.04_linux.run&lt;/a&gt;&lt;br /&gt;
sudo sh cuda_11.2.0_460.27.04_linux.run&lt;/p&gt;
&lt;p&gt;安裝時，不要另外裝驅動，只裝cuda&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;參數設定編碼允許png,出現錯誤&lt;br /&gt;
--enable-decoder=png --enable-encoder=png&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Disabled png_decoder because not all dependencies are satisfied: zlib&lt;/p&gt;
&lt;p&gt;需要先安裝 zlib&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://stackoverflow.com/questions/11040847/ffmpeg-png-watermark-issue&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ffmpeg &amp;amp; png watermark issue&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get install zlib1g-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;編譯完成後，執行發生錯誤，找不到libnpp&lt;br /&gt;
ffmpeg: error while loading shared libraries: libnppig.so.11: cannot open shared object file: No such file or directory&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://superuser.com/questions/1246209/libnppig-so-8-0-missing-ffmpeg&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;libnppig.so.8.0 Missing FFmpeg&lt;/a&gt;&lt;br /&gt;
設定參數&lt;br /&gt;
export LD_LIBRARY_PATH=/usr/local/cuda-11.2/targets/x86_64-linux/lib&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;驅動不支援&lt;br /&gt;
Driver does not support the required nvenc API version. Required: 11.0 Found: 9.0&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The minimum required Nvidia driver for nvenc is 455.28 or newer&lt;br /&gt;
Error initializing output stream 0:0 -- Error while opening encoder for output stream &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#0&quot;&gt;#0&lt;/a&gt;:0 - maybe incorrect parameters such as bit_rate, rate, width or height&lt;/p&gt;
&lt;p&gt;切到 nv-codec-headers 的資料夾底下，切換分支&lt;br /&gt;
git checkout sdk/9.0&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://blog.csdn.net/qq_23282479/article/details/107579032&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[記錄一個bug]關於運行ffmpeg with cuda出錯問題：Driver does not support the required nvenc API version..... [已解決|記錄一個bug]關於運行ffmpeg with cuda出錯問題：Driver does not support the required nvenc API version..... [已解決]&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;使用浮水印轉檔出現錯誤&lt;br /&gt;
Impossible to convert between the formats supported by the filter &#39;graph 0 input from stream 0:0&#39; and the filter &#39;auto_scaler_0&#39;&lt;br /&gt;
Error reinitializing filters!&lt;br /&gt;
Failed to inject frame into filter network: Function not implemented&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前寫的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ffmpeg -hwaccel cuvid -y -i 49805.mp4 -i logo.png &#92;
-filter_complex &amp;quot;[0]scale=&#39;min(1280,iw)&#39;:-1[bg];[1][bg]scale2ref=w=&#39;iw*15/100&#39;:h=&#39;iw*15/100*166/446&#39;[wm][vid];[vid][wm]overlay=10:10&amp;quot; &#92;
-c:v h264_nvenc ezio.mp4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;會發生上面的錯誤(auto_scaler_0)，但只要將 cuvid改成 nvdec 就正常了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ffmpeg -hwaccel nvdec -y -i 49805.mp4 -i logo.png &#92;
-filter_complex &amp;quot;[0]scale=&#39;min(1280,iw)&#39;:-1[bg];[1][bg]scale2ref=w=&#39;iw*15/100&#39;:h=&#39;iw*15/100*166/446&#39;[wm][vid];[vid][wm]overlay=10:10&amp;quot; &#92;
-c:v h264_nvenc ezio.mp4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://forums.developer.nvidia.com/t/filter-complex-through-cuda-hevc-cuvid-with-ffmpeg-input-4k-hevc-help-needed/70894/5&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Filter complex through CUDA hevc_cuvid with FFMPEG input 4k hevc, help needed&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;
&lt;p&gt;轉碼時查詢 詳細的log記錄&lt;br /&gt;
在ffmpeg的後面加上 -loglevel debug&lt;br /&gt;
ref. &lt;a href=&quot;http://hk.uwenku.com/question/p-kdwwpile-bz.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;FFMPEG的默認像素格式將圖像堆棧編碼為電影&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ffmpeg 常用指令&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ffmpeg -hwaccels  查詢能用的硬體加速&lt;br /&gt;
ffmpeg -codecs | grep cuvid  查看ffmpeg支持的cuvid的編碼格式&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;http://notes.maxwi.com/2017/03/01/ubuntu-compile-ffmpeg-with-cuvid-nvenc-npp/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Ubuntu 16.04下編譯ffmpeg支持CUDA下的cuvid vnenc和NPP&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://m.yisu.com/zixun/7438.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用GPU硬件加速FFmpeg視頻轉碼及排坑&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他參考項目&lt;br /&gt;
ref. &lt;a href=&quot;https://arnon.dk/matching-sm-architectures-arch-and-gencode-for-various-nvidia-cards/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Matching CUDA arch and CUDA gencode for various NVIDIA architectures&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/qq_29350001/article/details/72625866&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;FFmpeg再學習 -- Linux 安裝說明(參數說明)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/eae199a4cce0&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;在k8s中調用NVIDIA-GPU&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/nightseas/gpgpu_applications/blob/master/docker/ffmpeg/Dockerfile#L24&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;在k8s中調用NVIDIA-GPU(Dockerfile)&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/6. 編譯ffmpeg 硬體加速的坑/" />
        </entry>
        <entry>
            <title>
                51.curl 筆記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/51.curl 筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;最近在K網路架構，有些東西有點概念了。&lt;/p&gt;
&lt;p&gt;此時來看這張圖終於瞭解一點。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%A7%20Linux/51.fig-1.png&quot; alt=&quot;51.fig-1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://blog.cloudflare.com/a-question-of-timing/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;A Question of Timing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先來看這張圖，&lt;br /&gt;
有幾個關鍵字縮寫必須要先知道&lt;br /&gt;
SYN ： 同步序列號&lt;br /&gt;
ACK ： 要求回應&lt;br /&gt;
FIN   ：結束&lt;br /&gt;
SEQ  ： 序列號&lt;/p&gt;
&lt;p&gt;這邊簡單講，要更詳細的內容，建議去看一下&lt;a href=&quot;https://notfalse.net/7/three-way-handshake&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;TCP 三向交握 (Three-way Handshake)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在這張圖裡面沒有SEQ這個，因為沒畫出來，在SYN的時候，就會包含SEQ在裡面了。&lt;/p&gt;
&lt;p&gt;流程簡單說是這樣的，TCP是有順序性的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;clinet 詢問DNS server ，網域與IP的對應&lt;/li&gt;
&lt;li&gt;client 發出請求&lt;/li&gt;
&lt;li&gt;server 回應&lt;/li&gt;
&lt;li&gt;client 回應，我知道你回了。&lt;/li&gt;
&lt;li&gt;server 開始建立ssl憑證&lt;/li&gt;
&lt;li&gt;client 發出內容請求&lt;/li&gt;
&lt;li&gt;server 回應內容&lt;/li&gt;
&lt;li&gt;結束&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;好了，再來才是講curl ，&lt;br /&gt;
先建立一個 txt檔，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#92;n
 # DNS 解析時間，也就是查詢到 IP 的時間&#92;n
 time_namelookup: %{time_namelookup}&#92;n
 # TCP 連線時間，就是 TCP 三項交握的時間&#92;n
 time_connect: %{time_connect}&#92;n
 # SSL 連線的時間&#92;n
 time_appconnect: %{time_appconnect}&#92;n
 # 從開始到最後一個請求的時間，如果網頁有跳轉就會有時間&#92;n
 time_redirect: %{time_redirect}&#92;n
 # 從開始到響應開始的時間&#92;n
 time_pretransfer: %{time_pretransfer}&#92;n
 # 從開始到響應開始傳輸的時間&#92;n
 time_starttransfer: %{time_starttransfer}&#92;n
 ----------&#92;n
 # 整體時間&#92;n
 time_total: %{time_total}&#92;n
&#92;n

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;curl -w @curl-format.txt -o /dev/null https://daimom3020.blogspot.com/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊要注意， @curl-format.txt 這邊不能使用路徑方式去找檔案。如果怕改天找不到檔案的話，&lt;br /&gt;
curl 可以改成下面的指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -o /dev/null https://daimom3020.blogspot.com/ -w &amp;quot;                   
 # DNS 解析時間，也就是查詢到 IP 的時間
 time_namelookup: %{time_namelookup}
 # TCP 連線時間，就是 TCP 三項交握的時間
 time_connect: %{time_connect}
 # SSL 連線的時間
 time_appconnect: %{time_appconnect}
 # 從開始到最後一個請求的時間，如果網頁有跳轉就會有時間
 time_redirect: %{time_redirect}
 # 從開始到響應開始的時間
 time_pretransfer: %{time_pretransfer}
 # 從開始到響應開始傳輸的時間
 time_starttransfer: %{time_starttransfer}
 ----------
 # 整體時間
 time_total: %{time_total}
&#92;n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;搭配上方的圖片來看，&lt;br /&gt;
這邊顯示的時間是累加的，如果要算出區間的時間，&lt;br /&gt;
需要自行做相減。&lt;/p&gt;
&lt;p&gt;例如，&lt;br /&gt;
要知道server處理資料的時間多長，&lt;br /&gt;
可使用 time_starttransfer - time_pretransfer ，&lt;br /&gt;
就可得知server處理資料的時間。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.clarence.tw/2019/05/01/curl-details-tcp-ssl-connection-time/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;CURL 詳細資料包含 TCP 與 SSL 連線時間&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weifangan/article/details/80741981&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;CURL -w 參數詳解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://man.linuxde.net/curl&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;curl命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.howtogeek.com/439199/15-special-characters-you-need-to-know-for-bash/&quot; title=&quot;15 Special Characters You Need to Know for Bash&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;15 Special Characters You Need to Know for Bash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://begin4learn.gitbooks.io/begin-to-learn-linux/content/Command/Command_T_symbol.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Command symbol 符號_Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/2147101?from=15425&amp;amp;areaSource=102001.2&amp;amp;traceId=yoo0SjU9fE6zKa1DI8qyZ&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;curl 所有參數介紹&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;驗證網站是否為http2 ，&lt;br /&gt;
簡單說明&lt;br /&gt;
-v  顯示呼叫的步驟&lt;br /&gt;
-s Silent模式。不輸出任務內容&lt;br /&gt;
-o 指定輸出目錄&lt;/p&gt;
&lt;p&gt;只用 -s 的話，還是會輸出內容。&lt;br /&gt;
只用 -o的話，不會輸出內容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	curl https://www.cloudflare.com  --http2 -vso /dev/null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是的話，會出現 using http2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%A7%20Linux/51.fig-2.jpg&quot; alt=&quot;51.fig-2.jpg&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/51.curl 筆記/" />
        </entry>
        <entry>
            <title>
                49.npm 與 yarn 比較
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/49.npm 與 yarn 比較/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;回傳值&lt;/th&gt;
&lt;th&gt;方法名稱&lt;/th&gt;
&lt;th&gt;說明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;npm install&lt;/td&gt;
&lt;td&gt;yarn install&lt;/td&gt;
&lt;td&gt;安裝 json.package 所有依賴&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm install [package]&lt;/td&gt;
&lt;td&gt;(N/A)&lt;/td&gt;
&lt;td&gt;Yarn不支援直接安裝套件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm install --save [package]&lt;/td&gt;
&lt;td&gt;yarn add [paakage]&lt;/td&gt;
&lt;td&gt;儲存在 json.package中的dependencies&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm install --save-dev [package]&lt;/td&gt;
&lt;td&gt;yarn add [paakage] --dev&lt;/td&gt;
&lt;td&gt;儲存在 json.package中的devDependencies&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm install --global [package]&lt;/td&gt;
&lt;td&gt;yarn global add [package]&lt;/td&gt;
&lt;td&gt;安裝在電腦全域中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm uninstall [package]&lt;/td&gt;
&lt;td&gt;(N/A)&lt;/td&gt;
&lt;td&gt;Yarn不支援直接安裝與移除套件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm uninstall --save [package]&lt;/td&gt;
&lt;td&gt;yarn remove [package]&lt;/td&gt;
&lt;td&gt;移除dependencies某套件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm uninstall --save-dev [package]&lt;/td&gt;
&lt;td&gt;yarn remove [package]&lt;/td&gt;
&lt;td&gt;移除devDependencies某套件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rm -rf node_modules &amp;amp;&amp;amp; npm install&lt;/td&gt;
&lt;td&gt;yarn upgrade&lt;/td&gt;
&lt;td&gt;更新node_modules&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10191745&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;用Yarn取代npm加速開發&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/49.npm 與 yarn 比較/" />
        </entry>
        <entry>
            <title>
                48.SSH無法連線，REMOTE HOST IDENTIFICATION HAS CHANGED
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/48.SSH無法連線，REMOTE HOST IDENTIFICATION HAS CHANGED/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;出現下圖的錯誤，&lt;br /&gt;
[[48.fig-1.jpg]]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一般都是用文字編輯器開啟 /root/.ssh/known_hosts&lt;br /&gt;
將舊10.7.10.48 的key刪除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但這次碰到沒有權限，只能下指令刪除了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -R 10.7.10.48
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/48.SSH無法連線，REMOTE HOST IDENTIFICATION HAS CHANGED/" />
        </entry>
        <entry>
            <title>
                33. centos 7安裝redis 改port
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/33. centos 7安裝redis 改port/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;最簡單地安裝方式，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;yum install redis
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;編輯 /etc/redis.conf&lt;br /&gt;
找到 port 6379 ，將它改為 port 8090&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重啟服務  sudo systemctl restart redis&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;發現服務無法啟動(fig.1)，查log(fig.2)，發現沒有權限。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[[33.fig-1.jpg]]&lt;/p&gt;
&lt;p&gt;[[33.fig-2.jpg]]&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;selinux的問題，要麻關掉，要麻新增port&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo: semanage: command not found

安裝
yum install policycoreutils-python
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後執行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo semanage port -a -t redis_port_t -p tcp 8090
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://stackoverflow.com/questions/53009361/redis-creating-server-tcp-listening-socket-6388-bind-permission-denied&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Redis: Creating Server TCP listening socket *:6388: bind: Permission denied&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.opencli.com/linux/fix-semanage-command-not-found&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;解決 semanage command not found&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;重開redis。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo systemctl restart redis
sudo systemctl status redis
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://blog.yowko.com/install-redis-error/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;安裝 Redis 時遇到的錯誤排除&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/33. centos 7安裝redis 改port/" />
        </entry>
        <entry>
            <title>
                173. Linux殭屍程式
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/173. Linux殭屍程式/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;看文章看到一篇詳解，TOP指令，重新把linux的top理解一遍。&lt;br /&gt;
然後看到一個怪名詞 zombie ，這是我理解的意思嗎！？&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;簡單說有點像是windows 的應用程式，要死不死，卡在那邊當掉的情況。&lt;/p&gt;
&lt;p&gt;每一個process都會有一個parent process，&lt;br /&gt;
當child process處於結束與尚未結束中間時會發生。&lt;br /&gt;
詳細，請參考&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10302966&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Day 17: 殭屍與孤兒&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;top 顯示PPID&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;執行 top&lt;/li&gt;
&lt;li&gt;按下&lt;code&gt;f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;選擇需要的欄位，按&lt;code&gt;d&lt;/code&gt; 或 &lt;code&gt;space&lt;/code&gt; 選擇&lt;/li&gt;
&lt;li&gt;按下&lt;code&gt;→&lt;/code&gt; 鍵盤的方向鍵，然後按&lt;code&gt;上下鍵&lt;/code&gt;可以調整順序&lt;/li&gt;
&lt;li&gt;按&lt;code&gt;q&lt;/code&gt;離開&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%A7%20Linux/173.fig-1.jpg&quot; alt=&quot;173.fig-1.jpg&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/173. Linux殭屍程式/" />
        </entry>
        <entry>
            <title>
                171. linux top指令詳解
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/171. linux top指令詳解/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡唸&quot; tabindex=&quot;-1&quot;&gt;睡睡唸&lt;/h1&gt;
&lt;p&gt;linux常用 top ，看目前os裏面哪個程式資源吃比較兇，&lt;br /&gt;
但每次都是只看固定幾個欄位，&lt;br /&gt;
最近剛好喵到完整的說明。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;一般top會長這樣&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%A7%20Linux/171.fig-1.jpg&quot; alt=&quot;171.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;第一行&quot; tabindex=&quot;-1&quot;&gt;第一行&lt;/h3&gt;
&lt;p&gt;top&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;15:40:37&lt;/th&gt;
&lt;th&gt;目前時間&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;up 6 days&lt;/td&gt;
&lt;td&gt;已開機時間&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3 users&lt;/td&gt;
&lt;td&gt;目前登入的使用者數量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;load average&lt;/td&gt;
&lt;td&gt;1 min,5 min,15min的系統瓶均負載&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;第二行&quot; tabindex=&quot;-1&quot;&gt;第二行&lt;/h3&gt;
&lt;p&gt;Tasks&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;419 total&lt;/th&gt;
&lt;th&gt;總處理程序&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1 running&lt;/td&gt;
&lt;td&gt;執行中的程式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;418 sleeping&lt;/td&gt;
&lt;td&gt;睡眠中的程式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0 stopped&lt;/td&gt;
&lt;td&gt;停止中的程式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0 zombie&lt;/td&gt;
&lt;td&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/173.%20Linux%E6%AE%AD%E5%B1%8D%E7%A8%8B%E5%BC%8F/&quot;&gt;173. Linux殭屍程式&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;第三行&quot; tabindex=&quot;-1&quot;&gt;第三行&lt;/h3&gt;
&lt;p&gt;%Cpu(s):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;0.2 us&lt;/th&gt;
&lt;th&gt;使用者佔用的CPU&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0.1 sy&lt;/td&gt;
&lt;td&gt;核心空間佔用的CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0 ni&lt;/td&gt;
&lt;td&gt;改變過優先順序的程式佔用的CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;99.7 id&lt;/td&gt;
&lt;td&gt;閒置的CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0 wa&lt;/td&gt;
&lt;td&gt;IO等待佔用的CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0 hi&lt;/td&gt;
&lt;td&gt;硬體中斷(Hardware IRQ)佔用C的PU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0 si&lt;/td&gt;
&lt;td&gt;軟體中斷(Software IRQ)佔用的CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0 st&lt;/td&gt;
&lt;td&gt;偷取時間(Steal Time)佔用的CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Hardware IRQ : 硬體中斷是從外部裝置（如磁碟控製器、網路卡、鍵盤控製器、外部計時器、硬體感應器等）發送到處理器的電子警報訊號&lt;/p&gt;
&lt;p&gt;ref .  &lt;a href=&quot;https://blog.ycrash.io/2020/11/28/hardware-interrupt-time-hi-time-in-top/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Hardware Interrupt time – ‘hi’ time in top&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Software IRO：軟體中斷從程式引發的中斷行爲&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://blog.ycrash.io/2020/11/28/software-interrupt-time-si-time-in-top/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Software Interrupt time – ‘si’ time in top&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Steal CPU Time ：虛擬機器的CPU在虛擬機監護程式正在處理其他虛擬機器時，等待實際CPU的時間百分比。&lt;/p&gt;
&lt;p&gt;ref.  &lt;a href=&quot;https://blog.ycrash.io/2020/11/28/steal-cpu-time-st-time-in-top/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Steal CPU time – ‘st’ time in top&lt;br /&gt;
竊取 CPU 時間 – 頂部的「st」時間&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;第四行&quot; tabindex=&quot;-1&quot;&gt;第四行&lt;/h3&gt;
&lt;p&gt;MiB Mem&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;64207.4 total&lt;/th&gt;
&lt;th&gt;物理記憶體總量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;7866.7 free&lt;/td&gt;
&lt;td&gt;可用記憶體&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16649.0 used&lt;/td&gt;
&lt;td&gt;已使用記憶體&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;39691.6 buff/cache&lt;/td&gt;
&lt;td&gt;緩存的記憶體量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;第五行&quot; tabindex=&quot;-1&quot;&gt;第五行&lt;/h3&gt;
&lt;p&gt;MiB Swap&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;2048.0 total&lt;/th&gt;
&lt;th&gt;虛擬記憶體總量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2048.0 free&lt;/td&gt;
&lt;td&gt;可用虛擬記憶體總量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0.0 used&lt;/td&gt;
&lt;td&gt;已使用虛擬記憶體&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;46765.3.0 avail Mem&lt;/td&gt;
&lt;td&gt;可用記憶體[free+(buff/cache)]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;補充 Linux的計算方式跟windows的不一樣，&lt;br /&gt;
當 『可以被應用程式使用，但被暫時借去做別的用途』，&lt;br /&gt;
在Linux裏面也是顯示為used。&lt;/p&gt;
&lt;p&gt;所以要查目前記憶體使用量可以改用&lt;code&gt;htop&lt;/code&gt;或&lt;code&gt;free -m&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ref . &lt;a href=&quot;https://blog.gtwang.org/linux/linux-cache-memory-linux/&quot; title=&quot;Linux 的記憶體快取（Cache Memory）功能：Linux 系統把記憶體用光了？&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux 的記憶體快取（Cache Memory）功能：Linux 系統把記憶體用光了？&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;第七行&quot; tabindex=&quot;-1&quot;&gt;第七行&lt;/h3&gt;
&lt;p&gt;預設的欄位名稱&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PID&lt;/code&gt;: 執行任務的 Process ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;USER&lt;/code&gt;: 執行任務的使用者名稱&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PR&lt;/code&gt;: 任務的優先度 (Priority)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NI&lt;/code&gt;: 任務的 Nice Value，負的值代表優先度高，正的值代表優先度低&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VIRT&lt;/code&gt;: 總共用到多少 kB 虛擬記憶體 (Virtual Memory)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RES&lt;/code&gt;: 實體記憶體 (Resident Size) 大小 kB&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SHR&lt;/code&gt;: 總共用到多少 kB 的共享記憶體 (Shared Memory)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt;: 狀態 (Status)
&lt;ul&gt;
&lt;li&gt;R 代表執行中&lt;/li&gt;
&lt;li&gt;D 代表不可中斷睡眠 (不可被 signal 打斷通常在等 I/O)&lt;/li&gt;
&lt;li&gt;S 代表睡眠 (可被喚醒)&lt;/li&gt;
&lt;li&gt;T 中斷中或停止，可能是被 &lt;code&gt;SIGSTOP&lt;/code&gt; 或 &lt;code&gt;SIGTSTP&lt;/code&gt; 停止，或是被 degubber 中斷 (ptrace)&lt;/li&gt;
&lt;li&gt;Z 代表殭屍，通常發生在 Child 已經執行完，等待 Parent 結束或回收&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%CPU&lt;/code&gt;: 佔用到多少 CPU %，注意到一個核心是 100%，所以多核心是可以操過 100% 的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%MEM&lt;/code&gt;: 佔用到多少全部記憶體多少比例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TIME+&lt;/code&gt;: 程式已經執行多少時間，單位1/100秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COMMAND&lt;/code&gt;: 任務的指令名稱&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非預設的欄位名稱，&lt;br /&gt;
叫出來的方式為 &lt;code&gt;f&lt;/code&gt; -&amp;gt; 選擇欄位(&lt;code&gt;space&lt;/code&gt;)  -&amp;gt; 離開(&lt;code&gt;q&lt;/code&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PPID&lt;/code&gt;: 執行任務的 Process ID的父親 （原因參考&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/173.%20Linux%E6%AE%AD%E5%B1%8D%E7%A8%8B%E5%BC%8F/&quot;&gt;173. Linux殭屍程式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UID&lt;/code&gt;:執行程式的使用者ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RUID&lt;/code&gt;: 真正的使用者ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RUSER&lt;/code&gt;: 真正的使用者&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUID&lt;/code&gt;: 暫存使用者ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUSER&lt;/code&gt;: 暫存使用者名稱&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GID&lt;/code&gt;: 群組ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GROUP&lt;/code&gt;: 群組名稱&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PGRP&lt;/code&gt;: Process Group Id&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TTY&lt;/code&gt;: 控制終端的名稱&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TPGID&lt;/code&gt;: Tty Process Group Id&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SID&lt;/code&gt;:  session ID （一個login裏面的所有process)，有點像 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/134.%20%E9%97%9C%E9%96%89ssh%E9%80%A3%E7%B7%9A%E5%BE%8C%EF%BC%8C%E4%BB%8D%E5%8F%AF%E5%9F%B7%E8%A1%8C%E7%A8%8B%E5%BC%8F/&quot;&gt;134. 關閉ssh連線後，仍可執行程式&lt;/a&gt;裏面的screen&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nTH&lt;/code&gt;:  與一個進程關聯的執行緒數量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt;: 最後使用的CPU&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TIME&lt;/code&gt;: 程式已經執行多少時間，單位 1秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SWAP&lt;/code&gt;: 當前被移到交換區的記憶體大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CODE&lt;/code&gt;: 目前用於執行程式碼碼的物理記憶體&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DATA&lt;/code&gt;:一個程式保留的私有記憶體量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nMaj&lt;/code&gt;:已發生的主要分頁錯誤次數&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nMin&lt;/code&gt;:已發生的次要分頁錯誤次數&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nDRT&lt;/code&gt;: （已棄用）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WCHAN&lt;/code&gt;: 顯示了每個進程或執行緒目前正在等待的內核函數或事件的名稱或指針&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Flags&lt;/code&gt;:目前任務的排程標誌，以十六進製表示，並且去掉了零&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CGROUPS&lt;/code&gt;:表示程式所在的控制組的名稱&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUPGIDS&lt;/code&gt;:表示進程所在的父控制組的 ID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUPGRPS&lt;/code&gt;:表示程式所在的父控制組的名稱&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TGID&lt;/code&gt;:  Thread Group Id&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OOMa&lt;/code&gt;: 用來調整每個進程的 OOMS 值，以影響其被終止的機率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OOMs&lt;/code&gt;: 記憶體分數，評估進程或任務對內存需求的數值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ENVIRON&lt;/code&gt;: 顯示所有的環境變數&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vMj&lt;/code&gt;: 主要分頁錯誤計數增量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vMn&lt;/code&gt;: 次要分頁錯誤計數增量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;USED&lt;/code&gt;: 記憶體 Res+Swap Size&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nsIPC&lt;/code&gt;: IPC 命名空間，用於隔離進程間通訊資源，確保它們在不同的命名空間中互不干擾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nsMNT&lt;/code&gt;: MNT 命名空間，用於隔離和管理不同命名空間中的檔案系統掛載點資訊&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nsNET&lt;/code&gt;: NET 命名空間，用於隔離和管理不同命名空間中的網絡資源和網絡設置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nsPID&lt;/code&gt;: PID 命名空間，用於隔離不同命名空間中的進程識別號，確保它們在各自的命名空間中具有唯一的 PID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nsUSER&lt;/code&gt;:USER 命名空間，用於隔離不同命名空間中的用戶和用戶許可權，確保它們在各自的命名空間中具有獨立的用戶身份和權限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nsUTS&lt;/code&gt;:UTS (UNIX Time-sharing System)命名空間，用於隔離不同命名空間中的主機名和域名設置，確保它們在各自的命名空間中具有獨立的組態&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LXC&lt;/code&gt;: LXC(Linux Containers)容器名稱&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RSan&lt;/code&gt;: 代表一個進程或任務正在使用的匿名內存的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RSfd&lt;/code&gt;: 代表一個進程或任務正在使用的檔案內存的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RSlk&lt;/code&gt;: 代表一個進程或任務正在使用的已鎖定頁面的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RSsh&lt;/code&gt;: 代表一個進程或任務正在使用的共享內存的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CGNAME&lt;/code&gt;: 控制組名稱，用於標識和管理相關的進程或資源的分組。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NU&lt;/code&gt;: &amp;quot;最後已知的 NUMA 節點&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://xie.infoq.cn/article/92ce399000f46e5d308b3d935&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;記憶體都去哪了&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.1ju.org/linux/top&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;top命令詳解示例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tigercosmos.xyz/post/2020/04/unix/top-usage/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Unix/Linux TOP 指令使用詳解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://manpages.ubuntu.com/manpages/lunar/en/man1/top.1.html#3.%20fields%20/%20columns&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ubntu-top&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hy-star.com.tw/tech/linux/process/process.html#session&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;LInux中的process&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/171. linux top指令詳解/" />
        </entry>
        <entry>
            <title>
                165. Linux網路追蹤工具- MTR
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/165. Linux網路追蹤工具- MTR/</id>
            <content type="html">
                &lt;h2 id=&quot;mtr&quot; tabindex=&quot;-1&quot;&gt;mtr&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;MTR 在一開始會針對指定的主機，以 &lt;code&gt;traceroute&lt;/code&gt; 找出中間的每一個網路節點（閘道器、路由器、橋接器等），然後使用 &lt;code&gt;ping&lt;/code&gt; 去檢查每一個節點的網路連線狀況&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;補充，&lt;code&gt;traceroute -P -t 1935 &amp;lt;ip&amp;gt;&lt;/code&gt; 可透過指定port測試連線&lt;/p&gt;
&lt;h3 id=&quot;安裝方式&quot; tabindex=&quot;-1&quot;&gt;安裝方式&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# Debian/Ubuntu
sudo apt install mtr

# RHEL/CentOS/Fedora
sudo yum install mtr

# MAC
brew install mtr

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MAC安裝後，無法執行，因爲安裝的路徑是在 /usr/local/sbin底下，&lt;br /&gt;
找尋自己的shell&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/163.Shell%E7%9A%84%E5%8D%80%E5%88%A5%E5%8F%8A%E6%9F%A5%E8%A9%A2/&quot;&gt;163.Shell的區別及查詢&lt;/a&gt;，增加指定路徑&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim ~/.bash_profile 
export PATH=$PATH:/usr/local/sbin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 sudo 執行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo mtr -c 5 -wbr https://daimom.vercel.app &amp;gt; output.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%A7%20Linux/165.fig-1.jpg&quot; alt=&quot;165.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;參數介紹&quot; tabindex=&quot;-1&quot;&gt;參數介紹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
mtr -h 提供幫助命令 

mtr -v 顯示mtr的版本資訊 

mtr -r 以報告模式顯示

mtr -s 用來指定ping封包的大小 

mtr -n no-dns不對IP地址做域名解析 

mtr -a 來設定傳送封包的IP地址 這個對一個主機由多個IP地址是有用的 

mtr -i 使用這個參數來設定ICMP返回之間的要求默認是1秒 

mtr -4 IPv4 

mtr -6 IPv6

mtr -c 設定每秒傳送封包的數量

mtr -T 使用TCP連線

mtr -P 指定port

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;數據所代表的意思&lt;br /&gt;
以下是各個英文字母所代表的欄位：&lt;br /&gt;
RTT (Round Trip Time) 亦可稱為往返時間&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;L&lt;/code&gt;：封包遺失率（Loss ratio）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;D&lt;/code&gt;：封包遺失數（Dropped packets）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt;：封包接收數（Received packets）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt;：封包發送數（Sent Packets）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N&lt;/code&gt;：最新的 RTT（Newest RTT，單位為 ms）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt;：最佳的 RTT（Min/Best RTT，單位為 ms）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt;：平均的 RTT（Average RTT，單位為 ms）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;W&lt;/code&gt;：最差的 RTT（Max/Worst RTT，單位為 ms）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;V&lt;/code&gt;：標準差（Standard Deviation）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G&lt;/code&gt;：幾何平均（Geometric Mean）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;J&lt;/code&gt;：目前的 Jitter 值（Current Jitter）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;M&lt;/code&gt;：平均的 Jitter 值（Jitter Mean/Avg.）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X&lt;/code&gt;：最差的 Jitter 值（Worst Jitter）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;I&lt;/code&gt;：Interarrival Jitter&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cjkuo.net/linux_mtr/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;MTR 追蹤網路節點&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.gtwang.org/linux/mtr-linux-network-diagnostic-tool/&quot; title=&quot;MTR：Linux 網路診斷工具使用教學&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;MTR：Linux 網路診斷工具使用教學&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://what-a-good-day.blogspot.com/2019/02/mac-mtr.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;mac 安裝 mtr&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/165. Linux網路追蹤工具- MTR/" />
        </entry>
        <entry>
            <title>
                163.Shell的區別及查詢
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/163.Shell的區別及查詢/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;在測試gcloud安裝後，還是找不到gcloud command ，&lt;br /&gt;
於是開始了檢查之路。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;熟linux的應該都知道sh只是個代稱，你的sh是bash 、 zsh 或 dash，&lt;br /&gt;
都有可能。&lt;br /&gt;
所以判斷你的sh是哪一種&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo $SHELL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後你的sh會決定你的設定檔名稱是哪一個。&lt;br /&gt;
例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bash =&amp;gt; ~/.bashrc
zsh =&amp;gt;  ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果指令新增後，不想重啓Terminal的話，&lt;br /&gt;
可使用下面指令，將被指定目錄的bash讀入目前的環境中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/31037279/gcloud-command-not-found-while-installing-google-cloud-sdk&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud command not found - while installing Google Cloud SDK&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/163.Shell的區別及查詢/" />
        </entry>
        <entry>
            <title>
                16.dustise sleep 測試工具簡介
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/16.dustise sleep 測試工具簡介/</id>
            <content type="html">
                &lt;h2 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;之前就有用過 dustise/sleep ，用for 迴圈來打 網址做測試，&lt;br /&gt;
今天想說那裡面的http到底是哪一套工具，才發現原來裡面有那麼多的工具能用。&lt;br /&gt;
2021.03.18更新：又找到了幾款不錯用的工具，同步增加&lt;/p&gt;
&lt;h2 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;裡面的工具列表，可以參考他的&lt;a href=&quot;https://github.com/fleeto/sleep&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;git&lt;/a&gt;，&lt;br /&gt;
然後我們看到他的dockerfile,裡面有&lt;br /&gt;
bind-tools curl wrk vim&lt;br /&gt;
tcptraceroute iptables httpie bash&lt;br /&gt;
tini apache2-utils stress-ng strace&lt;br /&gt;
這次會抓幾個記錄一下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;bind-tools&lt;br /&gt;
安裝nslookup用，可查詢域名&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;      nslookup tw.yahho.com    &lt;/code&gt;&lt;br /&gt;
2. curl&lt;br /&gt;
取得網頁資料&lt;br /&gt;
&lt;code&gt;      curl ifconfig.me    &lt;/code&gt;&lt;br /&gt;
參數很多，通常會使用postman將要截取的資料轉成curl，再到command做測試。&lt;br /&gt;
如果只是要簡單測試，可以加上 -v 看詳細內容&lt;br /&gt;
3. wrk&lt;br /&gt;
模擬多人來網站時的效能，有點像壓力測試工具。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  wrk -t12 -c400 -d30s -T30s --latency http://localhost/productpage
  # -t12 用 12 個線程
  # -c400 模擬 400 個併發連接
  # -d30s 持續 30 秒
  # -T30s 設定超過 30 秒就算連接超時
  # --latency 響應時間的分佈情況
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.github.io/404&quot;&gt;[16.fig-1.jpg&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Latency: 響應時間&lt;/li&gt;
&lt;li&gt;Req/Sec: 每個線程每秒鐘的完成的請求數&lt;/li&gt;
&lt;li&gt;Avg: 平均值&lt;/li&gt;
&lt;li&gt;Stdev (Standard Deviation): 即標準偏差，是統計學的一個名詞，這裡表示請求響應時間的離散程度，值越大代表請求響應時間的差距越大，系統的響應約不穩定。&lt;/li&gt;
&lt;li&gt;Max: 最大值&lt;/li&gt;
&lt;li&gt;+/- Stdev: 正負一個標準差佔比&lt;/li&gt;
&lt;li&gt;Latency Distribution: 50% 在 3.23s 以內完成 / 99% 在 22.27s 以內完成&lt;/li&gt;
&lt;li&gt;Socket errors: 分為 連接錯誤, 讀取錯誤, 寫入錯誤, 超時錯誤&lt;/li&gt;
&lt;li&gt;Requests/sec: 每秒請求數量，也就是並發能力&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更詳細的說明，請參考：&lt;a href=&quot;https://mgleon08.github.io/blog/2018/04/09/http-benchmark/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;HTTP Benchmark 工具 Wrk&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;
&lt;p&gt;vim&lt;br /&gt;
文字編輯器，就不介紹了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tcptraceroute&lt;br /&gt;
路由追蹤器，追蹤網路死在哪一層&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;  traceroute tw.yahoo.com
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;
&lt;p&gt;iptables&lt;br /&gt;
路由表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;httpie&lt;br /&gt;
之前使用&lt;br /&gt;
for i in &lt;code&gt;seq 20&lt;/code&gt;;do http --body &lt;a href=&quot;http://ipaddress/api/v1/Health/health&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;http://ipaddress/api/v1/Health/health&lt;/a&gt;; done;&lt;br /&gt;
打網址的指令。&lt;br /&gt;
httpie 是一個 HTTP 的命令行客戶端。其目標是讓 CLI 和 web 服務之間的交互儘可能的人性化。&lt;br /&gt;
想用來取代wget ,curl 等功能，然後畫面比較美觀，如果回來的是json，那差異會更大。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[[16.fig-2.jpg]]&lt;/p&gt;
&lt;p&gt;下載&lt;br /&gt;
http --download &lt;a href=&quot;http://example.org/file&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;example.org/file&lt;/a&gt;&lt;br /&gt;
只看header&lt;br /&gt;
http -h &lt;a href=&quot;http://ipaddress/productpage&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;http://ipaddress/productpage&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://tonydeng.github.io/2015/07/10/httpie-howto/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;HTTPie:超爽的HTTP命令行客戶端&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://keelii.com/2018/09/03/HTTPie/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;HTTPie 官方文檔中文翻譯版&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;同場加註&lt;/p&gt;
&lt;p&gt;jid&lt;br /&gt;
&lt;a href=&quot;https://github.com/simeji/jid&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://github.com/simeji/jid&lt;/a&gt;&lt;br /&gt;
jq&lt;br /&gt;
&lt;a href=&quot;https://stedolan.github.io/jq/manual/#Basicfilters&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://stedolan.github.io/jq/manual/#Basicfilters&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;hey&lt;br /&gt;
&lt;a href=&quot;https://github.com/rakyll/hey&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://github.com/rakyll/hey&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;e.g.  加上 method ,content/type ,dataraw&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hey -z 3m -q 10 -c 3 -m POST -T &#39;application/json&#39; -d &#39;{ &amp;quot;method&amp;quot;: &amp;quot;GetUrlForWard&amp;quot;,  &amp;quot;host&amp;quot;: &amp;quot;landing500023.com&amp;quot;}&#39; https://landing500023.com/query.php
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/16.dustise sleep 測試工具簡介/" />
        </entry>
        <entry>
            <title>
                134. 關閉ssh連線後，仍可執行程式
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/134. 關閉ssh連線後，仍可執行程式/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;怎麼最近都在搞shell script阿..&lt;br /&gt;
這次是要把gce的圖片搬到gcs上面，&lt;br /&gt;
總計有三萬多張，一般執行時，如果碰到ssh斷線，執行就失敗了，&lt;br /&gt;
所以要讓他就算ssh斷線，也仍會執行&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;目前有兩種方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;nohup&lt;br /&gt;
算是最簡單，容易用的方式，直接 在後面接command就能用了，&lt;br /&gt;
但我禮拜五掛着，然後禮拜一回來看，發現程式掛了，cpu還飆到100，&lt;br /&gt;
就算用 指令找到pid後，強制刪除，還是有command在執行，最後只能重開。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;	ps -aux | grep &amp;quot;copyfile.sh&amp;quot;
	kill -9 &amp;lt;PID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://noter.tw/3946/ssh-%E9%81%A0%E7%AB%AF%E7%99%BB%E5%87%BA%E5%BE%8C%E7%B9%BC%E7%BA%8C%E5%9F%B7%E8%A1%8C/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SSH 遠端登出後繼續執行&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;screen&lt;br /&gt;
yum直接搜尋會找不到package，需要先額外安裝epel-release&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;yum install epel-release
yum install screen
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用方式&lt;/p&gt;
&lt;p&gt;先建立一個screen&lt;br /&gt;
可指定名稱&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;screen -S &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在screen裏面，執行程式，離開時按&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ctrl+a -&amp;gt; ctrl（不放）+d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看目前有哪些 screen&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;screen -ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%A7%20Linux/134.fig-1.jpg&quot; alt=&quot;134.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;回到剛剛的screen，可以上面指令看到這個screen的id是58245。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;screen -r 58245
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.twblogs.net/a/5db3ccc2bd9eee310da06d04&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;【Linux】screen解決退出終端會話結束問題&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://intone.cc/2018/07/%e5%ad%b8%e6%9c%83%e4%bd%bf%e7%94%a8screen%e4%b8%8d%e5%86%8d%e6%80%95ssh%e4%b8%ad%e6%96%b7-linux%ef%bc%88centos-7%ef%bc%89/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;學會使用Screen,不再怕SSH中斷 Linux（Centos 7）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/134. 關閉ssh連線後，仍可執行程式/" />
        </entry>
        <entry>
            <title>
                133. shell script字串處理
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/133. shell script字串處理/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;shell script的字串處理，原本以爲只能用grep 跟 awk 走pipeline來用，&lt;br /&gt;
原來還能直接透過${} 來處理，shell script的水好深阿...&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;來個例子，&lt;br /&gt;
有個tag 叫 dev_1.1.23 ，我只要後面的版號就好，該怎麼做。&lt;/p&gt;
&lt;p&gt;本來做法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash
set -x
abc=&amp;quot;dev_1.1.23&amp;quot;
echo $abc|grep -o &#39;&#92;d.&#92;d.&#92;d.&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用 grep 取值，並只顯示符合正則的字串， 所以要用 -o&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.1.23&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果改用${}的文字非貪婪左刪除&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash
set -x
abc=&amp;quot;dev_1.1.23&amp;quot;
echo ${abc#*_}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;1.1.23&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%A7%20Linux/133.fig-1.jpg&quot; alt=&quot;133.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;除了左刪除，也能做到右刪除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 小比對左
## 大比對左
% 小比對右
%% 大比對右
* 用來比對然後刪除

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ps.&lt;br /&gt;
set -x 是屬於xtrace的應用，用來除錯的。&lt;br /&gt;
也可以在執行的時候，加上 bash -x &lt;a href=&quot;http://curl.sh/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;curl.sh&lt;/a&gt; ，&lt;br /&gt;
這樣使用&lt;br /&gt;
詳細參考&lt;a href=&quot;https://hackmd.io/@seterrychen/rkZINBjKH&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Shell script前言&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.sunxidong.com/449.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux Shell 指令碼中 ${} 用法&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/133. shell script字串處理/" />
        </entry>
        <entry>
            <title>
                132. shell script 雙引號與單引號
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/132. shell script 雙引號與單引號/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;最近寫CI/CD，碰到一堆shell script的指令，&lt;br /&gt;
以前都是try error一路試過去的，&lt;br /&gt;
沒碰到什麼太大問題，直到現在那一長串，我才終於發瘋。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;簡單說法&quot; tabindex=&quot;-1&quot;&gt;簡單說法&lt;/h3&gt;
&lt;p&gt;shell script的 單引號 『 &#39; 』括起來的字，&lt;br /&gt;
會保留引號內每個字元，就是說裏面的變數不會變。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;abc=&amp;quot;a&amp;quot;
echo &#39;$abc&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就是印出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$abc&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而雙引號 『 &amp;quot; 』 括起來的字，&lt;br /&gt;
不會保留引號內的字元，就是說裏面的變數會跟着變&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;abc=a
echo &amp;quot;$abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;印出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以看起來會像這樣&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%A7%20Linux/132.fig-1.jpg&quot; alt=&quot;132.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果變成單引號包雙引號，或是 雙引號包單引號&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;echo &#39;&amp;quot;$abc&amp;quot;&#39;
echo &amp;quot;&#39;$abc&#39;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;$abc&lt;br /&gt;
&#39;a&#39;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;詳細說法&quot; tabindex=&quot;-1&quot;&gt;詳細說法&lt;/h3&gt;
&lt;p&gt;單引號：&lt;br /&gt;
shell 將逐字解釋單引號內的封閉文字，並且不會插入任何內容，包括變數、反引號、某些 &#92; 轉義符等，所有字元都會維持原始字面意義&lt;/p&gt;
&lt;p&gt;雙引號：&lt;br /&gt;
允許 shell 解釋美元符號 ( $ )、反引號 ( ` )、反斜槓 ( &#92; ) 和驚嘆號 (！）， 這些字元與雙引號一起使用時具有特殊含義，並且在顯示之前對其進行評估&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://officeguide.cc/bash-tutorial-quoted-strings-and-special-characters/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; Bash 程式設計教學與範例：單引號、雙引號、跳脫字元&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.51cto.com/article/685657.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;終於知道 Shell 中單引號雙引號的區別了&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;p.s 上面宣告的 abc 叫做本地變數(local variable)，&lt;br /&gt;
如果用上了export 則是 環境變數(environment variable)&lt;/p&gt;
&lt;p&gt;常見變數錯誤&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A = B #=號前後不能有空格
1A=B &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#變量名稱不能以數字開頭&quot;&gt;#變量名稱不能以數字開頭&lt;/a&gt;
$A=B &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#變量的名稱裡有&quot;&gt;#變量的名稱裡有&lt;/a&gt;$
a=B  &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#這跟a&quot;&gt;#這跟a&lt;/a&gt;=b是不同的
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://jasonblog.github.io/note/shell/2315.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; shell十三問之5:問var=value 在export前後的差在哪?&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/132. shell script 雙引號與單引號/" />
        </entry>
        <entry>
            <title>
                116. 安裝linux server 基本設定
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/116. 安裝linux server 基本設定/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;好久沒弄ubuntu了，有些預設要設定的東西，&lt;br /&gt;
還真的久沒用就忘記，&lt;br /&gt;
筆記筆記。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;新增使用者&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sudo useradd it
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;修改密碼&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sudo passwd it
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://blog.gtwang.org/linux/linux-useradd-command-tutorial-examples/&quot; title=&quot;Linux 新增使用者 useradd 指令用法教學與範例&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux 新增使用者 useradd 指令用法教學與範例&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指定帳號，輸入sudo免密碼&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;echo &amp;quot;username ALL=(ALL) NOPASSWD: ALL&amp;quot; &amp;gt; /etc/sudoers.d/username
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10270945?sc=hot&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;第8章：管理本地端主機之使用者與群組(二)&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更改固定ip，修改裏面的檔案 *.network-manager-all.yaml&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cd /etc/netplan/

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;network:  
  version: 2  
  renderer: NetworkManager  
  ethernets:  
    ens33:  
      dhcp4: no  
      addresses: [192.168.103.231/24]  
      gateway4: 192.168.0.1  
      nameservers:  
        addresses: [8.8.8.8,8.8.4.4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成後，先測試&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo netplan try
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.ruyut.com/2021/12/ubuntu-ip.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Ubuntu] 設定固定ip&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般使用者執行docker&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sudo usermod -a -G docker ${USER}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行完後，需重新登入&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/116. 安裝linux server 基本設定/" />
        </entry>
        <entry>
            <title>
                114. alpine linux 宣告變數,error bad variable name
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/114. alpine linux 宣告變數,error bad variable name/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;頭一次碰到這種坑，&lt;br /&gt;
我linux有待加強 （哭&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;先看執行結果，&lt;br /&gt;
變數後面不能接空格，不然會出現錯誤。&lt;br /&gt;
等號後面也不能接空格，不然會出現錯誤。&lt;br /&gt;
平常程式寫太順，都習慣按空格了，&lt;br /&gt;
結果....&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/ # export ab = &amp;quot;hello world&amp;quot;
sh: export: : bad variable name
/ # EXPORT ab = &amp;quot;hello world&amp;quot;
sh: EXPORT: not found
/ # export ab=&amp;quot;helloworld&amp;quot;
/ # echo $ab
helloworld
/ # export ab = &amp;quot;helloworld&amp;quot;
sh: export: : bad variable name
/ # export ab =&amp;quot;helloworld&amp;quot;
sh: export: : bad variable name
/ # export ab= &amp;quot;helloworld&amp;quot;
/ # echo $ab
helloworlda
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/114. alpine linux 宣告變數,error bad variable name/" />
        </entry>
        <entry>
            <title>
                108. linux shell 進階指令
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/108. linux shell 進階指令/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;我也不知道這算不算進階？&lt;br /&gt;
但平常我應該不會用，本文有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;計算某個開頭的tag數量有多少&lt;/li&gt;
&lt;li&gt;for迴圈的資料寫到文字檔&lt;/li&gt;
&lt;li&gt;取得檔案詳細時間&lt;/li&gt;
&lt;li&gt;取得檔案列表後刪除&lt;/li&gt;
&lt;li&gt;xargs 參數&lt;/li&gt;
&lt;li&gt;只顯示資料夾&lt;/li&gt;
&lt;li&gt;只顯示檔案&lt;/li&gt;
&lt;li&gt;ls參數&lt;/li&gt;
&lt;li&gt;計算目錄底下的檔案數&lt;/li&gt;
&lt;li&gt;查詢使用者&lt;/li&gt;
&lt;li&gt;消耗最多CPU的process&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;tag&quot; tabindex=&quot;-1&quot;&gt;計算某個開頭的tag數量有多少&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;for tag in $(git tag --sort -version:refname -l &amp;quot;1.1.*&amp;quot;); do
  echo $tag;
  let i++
done
echo $i;
unset i;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;for&quot; tabindex=&quot;-1&quot;&gt;for迴圈的資料寫到文字檔&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;for i in {20221201..20221202}
do
  for j in {00..01}
  do
      echo &amp;quot;mkdir $i$j&amp;quot; 
  done
done  &amp;gt; 1.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;取得檔案詳細時間&quot; tabindex=&quot;-1&quot;&gt;取得檔案詳細時間&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ls --full-time | sort -k6
or
stat file.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;取得檔案列表後刪除&quot; tabindex=&quot;-1&quot;&gt;取得檔案列表後刪除&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ls | grep 4793877c | xargs -p rm -f
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;xargs&quot; tabindex=&quot;-1&quot;&gt;xargs 參數&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;-I {} 將指令帶到後面的{}執行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ls nfs | head -10 | xargs -t -I {} ls nfs/{}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;-t   顯示執行的指令&lt;br /&gt;
-p 執行前的確認&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.gtwang.org/linux/xargs-command-examples-in-linux-unix/&quot; title=&quot;Linux 系統 xargs 指令範例與教學&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux 系統 xargs 指令範例與教學&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.runoob.com/linux/linux-comm-xargs.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux xargs 命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;只顯示資料夾&quot; tabindex=&quot;-1&quot;&gt;只顯示資料夾&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ls -l | grep
{ &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#d&quot;&gt;#d&lt;/a&gt;}
   # 利用詳細資訊，判斷開頭是不是 d(directory)
ls -d */
ls -F | grep &#92;/$  # 檔案名稱的最後如果有/表示是folder
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;只顯示檔案&quot; tabindex=&quot;-1&quot;&gt;只顯示檔案&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ls -F /etc | grep -v &#39;/$&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;ls&quot; tabindex=&quot;-1&quot;&gt;ls參數&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;-l  顯示檔案與目錄的詳細資訊&lt;br /&gt;
-a 顯示隱藏的檔案與目錄&lt;br /&gt;
-h 輸出的資訊以比較容易閱讀的格式呈現&lt;br /&gt;
-F 檔案名稱的後面加上檔案類型的標示字元&lt;br /&gt;
-r 檔案的列表以反向的排序列出&lt;br /&gt;
-R 用遞迴的方式列出所有子目錄的檔案&lt;br /&gt;
-S 檔案依照檔案的大小來排序&lt;br /&gt;
-d 只列出目錄，後面不加上*/   無法顯示&lt;br /&gt;
--full-time 顯示完整時間&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;計算目錄底下的檔案數&quot; tabindex=&quot;-1&quot;&gt;計算目錄底下的檔案數&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt; find ./ -type f -name *.*| wc -l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;find [obj_directory] [-type f] [-name filename]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;find參數說明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;obj_directory：要搜尋的路徑&lt;br /&gt;
-type：要搜尋的類型，f=檔案，d=目錄&lt;br /&gt;
-iname：不區分大小寫&lt;br /&gt;
-name：後面接檔名，可加萬用字元(*)，搜尋類似檔名的檔案&lt;/p&gt;
&lt;p&gt;wc [-l]&lt;br /&gt;
&lt;strong&gt;wc參數說明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;-c: 統計位元組數&lt;br /&gt;
-l：統計行數&lt;br /&gt;
-m：統計字元數。不能與 -c 一起使用。&lt;br /&gt;
-w 統計字數。一個字被定義為由空白、跳格或換行字元分隔的字串。&lt;br /&gt;
-L 列印最長行的長度。&lt;br /&gt;
-help 顯示説明資訊。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://yosia.net/article/181&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [Linux] 計算目錄底下的檔案數&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;查所有使用者&quot; tabindex=&quot;-1&quot;&gt;查所有使用者&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cat /etc/passwd | awk -F: &#39;{print $1}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://devconnected.com/how-to-list-users-and-groups-on-linux/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; How To List Users and Groups on Linux&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;刪除使用者&quot; tabindex=&quot;-1&quot;&gt;刪除使用者&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;userdel -r &amp;lt;userID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://medium.com/%E4%B8%80%E5%80%8B%E5%B0%8F%E5%B0%8F%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E9%9A%A8%E6%89%8B%E7%AD%86%E8%A8%98/gcp-%E9%81%87%E5%88%B0permission-denied-publickey-%E6%80%8E%E9%BA%BC%E8%BE%A6-e41e26ebdf47&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [GCP]遇到permission denied (publickey)怎麼辦？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.gtwang.org/linux/linux-ls-command-tutorial/&quot; title=&quot;Linux 的 ls 指令教學與常用範例整理&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux 的 ls 指令教學與常用範例整理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hy-star.com.tw/tech/linux/pipe/pipe.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;管線/重新導向&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;linux&quot; tabindex=&quot;-1&quot;&gt;linux何時安裝&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;stat / | awk &#39;/Birth: /{print $2 &amp;quot; &amp;quot; substr($3,1,5)}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://linuxiac.com/how-to-find-linux-os-installation-date/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux Installation Date: How to Discover Your System’s Age&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;condition&quot; tabindex=&quot;-1&quot;&gt;condition條件判斷&lt;/h3&gt;
&lt;p id=&quot;bdeaee&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;    if [[ !  -d &amp;quot;$1&amp;quot; ]]; then
        mkdir -p &amp;quot;$1&amp;quot;
    fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用 兩個 &lt;code&gt;[[&lt;/code&gt; 或 一個 &lt;code&gt;[&lt;/code&gt; ，&lt;br /&gt;
代表的意思差不多，只是兩個 &lt;code&gt;[&lt;/code&gt; 算是新版用法，&lt;br /&gt;
他可以多做字串的比較操作&lt;code&gt;== , != ,=~ &lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-d&lt;/code&gt; 是一個條件測試標誌，檢查是否為目錄&lt;br /&gt;
其他的相似的標誌如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; ，用於檢查指定路徑是否為目錄。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-f&lt;/code&gt;：檢查指定路徑是否為普通檔案。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-x&lt;/code&gt;：檢查檔案是否可執行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt;：檢查檔案是否可讀。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-w&lt;/code&gt;：檢查檔案是否可寫。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s&lt;/code&gt;：檢查檔案是否存在且大小不為零。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt;：檢查檔案是否存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;function&quot; tabindex=&quot;-1&quot;&gt;function 建立&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;function bindmount() {
    if [[ !  -d &amp;quot;$1&amp;quot; ]]; then
        mkdir -p &amp;quot;$1&amp;quot;
    fi

    chown -R :100 &amp;quot;$1&amp;quot; &amp;quot;$2&amp;quot;
	mount --bind &amp;quot;$1&amp;quot; &amp;quot;$2&amp;quot;
}

bindmount &amp;quot;/home/mike/upload&amp;quot; &amp;quot;/home/bms/mike&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;傳參數進去時，記得在後面加上&lt;code&gt;&amp;quot;&lt;/code&gt; 雙引號，包起來，&lt;br /&gt;
避免中間有特別的字元導致，輸入失敗。&lt;/p&gt;
&lt;p&gt;稍微提一下，mount --bind 前面是來源 ，後面是目的。&lt;br /&gt;
我不太懂GPT的回答&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%90%A7%20Linux/108.fig-1.png&quot; alt=&quot;108.fig-1.png&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;cpu-process&quot; tabindex=&quot;-1&quot;&gt;消耗最多CPU的process&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;ps H -eo pid,pcpu | sort -nk2 | tail   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;對應的服務名稱&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ps aux | fgrep &amp;lt;PID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/108. linux shell 進階指令/" />
        </entry>
        <entry>
            <title>
                0.Linux MOC
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🐧 Linux/0.Linux MOC/</id>
            <content type="html">
                &lt;h1 id=&quot;basic&quot; tabindex=&quot;-1&quot;&gt;basic&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/132.%20shell%20script%20%E9%9B%99%E5%BC%95%E8%99%9F%E8%88%87%E5%96%AE%E5%BC%95%E8%99%9F/&quot;&gt;132. shell script 雙引號與單引號&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/133.%20shell%20script%E5%AD%97%E4%B8%B2%E8%99%95%E7%90%86/&quot;&gt;133. shell script字串處理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/163.Shell%E7%9A%84%E5%8D%80%E5%88%A5%E5%8F%8A%E6%9F%A5%E8%A9%A2/&quot;&gt;163.Shell的區別及查詢&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;setting&quot; tabindex=&quot;-1&quot;&gt;Setting&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/33.%20centos%207%E5%AE%89%E8%A3%9Dredis%20%E6%94%B9port/&quot;&gt;33. centos 7安裝redis 改port&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/49.npm%20%E8%88%87%20yarn%20%E6%AF%94%E8%BC%83/&quot;&gt;49.npm 與 yarn 比較&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/116.%20%E5%AE%89%E8%A3%9Dlinux%20server%20%E5%9F%BA%E6%9C%AC%E8%A8%AD%E5%AE%9A/&quot;&gt;116. 安裝linux server 基本設定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;tools&quot; tabindex=&quot;-1&quot;&gt;Tools&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/16.dustise%20sleep%20%E6%B8%AC%E8%A9%A6%E5%B7%A5%E5%85%B7%E7%B0%A1%E4%BB%8B/&quot;&gt;16.dustise sleep 測試工具簡介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/51.curl%20%E7%AD%86%E8%A8%98/&quot;&gt;51.curl 筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/65.%20Linux%20command%20-%20grep/&quot;&gt;65. Linux command - grep&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/93.%20shellscript%E8%A7%A3%E6%9E%90/&quot;&gt;93. shellscript解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/108.%20linux%20shell%20%E9%80%B2%E9%9A%8E%E6%8C%87%E4%BB%A4/&quot;&gt;108. linux shell 進階指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/134.%20%E9%97%9C%E9%96%89ssh%E9%80%A3%E7%B7%9A%E5%BE%8C%EF%BC%8C%E4%BB%8D%E5%8F%AF%E5%9F%B7%E8%A1%8C%E7%A8%8B%E5%BC%8F/&quot;&gt;134. 關閉ssh連線後，仍可執行程式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/165.%20Linux%E7%B6%B2%E8%B7%AF%E8%BF%BD%E8%B9%A4%E5%B7%A5%E5%85%B7-%20MTR/&quot;&gt;165. Linux網路追蹤工具- MTR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/171.%20linux%20top%E6%8C%87%E4%BB%A4%E8%A9%B3%E8%A7%A3/&quot;&gt;171. linux top指令詳解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/173.%20Linux%E6%AE%AD%E5%B1%8D%E7%A8%8B%E5%BC%8F/&quot;&gt;173. Linux殭屍程式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/php%20exec%20ssh%20%E7%99%BC%E7%94%9F%20Host%20key%20verification%20failed%20%E9%8C%AF%E8%AA%A4/&quot;&gt;php exec ssh 發生 Host key verification failed 錯誤&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/114.%20alpine%20linux%20%E5%AE%A3%E5%91%8A%E8%AE%8A%E6%95%B8,error%20bad%20variable%20name/&quot;&gt;114. alpine linux 宣告變數,error bad variable name&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/48.SSH%E7%84%A1%E6%B3%95%E9%80%A3%E7%B7%9A%EF%BC%8CREMOTE%20HOST%20IDENTIFICATION%20HAS%20CHANGED/&quot;&gt;48.SSH無法連線，REMOTE HOST IDENTIFICATION HAS CHANGED&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/63.alpine%20linux%20apk%20ERROR%20unable%20to%20select%20packages/&quot;&gt;linux安裝測試package&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🐧 Linux/0.Linux MOC/" />
        </entry>
        <entry>
            <title>
                鼠鬚管輸入法
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🍎 Mac/鼠鬚管輸入法/</id>
            <content type="html">
                &lt;ol&gt;
&lt;li&gt;安裝 RIME&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;brew install --cask squirrel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安裝完後需要登出再登入&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;下載最新的檔案&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;https://github.com/Ponpon55837/Squirrel/releases
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;mac的話，先增加鼠鬚管的輸入法（在簡體中文內），再開啓他的用戶設定&lt;/li&gt;
&lt;li&gt;將(3)的內容全部刪除後，將(2)的檔案貼到上面&lt;/li&gt;
&lt;li&gt;然後點『重新部署』&lt;/li&gt;
&lt;li&gt;squirrel.custom.yaml 修改主題或顏色&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.github.io/🍎 Mac/鼠鬚管輸入法/" />
        </entry>
        <entry>
            <title>
                永久別名 alias
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🍎 Mac/永久別名 alias/</id>
            <content type="html">
                &lt;p&gt;修改路徑 ~/.zshrc&lt;br /&gt;
然後輸入要新增的alias.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alias tf=&amp;quot;terraform&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/🍎 Mac/永久別名 alias/" />
        </entry>
        <entry>
            <title>
                iTerm2安裝
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🍎 Mac/iTerm2安裝/</id>
            <content type="html">
                &lt;h1 id=&quot;2024-05-27&quot; tabindex=&quot;-1&quot;&gt;2024/05/27 更新&lt;/h1&gt;
&lt;p&gt;換了一台mac mini，&lt;br /&gt;
東西要重裝，然後發現，我指令都過時了，順便重新整理一下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安裝 Homebrew&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;   /bin/bash -c &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;安裝iTerm2&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;brew install --cask iterm2   
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;
&lt;p&gt;套用配色&lt;br /&gt;
到&lt;a href=&quot;http://iterm2colorschemes.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;iterm2 color schemes&lt;/a&gt; 選擇喜歡的配色後import。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8D%8E%20Mac/iTerm2-1.png&quot; alt=&quot;iTerm2-1.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8D%8E%20Mac/iTerm2-2.png&quot; alt=&quot;iTerm2-2.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝ZSH&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;   brew install zsh zsh-completions
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;將預設終端機改爲ZSH&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo sh -c &amp;quot;echo $(which zsh) &amp;gt;&amp;gt; /etc/shells&amp;quot;
chsh -s $(which zsh)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;安裝 Oh My ZSH&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sh -c &amp;quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;套用主題&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;open ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;找關鍵字， SH_THEME=&lt;br /&gt;
修改成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZSH_THEME=&amp;quot;agnoster&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;
&lt;p&gt;安裝 powerline font&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew install --cask font-sauce-code-pro-nerd-font
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;參考上面圖片，改選擇Text，修改字體，字體名稱為 &lt;code&gt;SauceCodePro Nerd Ford&lt;/code&gt;&lt;br /&gt;
如果要找其他字體的話，搜尋關鍵字&lt;code&gt;Nerd&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;brew search --cask nerd&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改字體，不然有亂碼（已棄用）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;# clone 複製  
git clone https://github.com/powerline/fonts.git --depth=1  
# install 安裝  
cd fonts  
./install.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;套用字體&lt;br /&gt;
iTerm → Preferences → Profiles → Text → Change Font→ Meslo&lt;/p&gt;
&lt;ol start=&quot;9&quot;&gt;
&lt;li&gt;程式碼高亮&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;brew install zsh-syntax-highlighting
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後修改設定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;open ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;設定檔最後加上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# For zsh syntax-highlighting
source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/statementdog-engineering/prettify-your-zsh-command-line-prompt-3ca2acc967f&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;超簡單！十分鐘打造漂亮又好用的 zsh command line 環境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@hazelwu/%E7%94%A8oh-my-zsh%E6%8A%8Aiterm%E8%AE%8A%E7%BE%8E%E7%BE%8E-8a18daa8eac&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;用Oh My Zsh把iTerm變美美&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://spreered.medium.com/%E5%AE%A2%E8%A3%BD%E6%88%91%E7%9A%84-cli-%E7%B5%82%E6%96%BC%E7%A8%8D%E5%BE%AE%E6%90%9E%E6%87%82-iterm-zsh-d3feed27f664&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;客製我的 CLI — 終於稍微搞懂 iTerm + ZSH&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🍎 Mac/iTerm2安裝/" />
        </entry>
        <entry>
            <title>
                iTerm2-Powerlevel10k設定
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🍎 Mac/iTerm2-Powerlevel10k設定/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;我記得以前我的iTerm最後面有顯示時間，&lt;br /&gt;
但目前用的沒有，&lt;br /&gt;
亂找了一下，發現一個簡單plugin，不像&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%8D%8E%20Mac/iTerm2%E5%AE%89%E8%A3%9D/&quot;&gt;iTerm2安裝&lt;/a&gt;，&lt;br /&gt;
需要自己手動裝字體。&lt;/p&gt;
&lt;h1 id=&quot;內容&quot; tabindex=&quot;-1&quot;&gt;內容&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;安裝好iTerm2後，參考&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%8D%8E%20Mac/iTerm2%E5%AE%89%E8%A3%9D/&quot;&gt;iTerm2安裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;安裝 zsh主題  &lt;a href=&quot;https://github.com/romkatv/powerlevel10k&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Powerlevel10k&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;設定zsh theme&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;ZSH_THEME=&amp;quot;powerlevel10k/powerlevel10k&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;開啟設定畫面&lt;br /&gt;
可以選擇重開iTerm2 或是 執行指令&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;p10k configure
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再來就看他的說明選擇你想要的設定。&lt;/p&gt;
&lt;p&gt;以下是我目前的畫面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8D%8E%20Mac/iTerm2-3.png&quot; alt=&quot;iTerm2-3.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;最後一項，選擇要不要開啟 &lt;a href=&quot;https://github.com/romkatv/powerlevel10k?tab=readme-ov-file#instant-prompt&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Instant Prompt&lt;/a&gt;&lt;br /&gt;
根據文章說法，可以消除啟動時間過長的情況（如果你的套件很多時）。&lt;/p&gt;
&lt;p&gt;我選擇關掉，沒啥差別。&lt;/p&gt;
&lt;p&gt;如果想再重新設定參數的話，再執行一次指令 &lt;code&gt;p10k configure&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.onejar99.com/terminal-iterm2-zsh-powerlevel10k/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;讓 macOS 的 Terminal 又潮又實用：手把手設定教學 iTerm2 + oh-my-zsh + Powerlevel10k&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;故障排除&quot; tabindex=&quot;-1&quot;&gt;故障排除&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;我輸入任何指令，都會跳出錯誤&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;prompt_context:2: command not found: prompt_segment&lt;br /&gt;
開啟 &lt;code&gt;~/.zshrc&lt;/code&gt; ，尋找關鍵字 &lt;code&gt;prompt_segment&lt;/code&gt;，&lt;br /&gt;
把那整個function砍了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://github.com/Powerlevel9k/powerlevel9k/issues/423&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;prompt_context:2: command not found: prompt_segment&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🍎 Mac/iTerm2-Powerlevel10k設定/" />
        </entry>
        <entry>
            <title>
                0.ＭAC MOC
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🍎 Mac/0.ＭAC MOC/</id>
            <content type="html">
                &lt;h1 id=&quot;安裝事項&quot; tabindex=&quot;-1&quot;&gt;安裝事項&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%8D%8E%20Mac/iTerm2%E5%AE%89%E8%A3%9D/&quot;&gt;iTerm2安裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%8D%8E%20Mac/%E9%BC%A0%E9%AC%9A%E7%AE%A1%E8%BC%B8%E5%85%A5%E6%B3%95/&quot;&gt;鼠鬚管輸入法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mcbopomofo.openvanilla.org/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;小麥注音輸入法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.mediaatelier.com/CheatSheet/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;cheatSheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://free.com.tw/hidden-bar/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;hidden Bar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.kocpc.com.tw/archives/280072&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Xnip&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;之後可以試試看&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;s&gt;&lt;a href=&quot;https://free.com.tw/vchewing/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;威注音輸入法&lt;/a&gt;&lt;/s&gt; （小麥真的好用，資源又吃不兇）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://free.com.tw/amphetamine/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Amphetamine&lt;/a&gt; (進階能源節約模式)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;mac&quot; tabindex=&quot;-1&quot;&gt;MAC 軟體&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.github.io/404&quot;&gt;64.mac用的fiddler，Whistle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://iina.io/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;iina(影片播放)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;s&gt;&lt;a href=&quot;https://evernote.com/intl/zh-tw/products/skitch&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;skitch(截圖)&lt;/a&gt;&lt;/s&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://apps.apple.com/tw/app/xnip-screenshot-annotation/id1221250572?mt=12&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;xnip(截圖)&lt;/a&gt;&lt;br /&gt;
簡單截圖用&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://shottr.cc/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;shotter(多功能截圖)&lt;/a&gt;&lt;br /&gt;
目前都改用這套了&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.coconut-flavour.com/coconutbattery/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;coconutbattery(查詢ios裝置電池)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://apps.apple.com/tw/app/hidden-bar/id1452453066?mt=12&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;hiddenbar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://applealmond.com/posts/97644&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Rectangle（視窗管理)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;mac-1&quot; tabindex=&quot;-1&quot;&gt;MAC操作&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.github.io/404&quot;&gt;mac在terminal開啓finder&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%8D%8E%20Mac/%E6%B0%B8%E4%B9%85%E5%88%A5%E5%90%8D%20alias/&quot;&gt;永久別名 alias&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;mac開啓隱藏檔案：&lt;code&gt;Shift+Command+ .&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🍎 Mac/0.ＭAC MOC/" />
        </entry>
        <entry>
            <title>
                99. nginx的除錯筆記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🌐 Network/99. nginx的除錯筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;我一直對nginx不太熟，&lt;br /&gt;
目前也只到了會用，大部分的指令看得懂。&lt;br /&gt;
但湊在一起，還是要查一下。&lt;/p&gt;
&lt;p&gt;這次的錯誤就發生在我以為的問題上&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;又多了一個新服務要架設，&lt;br /&gt;
所以想當然，東西又丟到我這來了。&lt;br /&gt;
這次跟以前的比較不一樣，這次是一個全新的服務。&lt;br /&gt;
所以之前的自動佈署、yaml、nginx設定檔通通重來。&lt;br /&gt;
雖然說是重來，但也只是複製貼上改一改，然後就炸了XDDDD&lt;/p&gt;
&lt;p&gt;我複製之前的設定檔像這個樣子。中間刪除了很多東西，&lt;br /&gt;
請不要照抄。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server_tokens off;
log_format  client  &#39;$remote_addr - $remote_user [$time_local] , &#39;
                  &#39;http-host: &amp;quot;$http_host&amp;quot; , URL: &amp;quot;$request&amp;quot;  , request-status : &amp;quot;$status&amp;quot;  ,   &#39;
                  &#39;body-byte: $body_bytes_sent  ,http-referer: &amp;quot;$http_referer&amp;quot;  ,&#39;
                  &#39;user-agent: &amp;quot;$http_user_agent&amp;quot; , X-Forwarded-For : &amp;quot;$http_x_forwarded_for&amp;quot; ,  &#39;
                  &#39; request-time: &amp;quot;$request_time&amp;quot;  , response_time : &amp;quot;$upstream_response_time&amp;quot;  &#39;;

client_max_body_size 100m;
gzip on;
gzip_min_length 1k;
gzip_buffers 4 16k;
gzip_comp_level 5;
gzip_types text/plain text/css application/x-javascript application/javascript application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;

# GCP HTTP(S) LoadBalancer will add Via, but nginx check it to disable compress by default...
gzip_proxied any;
gzip_vary on;

server {
    listen 80 default_server;
    listen [::]:80 default_server;
    access_log  /dev/stdout   client;
      error_log /dev/stderr;
        
    index index.html index.htm;
    location = /favicon.ico { access_log off; log_not_found off; }
    location = /robots.txt  { access_log off; log_not_found off; }
      

    location /api/socket.io/ {
        proxy_pass http://rd5-api;
        proxy_set_header Host $host;
        proxy_set_header token $rd5_token;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        # proxy_set_header X-NginX-Proxy true;
        proxy_set_header X-Real-IP $remote_addr;
        # proxy_set_header via &#39;proxy_pass/token-proxy ws&#39;;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection &amp;quot;Upgrade&amp;quot;;
        proxy_read_timeout 1d;
        
    }

    location /50x.html {
        root /usr/share/nginx/html/frontend-client/;
        internal;
    }
    location /healthz {
        access_log off;
        return 200 &#39;ok&#39;;
    }

    location / {
        error_page 418 = @fjysdz;
        recursive_error_pages on;

        if ($host = &#39;yb-test.fjysdz.cn&#39;) {
           return 418;
        }
        rewrite &amp;quot;^(.*)&#92;$&amp;quot; $1 permanent; # 去除url尾部重複斜線
        root /usr/share/nginx/html/frontend-client/$dir;
        add_header via frontend-proxy;
        try_files $uri $uri/ /index.html /index.htm =404;
    }



}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後就出現錯誤了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;server_tokens&amp;quot; directive is not allowed here&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我百思不得其解，我明明是照抄的怎麼會錯。&lt;br /&gt;
後來將server_tokens搬進去 server 的區塊內，好了能跑了。&lt;br /&gt;
但又爆出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;log_format&amp;quot; directive is not allowed here&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我又只好在最外層加上http {}  ，但心中一直有一個疑問，&lt;br /&gt;
為什麼會失敗！？&lt;/p&gt;
&lt;p&gt;最後變成這樣&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
events {
     worker_connections 1024;
}
http {

log_format  client  &#39;$remote_addr - $remote_user [$time_local] , &#39;
                  &#39;http-host: &amp;quot;$http_host&amp;quot; , URL: &amp;quot;$request&amp;quot;  , request-status : &amp;quot;$status&amp;quot;  ,   &#39;
                  &#39;body-byte: $body_bytes_sent  ,http-referer: &amp;quot;$http_referer&amp;quot;  ,&#39;
                  &#39;user-agent: &amp;quot;$http_user_agent&amp;quot; , X-Forwarded-For : &amp;quot;$http_x_forwarded_for&amp;quot; ,  &#39;
                  &#39; request-time: &amp;quot;$request_time&amp;quot;  , response_time : &amp;quot;$upstream_response_time&amp;quot;  &#39;;

client_max_body_size 100m;
gzip on;
gzip_min_length 1k;
gzip_buffers 4 16k;
gzip_comp_level 5;
gzip_types text/plain text/css application/x-javascript application/javascript application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;

# GCP HTTP(S) LoadBalancer will add Via, but nginx check it to disable compress by default...
gzip_proxied any;
gzip_vary on;

server {

    server_tokens off;
    listen 80 default_server;
    listen [::]:80 default_server;
    access_log  /dev/stdout   client;
      error_log /dev/stderr;
        
    index index.html index.htm;
    location = /favicon.ico { access_log off; log_not_found off; }
    location = /robots.txt  { access_log off; log_not_found off; }
      
    location /conf/domain {
       access_log off;
        default_type application/json;
        add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;
        add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET&#39;;
        return 200 &#39;{&amp;quot;domain&amp;quot;:&amp;quot;500015&amp;quot;, &amp;quot;site&amp;quot;: &amp;quot;porn1&amp;quot; ,&amp;quot;cdn&amp;quot;:&amp;quot;x-cdn-yb&amp;quot;}&#39;;
    }

    # frontend-client
    error_page 404 /404.html;
    error_page 500 502 503 504 /50x.html;
    location /404.html {
        root /usr/share/nginx/html/frontend-client/;
        internal;
    }
    location /50x.html {
        root /usr/share/nginx/html/frontend-client/;
        internal;
    }
    location /healthz {
        access_log off;
        return 200 &#39;ok&#39;;
    }

    location / {
        rewrite &amp;quot;^(.*)&#92;$&amp;quot; $1 permanent; # 去除url尾部重複斜線
        root /usr/share/nginx/html/$dir;
        add_header via frontend-proxy;
        try_files $uri $uri/ /index.html /index.htm =404;
    }


}


}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跑是能正常跑了，但頁面載入一直出問題，&lt;br /&gt;
因為nginx log正常了，就聯絡前端同仁幫看一下。&lt;br /&gt;
他說從伺服器取得的css context-type有問題。&lt;br /&gt;
查了一下，又發現一個東西沒帶。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;include /etc/nginx/mime.types;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;為什麼一個能跑一個不能跑？？？&lt;br /&gt;
最後發現一個重點。&lt;/p&gt;
&lt;h3 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h3&gt;
&lt;p&gt;Nginx 的設定檔預設的位置是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/etc/nginx/nginx.conf&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然後，這個檔案裡面會先寫好預設的設定。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &#39;
                      &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39;
                      &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&#39;;

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#tcp_nopush&quot;&gt;#tcp_nopush&lt;/a&gt;     on;

    keepalive_timeout  65;

    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#gzip&quot;&gt;#gzip&lt;/a&gt;  on;

    include /etc/nginx/conf.d/*.conf;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以能跑的服務，是因為他的設定檔放在 conf.d 裡面，&lt;br /&gt;
所以是從 nginx.conf載入 /etc/nginx/conf.d/*.conf 的設定。&lt;/p&gt;
&lt;p&gt;而不能跑的服務，我是將設定檔直接覆蓋 /etc/nginx/nginx.conf  ，&lt;br /&gt;
所以上面那一些設定我都沒寫到。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.796t.com/content/1546357704.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;nginx中CSS重定向解析有問題——mime.type詳解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/188358/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Nginx筆記（二）Nginx基礎&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🌐 Network/99. nginx的除錯筆記/" />
        </entry>
        <entry>
            <title>
                92. proxy 代理
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🌐 Network/92. proxy 代理/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;代理伺服器，以前最常用過的應該是Hinet的proxy，&lt;br /&gt;
在以前網路不快的時候，有時會掛prxoy，來讓瀏覽速度變快。&lt;br /&gt;
proxy的用途主要也是如此，將user的請求透過prxoy去跟網站取得資料，再回給user。&lt;/p&gt;
&lt;p&gt;但proxy分成很多種..下面簡單說明&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;HTTP代理&lt;br /&gt;
主要用於存取網頁，一般有內容過濾和快取功能（將HTTP請求轉發到所需的HTTP伺服器）。&lt;br /&gt;
user使用方法，是瀏覽器掛http代理伺服器後，去瀏覽網頁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP代理&lt;br /&gt;
伺服器端實作轉發TCP請求，當訪問本機的port時，會轉到指定ip的port上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP代理&lt;br /&gt;
伺服器端實作轉發UDP請求，當訪問本機的port時，會轉到指定ip的port上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;內網穿透&lt;br /&gt;
將內網服務提供給外部做使用, Ngrok,frp&lt;br /&gt;
，當請求連到外網server的固定port時，轉發到內網服務的port上。&lt;br /&gt;
（需在提供服務的內網server及外網的server分別設定）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SOCKS代理&lt;br /&gt;
只是單純傳遞封包，不關心具體協定和用法，所以速度快很多（更低的協定，SOCKS5能處理udp protocol)。&lt;br /&gt;
第五層協定，故能處理HTTP，HTTPS，POP3，SMTP和FTP。&lt;br /&gt;
user簡易使用方法：使用 ssh tunnel 連到內部主機。&lt;br /&gt;
(比較偏伺服器端建設，需額外的軟體透過socks協定連入)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SS代理&lt;br /&gt;
Shadowsocks，基於SOCKS5代理方式的加密協定&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref.&lt;br /&gt;
1. &lt;a href=&quot;https://zh.wikipedia.org/zh-tw/SOCKS&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SOCKS&lt;/a&gt;&lt;br /&gt;
2. &lt;a href=&quot;https://zh.wikipedia.org/zh-tw/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;代理伺服器&lt;/a&gt;&lt;br /&gt;
3. &lt;a href=&quot;https://www.netadmin.com.tw/netadmin/zh-tw/technology/E76819FB28CC4C3D99D3A6C37B6BD3F4&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;實戰frp內網穿透　內部主機也能對外服務&lt;/a&gt;&lt;br /&gt;
4. &lt;a href=&quot;https://www.easyatm.com.tw/wiki/SOCKS5%E4%BB%A3%E7%90%86&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SOCKS5代理&lt;/a&gt;&lt;br /&gt;
5. &lt;a href=&quot;https://yangxikun.com/http/2017/09/16/http-proxy.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Golang動手寫一個Http Proxy&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;題外話補充：&lt;/p&gt;
&lt;h2 id=&quot;正向代理：&quot; tabindex=&quot;-1&quot;&gt;正向代理：&lt;/h2&gt;
&lt;p&gt;代理用戶端，讓伺服器不知道用戶的IP&lt;/p&gt;
&lt;h2 id=&quot;反向代理：&quot; tabindex=&quot;-1&quot;&gt;反向代理：&lt;/h2&gt;
&lt;p&gt;代理伺服器端，讓用戶不知道伺服器端的IP&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://www.pressplay.cc/author/28A3631456F0C5949514CAD4CB43150D&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;用人類語言跟你說甚麼是正向代理(Forward Proxy)和反向代理(Reverse Proxy)&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🌐 Network/92. proxy 代理/" />
        </entry>
        <entry>
            <title>
                182. Fortigate 設定 內部服務負載平衡
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🌐 Network/182. Fortigate 設定 內部服務負載平衡/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;&amp;amp;(&lt;/em&gt;&amp;amp;%(%^&amp;amp;&lt;em&gt;%@#$%^((&amp;amp;^%&lt;/em&gt; 一連串消音，&lt;br /&gt;
說過我只會簡易的網路管理，然後現在叫我搞這個，&lt;br /&gt;
目前是第二次，再來一次，直接畢業好了。&lt;br /&gt;
直接去改客戶的防火牆設定是你瘋了，還是我瘋了。&lt;br /&gt;
弄不好網路全斷誰負責！？&lt;br /&gt;
還是你認爲網路很簡單，那你他馬的怎麼不自己搞。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;要達成的目標，user呼叫一個ip網址，會自動轉到其他的伺服器上面 。&lt;/p&gt;
&lt;p&gt;主要參考fortigate官網說明，&lt;a href=&quot;https://docs.fortinet.com/document/fortigate/6.2.15/cookbook/713497/virtual-server&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Virtual server&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;測試使用的FortiOS版本為 7.2.5&lt;/p&gt;
&lt;h4 id=&quot;簡略說明&quot; tabindex=&quot;-1&quot;&gt;簡略說明&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;打開 Virtual server&lt;br /&gt;
如果沒看到，需到 System -&amp;gt; Feature Visibility 開啓 Additional Features底下的  Load Balance&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8C%90%20Network/182-fig.1.png&quot; alt=&quot;182-fig.1.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;新增Virtual Server&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8C%90%20Network/182-fig.2.png&quot; alt=&quot;182-fig.2.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;新增Firewall Policy&lt;br /&gt;
問題點在 Inspection Mode ，選擇 Flow-based的話，會找不到你剛剛設定的virtual server，必需設定Proxy-based才有&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8C%90%20Network/182-fig.3.png&quot; alt=&quot;182-fig.3.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8C%90%20Network/182-fig.4.png&quot; alt=&quot;182-fig.4.png&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;troubleshoting&quot; tabindex=&quot;-1&quot;&gt;troubleshoting&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;測試結果跟沒走virtual server不一樣？&lt;br /&gt;
檢查看看 virtual server 的 Persistence 有沒有設定 HTTP Cookie&lt;/li&gt;
&lt;li&gt;呼叫api，發現呼叫的都是同一個ip&lt;br /&gt;
檢查一下 Load Balancing method 是不是設定成 Static，上面設定就設錯了，導致固定只打同一個。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8C%90%20Network/182-fig.5.png&quot; alt=&quot;182-fig.5.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;Firewall Policy的 Inspection Mode 沒出現選項&lt;br /&gt;
這塊比較不確定，但我是先到 System -&amp;gt; Feature Visibility 開啓 Security Features底下的  Zero Trust Network Access後，才突然跑出來，但我把他關掉，也沒有消失...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://docs.fortinet.com/document/fortigate/6.2.15/cookbook/713497/virtual-server&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Virtual server&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🌐 Network/182. Fortigate 設定 內部服務負載平衡/" />
        </entry>
        <entry>
            <title>
                176. Nginx cheat sheet
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🌐 Network/176. Nginx cheat sheet/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;驗證nginx的http2開啓方式時，&lt;br /&gt;
才突然驚覺我需要一個nginx cheat sheet&lt;br /&gt;
不然怎麼單純回個狀態都不知道去哪抄&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h4 id=&quot;response-200&quot; tabindex=&quot;-1&quot;&gt;response 200&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;location / {
    add_header Content-Type text/plain;
    return 200 &#39;Hey James,Say Hello Nginx&#39;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;自簽憑證&quot; tabindex=&quot;-1&quot;&gt;自簽憑證&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout example.key -out example.crt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Common Name時，記得輸入你目前電腦的ip，&lt;br /&gt;
產生完後，掛載對應的volume到nginx裏面。&lt;br /&gt;
更改config。&lt;/p&gt;
&lt;p&gt;docker-compose.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;
version: &#39;3.8&#39;
services:
  nginx-lb:
    container_name: nginx
    image: nginx
    pull_policy: if_not_present
    restart: always
    volumes:
      - ./certs:/etc/ssl
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./proxy.conf:/etc/nginx/conf.d/proxy.conf
    ports:
      - 443:443
      - 80:80
    networks:
      - internal
networks:
  internal:
    name: internal
    driver: bridge
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;proxy.conf(某個nginx版本後 http2開啓的方式要改用下面的方式)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
    listen       443 ssl;
    server_name  192.168.1.106;
    http2 on;

    ssl_certificate           /etc/ssl/example.crt;
    ssl_certificate_key       /etc/ssl/example.key;
    ssl_protocols             TLSv1.3 TLSv1.2;
    ssl_prefer_server_ciphers on;
    ssl_ecdh_curve            X25519:secp521r1:secp384r1;
    ssl_ciphers               TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    ssl_session_cache         shared:TLS:2m;
    ssl_buffer_size           4k;

	location / {
	    add_header Content-Type text/plain;
	    return 200 &#39;Hey James,Say Hello Nginx&#39;;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;proxy-pass&quot; tabindex=&quot;-1&quot;&gt;Proxy_pass&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;proxy_pass url&lt;/code&gt; 中包含路徑時，結尾的 &lt;code&gt;/&lt;/code&gt; 最好同 &lt;code&gt;location&lt;/code&gt; 匹配規則一致。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://xuexb.github.io/learn-nginx/example/proxy_pass.html#url-%E5%8F%AA%E6%98%AF-host&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;proxy_pass url 反向代理的坑&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🌐 Network/176. Nginx cheat sheet/" />
        </entry>
        <entry>
            <title>
                169. Nginx的負載平衡
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🌐 Network/169. Nginx的負載平衡/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡唸&quot; tabindex=&quot;-1&quot;&gt;睡睡唸&lt;/h1&gt;
&lt;p&gt;雖然知道nginx應該可以做到負載平衡，&lt;br /&gt;
但從來沒弄過，&lt;br /&gt;
查了一下，還挺簡單的。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;主要有四種模式，&lt;br /&gt;
都是寫在upstream底下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;輪詢(Round Robin) ：什麼都不要寫，預設的方法&lt;/li&gt;
&lt;li&gt;最少連接(least_conn)：會轉發到伺服器連接數最少的那臺&lt;/li&gt;
&lt;li&gt;ip地址雜湊(ip_hash)：使用者會連到特定的伺服器上&lt;/li&gt;
&lt;li&gt;權重劃分(weight)：根據權重比例切換伺服器，這種寫法跟上面的三種不一樣。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.cnblogs.com/felixzh/p/9047021.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Nginx負載平衡的4種方式 ：輪詢-Round Robin 、Ip地址-ip_hash、最少連接-least_conn、加權-weight=n&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;config.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;upstream yolox-brand {
    least_conn;
    server yolox-brand-1:8080;
    server yolox-brand-2:8080;
}

server {
    listen       80;
    server_name  192.168.1.79;

    location / {
        proxy_pass         http://yolox-brand;
        proxy_redirect     off;
        proxy_set_header   Host $host;
        proxy_set_header   X-Real-IP $remote_addr;
        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header   X-Forwarded-Host $server_name;
        
        proxy_hide_header  &#39;Access-Control-Allow-Origin&#39;;
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods &#39;GET, POST, OPTIONS&#39;;
        add_header Access-Control-Allow-Headers &#39;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#39;;

        if ($request_method = &#39;OPTIONS&#39;) {
            return 204;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後，docker-compose.yaml如下，&lt;br /&gt;
要注意別把config檔塞錯地方了，不然會碰到 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%8C%90%20Network/99.%20nginx%E7%9A%84%E9%99%A4%E9%8C%AF%E7%AD%86%E8%A8%98/&quot;&gt;99. nginx的除錯筆記&lt;/a&gt;的錯誤&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version: &#39;3.8&#39;
services:
  python-1:
    container_name: yolox-brand-1
    image: busybox
    pull_policy: if_not_present
    restart: always
    networks:
      - internal
  python-2:
    container_name: yolox-brand-2
    image: busybox
    pull_policy: if_not_present
    restart: always
    networks:
      - internal
  nginx-lb:
    container_name: nginx
    image: nginx
    pull_policy: if_not_present
    restart: always
    volumes:
      - ./proxy.conf:/etc/nginx/conf.d/proxy.conf
    ports:
      - 80:80
    networks:
      - internal
networks:
  internal:
    name: internal
    driver: bridge
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;補充，&lt;code&gt;proxy_pass url&lt;/code&gt; 中包含路徑時，結尾的 &lt;code&gt;/&lt;/code&gt; 最好同 &lt;code&gt;location&lt;/code&gt; 匹配規則一致。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://xuexb.github.io/learn-nginx/example/proxy_pass.html#url-%E5%8C%85%E5%90%AB%E8%B7%AF%E5%BE%84&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;proxy_pass url 反向代理的坑&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🌐 Network/169. Nginx的負載平衡/" />
        </entry>
        <entry>
            <title>
                106. zyxel 與 fortigate 建立VPN 點對點通道
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🌐 Network/106. zyxel 與 fortigate 建立VPN 點對點通道/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;換公司後，DevOps還要兼網管，&lt;br /&gt;
然後，在辦公室還要連vpn才能連到dev的開發環境（？&lt;br /&gt;
我很懶，為什麼要這樣對我，&lt;br /&gt;
所以...就改了吧。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8C%90%20Network/106.fig-1.png&quot; alt=&quot;106.fig-1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;預計完成的架構圖如上&lt;/p&gt;
&lt;p&gt;有幾個地方的坑很深，&lt;br /&gt;
建議都先查一下。&lt;/p&gt;
&lt;p&gt;本次做的是site to site VPN連線&lt;/p&gt;
&lt;h3 id=&quot;1&quot; tabindex=&quot;-1&quot;&gt;1. 檢查小烏龜跟防火牆的連線方式&lt;/h3&gt;
&lt;p&gt;因爲有申請固定ip，但本來是透過小烏龜連到外網，&lt;br /&gt;
後來一查才發現應該是要讓Firewall自己擁有實體ip才對。&lt;br /&gt;
不用再透過FW。&lt;/p&gt;
&lt;p&gt;有幾種解法，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;小烏龜改bridge mode （網路上看到的都這種居多）&lt;/li&gt;
&lt;li&gt;小烏龜改浮動ip撥接，然後再FW上使用固定ip 撥接方式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重點是要讓防火牆有直接的對外ip，環境上會比較單純。&lt;br /&gt;
我之前的環境，小烏龜連到Zyxel 是192.168.1.X ，&lt;br /&gt;
然後小烏龜接防火牆走wan port，但到內部的機器ip也是192.168.1.X，&lt;/p&gt;
&lt;h3 id=&quot;2-ip-sec&quot; tabindex=&quot;-1&quot;&gt;2.設定 ipSec&lt;/h3&gt;
&lt;p&gt;這邊設定的方式網路上很多種，可以先看一下 &lt;a href=&quot;https://community.zyxel.com/tw/discussion/13794/nebula-x-firewall-%E8%88%87fortigate%E5%BB%BA%E7%AB%8Bipsec%E7%AB%99%E5%88%B0%E7%AB%99site-to-site-vpn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [Nebula x Firewall]與Fortigate建立IPSec站到站site-to-site VPN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;關鍵點在，Phase 1、Phase 2跟金鑰的設定一定要兩臺一樣。&lt;/p&gt;
&lt;p&gt;我在連線的時候，一直碰到ZyXel 連vpn時 一直timeout，&lt;br /&gt;
最後是在改完 1 的架構以後，一整個雨過天晴&lt;/p&gt;
&lt;p&gt;Zyxel的IPsec設定&lt;br /&gt;
本地的ip跟遠端的ip要分清楚&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8C%90%20Network/106.fig-2.png&quot; alt=&quot;106.fig-2.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8C%90%20Network/106.fig-3.png&quot; alt=&quot;106.fig-3.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;fortigate的IPsec通道 設定&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8C%90%20Network/106.fig-4.jpg&quot; alt=&quot;106.fig-4.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8C%90%20Network/106.fig-5.jpg&quot; alt=&quot;106.fig-5.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8C%90%20Network/106.fig-6.jpg&quot; alt=&quot;106.fig-6.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然後檢查連線有沒有通，&lt;br /&gt;
兩邊都要設定好，才會通。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8C%90%20Network/106.fig-6-2.jpg&quot; alt=&quot;106.fig-6-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;3&quot; tabindex=&quot;-1&quot;&gt;3. 設定路由&lt;/h3&gt;
&lt;p&gt;我看的網路上的教學，他們是一設定好後，就連的通了。&lt;br /&gt;
但我怎麼連就是不通。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用tracert看路由，是只跑到192.168.1.1 (Zyxel FW上)，就沒在往下了。於是先弄個（ZyXel )策略路由，看轉不轉的過去。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8C%90%20Network/106.fig-7.jpg&quot; alt=&quot;106.fig-7.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fortigate的防火牆策略及路由，防火牆記得不能開NAT。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8C%90%20Network/106.fig-11.jpg&quot; alt=&quot;106.fig-11.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8C%90%20Network/106.fig-12.jpg&quot; alt=&quot;106.fig-12.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;fortigate上面檢查的方式有兩種&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;撈封包，然後用wireshark看&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8C%90%20Network/106.fig-8.jpg&quot; alt=&quot;106.fig-8.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8C%90%20Network/106.fig-9.jpg&quot; alt=&quot;106.fig-9.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;到fortigate的 CLI控制檯下指令查(這個比較快)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;diag debug reset
diag debug flow filter clear
diagnose sniffer packet any &amp;quot;host 192.168.103.221 and icmp&amp;quot; 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正常的話，會像這樣有回應&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%8C%90%20Network/106.fig-10.jpg&quot; alt=&quot;106.fig-10.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我當時碰到的是有流量打到 fortigate的機器上，但沒有轉過去，&lt;br /&gt;
所以路由跟防火牆&lt;/p&gt;
&lt;h3 id=&quot;結語&quot; tabindex=&quot;-1&quot;&gt;結語&lt;/h3&gt;
&lt;p&gt;花了我三天的時間，我真的只是個半吊子的網管，網路我不熟阿  嗚嗚...(╥﹏╥)&lt;br /&gt;
讓我懷念起以前當MIS時的防火牆設定，都是廠商幫我們設定的，我們只要稍微知道一些管理就好，感謝ShareTech 。老闆！！如果下次採購時，我還在的話，我要換廠商啊啊啊。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ichiayi.com/tech/fortigate_tips&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;有關 FortiGate 防火牆相關設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://community.zyxel.com/tw/discussion/13794/nebula-x-firewall-%E8%88%87fortigate%E5%BB%BA%E7%AB%8Bipsec%E7%AB%99%E5%88%B0%E7%AB%99site-to-site-vpn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [Nebula x Firewall]與Fortigate建立IPSec站到站site-to-site VPN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🌐 Network/106. zyxel 與 fortigate 建立VPN 點對點通道/" />
        </entry>
        <entry>
            <title>
                102. OSI七層
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🌐 Network/102. OSI七層/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;因為一直背不起來 OSI七層，上網查了下發現還真的有人發明了口訣&lt;br /&gt;
OSI由最上層往下&lt;br /&gt;
All People Seem To Need Domino&#39;s Pizza&lt;br /&gt;
（所有的人看來都需要達美樂比薩)&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Application ：應用層&lt;br /&gt;
主要功能是處理應用程式，進而提供使用者網路應用服務，&lt;br /&gt;
透過通訊協定(DHCP、FTP、HTTP...)和資料操作，將資訊整合起來，提供給使用者進行操作&lt;/li&gt;
&lt;li&gt;Presentation ：展示層&lt;br /&gt;
展示層主要負責轉譯、加密和壓縮資料&lt;/li&gt;
&lt;li&gt;Session ：會議層&lt;br /&gt;
會議層主要負責建立網絡連線，等到資料傳輸結束時，再將連線中斷。&lt;/li&gt;
&lt;li&gt;Transport ：傳輸層&lt;br /&gt;
傳輸層的主要用途是，協助OSI前三層與OSI後三層進行溝通，傳輸層也負責處理流量控制和錯誤控制。&lt;/li&gt;
&lt;li&gt;Network ：網路層&lt;br /&gt;
網路層是針對位於不同網路(WAN)的兩個裝置，促進兩者之間的資料傳輸。&lt;br /&gt;
(路由器及Layer 3交換器即屬於第三層的網路設備，主要以IP作為資料傳輸依據)&lt;/li&gt;
&lt;li&gt;Data Link：資料連結層&lt;br /&gt;
資料連結層是針對位於相同網路(LAN)的兩個裝置，促進兩者之間的資料傳輸。&lt;br /&gt;
(網路交換器（Switch）是這個層級常見的設備，主要在區域網路上運作，能依據MAC位址，將網路資料傳送到目的主機上。)&lt;/li&gt;
&lt;li&gt;Physical：實體層&lt;br /&gt;
實體層主要是用來定義設備裝置之間位元資料傳輸，也就是透過物理線材連接至其他實體設備，傳遞0和1的數位訊號。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://vocus.cc/article/618c7853fd8978000108c4d5&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;OSI 七層架構&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://www.ithome.com.tw/tech/47085&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;什麼是OSI的7層架構？&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/🌐 Network/102. OSI七層/" />
        </entry>
        <entry>
            <title>
                0.Network MOC
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🌐 Network/0.Network MOC/</id>
            <content type="html">
                &lt;h1 id=&quot;基礎&quot; tabindex=&quot;-1&quot;&gt;基礎&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%8C%90%20Network/92.%20proxy%20%E4%BB%A3%E7%90%86/&quot;&gt;92. proxy 代理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%8C%90%20Network/102.%20OSI%E4%B8%83%E5%B1%A4/&quot;&gt;102. OSI七層&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;nginx&quot; tabindex=&quot;-1&quot;&gt;Nginx&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%8C%90%20Network/169.%20Nginx%E7%9A%84%E8%B2%A0%E8%BC%89%E5%B9%B3%E8%A1%A1/&quot;&gt;169. Nginx的負載平衡&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%8C%90%20Network/176.%20Nginx%20cheat%20sheet/&quot;&gt;176. Nginx cheat sheet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%8C%90%20Network/99.%20nginx%E7%9A%84%E9%99%A4%E9%8C%AF%E7%AD%86%E8%A8%98/&quot;&gt;99. nginx的除錯筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%8C%90%20Network/106.%20zyxel%20%E8%88%87%20fortigate%20%E5%BB%BA%E7%AB%8BVPN%20%E9%BB%9E%E5%B0%8D%E9%BB%9E%E9%80%9A%E9%81%93/&quot;&gt;106. zyxel 與 fortigate 建立VPN 點對點通道&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🌐 Network/0.Network MOC/" />
        </entry>
        <entry>
            <title>
                160.Obsidian發佈網站
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🆒 SideProject/160.Obsidian發佈網站/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;因為被google的blog搞了一波（原因請看&lt;a href=&quot;https://daimom3020.blogspot.com/2023/07/blog-post.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;這&lt;/a&gt; ），&lt;br /&gt;
讓我終於下定決心研究 md轉html的方法。&lt;/p&gt;
&lt;h1 id=&quot;發佈方式&quot; tabindex=&quot;-1&quot;&gt;發佈方式&lt;/h1&gt;
&lt;p&gt;從Obsidian發佈主要有幾種方法，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;官方提供 ，每個月8美金，詳情參考 &lt;a href=&quot;https://obsidian.md/publish&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;這裏&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;jekyll ，也有人是用這個掛上去的，格式稍微改一下，然後在github上面改一下設定，push上去就會自動部署了，改天再用另一篇介紹，因為要改許多東西，我就沒用這種了&lt;/li&gt;
&lt;li&gt;Obsidian的第三方plugin , Digital Garden ，本篇就是透過這套來發佈網站。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;原文連結： &lt;a href=&quot;https://dg-docs.ole.dev/getting-started/01-getting-started/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Digital Garden-Get start&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先在obsidian安裝 digital Garden&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%86%92%20SideProject/160-fig.1.jpg&quot; alt=&quot;160-fig.1.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%86%92%20SideProject/160-fig.2.jpg&quot; alt=&quot;160-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一個&lt;a href=&quot;https://daimom.github.io/github.com&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Github&lt;/a&gt;帳號。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;申請 &lt;a href=&quot;https://vercel.com/signup&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Vercel&lt;/a&gt;，用github帳號登入。&lt;br /&gt;
如果要用&lt;a href=&quot;https://www.netlify.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Netlify&lt;/a&gt;應該也可以，&lt;br /&gt;
這兩個網站都是直接用子域名作爲你的網站名稱，&lt;br /&gt;
github以前也有，但現在已經改掉了。&lt;br /&gt;
(記得在這邊，會問你要給Vercel哪個repostory的權限，可以全給，之後再到github 的設定指定repostory就好)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打開作者的&lt;a href=&quot;https://github.com/oleeskild/digitalgarden&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;repository &lt;/a&gt;，按下下面的部署按鈕，會到Vercel部署一個網站。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%86%92%20SideProject/160-fig.3.jpg&quot; alt=&quot;160-fig.3.jpg&quot; /&gt;&lt;br /&gt;
如果你熟git的話，也可以直接clone那個repository，&lt;br /&gt;
再自己到vercel或Netlify部署上去也可以。&lt;/p&gt;
&lt;p&gt;如果你想要再本機測試開啓的話，&lt;br /&gt;
clone這個專案後，執行下面程式，注意需先安裝&lt;a href=&quot;https://nodejs.org/zh-tw/download&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;nodejs&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;npm install
npm run build
npm run start
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;再來需建立github token，這是為了讓Vercel可以讀取到你的repostory。&lt;br /&gt;
開啓&lt;a href=&quot;https://github.com/settings/tokens/new?scopes=repo&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;github token&lt;/a&gt;，取個名字、建立。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&quot;github-token&quot; tabindex=&quot;-1&quot;&gt;建立github token&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%86%92%20SideProject/160-fig.4.jpg&quot; alt=&quot;160-fig.4.jpg&quot; /&gt;&lt;br /&gt;
Expiration ：到期天數，如果不想一直改的話，就設定沒有期限。&lt;br /&gt;
下面紅框是必須要有的權限。&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;
&lt;p&gt;打開你的obsidian的Digital Garden設定&lt;br /&gt;
在四個方塊裏面輸入你的資訊&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%86%92%20SideProject/160-fig.5.jpg&quot; alt=&quot;160-fig.5.jpg&quot; /&gt;&lt;br /&gt;
Github Repo Name： 前面所新增的repostory的名稱&lt;br /&gt;
Github UserName：你的帳號名稱&lt;br /&gt;
Github Token：步驟5建立的資料&lt;br /&gt;
BaseUrl ：如果你剛剛已經初步在Vercel建立一個網站的話，應該就會看到你的網址。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%86%92%20SideProject/160-fig.6.jpg&quot; alt=&quot;160-fig.6.jpg&quot; /&gt;&lt;br /&gt;
我這邊有兩個domain，前面的&lt;a href=&quot;http://daimom.vercel.app/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;http://daimom.vercel.app&lt;/a&gt;  是後來自定的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;發佈&lt;br /&gt;
先到你要設成首頁的文章上面，設定&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;dg-publish: true
dg-home: true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;dg-publish ：表示發佈&lt;br /&gt;
dg-home：表示設爲首頁&lt;/p&gt;
&lt;p&gt;再來你有兩種方法可以發佈，叫出Obsidian的命令面板&lt;br /&gt;
Win： CTRL+P&lt;br /&gt;
Mac：Cmd+P&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%86%92%20SideProject/160-fig.7.jpg&quot; alt=&quot;160-fig.7.jpg&quot; /&gt;&lt;br /&gt;
先輸入dg，然後會看到 &lt;code&gt;Digital Garden: Publish Single Note&lt;/code&gt;&lt;br /&gt;
執行後就會發佈到Vercel。&lt;/p&gt;
&lt;p&gt;或是 GUI畫面&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%86%92%20SideProject/160-fig.8.jpg&quot; alt=&quot;160-fig.8.jpg&quot; /&gt;&lt;br /&gt;
按下 &lt;code&gt;Publish unpublished Note&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;建置&lt;br /&gt;
如果你速度夠快，切到Vercel的網站，會看到Deployment正在執行的畫面，或是已經執行完成的畫面。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%86%92%20SideProject/160-fig.9.jpg&quot; alt=&quot;160-fig.9.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;q-and-amp-a&quot; tabindex=&quot;-1&quot;&gt;Q&amp;amp;A&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;切換主題的時候，有時候會沒有更改，此時請按下 設定的 Update site 的Manage site Template按鈕，他會幫你建立PR。 ref. &lt;a href=&quot;https://dg-docs.ole.dev/getting-started/06-updating-the-template/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Updating the template&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;主題改得只有顏色跟字體大小，如果要右邊的路徑圖可以到設定打開 &lt;code&gt;Show local graph for notes&lt;/code&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%86%92%20SideProject/160-fig.10.jpg&quot; alt=&quot;160-fig.10.jpg&quot; /&gt;&lt;br /&gt;
更多的設定，請參考&lt;a href=&quot;https://dg-docs.ole.dev/getting-started/03-note-settings/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Note settings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本篇的theme是 &lt;code&gt;Rmaki&lt;/code&gt; ，一些小設定是我改css跟js改出來的。&lt;/li&gt;
&lt;li&gt;如果要整批加入發佈的yaml，可以考慮使用 &lt;a href=&quot;https://github.com/chhoumann/MetaEdit&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;MetaEdit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;將Vercel的權限限縮特定repostory，先到github的個人設定畫面，找到 Application&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%86%92%20SideProject/160-fig.11.jpg&quot; alt=&quot;160-fig.11.jpg&quot; /&gt;&lt;br /&gt;
按下Configure&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%86%92%20SideProject/160-fig.12.jpg&quot; alt=&quot;160-fig.12.jpg&quot; /&gt;&lt;br /&gt;
從原先的All repostories改成 Only select repositories，&lt;br /&gt;
最後指定你的repository即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://dg-docs.ole.dev/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Digital Garden Doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://fengrin.me/posts/2022-12-19-publish-your-website-free-use-your-local-note-obsidian-gitHub-netlify&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;免費直接把筆記發佈成網站:Obsidian + GitHub + Netlify&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://notes.oldwinter.top/obsidian-%E7%9B%AE%E5%89%8D%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84%E5%85%8D%E8%B4%B9%E5%8F%91%E5%B8%83%E6%96%B9%E6%A1%88-%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%95%99%E7%A8%8B&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;obsidian 目前最完美的免費發佈方案 - 漸進式教學&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🆒 SideProject/160.Obsidian發佈網站/" />
        </entry>
        <entry>
            <title>
                125. Google sheet Query
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/🆒 SideProject/125. Google sheet Query/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;今天收到個消息，說要給user hosts的檔案，&lt;br /&gt;
裏面內容要包含目前的dns跟ip的對應，&lt;br /&gt;
但我日後不想手動更新阿...&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h2 id=&quot;開始發想&quot; tabindex=&quot;-1&quot;&gt;開始發想&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;本來是想用if ，單獨判斷一個欄位是不是符合規則。&lt;br /&gt;
但這樣會有個問題，當資料變動時，就必須手動拉公式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查到一個&lt;a href=&quot;https://vocus.cc/article/6162ebdafd89780001c6fb8b&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;importrange&lt;/a&gt;的函數，可以整批匯入資料，&lt;br /&gt;
但這樣我還是要分析截取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在查資料過程中，發現query函數，能夠整個sheet搜尋 ，&lt;br /&gt;
就像SQL語法一樣，就決定是你了！！！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;實作&quot; tabindex=&quot;-1&quot;&gt;實作&lt;/h2&gt;
&lt;p&gt;QUERY使用 欄位的做關鍵字，&lt;br /&gt;
不過只有基本的查詢功能。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;=query(Prod!4:1010,&amp;quot;select D,E,G where G=&#39;Y&#39; order by E desc&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%F0%9F%86%92%20SideProject/125-fig.1.jpg&quot; alt=&quot;125-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;比較特別的應該是&lt;br /&gt;
where裏面的 文字搜尋&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Where A contains &#39;Ezio&#39;      查詢包含Ezio的字
Where A starts with &#39;Ezio&#39;   查詢Ezio開頭的字
Where A ends with &#39;Ezio&#39;     查詢Ezio結尾的字
Where A like &#39;%Ezio&#39;         跟SQL的like差不多意思
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，like 後面接 % 是 任意字元  ,  如果接 _ 就是一個字元&lt;/p&gt;
&lt;p&gt;多了一些mysql 的語法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select A,B limit 3       只取3行的資料
select A,B offset 3      跳過3行，開始取資料
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;還有一個特別的，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select A,B SKIPPING 2     每隔2行抓一次資料
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他相似的就&lt;br /&gt;
聚合函數  SUM()、AVG()、COUNT()、MAX()、MIN()&lt;br /&gt;
排序 order by&lt;br /&gt;
另外還支援 PIVOT&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://vocus.cc/mrsheet/606b50b8fd897800011eba1d&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;QUERY 函式大解析（一）：基本原理與 SELECT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/🆒 SideProject/125. Google sheet Query/" />
        </entry>
        <entry>
            <title>
                89. istio 常見狀態碼
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/89. istio 常見狀態碼/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近用istio偵測，常碰到某個服務狀態會掉到80%以下，&lt;br /&gt;
那時都有看到APM的程式報錯，但沒人反應，最近有次發生在上班時間，&lt;br /&gt;
馬上聯絡同事看他的服務有沒有正常，&lt;br /&gt;
最後一路追，&lt;br /&gt;
發現狀態碼是回 503 DC ，對這個關鍵字有印象，但常會忘記他的全名。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/89-fig.1.png&quot; alt=&quot;89-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;下列為envoy常見縮寫比對&lt;/p&gt;
&lt;p&gt;HTTP and TCP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UH&lt;/strong&gt;: No healthy upstream hosts in upstream cluster in addition to 503 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UF&lt;/strong&gt;: Upstream connection failure in addition to 503 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UO&lt;/strong&gt;: Upstream overflow (&lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/circuit_breaking#arch-overview-circuit-break&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;circuit breaking&lt;/a&gt;) in addition to 503 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NR&lt;/strong&gt;: No &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/http_routing#arch-overview-http-routing&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;route configured&lt;/a&gt; for a given request in addition to 404 response code, or no matching filter chain for a downstream connection.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;URX&lt;/strong&gt;: The request was rejected because the &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#envoy-v3-api-field-config-route-v3-retrypolicy-num-retries&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;upstream retry limit (HTTP)&lt;/a&gt; or &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto#envoy-v3-api-field-extensions-filters-network-tcp-proxy-v3-tcpproxy-max-connect-attempts&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;maximum connect attempts (TCP)&lt;/a&gt; was reached.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NC&lt;/strong&gt;: Upstream cluster not found.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DT&lt;/strong&gt;: When a request or connection exceeded &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-max-connection-duration&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;max_connection_duration&lt;/a&gt; or &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto#envoy-v3-api-field-extensions-filters-network-tcp-proxy-v3-tcpproxy-max-downstream-connection-duration&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;max_downstream_connection_duration&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP only&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DC&lt;/strong&gt;: Downstream connection termination.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LH&lt;/strong&gt;: Local service failed &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/health_checking#arch-overview-health-checking&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;health check request&lt;/a&gt; in addition to 503 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UT&lt;/strong&gt;: Upstream request timeout in addition to 504 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: Connection local reset in addition to 503 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UR&lt;/strong&gt;: Upstream remote reset in addition to 503 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UC&lt;/strong&gt;: Upstream connection termination in addition to 503 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DI&lt;/strong&gt;: The request processing was delayed for a period specified via &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/fault_filter#config-http-filters-fault-injection&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;fault injection&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FI&lt;/strong&gt;: The request was aborted with a response code specified via &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/fault_filter#config-http-filters-fault-injection&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;fault injection&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RL&lt;/strong&gt;: The request was ratelimited locally by the &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/rate_limit_filter#config-http-filters-rate-limit&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;HTTP rate limit filter&lt;/a&gt; in addition to 429 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UAEX&lt;/strong&gt;: The request was denied by the external authorization service.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RLSE&lt;/strong&gt;: The request was rejected because there was an error in rate limit service.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;IH&lt;/strong&gt;: The request was rejected because it set an invalid value for a &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/http/router/v3/router.proto#envoy-v3-api-field-extensions-filters-http-router-v3-router-strict-check-headers&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;strictly-checked header&lt;/a&gt; in addition to 400 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SI&lt;/strong&gt;: Stream idle timeout in addition to 408 response code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DPE&lt;/strong&gt;: The downstream request had an HTTP protocol error.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UPE&lt;/strong&gt;: The upstream response had an HTTP protocol error.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;UMSDR&lt;/strong&gt;: The upstream request reached max stream duration.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;OM&lt;/strong&gt;: Overload Manager terminated the request.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DF&lt;/strong&gt;: The request was terminated due to DNS resolution failure.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;envoy Access logging&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://www.cnblogs.com/xuliang666/p/12089915.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;istio之envoy常見術語及狀態碼&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/89. istio 常見狀態碼/" />
        </entry>
        <entry>
            <title>
                75. istio virtual service 常用參數
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/75. istio virtual service 常用參數/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;有些東西偶爾會用，但碰到時就忘了怎麼寫，&lt;br /&gt;
還要回去翻一下，&lt;br /&gt;
此篇包含&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;set/remove header&lt;/li&gt;
&lt;li&gt;match header host 正規表示&lt;/li&gt;
&lt;li&gt;fault 回傳特定狀態&lt;/li&gt;
&lt;li&gt;allow cors&lt;/li&gt;
&lt;li&gt;rewrite&lt;/li&gt;
&lt;li&gt;match uri 正規表示&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;當同一個virtual service內，有多個match uri時，優先順序，是由上到下。&lt;br /&gt;
　&lt;br /&gt;
例如：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;match:
	- uri:
			prefix : /api
	- uri:
		    prefix: /api/video		
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這樣是永遠到不了 /api/video的&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;set/remove header&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;add or modify header&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spec:
  http:
    - name: api
      headers:
        request:
          set:
            x-forward-for: 127.0.0.1
      match:
        - uri:
            prefix: /api
      
      route:
        - destination:
            host: reverse-proxy.abc.svc.cluster.local
            port:
              number: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;remove header&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spec:
  http:
    - name: api
      headers:
        request:
          remove:
            - x-forward-for
      match:
        - uri:
            prefix: /api
      
      route:
        - destination:
            host: reverse-proxy.abc.svc.cluster.local
            port:
              number: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;match header host&lt;br /&gt;
當 header host有對應到 這兩個 domain其中一個的話，&lt;br /&gt;
則轉到對應的路徑&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;http:
  - match:
      - headers:
          Host:
            regex: (api.asia.com|api.american.com)
        uri:
          prefix: /api-v2
    rewrite:
      uri: /api
    route:
      - destination:
          host: reverse-proxy.abc.svc.cluster.local
          port:
            number: 80
        weight: 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;符合正則的皆進入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
hosts:
  - &#39;*&#39;
gateways:
  - istio-system/istio-gateway-external
  - istio-system/istio-gateway-internal
http:
  - match:
      - headers:
          Host:
            regex: sxqa2.?&#92;.777.+&#92;.com
    route:
      - destination:
          host: video-admin-api-primary
          port:
            number: 80
        weight: 100
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;fault&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;當路徑有倒到 api/v1/abc時，直接回傳 487的錯誤碼。&lt;br /&gt;
（這其實是拿來模擬錯誤用的）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http:
  - fault:
      abort:
        httpStatus: 487
        percentage:
          value: 100
    match:
      - uri:
          prefix: /api/v1/abc
    name: fault
    route:
      - destination:
          host: reverse-proxy.abc.svc.cluster.local
          port:
            number: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;allow cors&lt;br /&gt;
開啟 cors的允許範圍&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;http:
  - corsPolicy:
      allowHeaders:
        - &#39;*&#39;
      allowOrigin:
        - &#39;*&#39;
    match:
      - uri:
          prefix: /api
    name: filedownload
    route:
      - destination:
          host:  reverse-proxy.abc.svc.cluster.local
          port:
            number: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;rewrite&lt;br /&gt;
覆寫本來的uri&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;http:
  - match:
      - uri:
          prefix: /apmapi
    name: api
    rewrite:
      uri: /api
    route:
      - destination:
          host: reverse-proxy.abc.svc.cluster.local
          port:
            number: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在api之後的通通進去，但這種就無法使用rewrite了。&lt;br /&gt;
因為會將uri全部取代掉。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http:
  - match:
      - uri:
          regex: ^/api/.*
    route:
      - destination:
          host: yabo-api-qa-primary
          port:
            number: 80
        weight: 100
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/75. istio virtual service 常用參數/" />
        </entry>
        <entry>
            <title>
                73. istio sidecar 注入規則
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/73. istio sidecar 注入規則/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;因為drone 的 kubernetes Runner的關係，&lt;br /&gt;
導致我有一個ns要預設取消istio inject，&lt;br /&gt;
但某些特定的pod要注入就失敗了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;先來看一張官方做的表(1)，&lt;br /&gt;
其實就很好解釋為什麼不會注入了。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;namespaceSelector match&lt;/th&gt;
&lt;th&gt;default policy&lt;/th&gt;
&lt;th&gt;Pod override annotation &lt;a href=&quot;http://sidecar.istio.io/inject&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;sidecar.istio.io/inject&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;Sidecar injected?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;enabled&lt;/td&gt;
&lt;td&gt;true (default)&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;enabled&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;disabled&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;disabled&lt;/td&gt;
&lt;td&gt;false (default)&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;enabled&lt;/td&gt;
&lt;td&gt;true (default)&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;enabled&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;disabled&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;disabled&lt;/td&gt;
&lt;td&gt;false (default)&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;各欄位解釋，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;namespaceSelector match：各namespace的 istio-inject是 enable或 disable&lt;/li&gt;
&lt;li&gt;default policy： 這個預設都是enable，要查看使用command或到configmap查看 istio-sidecar-injector&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;kubectl -n istio-system get configmap istio-sidecar-injector -o jsonpath=&#39;{.data.config}&#39; | grep policy:

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Pod override annotation ： 直接指定pod會不會注入的 annotation&lt;/li&gt;
&lt;li&gt;Sidecar injected ：結果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;結論，&lt;br /&gt;
namespace只要是 disabled的，通通不會inject sidecar&lt;/p&gt;
&lt;h3 id=&quot;指令篇&quot; tabindex=&quot;-1&quot;&gt;指令篇&lt;/h3&gt;
&lt;p&gt;namespace&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;### 查看ns的label
kc get namespace --show-labels

### 新增修改 istio-injection
kubectl label namespace &amp;lt;my-namespace&amp;gt; istio-injection=enabled --overwrite

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;單獨指定deploy掛載sidecar&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  apiVersion: apps/v1
  kind: Deployment
  metadata:
	name: grafana
	namespace: istio-system
  spec:
	replicas: 1
	selector:
	  matchLabels:
		app: websocketclient
	template:
	  metadata:
		creationTimestamp: null
		labels:
		  app: websocketclient
		  sidecar.istio.io/inject: &#39;true&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
1. &lt;a href=&quot;https://istio.io/latest/docs/ops/configuration/mesh/injection-concepts/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Automatic Sidecar Injection&lt;/a&gt;&lt;br /&gt;
2. &lt;a href=&quot;https://istio.io/latest/zh/docs/ops/common-problems/injection/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Sidecar 自動注入問題&lt;/a&gt;&lt;br /&gt;
3. &lt;a href=&quot;https://morpheushuang.medium.com/istio-automatic-sidecar-injection-543-4981ae7375f7&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;關於Istio Automatic Sidecar Injection那檔事&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/73. istio sidecar 注入規則/" />
        </entry>
        <entry>
            <title>
                7. Istio安裝及使用
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/7. Istio安裝及使用/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;k8s還沒摸很熟，新的東西就過來了。&lt;br /&gt;
這次是server mesh架構...&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;前個工作還沒結束，新的東西就來了。&lt;br /&gt;
這次搞Istio，當然可以在東西都建立完後，再開始玩。&lt;br /&gt;
但這樣就會變成要把舊的pod砍掉重新建立了。&lt;/p&gt;
&lt;h2 id=&quot;istio&quot; tabindex=&quot;-1&quot;&gt;Istio 知識圖譜&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/servicemesher/istio-knowledge-map/master/png/istio-knowledge-map.png&quot; alt=&quot;image&quot; /&gt;&lt;br /&gt;
ref.&lt;a href=&quot;https://github.com/servicemesher/istio-knowledge-map&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio Knowledge Map&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安裝前&quot; tabindex=&quot;-1&quot;&gt;安裝前&lt;/h2&gt;
&lt;p&gt;有查到要安裝istio 有最低的資源限制，但沒看到有明確的指定。&lt;br /&gt;
目前測試GKE的機器  設成 cpu 1 ram 2G 會發生 timeout的錯誤，&lt;br /&gt;
改成 cpu 2,ram 4G 則無此狀況。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/7.fig-4.jpg&quot; alt=&quot;7.fig-4.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://stackoverflow.com/questions/64373346/istioctl-install-fails-with-multiple-timeouts&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;istioctl install fails with multiple timeouts&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;機器大小設定&quot; tabindex=&quot;-1&quot;&gt;機器大小設定&lt;/h2&gt;
&lt;p&gt;主要的節點區域，cpu則會吃到 900 mCPU，記憶體 2.75G&lt;br /&gt;
還沒安裝 kiali,jaeger,prometheus...等，&lt;br /&gt;
開機器大小時，需特別注意。&lt;/p&gt;
&lt;h2 id=&quot;開始安裝&quot; tabindex=&quot;-1&quot;&gt;開始安裝&lt;/h2&gt;
&lt;p&gt;這次要安裝在GKE上，此次安裝的配置是 minimal版，&lt;br /&gt;
各版本的差異，不要看中文的，沒有更新。如果要看原理可以看。&lt;br /&gt;
請參考 &lt;a href=&quot;https://istio.io/latest/docs/setup/additional-setup/config-profiles/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Installation Configuration Profiles&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; curl -L https://istio.io/downloadIstio | sh -
 cd istio-1.8.1
 export PATH=$PWD/bin:$PATH
 istioctl install
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;移除安裝&quot; tabindex=&quot;-1&quot;&gt;移除安裝&lt;/h2&gt;
&lt;p&gt;1.20指令更改為  &lt;code&gt;istioctl uninstall -y --purge&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istioctl x uninstall --purge&lt;/code&gt;&lt;br /&gt;
(注意 purge會把共用的東西通通刪光光，不使用purge也可刪除，但會留下 deployment以及 service)&lt;br /&gt;
istioctl x uninstall -f /Users/ezio_liu/Documents/k8s/Sample-Yaml/istio-sample-newingeressway.yaml   （當初安裝的yaml)&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://istio.io/latest/docs/setup/getting-started/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Getting Started&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://istio.io/latest/docs/setup/install/istioctl/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Uninstall Istio&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安裝套件&quot; tabindex=&quot;-1&quot;&gt;安裝套件&lt;/h2&gt;
&lt;p&gt;在原目錄下執行&lt;/p&gt;
&lt;p&gt;kubectl apply -f samples/addons&lt;br /&gt;
第一次執行完可能會有錯誤，可以在執行一次。&lt;br /&gt;
因執行建置的機器，會有時間差。&lt;br /&gt;
ref. &lt;a href=&quot;https://github.com/istio/istio/tree/release-1.8/samples/addons&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Telemetry Addons&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;namespace-istio&quot; tabindex=&quot;-1&quot;&gt;在namespace上面 植入 istio&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;kubectl label namespaces auto istio-injection=enabled
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本來想使用自動植入，就是連這行也不用打。&lt;br /&gt;
但是 有些 k8s版本，本身會禁止這個行為，需要的話要另行打開。&lt;br /&gt;
ref. &lt;a href=&quot;https://istio.io/latest/docs/setup/additional-setup/sidecar-injection/#automatic-sidecar-injection&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Automatic sidecar injection&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此時可建立一個pod ，就可看到裡面多了一個 container&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/7.%20fig-1.jpg&quot; alt=&quot;7. fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果植入sidecar失敗，出現&lt;br /&gt;
Internal error occurred: failed calling webhook &amp;quot;&lt;a href=&quot;http://sidecar-injector.istio.io/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;sidecar-injector.istio.io&lt;/a&gt;&amp;quot;: Post &lt;a href=&quot;https://istiod.istio-system.svc/inject?timeout=30s:&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://istiod.istio-system.svc:443/inject?timeout=30s:&lt;/a&gt; context deadline exceeded&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/7.fig-5.jpg&quot; alt=&quot;7.fig-5.jpg&quot; /&gt;&lt;br /&gt;
需開啟GKE的master防火牆規則，增加 tcp:15017 的 port&lt;br /&gt;
(題外話，如果要使用kiali的話，請開啟 tcp: 8080 的 port，不然你會看kiali一直在轉圈圈)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/7.fig-6.jpg&quot; alt=&quot;7.fig-6.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;不知道要設定哪個防火牆規則，可下指令尋找&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute firewall-rules list --filter=&amp;quot;name~gke-${CLUSTER_NAME}-[0-9a-z]*-master&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中的 ${CLUSTER_NAME} 需改為你要尋找的叢集名稱&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute firewall-rules update &amp;lt;firewall-rule-name&amp;gt; --allow tcp:10250,tcp:443,tcp:15017,tcp:8080
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://istio.io/latest/docs/setup/platform-setup/gke/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Google Kubernetes Engine&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;開啟套件&quot; tabindex=&quot;-1&quot;&gt;開啟套件&lt;/h2&gt;
&lt;p&gt;我是使用GKE，原本以為要能夠連到內部的服務，都要走外部ip&lt;br /&gt;
今天在亂點的時候，點到了這個地方，將那行指令複製，在本機執行。&lt;br /&gt;
前提是你的gcloud要有認證。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/7.%20fig-2.jpg&quot; alt=&quot;7. fig-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;他就能夠透過通訊埠轉發的方式存取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/7.%20fig-3.jpg&quot; alt=&quot;7. fig-3.jpg&quot; /&gt;&lt;br /&gt;
由(fig.3) 可以看到，他將本機的8080對到了service內的20001，&lt;br /&gt;
所以直接開啟網頁指向 localhost:8080 就可以看到該網頁的內容了。&lt;/p&gt;
&lt;h1 id=&quot;佈署時由上往下開始佈署&quot; tabindex=&quot;-1&quot;&gt;佈署時由上往下開始佈署&lt;/h1&gt;
&lt;h2 id=&quot;destination-rule&quot; tabindex=&quot;-1&quot;&gt;DestinationRule&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: localgo
  namespace: auto
spec:
  host: localgo
  trafficPolicy:
    loadBalancer:
      simple: LEAST_CONN
  subsets:
    - name: Localgov1
      labels:
        version: v1
    - name: v2
      labels:
        version: v2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/destination-rule/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Destination Rule&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;參數說明&lt;br /&gt;
trafficPolicy內的 loadBalancer:&lt;br /&gt;
代表的是幾種流量分發方式：&lt;br /&gt;
•Round_Robin： 輪詢演算法，顧名思義請求將會依次發給每一個例項，來共同分擔所有的請求。&lt;/p&gt;
&lt;p&gt;•Random： 隨機演算法，將所有的請求隨機分發給健康的例項&lt;/p&gt;
&lt;p&gt;•Least_Conn: 最小連線數，在所有健康的例項中任選兩個，將請求發給連線數較小的那一個例項。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.mdeditor.tw/pl/2AOq/zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;idou老師教你學Istio 19 : Istio 流量治理功能原理與實戰&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;virtual-service&quot; tabindex=&quot;-1&quot;&gt;VirtualService&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: localgo-vs
  namespace: auto
spec:
  hosts:
  - &amp;quot;*&amp;quot;
  gateways:
    - istio-ingressgateway
  http:
  - name: &amp;quot;route-v1&amp;quot;
    route:
    - destination:
        port:
          number: 80
        host: localgo.auto.svc.cluster.local    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#這裡就是指向你真正服務&quot;&gt;#這裡就是指向你真正服務&lt;/a&gt; service 的名稱喔
        subset: Localgov1   &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#這裡指的是DestinationRule的subset&quot;&gt;#這裡指的是DestinationRule的subset&lt;/a&gt;.name
      weight: 80
    - destination:
        port:
          number: 80
        host: localgo.auto.svc.cluster.local
        # 上面 destionation 下面的 host 名稱會這麼長，這是 k8s 內部實際 dns 全名，如果需要跨 namspace 存取，就需要用這樣的全名方式指定。
        # {service name}.{namespace}.svc.cluster.local 這就是它的規則
        subset: v2
      weight: 20
      corsPolicy:  ##限制
        allowOrigin:    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#允許所有來源&quot;&gt;#允許所有來源&lt;/a&gt;
          - &#39;*&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;corsPolicy 有以下的選項&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;allowOrigins&lt;/li&gt;
&lt;li&gt;allowMethods&lt;/li&gt;
&lt;li&gt;allowHeaders&lt;/li&gt;
&lt;li&gt;exposeHeaders&lt;/li&gt;
&lt;li&gt;maxAge&lt;/li&gt;
&lt;li&gt;allowCredentials&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;weight 則是用來做流量分配用的&lt;br /&gt;
同一個route內，相加必須 =100&lt;/p&gt;
&lt;p&gt;詳細說明，參考下面連結&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://istio.io/latest/zh/docs/reference/config/networking/virtual-service/#CorsPolicy&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;CorsPolicy細項設定&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然後在 這邊還有另一種是 match的用法，&lt;br /&gt;
虛擬服務中定義的第一條規則有最高優先級，&lt;br /&gt;
當第一個沒有match到相對應的規則時，&lt;br /&gt;
則繼續往下執行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: localgo-vs
  namespace: auto
spec:
  hosts:
  - &amp;quot;*&amp;quot;
  gateways:
    - istio-ingressgateway
  http:
  - name: &amp;quot;route-v1&amp;quot;
    match:
    - uri:
        prefix: /reviews
    route:
    - destination:
        port:
          number: 80
        host: localgo.auto.svc.cluster.local    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#這裡就是指向你真正服務&quot;&gt;#這裡就是指向你真正服務&lt;/a&gt; service 的名稱喔
        subset: Localgov1   &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#這裡指的是DestinationRule的subset&quot;&gt;#這裡指的是DestinationRule的subset&lt;/a&gt;.name
  - name: &amp;quot;route-v3&amp;quot;
    match:
      - uri:
          prefix: /Player
    route:
     - destination:
        port:
          number: 80
        host: localgo.auto.svc.cluster.local    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#這裡就是指向你真正服務&quot;&gt;#這裡就是指向你真正服務&lt;/a&gt; service 的名稱喔
        subset: Localgov1   &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#這裡指的是DestinationRule的subset&quot;&gt;#這裡指的是DestinationRule的subset&lt;/a&gt;.name       
  - name: &amp;quot;route-v2&amp;quot;
    route:
    - destination:
        port:
          number: 80
        host: localgo.auto.svc.cluster.local
        # 上面 destionation 下面的 host 名稱會這麼長，這是 k8s 內部實際 dns 全名，如果需要跨 namspace 存取，就需要用這樣的全名方式指定。
        # {service name}.{namespace}.svc.cluster.local 這就是它的規則
        subset: v2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;match 下面的用法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;exact (完全匹配)&lt;/li&gt;
&lt;li&gt;prefix  (只有前綴)&lt;/li&gt;
&lt;li&gt;regex (正規表示法)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面那段的規則為，當網址進來後，如果網域的後面不是reviews的話，&lt;br /&gt;
則往下執行到route-v3，如果網址為 Player的話，則執行下面的路由&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/virtual-service/#StringMatch&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;StringMatch&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://istio.io/latest/zh/docs/concepts/traffic-management/#more-about-routing-rules&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;路由規則&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10247889&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Day24 什麼是 istio virtual service?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;gateway&quot; tabindex=&quot;-1&quot;&gt;gateway&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: istio-ingressgateway
  # 這裡就是填入kubectl get service -n istio-system 所查到的 istio-ingressgateway，實務上如果你有多個 ip ，就會有多個 gateway 代理，
  # 然後就要描述多個 gateway 去使用 gateway 代理
  namespace: auto
spec:
  selector:
    istio: ingressgateway   # 使用默認的控制器
  servers:
  - port: &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#加密傳輸&quot;&gt;#加密傳輸&lt;/a&gt;
      number: 443
      name: https
      protocol: HTTPS
    tls:
      mode: SIMPLE
      serverCertificate: /etc/istio/ingressgateway-certs/tls.crt &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#設定憑證路徑&quot;&gt;#設定憑證路徑&lt;/a&gt;
      privateKey: /etc/istio/ingressgateway-certs/tls.key  &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#設定憑證路徑&quot;&gt;#設定憑證路徑&lt;/a&gt;
    hosts:
     - &amp;quot;*&amp;quot; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#該服務對應domain&quot;&gt;#該服務對應domain&lt;/a&gt;
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
     - &amp;quot;*&amp;quot; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#該服務對應domain&quot;&gt;#該服務對應domain&lt;/a&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10247372&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;istio gateway 是什麼？&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;ingressgateway&quot; tabindex=&quot;-1&quot;&gt;同一個叢集安裝多個ingressgateway&lt;/h3&gt;
&lt;p&gt;滿滿的坑，卡了兩天才搞定。&lt;/p&gt;
&lt;p&gt;這邊要改使用operator安裝&lt;br /&gt;
所以先初始化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;istioctl operator init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://istio.io/latest/docs/setup/install/operator/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio Operator Install&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再來設定新增的 ingressgateway&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kind: IstioOperator
apiVersion: install.istio.io/v1alpha1
metadata:
  annotations:
    install.istio.io/ignoreReconcile: &#39;true&#39;
  name: video-state
  namespace: istio-system
spec:
  addonComponents:
    istiocoredns:
      enabled: false
  components:
    base:
      enabled: true
    cni:
      enabled: false
    ingressGateways:
        - name: ingressgateway-private
          namespace: istio-system
          enabled: true
          k8s:
              env:
                - name: ISTIO_META_ROUTER_MODE
                  value: standard          
              hpaSpec:
                minReplicas: 2
              overlays:
                    - kind: HorizontalPodAutoscaler
                      name: ingressgateway-private
                      patches:
                        - path: metadata.labels.app
                          value: ingressgateway-private
                        - path: metadata.labels.istio
                          value: ingressgateway-private
                        - path: spec.scaleTargetRef.name
                          value: ingressgateway-private
                    - kind: Deployment
                      name: ingressgateway-private
                      patches:
                        - path: metadata.labels.app
                          value: ingressgateway-private
                        - path: metadata.labels.istio
                          value: ingressgateway-private
                        - path: spec.selector.matchLabels.app
                          value: ingressgateway-private
                        - path: spec.selector.matchLabels.istio
                          value: ingressgateway-private
                        - path: spec.template.metadata.labels.app
                          value: ingressgateway-private
                        - path: spec.template.metadata.labels.istio
                          value: ingressgateway-private
                    - kind: Service
                      name: ingressgateway-private
                      patches:
                        - path: metadata.labels.app
                          value: ingressgateway-private
                        - path: metadata.labels.istio
                          value: ingressgateway-private
                        - path: spec.selector.app
                          value: ingressgateway-private
                        - path: spec.selector.istio
                          value: ingressgateway-private
                    - kind: PodDisruptionBudget
                      name: ingressgateway-private
                      patches:
                        - path: metadata.name
                          value: ingressgateway-private
                        - path: metadata.labels.app
                          value: ingressgateway-private
                        - path: metadata.labels.istio
                          value: ingressgateway-private
                        - path: spec.selector.matchLabels.app
                          value: ingressgateway-private
                        - path: spec.selector.matchLabels.istio
                          value: ingressgateway-private
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先使用&lt;br /&gt;
istioctl manifest generate -f newingeressway.yaml&lt;br /&gt;
預先編譯一下，看有沒有成功。 istioctl manifest的原理，有點像是kustomize，&lt;br /&gt;
有一個基底，後面的程式都是根據這個基底去修改覆蓋。&lt;/p&gt;
&lt;p&gt;安裝的話，則是使用&lt;br /&gt;
istioctl manifest install -f newingeressway.yaml&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://discuss.istio.io/t/multiple-ingress-controller-services-via-istiooperator/7620&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Multiple ingress controller services via IstioOperator?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/istio/istio&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;istio&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://reader.epubee.com/books/mobile/f2/f2b61f60ba2d351d9bc7c69e933ab394/text00001.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio入門與實戰&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/7. Istio安裝及使用/" />
        </entry>
        <entry>
            <title>
                62. isito 鏡像流量
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/62. isito 鏡像流量/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;最近在測試 istio的鏡像流量，&lt;br /&gt;
想要針對舊的 websocket 做鏡像將流量導到新版的websocket上面。&lt;/p&gt;
&lt;p&gt;實測的結果，websocket不能用。&lt;br /&gt;
但http能夠使用，這是由於 istio的鏡像流量是 『 fire and forget』&lt;/p&gt;
&lt;p&gt;但websocket 是需要交握後，才能持續進行下面的步驟。&lt;br /&gt;
所以導致連線無法建立，但 RESTful的請求，是沒問題的。&lt;/p&gt;
&lt;p&gt;先決條件，&lt;br /&gt;
2個deployment，分別叫 A 跟 B，&lt;br /&gt;
label 使用 version：v1  以及 version: v2 做區別&lt;br /&gt;
1個 service ，分別指到這2個deployment&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: ws-qa
  namespace: istio
spec:
  hosts:
    - www.abc.com
    - yabo-ws-qa
  gateways:
    - istio-system/istio-gateway-external
    - istio-system/istio-gateway-internal     
  http:
  - match:
      - uri:
          regex: ^/ws/.*
    route:
      - destination:
          host: ws-qa
          subset: v1
          port:
            number: 80
        weight: 100
    mirror:
        host: ws-qa
        subset: v2
    mirrorPercentage: 
        value: 100.0
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
 name: ws-qa
 namespace: istio
spec:
 host: ws-qa
 subsets:
 - labels:
     version: v1
   name: v1
 - labels:
     version: v2
   name: v2 		
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用任一的壓測軟體，呼叫本來的網站，就會得到下圖的數據。&lt;br /&gt;
v2是鏡像流量，流量過去後就不會管是否回應。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/62-fig.1.jpg&quot; alt=&quot;62-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.servicemesher.com/istio-handbook/practice/traffic-shadow.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;流量鏡像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://istio.io/latest/docs/tasks/traffic-management/mirroring/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Mirroring&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/62. isito 鏡像流量/" />
        </entry>
        <entry>
            <title>
                54. istio 掛載ECK kibana
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/54. istio 掛載ECK kibana/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;正常設定vs的時候，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- match:
    - uri:
        prefix: /
  name: kibana
  route:
    - destination:
        host: quickstart-kb-http.default.svc.cluster.local
        port:
          number: 5601
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;會發生錯誤&lt;br /&gt;
upstream connect error or disconnect/reset before headers. reset reason: connection termination&lt;/p&gt;
&lt;p&gt;不管怎樣改vs還是不通，最後是要把kibana的設定改掉，&lt;/p&gt;
&lt;p&gt;完整的yaml如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: kibana.k8s.elastic.co/v1
kind: Kibana
metadata:
  name: quickstart
spec:
  version: 7.15.0
  count: 1
  elasticsearchRef:
    name: quickstart
  http:
    tls:
      selfSignedCertificate:
        disabled: true
    service:
      spec:
        ports:
          - name: http
            port: 5601
            targetPort: 5601   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重點在於一定要加 http 下面的設定。&lt;/p&gt;
&lt;p&gt;selfSignedCertificate ，請參考[3]&lt;/p&gt;
&lt;p&gt;補充：&lt;br /&gt;
[1] 的連結有提到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    metadata:
      annotations:
        sidecar.istio.io/rewriteAppHTTPProbers: &amp;quot;true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊請參考[2]&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/59643343/expose-kibana-eck-operator-via-istio-gateway-https-problem-error-503&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Expose kibana (eck operator) via istio gateway - https problem (Error 503)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://istio.io/latest/zh/docs/ops/configuration/mesh/app-health-check/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio 服務的健康檢查&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-kibana-http-configuration.html#k8s-kibana-http-publish&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;HTTP configuration&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/54. istio 掛載ECK kibana/" />
        </entry>
        <entry>
            <title>
                35. istio virtualService delegate使用
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/35. istio virtualService delegate使用/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;會用到delegate的原因，是為了要解決在維護時上的痛點。&lt;br /&gt;
因目前使用flagger canary，&lt;br /&gt;
導致每個服務就一個virtualService (下面會用VS代替)，&lt;br /&gt;
而多個服務會共用一個host ，導致在維護上的困難。&lt;br /&gt;
而且在kiali上面會出現警告(fig.1)，看了實在礙眼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/35-fig.1.jpg&quot; alt=&quot;35-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以使用delegate。這樣的話，流量會先導到 delegate vs，之後才會根據path到各服務的vs。&lt;/p&gt;
&lt;p&gt;delegate 有幾點要注意，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不支援 regex&lt;/li&gt;
&lt;li&gt;在delegate上寫rewrite不會被轉導，要在導過去的vs寫。&lt;/li&gt;
&lt;li&gt;目前測試只能在同一個namespace上面。如果不是用藍綠佈署自定義的話，在destination 上面，可以使用完整的FQDN，是可以執行的。(例如: video-admin-primary.default.svc.cluster.local)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;VS delegate&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: control-dashboard
  namespace: default
spec:
  hosts:
  - &amp;quot;*&amp;quot;
  gateways:
    - istio-gateway-external.istio-system.svc.cluster.local
  http:
    - delegate:
        name: video-admin
        namespace: default
      match:
        - uri:
            prefix: /ezio
        - uri:
            prefix: /abc
        - uri:
            prefix: /api
      name: reviews-v2-routes
    - delegate:
        name: tw-frontend
        namespace: default
      match:
        - uri:
            prefix: /
      name: tw-frontend
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;服務的 vs，（注意：此處的yaml是由flagger自動產生的）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kind: VirtualService
apiVersion: networking.istio.io/v1alpha3
metadata:
  name: video-admin
  namespace: default
spec:
  hosts: []
  http:
    - match:
        - uri:
            prefix: /api
        - uri:
            prefix: /abc
        - uri:
            prefix: /ezio
      rewrite:
        uri: /api
      route:
        - destination:
            host: video-admin-primary
          weight: 100
        - destination:
            host: video-admin-canary
          weight: 0

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ps. 使用canary的話，在service下面加上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delegation: true  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://docs.flagger.app/faq#how-does-flagger-interact-with-istio&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How does Flagger interact with Istio?&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: flagger.app/v1beta1
kind: Canary
metadata:
  name: example-api-qa-v2
  namespace: istio-example
spec:
  provider: istio
  targetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: example-api-qa-v2
  autoscalerRef:
    apiVersion: autoscaling/v1
    kind: HorizontalPodAutoscaler
    name: example-api-qa-v2

  service:
    delegation: true    # use delegate
    name: example-api-qa-v2
    port: 80
    targetPort: 80
    portName: http
    portDiscovery: true

    trafficPolicy:
      tls:
        mode: DISABLE
    match:
      - uri:
          prefix: /api-v2
    rewrite:
      uri: /api
    timeout: 30s
  analysis:
    # analysis spend time  : interval * iterations 
    # 時間間隔 (默認 60s)
    interval: 30s
    # 回滾前的最大失敗指標檢查次數(可能因為檢查時間差的關係，至少會有兩次失敗)
    threshold: 5
    iterations: 1
    metrics:
      - name: request-success-rate
        thresholdRange:
          min: 99
        interval: 1m
      - name: request-duration
        thresholdRange:
          max: 500
        interval: 30s
    webhooks:
      - name: load-test-get
        type: pre-rollout
        url: http://flagger-loadtester.tools/
        timeout: 15s
        metadata:
          type: cmd
          cmd: &amp;quot;hey -z 1m -q 10 -c 2 http://example-api-qa-v2-canary.istio-example&amp;quot;
      - name: &amp;quot;notify&amp;quot;
        type: event
        url: http://webhook-api.tools/webhook/flagger
        timeout: 5s
        metadata:
          channel: &amp;quot;-1001429024676&amp;quot;
      - name: load-test
        type: rollout
        url: http://flagger-loadtester.tools/
        timeout: 5s
        metadata:
          type: cmd
          cmd: &amp;quot;hey -z 1m -q 10  http://example-api-qa-v2-canary.istio-example&amp;quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/virtual-service/#Delegate&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;VS Delegate&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPMatchRequest&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;VS HTTPMatchRequest&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/35. istio virtualService delegate使用/" />
        </entry>
        <entry>
            <title>
                34. istio operator 安裝新的 ingress deploy及service
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/34. istio operator 安裝新的 ingress deploy及service/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;主管挑戰DC失敗，變成又要變回舊的系統架構。暈...&lt;br /&gt;
用了istio是為了一個ip打所有服務，現在又變回去。&lt;br /&gt;
服務跟 ip 是一對一的存在。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;最簡單的安裝方式，可看前一篇 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/7.%20Istio%E5%AE%89%E8%A3%9D%E5%8F%8A%E4%BD%BF%E7%94%A8/&quot;&gt;7. Istio安裝及使用&lt;/a&gt;&lt;br /&gt;
以前新增的時候，都會同時安裝最原始的deploy 以及 service(fig.1)，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/34.fig-1.jpg&quot; alt=&quot;34.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以在新增新的ingressgateway的時候，需要先指定原始的istio-ingressgateway 為 enable:false。&lt;br /&gt;
這樣在安裝的時候，才不會同時安裝。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kind: IstioOperator
apiVersion: install.istio.io/v1alpha1
metadata:
annotations:
  install.istio.io/ignoreReconcile: &#39;true&#39;
name: istio-external-test
namespace: istio-system
spec:
addonComponents:
  istiocoredns:
    enabled: false
components:
  base:
    enabled: true
  cni:
    enabled: false
  ingressGateways:
      - name: istio-ingressgateway     # 20210730新增，可取消單獨佈署此yaml還會額外裝ingress-gateway
        enabled: false
      - name: ingressgateway-external              
        namespace: istio-system
        enabled: true
        k8s:
          service:
        # loadBalancerIP 要跟著改，最好先將IP設成靜態
            loadBalancerIP: 
            loadBalancerSourceRanges:
                # - 0.0.0.0/0   
                - 10.0.0.0/8
                - 172.16.0.0/12
                - 192.168.0.0/16 
          env:
            - name: ISTIO_META_ROUTER_MODE
              value: standard          
          hpaSpec:
            minReplicas: 1
          overlays:
                - kind: HorizontalPodAutoscaler
                  name: ingressgateway-external
                  patches:
                    - path: metadata.labels.app
                      value: ingressgateway-external
                    - path: metadata.labels.istio
                      value: ingressgateway-external
                    - path: spec.scaleTargetRef.name
                      value: ingressgateway-external
                - kind: Deployment
                  name: ingressgateway-external
                  patches:
                    - path: metadata.labels.app
                      value: ingressgateway-external
                    - path: metadata.labels.istio
                      value: ingressgateway-external
                    - path: spec.selector.matchLabels.app
                      value: ingressgateway-external
                    - path: spec.selector.matchLabels.istio
                      value: ingressgateway-external
                    - path: spec.template.metadata.labels.app
                      value: ingressgateway-external
                    - path: spec.template.metadata.labels.istio
                      value: ingressgateway-external
                - kind: Service
                  name: ingressgateway-external
                  patches:
                    - path: metadata.labels.app
                      value: ingressgateway-external
                    - path: metadata.labels.istio
                      value: ingressgateway-external
                    - path: spec.selector.app
                      value: ingressgateway-external
                    - path: spec.selector.istio
                      value: ingressgateway-external
                - kind: PodDisruptionBudget
                  name: ingressgateway-external
                  patches:
                    - path: metadata.name
                      value: ingressgateway-external
                    - path: metadata.labels.app
                      value: ingressgateway-external
                    - path: metadata.labels.istio
                      value: ingressgateway-external
                    - path: spec.selector.matchLabels.app
                      value: ingressgateway-external
                    - path: spec.selector.matchLabels.istio
                      value: ingressgateway-external
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/34. istio operator 安裝新的 ingress deploy及service/" />
        </entry>
        <entry>
            <title>
                31.istio 抓蟲記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/31.istio 抓蟲記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;狀況很奇特，奇特到我不知道該從哪里找。簡單說就是gateway裡面有mesh的話，&lt;br /&gt;
就會有此坑出現。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;先說明一下環境，Deployment  A 的 VirtualService 有設定 domain , &lt;a href=&quot;http://abc.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;abc.com&lt;/a&gt;&lt;br /&gt;
此時進去 Deployment裡面的 pod ， 使用 curl 呼叫外部的ip，會發生404的錯誤。&lt;br /&gt;
e.g.   curl -v 123.213.123.213 -H &amp;quot;Host:abc.com&amp;quot;&lt;br /&gt;
但是，&lt;a href=&quot;http://xn--hostabc-7w3kl56ffok94z.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;如果Host不帶abc.com&lt;/a&gt; ，改帶任意的 domain，即可正常執行。&lt;/p&gt;
&lt;h2 id=&quot;除錯過程&quot; tabindex=&quot;-1&quot;&gt;除錯過程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用tcpdump ，將所有的封包撈出，但發現如果 host 帶 &lt;a href=&quot;http://abc.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;abc.com&lt;/a&gt; ，沒有任何的封包進出。&lt;br /&gt;
但帶任意 domain:  &lt;a href=&quot;http://def.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;def.com&lt;/a&gt; ，則會有封包進出。故開始懷疑是 sidecar的某些機制將流量導到本機，&lt;br /&gt;
以至於回傳404的錯誤。&lt;/p&gt;
&lt;p&gt;簡易的tcpdump使用，&lt;br /&gt;
詳細用法請參考連結&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  針對 host 是 123.213.123.213 且 port 是 80 的封包截取，並存入demo2.pcap的檔案
  tcpdump host 123.213.123.213 and port 80 -w demo2.pcap
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是從pod裡面看封包，會想哭，所以進一步要把封包的檔案放到自己的機器上，再使用wireshark看。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  將pod(api-beta-v2-primary-69797b47d6-bl6vf)，裡面的檔案 demo2.pcap 複製到本機上
  kubectl cp api-beta-v2-primary-69797b47d6-bl6vf:/app/demo2.pcap -n istio ./demo2.pcap
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.jinnsblog.com/2020/09/linux-tcpdump-network-traffic-tutorial.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Linux] Tcpdump 擷取封包指令範例教學&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查詢outbound handler&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;  istioctl proxy-config route api-beta-v2-primary-69797b47d6-bl6vf -n istio
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;終於查到了一個關鍵，在有問題domain，他match的path是另外一個virtualService(fig.1)，最後查到那個VirtualSerice ，在gateway上面多設了一組 mesh，&lt;br /&gt;
導致他一直在網格內繞，所以才會404。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/31.fig-1.jpg&quot; alt=&quot;31.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;額外補充，查詢 Inbound handler&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   istioctl proxy-config listener reviews-v1-54b8794ddf-jxksn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可直接用 istioctl pc 來取代 proxy-config&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://jimmysong.io/blog/sidecar-injection-iptables-and-traffic-routing/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio 中的 Sidecar 注入及透明流量劫持過程詳解&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/31.istio 抓蟲記/" />
        </entry>
        <entry>
            <title>
                30. istio的virtualservice match比對
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/30. istio的virtualservice match比對/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近因為新的需求，再度跟istio的virtualservice槓上了。&lt;br /&gt;
這次要做的是針對domain去解析網址，host不再自定。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;踩到的坑很特別，根據官方文件上寫的是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For example, the following restricts the rule to match only requests where the URL path starts with /ratings/v2/ and the request contains a custom end-user header with value jason&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文章的範例如下，官方文件是說明當url path 符合 /ratings/v2 而且 header裡面的end-user的值為 jason 才會轉到正確的路由。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  apiVersion: networking.istio.io/v1beta1
  kind: VirtualService
  metadata:
  name: ratings-route
  spec:
  hosts:
  - ratings.prod.svc.cluster.local
  http:
  - match:
    - headers:
        end-user:
          exact: jason
      uri:
        prefix: &amp;quot;/ratings/v2/&amp;quot;
      ignoreUriCase: true
    route:
    - destination:
        host: ratings.prod.svc.cluster.local
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/virtual-service/?_ga=2.150842550.1248538041.1620980160-699625840.1605505006#HTTPMatchRequest&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;HTTPMatchRequest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再來就是我踩坑的地方，因為我不管怎麼測試，測試出來的都是 『或』，&lt;br /&gt;
也就是說 當流量進入時， 只要 url path 是 /api 『或』 header 的Host是 符合 qa2.777.+.com的正則，才會導去正確的路由。&lt;br /&gt;
跟官方文件的講法落差有點大，後來測試了老半天才發現，關鍵在 『 - 』。&lt;/p&gt;
&lt;p&gt;下面的程式，條件是 『或』，兩個條件其中一個過都會導到正確的路由&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;match:
  - headers:
      Host:
        regex: qa2&#92;.777.+&#92;.com
  - uri:
      prefix: /api
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面的程式，條件式 『而且』 ，兩個條件都要符合才會導到正確的路由&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;match:
  - headers:
      Host:
        regex: qa2.?&#92;.777.+&#92;.com
    uri:
      prefix: /api
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本來還有在探討另一種方法，直接在hosts上面做判斷(fig.1)，&lt;br /&gt;
但是測試出來只能針對 sub domain，如果把萬用字元放在後面，連存檔都會出錯握。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/30.fig-1.jpg&quot; alt=&quot;30.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hosts:
  - &amp;quot;*.777.com&amp;quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://github.com/istio/istio/issues/15456&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Support wildcard/regexp in VirtualService host&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#envoy-v3-api-msg-config-route-v3-virtualhost&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;config.route.v3.VirtualHost&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/30. istio的virtualservice match比對/" />
        </entry>
        <entry>
            <title>
                23.istio的 prometheus截取GKE metrics
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/23.istio的 prometheus截取GKE metrics/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;主要架構弄得差不多的，使用 istio 加上 drone 的 自動佈署，&lt;br /&gt;
再配合 flagger的藍綠佈署，藍綠佈署時使用telegram通知目前佈署進度。&lt;br /&gt;
，現在剩下監控這一塊。&lt;br /&gt;
然後，阿伯，出事拉....&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;一開始想使用grafana上面的樣板，原以爲只要這樣就好。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://grafana.com/grafana/dashboards/8588&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;1. Kubernetes Deployment Statefulset Daemonset metrics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://grafana.com/grafana/dashboards/13105&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;1 Kubernetes for Prometheus Dashboard CN 20201209&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10224491&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Prometheus 2 - Deploy Grafana&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是，發現我抓不到資料。直接連線至Prometheus裡面查詢也沒有，&lt;br /&gt;
於是斷定，我根本沒有撈資料到Prometheus。&lt;/p&gt;
&lt;p&gt;如果直接架設一個新的grafana不使用istio的grafana會不會比較好？&lt;br /&gt;
但是這樣本來istio的grafana dashboard (Fig.1) 就要自己建立了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/23-fig.1.jpg&quot; alt=&quot;23-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;kube-state-metrics&quot; tabindex=&quot;-1&quot;&gt;kube-state-metrics&lt;/h2&gt;
&lt;p&gt;查了一些資料，最後找到的方案是安裝 &lt;a href=&quot;https://github.com/kubernetes/kube-state-metrics&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kube-state-metrics&lt;/a&gt;&lt;br /&gt;
但是光安裝還是不行，必須要讓Prometheus抓得到資料才行。&lt;/p&gt;
&lt;p&gt;建議先將yaml檔抓下來，因為有些地方需要更改。&lt;br /&gt;
打開 standard/service.yaml&lt;br /&gt;
在metadata底下 加上   &lt;a href=&quot;http://prometheus.io/scrape:&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;prometheus.io/scrape:&lt;/a&gt; &#39;true&#39;&lt;br /&gt;
這是要讓prometheus 可以自動得去發現服務&lt;/p&gt;
&lt;p&gt;metadata完整的yaml如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;metadata:
  labels:
    app.kubernetes.io/name: kube-state-metrics
    app.kubernetes.io/version: v1.9.8
  annotations:
      prometheus.io/scrape: &#39;true&#39;
  name: kube-state-metrics
  namespace: kube-system
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後，佈署&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  kubectl apply -f standard
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;node-exporter&quot; tabindex=&quot;-1&quot;&gt;Node-Exporter&lt;/h2&gt;
&lt;p&gt;後來查了一下，這邊的指標資料已經在 cadvisor 裡面了，所以不用在額外做。&lt;br /&gt;
ref. &lt;a href=&quot;https://stackoverflow.com/questions/63741959/prometheus-node-exporter-issue-when-update-from-gke-1-15-to-1-16&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Prometheus (node_exporter) issue when update from GKE 1.15 to 1.16&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10225912&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Prometheus 5 - Node Exporter &amp;amp; Kube State Metrics&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.uj5u.com/qita/31194.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;prometheus（九） 收集kube-state-metrics指標資訊&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/23.istio的 prometheus截取GKE metrics/" />
        </entry>
        <entry>
            <title>
                21. flagger 自動金絲雀佈署 for istio
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/21. flagger 自動金絲雀佈署 for istio/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;本來自動佈署配上istio都好了，&lt;br /&gt;
但在實際上測試的時候發現，如果不導入自動藍綠佈署或金絲雀佈署的話，&lt;br /&gt;
到時開發人員發佈程式時，需要更改istio 的 VirtualService 以及 DestinationRule。&lt;br /&gt;
除非發佈的人懂這些東西，不然...改壞就...，所以只好先研究flagger了。減少開發人員佈署的know how，&lt;br /&gt;
只要git tag ，然後『等』  就好了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;簡易流程介紹&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前正在執行的deploy 為abc-primary ，當有新的deploy 佈署在 abc 時，flagger啟動，&lt;br /&gt;
先將流量從 abc-primary 轉到 abc ，因為abc 為新版本。&lt;br /&gt;
當流量全部轉到abc後，將 abc-primary 刪除，並佈署成新的版本。&lt;br /&gt;
當abc-primary佈署完後，再將 流量從 abc 轉回 abc-primary，&lt;br /&gt;
等待全部流量轉回來後，再將abc的deploy刪除。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;先安裝flagger&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;  kustomize build https://github.com/fluxcd/flagger/kustomize/istio?ref=main | kubectl apply -f -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://docs.flagger.app/install/flagger-install-on-kubernetes&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Flagger Install on Kubernetes&lt;/a&gt;&lt;br /&gt;
3. 佈署負載測試服務 flagger-loadtester&lt;br /&gt;
如果namespace要先建立test ，如果不想使用這個名稱，請下載yaml檔後修改 kustomization.yaml 的namespace&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/fluxcd/flagger/tree/main/kustomize/tester&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;flagger-loadtester&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  kubectl apply -k https://github.com/fluxcd/flagger//kustomize/tester?ref=main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這裏面主要是使用&lt;a href=&quot;https://github.com/rakyll/hey&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;hey&lt;/a&gt; 作爲連線測試的工具，&lt;br /&gt;
在後面的webhook會用到此服務。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;設定Canary&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此範例為AB佈署，另有金絲雀佈署，請參考&lt;br /&gt;
spec 底下的參數，&lt;br /&gt;
- &lt;a href=&quot;http://targetref.name/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;targetRef.name&lt;/a&gt; 是 deploy會截取現有的deploy設定，確認名稱與現有的deploy名稱一樣&lt;br /&gt;
- &lt;a href=&quot;http://autoscalerref.name/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;autoscalerRef.name&lt;/a&gt; 是 HPA會截取現有的HPA設定，確認名稱與現有的HPA名稱一樣。&lt;br /&gt;
- service.name是 service會截取現有的service設定，確認名稱與現有的service名稱一樣。&lt;br /&gt;
- service.host 需指定目前服務的domain，如果為ip只能有一組&lt;br /&gt;
- webhooks.metadata.cmd ，網址必須更改成服務能夠訪問的網址。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: flagger.app/v1beta1
kind: Canary
metadata:
name: video
namespace: sex-system
spec:
provider: istio
targetRef:
apiVersion: apps/v1
kind: Deployment
name: video-api
autoscalerRef:
apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
name: video-api

service:
name: video-api
port: 80
targetPort: 80
portName: http
portDiscovery: true
gateways:
  - istio-gateway-external.istio-system.svc.cluster.local
  - istio-gateway-internal.istio-system.svc.cluster.local
  - mesh
hosts:
  - 123.123.123.123
trafficPolicy:
  tls:
    mode: DISABLE
match:
  - uri:
      prefix: /
rewrite:
  uri: /
timeout: 30s
analysis:
# analysis spend time  : interval * iterations
# 時間間隔 (默認 60s)
interval: 30s
# 回滾前的最大失敗指標檢查次數(可能因為檢查時間差的關係，至少會有兩次失敗)
threshold: 5
iterations: 1
metrics:
  - name: request-success-rate
    thresholdRange:
      min: 99
    interval: 1m
  - name: request-duration
    thresholdRange:
      max: 500
    interval: 30s
webhooks:
  - name: load-test-get
    type: pre-rollout
    url: http://flagger-loadtester.tools/
    timeout: 15s
    metadata:
      type: cmd
      cmd: &amp;quot;hey -z 1m -q 10 -c 2 http://video-api-canary.test/api/v1/Health/health&amp;quot;
  - name: &amp;quot;notify&amp;quot;
    type: event
    url: http://webhook-api.tools/webhook/flagger
    timeout: 5s
    metadata:
      channel: &amp;quot;-1023450&amp;quot;  
  - name: load-test
    type: rollout
    url: http://flagger-loadtester.tools/
    timeout: 5s
    metadata:
      type: cmd
      cmd: &amp;quot;hey -z 1m -q 10  http://video-api-canary.test/api/v1/Health/health&amp;quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;寫好canary，然後直接佈署。&lt;br /&gt;
此時，k8s會根據你的設定，建立起 一些相關的service以及 deployment ，&lt;br /&gt;
例如，本來的deployment、service以及 hpa的 名稱叫 abc ，&lt;br /&gt;
那同時會建立 abc-primary 的deployment 跟 hpa，&lt;br /&gt;
以及 abc-canary 、 abc-primary 的 service  。&lt;/p&gt;
&lt;p&gt;然後再istio上面也會自動建立 VirtualService 跟 DestinationRule&lt;br /&gt;
所以Canary很重要、很重要、很重要。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://github.com/fluxcd/flagger/blob/main/artifacts/examples/istio-canary.yaml&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;flagger/artifacts/examples/istio-canary.yaml&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://docs.flagger.app/tutorials/istio-progressive-delivery#bootstrap&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio Canary Deployments&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://docs.flagger.app/tutorials/istio-ab-testing#bootstrap&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio A/B Testing&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;引入 grafana&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因為istio本身就有grafana了，所以我不想重複安裝，&lt;br /&gt;
到他們的&lt;a href=&quot;https://github.com/fluxcd/flagger/tree/main/charts/grafana/dashboards&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;git&lt;/a&gt;&lt;br /&gt;
將json檔下載下來，&lt;br /&gt;
到grafana匯入json(fig.1)，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/21.fig-1.jpg&quot; alt=&quot;21.fig-1.jpg&quot; /&gt;&lt;br /&gt;
此時會發生錯誤&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Template variables could not be initialized: Datasource named prometheus was not found
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原因是原本的json檔裡面的datasource是 prometheus&lt;br /&gt;
而目前安裝的是 Promethus ，將本來的json更改後再匯入。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://medium.com/expedia-group-tech/flagger-monitor-your-canary-deployments-with-grafana-21b9dd58b10e&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Flagger - Monitor Your Canary Deployments with Grafana&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;佈署失敗，重新佈署方式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;藍綠佈署或金絲雀佈署上面有提到，會自動新增一個deployment，再原有的名稱上面加上-primary，&lt;br /&gt;
然後原有的deployment還會存在，但他的pod會清除。&lt;br /&gt;
當有新的image時，會觸發動作，在原有的deployment上將pod產生出來，&lt;br /&gt;
然後開始做流量的導轉，並發佈新版本。&lt;br /&gt;
但在測試的時候，如果canary寫錯了，會導致發佈失敗。&lt;br /&gt;
此時修改完，重新apply ，也會卡在Fail的狀態，&lt;br /&gt;
需到 原本的deployment 增加 下面的程式，&lt;br /&gt;
讓canary重新觸發。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
spec:
  template:
    metadata:
      annotations:
        timestamp: &amp;quot;2020-03-10T14:24:48+0000&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://docs.flagger.app/faq#how-to-retry-a-failed-release&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to retry a failed release&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;佈署失敗原因&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前測試，~每次一定會跳這個出來~ ，已解決。差別只在次數&lt;br /&gt;
Halt advancement no values found for istio metric request-success-rate probably video-api.sex-system is not receiving traffic: running query failed: no values found&lt;/p&gt;
&lt;p&gt;用curl打 不會產生此錯誤，&lt;br /&gt;
interval 時間壓在30s ，此錯誤只會發生1次&lt;br /&gt;
interval 時間壓在20s ，此錯誤會發生2次&lt;br /&gt;
threshold：回滾最大錯誤發生次數，設成5，只要小於錯誤發生的次數，還是可以成功自動佈署&lt;/p&gt;
&lt;p&gt;有查到會發生這個錯誤的原因，如果在流量導轉期間沒有收到流量的話就會發生此錯誤。&lt;br /&gt;
所以要解決這個錯誤，要再 pre-rollout 的時候，先送一些連線過去。&lt;br /&gt;
這樣就不會有此錯誤發生了。&lt;/p&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://docs.flagger.app/usage/webhooks#load-testing&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Load Testing&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;監控方式&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;查詢flagger佈署狀態，需額外安裝&lt;a href=&quot;https://stedolan.github.io/jq/manual/#Basicfilters&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;jq&lt;/a&gt;（解析json的軟體)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    watch &amp;quot;kubectl -n istio-system logs deployment/flagger --tail=10 | jq &#39;.ts,.msg&#39;&amp;quot;
    或
    kubectl -n test describe canary/video-api | tail -20f
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;看流量比重&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    watch kubectl get canaries -A
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;9&quot;&gt;
&lt;li&gt;webhook主動通知&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在flagger裡面，有實作webhook，可以將事件的狀態通知給需要的人。&lt;br /&gt;
內建有 slack 、discord ， 這段我沒實作 ，看起來只要加參數即可，&lt;br /&gt;
請參考 &lt;a href=&quot;https://docs.flagger.app/usage/alerting&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Alerting&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但因為公司政策，我不能用slack所以只好自己做telegram了，&lt;br /&gt;
telegram做機器人還挺快的，改天再寫一篇關於telegram的使用方式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;webhooks:
- name: &amp;quot;notify&amp;quot;
  type: event
  url: http://webhook-api-v2.test/webhook/flagger
  timeout: 5s
  metadata:
    some: &amp;quot;some message&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在canary上面加入上面的程式碼，然後當有事件觸發時，&lt;br /&gt;
會回傳下面的json格式。&lt;/p&gt;
&lt;p&gt;注意 webhook-api-v2.test 是一個我自己建立在 namespce ：test ，deployment：webhook-api-v2 的api&lt;/p&gt;
&lt;p&gt;webhook其實就是自己建立一個api的接收機制，當server端有資料時，&lt;br /&gt;
會根據上面的url送出json給你，此時要怎麼利用，就看各自的需求了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
   &amp;quot;name&amp;quot;:&amp;quot;video&amp;quot;,
   &amp;quot;namespace&amp;quot;:&amp;quot;test&amp;quot;,
   &amp;quot;phase&amp;quot;:&amp;quot;Failed&amp;quot;,
   &amp;quot;metadata&amp;quot;:{
      &amp;quot;eventMessage&amp;quot;:&amp;quot;Canary failed! Scaling down abc.test&amp;quot;,
      &amp;quot;eventType&amp;quot;:&amp;quot;Warning&amp;quot;,
      &amp;quot;some&amp;quot;:&amp;quot;some message&amp;quot;,
      &amp;quot;timestamp&amp;quot;:&amp;quot;1616654792750&amp;quot;
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://studygolang.com/articles/15056&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;webhook 是什麼以及如何創建&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://medium.com/@justinlee_78563/line-bot-%E7%B3%BB%E5%88%97%E6%96%87-%E4%BB%80%E9%BA%BC%E6%98%AF-webhook-d0ab0bb192be&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;LINE Bot 系列文 — 什麼是 Webhook?&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h2&gt;
&lt;p&gt;有時文章測試有問題的話，建議到他們的&lt;a href=&quot;https://github.com/fluxcd/flagger/tree/main/artifacts&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;git&lt;/a&gt;&lt;br /&gt;
找相關的範例，做測試。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://www.servicemesher.com/blog/automated-canary-deployments-with-flagger-and-istio/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;基於Flagger和Istio實現自動化金絲雀部署&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://wiki.shileizcc.com/confluence/pages/viewpage.action?pageId=84967496#Istio%E5%AE%9E%E8%B7%B5-%E8%87%AA%E5%8A%A8%E5%8C%96%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio 實踐&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.51cto.com/zero01/2572820&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Service Mesh - Istio實戰篇（上）&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://medium.com/google-cloud/automated-canary-deployments-with-flagger-and-istio-ac747827f9d1&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Automated canary deployments with Flagger and Istio&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.niewx.cn/istio/2020/12/10/istio%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;istio入門系列之自動化灰度發佈&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/21. flagger 自動金絲雀佈署 for istio/" />
        </entry>
        <entry>
            <title>
                20. 訪問istio 內部負載平衡ip
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/20. 訪問istio 內部負載平衡ip/</id>
            <content type="html">
                &lt;h2 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;h2 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;要指定內部負載平衡IP的話，一般在svc上面是只要指定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;metadata:
  annotations:
    cloud.google.com/load-balancer-type: &amp;quot;Internal&amp;quot;
spec:
    type: LoadBalancer    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這樣在GKE上面就會指定成內部負載平衡。&lt;br /&gt;
但在istio上面要指定的話，需在k8s底下新增 serviceAnnotations&lt;br /&gt;
像下面這樣（這是GKE的寫法，其他雲端機器設定的方式會不一樣）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;k8s:
  serviceAnnotations:
    cloud.google.com/load-balancer-type: &amp;quot;Internal&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他的參數請參考 istio安裝及使用 =&amp;gt; 同一個叢集安裝多個ingressgateway&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/20.fig-1.jpg&quot; alt=&quot;20.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://medium.com/faun/setup-multiple-ingress-gateways-in-istio-52ad0dc7f99d&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Setup Multiple Ingress Gateways in Istio&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://stackoverflow.com/questions/61963659/how-can-i-add-service-annotation-in-istio-operator-patch&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How can I add service annotation in istio operator patch&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;virtual-service&quot; tabindex=&quot;-1&quot;&gt;VirtualService的寫法&lt;/h3&gt;
&lt;p&gt;Gateway的寫法與之前的一致，&lt;br /&gt;
比較有差異的是VS的寫法&lt;/p&gt;
&lt;p&gt;hosts 需設定內部ip，不能使用 &amp;quot;*&amp;quot;&lt;br /&gt;
gateways  需增加mesh，表示路由是從網格內的流量來的。&lt;/p&gt;
&lt;p&gt;如果不在gateways上面，寫mesh，會發生&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;503 upstream connect error or disconnect/reset before headers. reset reason local reset istio
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;的錯誤。&lt;br /&gt;
會發現這個錯誤，是因為看了&lt;a href=&quot;https://kknews.cc/zh-tw/code/ja4r3ee.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio實踐避坑指南：10 大常見異常、最佳實踐及解決方案&lt;/a&gt;清楚網格內，與網格邊緣的差異，才知道增加此設定。&lt;/p&gt;
&lt;p&gt;最後yaml如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: vs-internal
  namespace: default
spec:
  hosts:
    - 10.4.0.37
  gateways:
    - mesh
    - istio-ingressgateway-internal.default.svc.cluster.local
  http:
    - corsPolicy:
        allowOrigin:
          - &#39;*&#39;
      match:
        - uri:
            exact: /api/v1/health
      name: route-v1
      route:
        - destination:
            host: abc.default.svc.cluster.local
            port:
              number: 80
          weight: 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://iter01.com/536043.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio 運維實戰系列（3）：讓人頭大的『無頭服務』-下&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.twblogs.net/a/5d3f73a9bd9eee51fbf92230?lang=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;記一次Istio間歇503的問題排查&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/20. 訪問istio 內部負載平衡ip/" />
        </entry>
        <entry>
            <title>
                186. istio的Authorization policy(白名單)
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/186. istio的Authorization policy(白名單)/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;經過一個月的搬家事宜，&lt;br /&gt;
這篇應該是第一篇，之後還有許多東西，&lt;br /&gt;
都是這個月搬project碰到的。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h4 id=&quot;目的&quot; tabindex=&quot;-1&quot;&gt;目的&lt;/h4&gt;
&lt;p&gt;只要設定白名單，限制某些ip能進入就好，&lt;br /&gt;
其他不用。&lt;/p&gt;
&lt;h4 id=&quot;network&quot; tabindex=&quot;-1&quot;&gt;實作-Network&lt;/h4&gt;
&lt;p&gt;這邊使用istio 1.20 版本，雖然gateway API 剛出爐，&lt;br /&gt;
但我還沒去研究，所以下面用的都還是 istio API&lt;/p&gt;
&lt;p&gt;首先確認你的LB類型，&lt;br /&gt;
直連（Network)的話，基本上沒太大問題，白名單很好設定。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;開啓 &lt;code&gt;externalTrafficPolicy&amp;quot;:&amp;quot;Local&amp;quot;&lt;/code&gt;，&lt;br /&gt;
兩種方法&lt;/p&gt;
&lt;p&gt;a. 手動改service&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;   kubectl patch svc istio-ingressgateway -n istio-system -p &#39;{&amp;quot;spec&amp;quot;:{&amp;quot;externalTrafficPolicy&amp;quot;:&amp;quot;Local&amp;quot;}}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;b. 加在istioOperator上面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ingressGateways:
    - name: istio-ingressgateway    
      enabled: true
      k8s: 
        service:
          externalTrafficPolicy: Local
          loadBalancerSourceRanges:
              - 10.0.0.0/8
              - 172.16.0.0/12
              - 192.168.0.0/16
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Authorization設定&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: manage-ingress-policy
  namespace: istio-system
spec:
  selector:
    matchLabels:
      istio: ingressgateway
  action: ALLOW
  rules:
  - from:
    - source:
        ipBlocks:
          - &amp;quot;10.0.0.0/8&amp;quot;
          - &amp;quot;172.16.0.0/12&amp;quot;
          - &amp;quot;192.168.0.0/16&amp;quot;   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（注意，這邊的Load Balancer Type指的是Network，沒透過proxy的，&lt;br /&gt;
如果有開CDN，那就是istio說明上面的Load Balancer Type 是TCP Proxy)&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://istio.io/latest/docs/tasks/security/authorization/authz-ingress/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Ingress Access Control&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;proxy&quot; tabindex=&quot;-1&quot;&gt;實作-Proxy&lt;/h4&gt;
&lt;p&gt;這邊的網路走法是，有透過CDN，或是其他的prxoy代理連過來的服務。&lt;br /&gt;
numTrustedProxies 這個的值，取決於你的走法過了幾層的proxy，&lt;br /&gt;
我只有cdn轉導到gke上面的istio LB&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;設定方式&lt;/p&gt;
&lt;p&gt;a. 在pod上面新增 anntations&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;  metadata:
    annotations:
      &amp;quot;proxy.istio.io/config&amp;quot;: &#39;{&amp;quot;gatewayTopology&amp;quot; : { &amp;quot;numTrustedProxies&amp;quot;: 1 } }&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;b. 在istioOperator新增&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
spec:
  meshConfig:
    defaultConfig:
      gatewayTopology:
        numTrustedProxies: 1	
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Authorization設定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這邊有點坑，搞了一天才搞清楚。&lt;br /&gt;
強烈建議把istio的&lt;a href=&quot;https://istio.io/latest/docs/ops/configuration/traffic-management/network-topologies/#example-using-x-forwarded-for-capability-with-httpbin&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;httpbin&lt;/a&gt;裝起來，實際去打，&lt;br /&gt;
然後一邊查看ingressgateway的deployment的log。&lt;/p&gt;
&lt;p&gt;a. 限制全部&lt;/p&gt;
&lt;p&gt;這是第一種方法，但這個只能針對『入口』的ingress做白名單驗證。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
 name: frontend-ingress-policy
 namespace: istio-system
spec:
 selector:
   matchLabels:
     app: ingressgateway-external
 action: ALLOW
 rules:
 - from:
   - source:
       remoteIpBlocks: 
         - &amp;quot;10.0.0.0/8&amp;quot;
         - &amp;quot;172.16.0.0/12&amp;quot;
         - &amp;quot;192.168.0.0/16&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;b. 針對單個&lt;br /&gt;
假如沒有在入口的話，無法照上面a.的方式抓到資料，&lt;br /&gt;
所以只能強制指定判斷header。&lt;br /&gt;
ref. &lt;a href=&quot;https://github.com/istio/istio/issues/30166&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Incorrect RemoteIP when Authorization Policy is applied to Injected Istio Proxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;過cdn時，只能判斷header。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: frontend-ingress-policy
spec:
  selector:
    matchLabels:
      group: frontend
  action: ALLOW
  rules:
    - when:
        - key: request.headers[X-Envoy-External-Address]
          values:
            - &amp;quot;10.*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不過CDN，則可使用下面的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      apiVersion: security.istio.io/v1
      kind: AuthorizationPolicy
      metadata:
        name: allowlist-frontend
      spec:
        selector:
          matchLabels:
            group: frontend
        action: ALLOW
        rules:
          - from:
            - source:
                remoteIpBlocks: 
                  - &amp;quot;59.127.129.63&amp;quot;
                  - &amp;quot;114.33.44.39&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://istio.io/latest/docs/ops/configuration/traffic-management/network-topologies/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Configuring Gateway Network Topology&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h4&gt;
&lt;h5 id=&quot;header&quot; tabindex=&quot;-1&quot;&gt;查看請求header的方法&lt;/h5&gt;
&lt;p&gt;將domain綁在vs上面直接呼叫即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
apiVersion: apps/v1
kind: Deployment
metadata:
  name: header-debugger
spec:
  replicas: 1
  selector:
    matchLabels:
      app: header-debugger
  template:
    metadata:
      labels:
        app: header-debugger
    spec:
      containers:
      - name: flask-server
        image: python:3.10-slim
        command: [&amp;quot;sh&amp;quot;, &amp;quot;-c&amp;quot;]
        args:
        - |
          pip install flask &amp;amp;&amp;amp; &#92;
          echo &#39;from flask import Flask, request
          app = Flask(__name__)
          @app.route(&amp;quot;/&amp;quot;)
          def index():
              return {k: v for k, v in request.headers.items()}
          app.run(host=&amp;quot;0.0.0.0&amp;quot;, port=8080)&#39; &amp;gt; app.py &amp;amp;&amp;amp; &#92;
          python app.py
        ports:
        - containerPort: 8080


---

apiVersion: v1
kind: Service
metadata:
  name: header-debugger
spec:
  selector:
    app: header-debugger
  ports:
  - port: 80
    targetPort: 8080

&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&quot;istio-operator-log&quot; tabindex=&quot;-1&quot;&gt;istioOperator增加log 閱讀性&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;spec:
  meshConfig:
    accessLogFile: /dev/stdout
    accessLogEncoding: JSON
    accessLogFormat: |
      {
        &amp;quot;protocol&amp;quot;: &amp;quot;%PROTOCOL%&amp;quot;,
        &amp;quot;upstream_service_time&amp;quot;: &amp;quot;%REQ(X-ENVOY-UPSTREAM_SERVICE_TIME)%&amp;quot;,
        &amp;quot;upstream_local_address&amp;quot;: &amp;quot;%UPSTREAM_LOCAL_ADDRESS%&amp;quot;,
        &amp;quot;duration&amp;quot;: &amp;quot;%DURATION%&amp;quot;,
        &amp;quot;upstream_transport_failure_reason&amp;quot;: &amp;quot;%UPSTREAM_TRANSPORT_FAILURE_REASON%&amp;quot;,
        &amp;quot;route_name&amp;quot;: &amp;quot;%ROUTE_NAME%&amp;quot;,
        &amp;quot;downstream_local_address&amp;quot;: &amp;quot;%DOWNSTREAM_LOCAL_ADDRESS%&amp;quot;,
        &amp;quot;user_agent&amp;quot;: &amp;quot;%REQ(USER-AGENT)%&amp;quot;,
        &amp;quot;response_code&amp;quot;: &amp;quot;%RESPONSE_CODE%&amp;quot;,
        &amp;quot;response_flags&amp;quot;: &amp;quot;%RESPONSE_FLAGS%&amp;quot;,
        &amp;quot;start_time&amp;quot;: &amp;quot;%START_TIME%&amp;quot;,
        &amp;quot;method&amp;quot;: &amp;quot;%REQ(:METHOD)%&amp;quot;,
        &amp;quot;request_id&amp;quot;: &amp;quot;%REQ(X-REQUEST-ID)%&amp;quot;,
        &amp;quot;upstream_host&amp;quot;: &amp;quot;%UPSTREAM_HOST%&amp;quot;,
        &amp;quot;x_forwarded_for&amp;quot;: &amp;quot;%REQ(X-FORWARDED-FOR)%&amp;quot;,
        &amp;quot;client_ip&amp;quot;: &amp;quot;%REQ(TRUE-Client-IP)%&amp;quot;,
        &amp;quot;requested_server_name&amp;quot;: &amp;quot;%REQUESTED_SERVER_NAME%&amp;quot;,
        &amp;quot;bytes_received&amp;quot;: &amp;quot;%BYTES_RECEIVED%&amp;quot;,
        &amp;quot;bytes_sent&amp;quot;: &amp;quot;%BYTES_SENT%&amp;quot;,
        &amp;quot;upstream_cluster&amp;quot;: &amp;quot;%UPSTREAM_CLUSTER%&amp;quot;,
        &amp;quot;downstream_remote_address&amp;quot;: &amp;quot;%DOWNSTREAM_REMOTE_ADDRESS%&amp;quot;,
        &amp;quot;authority&amp;quot;: &amp;quot;%REQ(:AUTHORITY)%&amp;quot;,
        &amp;quot;path&amp;quot;: &amp;quot;%REQ(X-ENVOY-ORIGINAL-PATH?:PATH)%&amp;quot;,
        &amp;quot;response_code_details&amp;quot;: &amp;quot;%RESPONSE_CODE_DETAILS%&amp;quot;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://dev.to/aws-builders/understanding-istio-access-logs-2k5o&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Understanding Istio Access Logs&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;authorization-policy&quot; tabindex=&quot;-1&quot;&gt;Authorization Policy規則&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;If there are any CUSTOM policies that match the request, evaluate and deny the request if the evaluation result is deny.
&lt;blockquote&gt;
&lt;p&gt;如果有任何符合請求的自訂策略，則評估並拒絕請求，若評估結果為拒絕。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;If there are any DENY policies that match the request, deny the request.
&lt;blockquote&gt;
&lt;p&gt;如果有符合請求的任何拒絕策略，則拒絕該請求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;If there are no ALLOW policies for the workload, allow the request.
&lt;blockquote&gt;
&lt;p&gt;如果工作負載沒有任何允許策略，則允許該請求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;If any of the ALLOW policies match the request, allow the request.
&lt;blockquote&gt;
&lt;p&gt;如果有任何允許策略符合該請求，則允許該請求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Deny the request.
&lt;blockquote&gt;
&lt;p&gt;拒絕該請求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://istio.io/latest/docs/reference/config/security/authorization-policy/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Authorization Policy&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;cloudflare&quot; tabindex=&quot;-1&quot;&gt;cloudflare轉發&lt;/h4&gt;
&lt;p&gt;上面有提到用cloudflare的CDN時，白名單會跟着變，&lt;br /&gt;
但在那之前還有個東西要注意，CDN轉發時，&lt;br /&gt;
cloudflare可以指定走http還是走https&lt;br /&gt;
這個會影響到istio的gateway，是開80還是443。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/186-fig.1.jpg&quot; alt=&quot;186-fig.1.jpg&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/186. istio的Authorization policy(白名單)/" />
        </entry>
        <entry>
            <title>
                18.istio Virtual Service 跨namespace讀取 DestinationRule
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/18.istio Virtual Service 跨namespace讀取 DestinationRule/</id>
            <content type="html">
                &lt;h2 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;因為在寫 vs的match uri，有發生一些坑，使用了prefix導致其他的VS都去抓到另一個VS的路徑，&lt;br /&gt;
於是想要讓所有的VS都用同一個VS，避免未來發生同樣的錯誤，不好找原因。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;目前的狀況是 A服務在 A 的namespace上面， B服務在 B 的 namespace上面。&lt;br /&gt;
正常的方式，&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/18.fig-1.jpg&quot; alt=&quot;18.fig-1.jpg&quot; /&gt;&lt;br /&gt;
VirtualService 跟 DestinationRule 都會各自在所屬服務上面的 namespace上面。&lt;br /&gt;
所以，如果有 三個服務，就會有 三個 VirtualService ，&lt;br /&gt;
同時 match uri的prefix部分，也都寫 /api /api2 /api3 的話，就會發現，服務不管怎麼呼叫都是呼叫到api&lt;br /&gt;
其實這也算我發生的錯誤，prefix 是只針對前面的字串符合就過了。&lt;br /&gt;
ref. &lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPMatchRequest&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;HTTPMatchRequest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但這個錯誤未來不知道有沒有辦法避免，是也能夠使用exact 完全符合的關鍵字來避免上面的錯誤發生。&lt;br /&gt;
但此時我就在思考，能不能未來都統一使用一個 VirtualService 就好，&lt;br /&gt;
這樣也方便管理。&lt;/p&gt;
&lt;p&gt;過程中的血淚，就不細說了。&lt;/p&gt;
&lt;p&gt;目前能做到的是 A、B 共用一個 VirtualService，此 VS在A的 namespace上面，&lt;br /&gt;
然後 DestinationRule 則分別在A、B 的namespace上面各架設一個。&lt;/p&gt;
&lt;p&gt;如果DR也想要共用的話，會發生錯誤，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  This subset’s labels are not found in any matching host
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;s&gt;想過使用指定的FQDN的label，來強迫他去指定的地方找deployment，但失敗了。&lt;br /&gt;
如果有人有看到方法還麻煩告知。&lt;/s&gt;&lt;br /&gt;
剛在寫文章的時候，有看到DR 也有exportTO的指令，&lt;br /&gt;
所以應該也是可以透過exportTO的方法，來共用同一個DR。&lt;/p&gt;
&lt;p&gt;目前的yaml寫法如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  exportTo:
    - &#39;*&#39;
  http:
    - match:
        - uri:
            prefix: /v2
      name: bale-api-v2
      rewrite:
        uri: /api
      route:
        - destination:
            host: bale-api.sex-system.svc.cluster.local
            port:
              number: 80
            subset: bale-api2
          weight: 80
        - destination:
            host: bale-api.sex-system.svc.cluster.local
            port:
              number: 80
            subset: bale-api
          weight: 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊在kiali會看到警告 Subnet not found (Fig.1)，但如果直接從Graph看流量分佈的話，是有在分流的。&lt;br /&gt;
這邊要注意，一定要加上  exportTO ，允許該服務可以跨過邊界去尋找到DR。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;exportTO:
  - &#39;*&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/virtual-service/#VirtualService&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;VirtualService&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/istio/istio/issues/15556&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Destination Rule is not applied to traffic from all namespaces it&#39;s exported to&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.cnblogs.com/charlieroro/p/13626429.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio 的配置分析&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/hxpjava1/article/details/108318645&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;VirtualService資源詳解&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/18.istio Virtual Service 跨namespace讀取 DestinationRule/" />
        </entry>
        <entry>
            <title>
                15.istio服務無法訪問
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/15.istio服務無法訪問/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;今天上班就發現這個情況，istio的服務無法訪問，但同一個叢集的另一個istio卻正常。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;看事件錯誤寫的是&lt;br /&gt;
&lt;code&gt;Readiness probe failed: HTTP probe failed with statuscode: 503&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/15.fig-1.jpg&quot; alt=&quot;15.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;pod 的狀態是running ，但istio-proxy 卻是 containers with unready status&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/15.fig-2.jpg&quot; alt=&quot;15.fig-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;根據錯誤訊息都沒找到相符合的資料&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://github.com/istio/istio/issues/23283&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Readiness probe failed: HTTP probe failed with statuscode: 503 &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#23283&quot;&gt;#23283&lt;/a&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;現在看istio-proxy的日誌，上面寫的是&lt;br /&gt;
Envoy proxy is NOT ready: config not received from Pilot (is Pilot running?)&lt;br /&gt;
這個似乎是原因..&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查看網格的狀況&lt;br /&gt;
istioctl proxy-status&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/15.fig-3.jpg&quot; alt=&quot;15.fig-3.jpg&quot; /&gt;&lt;br /&gt;
所屬的網格LDS寫 Never Ackonwledged&lt;br /&gt;
各欄位的意思如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LDS，Listener 發現服務：Listener 監聽器控制 sidecar 啟動端口監聽（目前只支持 TCP 協議），並配置 L3/L4 層過濾器，當網絡連接達到後，配置好的網絡過濾器堆棧開始處理後續事件。&lt;/li&gt;
&lt;li&gt;RDS，Router 發現服務：用於 HTTP 連接管理過濾器動態獲取路由配置，路由配置包含 HTTP 頭部修改（增加、刪除  HTTP 頭部鍵值），virtual hosts （虛擬主機），以及 virtual hosts 定義的各個路由條目。&lt;/li&gt;
&lt;li&gt;CDS，Cluster 發現服務：用於動態獲取 Cluster 信息。&lt;/li&gt;
&lt;li&gt;EDS，Endpoint 發現服務：用於動態維護端點信息，端點信息中還包括負載均衡權重、金絲雀狀態等，基於這些信息，sidecar 可以做出智能的負載均衡決策。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.servicemesher.com/istio-handbook/concepts/pilot.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Pilot&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;查看pod錯誤&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Envoy proxy is NOT ready: config not received from Pilot (is Pilot running?): cds updates: 1 successful, 0 rejected; lds updates: 0 successful, 1 rejected
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我一直以爲關鍵字是查前面的config not received from Pilot(is Pilot running?)&lt;br /&gt;
但後來開了工單找了Google工程師，他說重點是後面那句  lds updates: 0 successful, 1 rejected&lt;/p&gt;
&lt;p&gt;然後查看 istiod log，可以看到lds為什麼會rejected&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;warn	ads	ADS:LDS: ACK ERROR router~10.131.1.19~istio-ingressgateway-794bbdb877-np94z.istio-system~istio-system.svc.cluster.local-994 Internal:Error adding/updating listener(s) 0.0.0.0_8443: Invalid path: /etc/istio/ingressgateway-certs/tls.crt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這段在pod剛開始建立時也有出現此錯誤，看起來是https的憑證有問題，&lt;br /&gt;
本來佈署gateway的yaml檔像這樣&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: istio-ingressgateway-video
  namespace: sex-system
spec:
  selector:
    istio: ingressgateway   # 使用默認的控制器
  servers:
  - port: &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#加密傳輸&quot;&gt;#加密傳輸&lt;/a&gt;
      number: 443
      name: http
      protocol: HTTPS
    tls:
      mode: SIMPLE
      serverCertificate: /etc/istio/ingressgateway-certs/tls.crt &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#設定憑證路徑&quot;&gt;#設定憑證路徑&lt;/a&gt;
      privateKey: /etc/istio/ingressgateway-certs/tls.key  &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#設定憑證路徑&quot;&gt;#設定憑證路徑&lt;/a&gt;
    hosts:
      - &amp;quot;*&amp;quot; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#該服務對應domain&quot;&gt;#該服務對應domain&lt;/a&gt;
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
     - &amp;quot;*&amp;quot; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#該服務對應domain&quot;&gt;#該服務對應domain&lt;/a&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;憑證路徑是直接指向pod裡面的路徑，&lt;br /&gt;
但&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;google工程師說 istio v1.6開始gateway的tls已经不支援file mount类的设置了(i.e. &lt;code&gt;privateKey&lt;/code&gt;, &lt;code&gt;serverCertificate&lt;/code&gt;). 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，要麻自己建立 https的憑證 ，或者是乾脆不要https。&lt;br /&gt;
（ref. &lt;a href=&quot;https://istio.io/v1.8/docs/tasks/traffic-management/ingress/secure-ingress/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Secure Gateways&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;自己建立憑證的話，&lt;br /&gt;
根據上面的網址，產生 crt 跟 key ，然後使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl create secret tls credential-httpbin -n istio-system --cert=./httpbin.com.crt --key=./httpbin.com.key
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立sercret，最後再yaml內直接使用這個sercret的name&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: istio-ingressgateway-custom
  namespace: rd7-video
spec:
  selector:
    istio: ingressgateway-private   # 使用默認的控制器
  servers:
  - hosts:
      - httpbin.com
    port:
      name: httpbin
      number: 443
      protocol: HTTPS
    tls:
      credentialName: credential-httpbin
      mode: SIMPLE
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
     - &amp;quot;*&amp;quot; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#該服務對應domain&quot;&gt;#該服務對應domain&lt;/a&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;目前看起來是有直接解掉這個問題，&lt;br /&gt;
剛剛掛掉的pod，有變回正常的狀態。&lt;br /&gt;
但當初兩個pod，一個活着，另一個陣亡，還不知道爲何會這樣。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/15.istio服務無法訪問/" />
        </entry>
        <entry>
            <title>
                14.istio安裝時固定ip
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/14.istio安裝時固定ip/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;如果刪除GKE的節點，重建新的話，必須要把istio移除，才能夠使用 遷移工作負載到不同node。&lt;br /&gt;
但如果已經將istio的ip ，綁上固定的domain，一旦移除就必須要重新綁定。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;以下內容都在GCP上面實作(istio 版本為1.8.2)。 騰訊雲不能這樣玩。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先將IP變成靜態，而不是臨時。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/14.fig-1.jpg&quot; alt=&quot;14.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;將下面yaml另存成檔案&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
spec:
  components:
    ingressGateways:
    - name: istio-ingressgateway
      enabled: true
      k8s:
        service:
          loadBalancerIP: 123.123.123.123
          loadBalancerSourceRanges:
          - 111.222.222.111/32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;跟舊版的差異在必須加上name的名稱，不然在manifest generate 的時候會發生錯誤&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;安裝&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;istioctl install  -f value.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以先產生yaml看內容是不是有跟想象中的一樣&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;istioctl manifest generate -f value.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://cloud.tencent.com/developer/article/1607842&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio 1.5 部署指南修正版&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://istio.io/latest/docs/reference/config/istio.operator.v1alpha1/#ServiceSpec&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;IstioOperator Options&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/14.istio安裝時固定ip/" />
        </entry>
        <entry>
            <title>
                11. istio 與 kiali
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/11. istio 與 kiali/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;從istio扯到kiali，是說kiali是真的好用，看東西挺直覺得。&lt;br /&gt;
但有些警告，要解調就要照他的規範走&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;現在最常碰到的，也還沒解&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果使用GKE的私人叢集，請記得要把 master的防火牆規則，開啟8080 ，不然會發生讀取時需要一分鐘，資料才會出現。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;No matching workload found for gateway selector in this namespace&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/11.fig-1.jpg&quot; alt=&quot;11.fig-1.jpg&quot; /&gt;&lt;br /&gt;
簡單講就是目前的namespace沒有找到目前的 ingressgateway，未來可能會發生問題&lt;br /&gt;
ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kiali.io/documentation/v1.13/validations/#_no_matching_workload_found_for_gateway_selector_in_this_namespace&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;No matching workload found for gateway selector in this namespace&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Port name must follow &amp;lt;protocol&amp;gt;[-suffix] form&lt;/code&gt;&lt;br /&gt;
service上的 port name 必須要符合格式，&lt;br /&gt;
格式必須為 &lt;code&gt;http-&lt;/code&gt; 這樣的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  namespace: rd7-video
  labels:
    app: video-api-qa
  name: video-api
spec:
  ports:
  # 需遵照格式 前面為 protocol 後面為 -suffix
  - name: &amp;quot;http-video&amp;quot;
    port: 80
  selector:
    app: video-api-qa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kiali.io/documentation/v1.13/validations/#_port_name_must_follow_protocol_suffix_form&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Port name must follow &amp;lt;protocol&amp;gt;[-suffix] form&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;另外，如果編輯config有錯時，&lt;br /&gt;
按了SAVE沒有反應，錯誤訊息可能在最上面，要將捲軸往上拉。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kiali.io/documentation/v1.13/validations/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;v1.13 validation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;為了kiali的健康度，最好是在pod上面寫個 readinessProbe（就緒探針）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;readinessProbe:
  failureThreshold: 3
  initialDelaySeconds: 30
  periodSeconds: 10
  successThreshold: 1
  tcpSocket:
    port: 80
  timeoutSeconds: 1
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;kiali健康度 檢查 pod 變成 proxy unsynced&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%9B%B5%EF%B8%8F%20istio/11.fig-2.jpg&quot; alt=&quot;11.fig-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kiali.io/documentation/latest/configuration/health/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;v1.28Health Configuration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/xuliang666/p/12089915.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;istio之envoy常見術語及狀態碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kiali.io/documentation/latest/features/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kiali圖表說明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;virtualservice is pointing to a non-existent gateway&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/2113395/50571006-acd1b680-0dd9-11e9-9b34-db3f1bc95e08.png&quot; alt=&quot;fig.3&quot; /&gt;&lt;/p&gt;
&lt;p&gt;因為gateway不在同一層的namespace上面，所以要設定名稱時，&lt;br /&gt;
要改用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gateways:
  - istio-ingressgateway-video.sex-system.svc.cluster.local
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/11. istio 與 kiali/" />
        </entry>
        <entry>
            <title>
                0.istio MOC
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⛵️ istio/0.istio MOC/</id>
            <content type="html">
                &lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/73.%20istio%20sidecar%20%E6%B3%A8%E5%85%A5%E8%A6%8F%E5%89%87/&quot;&gt;73. istio sidecar 注入規則&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/89.%20istio%20%E5%B8%B8%E8%A6%8B%E7%8B%80%E6%85%8B%E7%A2%BC/&quot;&gt;89. istio 常見狀態碼&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;建置&quot; tabindex=&quot;-1&quot;&gt;建置&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/7.%20Istio%E5%AE%89%E8%A3%9D%E5%8F%8A%E4%BD%BF%E7%94%A8/&quot;&gt;7. Istio安裝及使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/11.%20istio%20%E8%88%87%20kiali/&quot;&gt;11. istio 與 kiali&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/14.istio%E5%AE%89%E8%A3%9D%E6%99%82%E5%9B%BA%E5%AE%9Aip/&quot;&gt;14.istio安裝時固定ip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/20.%20%E8%A8%AA%E5%95%8Fistio%20%E5%85%A7%E9%83%A8%E8%B2%A0%E8%BC%89%E5%B9%B3%E8%A1%A1ip/&quot;&gt;20. 訪問istio 內部負載平衡ip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/21.%20flagger%20%E8%87%AA%E5%8B%95%E9%87%91%E7%B5%B2%E9%9B%80%E4%BD%88%E7%BD%B2%20for%20istio/&quot;&gt;21. flagger 自動金絲雀佈署 for istio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/23.istio%E7%9A%84%20prometheus%E6%88%AA%E5%8F%96GKE%20metrics/&quot;&gt;23.istio的 prometheus截取GKE metrics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/34.%20istio%20operator%20%E5%AE%89%E8%A3%9D%E6%96%B0%E7%9A%84%20ingress%20deploy%E5%8F%8Aservice/&quot;&gt;34. istio operator 安裝新的 ingress deploy及service&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.github.io/404&quot;&gt;199. istio使用gatewayAPI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;virtual-service&quot; tabindex=&quot;-1&quot;&gt;VirtualService&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/11.%20istio%20%E8%88%87%20kiali/&quot;&gt;11. istio 與 kiali&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/30.%20istio%E7%9A%84virtualservice%20match%E6%AF%94%E5%B0%8D/&quot;&gt;30. istio的virtualservice match比對&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/35.%20istio%20virtualService%20delegate%E4%BD%BF%E7%94%A8/&quot;&gt;35. istio virtualService delegate使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/54.%20istio%20%E6%8E%9B%E8%BC%89ECK%20kibana/&quot;&gt;54. istio 掛載ECK kibana&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/62.%20isito%20%E9%8F%A1%E5%83%8F%E6%B5%81%E9%87%8F/&quot;&gt;62. isito 鏡像流量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/75.%20istio%20virtual%20service%20%E5%B8%B8%E7%94%A8%E5%8F%83%E6%95%B8/&quot;&gt;75. istio virtual service 常用參數&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/89.%20istio%20%E5%B8%B8%E8%A6%8B%E7%8B%80%E6%85%8B%E7%A2%BC/&quot;&gt;89. istio 常見狀態碼&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;authorization-policy&quot; tabindex=&quot;-1&quot;&gt;Authorization Policy&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/186.%20istio%E7%9A%84Authorization%20policy(%E7%99%BD%E5%90%8D%E5%96%AE)/&quot;&gt;186. istio的Authorization policy(白名單)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/15.istio%E6%9C%8D%E5%8B%99%E7%84%A1%E6%B3%95%E8%A8%AA%E5%95%8F/&quot;&gt;15.istio服務無法訪問&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/18.istio%20Virtual%20Service%20%E8%B7%A8namespace%E8%AE%80%E5%8F%96%20DestinationRule/&quot;&gt;18.istio Virtual Service 跨namespace讀取 DestinationRule&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/31.istio%20%E6%8A%93%E8%9F%B2%E8%A8%98/&quot;&gt;31.istio 抓蟲記&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⛵️ istio/0.istio MOC/" />
        </entry>
        <entry>
            <title>
                GCP費用
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/Price/GCP費用/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;GCP的費用主要分三塊，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;機器規格的開機費用&lt;br /&gt;
簡單說就是，機器開機的話產生的費用，但要注意的GCP他有續用折扣，當你用越多就能夠打折。而且他會主動合併未滿一個月機器，再一起算費用。&lt;br /&gt;
ref.
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.cloud-ace.tw/google-cloud-platform/pricing/gcp-is-cheap-each-discount-plan-introduction/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; 聽說 GCP 費用最低？各種折扣方案完整說明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/compute/docs/sustained-use-discounts&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;持續使用折扣&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;硬碟的費用&lt;br /&gt;
恩...就開機器時，所需要的硬碟空間大小費用，就算你機器關機一樣照算。&lt;br /&gt;
ref. &lt;a href=&quot;https://cloud.google.com/compute/disks-image-pricing#persistentdisk&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;磁碟和映像價格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;網路的費用&lt;br /&gt;
以伺服器的角度來說，ingress(流量進來）不算錢，egress（流量出去）算錢。&lt;br /&gt;
以使用者的角度來說，上傳不用錢，下載要錢。&lt;br /&gt;
ref. &lt;a href=&quot;https://blog.cloud-ace.tw/google-cloud-platform/pricing/gcp-price-estimate/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GCP 如何計費？就像水電費一樣&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;registry&quot; tabindex=&quot;-1&quot;&gt;Registry&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Artifact Registry&lt;/th&gt;
&lt;th&gt;Container Registry&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0.5GB以下免費，超過0.5GB，每GB 0.1 美元&lt;/td&gt;
&lt;td&gt;根據cloudStorage計價&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;網路輸出另計&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/artifact-registry/pricing?hl=zh-tw#storage&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Artifact Registry 定價&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/Price/GCP費用/" />
        </entry>
        <entry>
            <title>
                GCP CPU用途
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/Price/GCP CPU用途/</id>
            <content type="html">
                &lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/Price/GCP%20CPU%E7%94%A8%E9%80%94/#2024-07-09&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#2024/07/09更新&quot;&gt;#2024/07/09更新&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;官方建議&quot; tabindex=&quot;-1&quot;&gt;官方建議&lt;/h1&gt;
&lt;p&gt;下表是官方建議的機器型號及用途&lt;br /&gt;
ref.&lt;a href=&quot;https://cloud.google.com/compute/docs/general-purpose-machines&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;通用機器系列&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;E2&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web 服務&lt;/li&gt;
&lt;li&gt;中小型資料庫&lt;/li&gt;
&lt;li&gt;應用提供服務&lt;/li&gt;
&lt;li&gt;後台應用&lt;/li&gt;
&lt;li&gt;微服務&lt;/li&gt;
&lt;li&gt;虛擬桌面&lt;/li&gt;
&lt;li&gt;開發環境&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;N2、N2D、Tau T2D、N1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web 服務&lt;/li&gt;
&lt;li&gt;大中型資料庫&lt;/li&gt;
&lt;li&gt;應用提供服務&lt;/li&gt;
&lt;li&gt;後台應用&lt;/li&gt;
&lt;li&gt;快取&lt;/li&gt;
&lt;li&gt;媒體/流式傳輸&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tau T2A&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;應用服務、Web 服務和遊戲服務&lt;/li&gt;
&lt;li&gt;嵌入式系統開發&lt;/li&gt;
&lt;li&gt;Arm 上的 CI/CD 開發&lt;/li&gt;
&lt;li&gt;視訊和圖片編碼、轉碼和處理&lt;/li&gt;
&lt;li&gt;數字廣告交易和投放&lt;/li&gt;
&lt;li&gt;快取伺服器&lt;/li&gt;
&lt;li&gt;計算型藥品研發&lt;/li&gt;
&lt;li&gt;Android 開發&lt;/li&gt;
&lt;li&gt;自動駕駛或傳統汽車軟體開發&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他 N2D 跟 Tau T2D都是AMD的CPU，價格比N2的便宜&lt;/p&gt;
&lt;p&gt;以同樣的 4 cpu , 16GB memory 來比較價格的話，&lt;br /&gt;
改天要開到N2的話，可以試試N2D的機器。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;類型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;CPU&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;記憶體&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;價格&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;n2-standard-4&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;4&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;16GB&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$0.1942&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;n2d-standard-4&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;4&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;16GB&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$0.1690&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;e2-standard-4&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;4&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;16GB&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$0.13402&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;更詳細的價格，參考 &lt;a href=&quot;https://cloud.google.com/compute/vm-instance-pricing&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;虛擬機器實例價格&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2024-07-09&quot; tabindex=&quot;-1&quot;&gt;2024/07/09更新&lt;/h2&gt;
&lt;p&gt;今天來算數學了，&lt;br /&gt;
現在要來比較N2D與C2D的價格差距&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;類型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;On-demand price&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;1-year&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;3-year&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Unit&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;N2D CPU&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$23.24612&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$14.64453&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$10.4609&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;vCPU month&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;C2D CPU&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$24.98863&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$15.74245&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$11.24492&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;vCPU month&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;C3D CPU&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$26.62383&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$16.77321&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$11.98076&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;vCPU month&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;N2D Memory&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$3.11564&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$1.96297&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$1.40233&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;GB month&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;C2D Memory&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$3.34632&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$2.10824&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$1.50599&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;GB month&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;C3D Memory&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$3.56532&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$2.24621&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;$1.60454&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;GB month&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;但要特別注意 N2D，如果自定義CPU與Memory的話，&lt;br /&gt;
價格又不一樣了。&lt;/p&gt;
&lt;p&gt;CPU 會來到  $24.408426 / vCPU month&lt;br /&gt;
Memory 會來到  $3.271422 / GB month&lt;/p&gt;
&lt;p&gt;同樣以4顆CPU來算的話，&lt;br /&gt;
當記憶體到13.82G時，價格將接近標準N2D。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/Price/GCP CPU用途/" />
        </entry>
        <entry>
            <title>
                180. GCP 監控費用
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/Price/180. GCP 監控費用/</id>
            <content type="html">
                &lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;價格&lt;a href=&quot;https://cloud.google.com/stackdriver/pricing?hl=zh-cn#binary-units&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;1&lt;/a&gt;&lt;/th&gt;
&lt;th&gt;每月免費配額&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Logging&lt;/a&gt; 儲存*&lt;/td&gt;
&lt;td&gt;$0.50/GiB；  &lt;br /&gt;將日誌流式傳輸到日誌儲存桶儲存空間，以便編入索引、查詢和分析的一次性費用；包括日誌儲存桶中長達 30 天的儲存費用。 查詢和分析日誌資料不會產生額外費用。&lt;/td&gt;
&lt;td&gt;每個項目每月的前 50 GiB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Logging&lt;/a&gt; 保留†&lt;/td&gt;
&lt;td&gt;對於保留超過 30 天的日誌，每月每 GiB 為 $0.01；根據留存率按月結算。&lt;/td&gt;
&lt;td&gt;在&lt;a href=&quot;https://cloud.google.com/logging/quotas?hl=zh-cn#logs_retention_periods&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;默認保留期限&lt;/a&gt;內保留的日誌不會產生保留費用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;日誌記錄&lt;/a&gt;入站流量‡&lt;/td&gt;
&lt;td&gt;無需額外費用&lt;/td&gt;
&lt;td&gt;不適用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs/routing/overview?hl=zh-cn#ingesting-routing&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;日誌路由器&lt;/a&gt;♦&lt;/td&gt;
&lt;td&gt;無需額外費用&lt;/td&gt;
&lt;td&gt;不適用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs/log-analytics?hl=zh-cn#analytics&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Log Analytics&lt;/a&gt;♣&lt;/td&gt;
&lt;td&gt;無需額外費用&lt;/td&gt;
&lt;td&gt;不適用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;logging&quot; tabindex=&quot;-1&quot;&gt;Logging保留&lt;/h2&gt;
&lt;p&gt;Logging保留的費用，在默認保留的天數為以下&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;日誌儲存桶&lt;/th&gt;
&lt;th&gt;默認保留期限&lt;/th&gt;
&lt;th&gt;自訂保留期限&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_Required&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;400 天&lt;/td&gt;
&lt;td&gt;不可組態&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_Default&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;30 天&lt;/td&gt;
&lt;td&gt;可組態&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用者定義&lt;/td&gt;
&lt;td&gt;30 天&lt;/td&gt;
&lt;td&gt;可組態&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&quot;code-required-code&quot; tabindex=&quot;-1&quot;&gt;&lt;code&gt;_Required&lt;/code&gt; 日誌儲存桶&lt;/h5&gt;
&lt;p&gt;Cloud Logging 會自動將以下類型的日誌路由到 &lt;code&gt;_Required&lt;/code&gt; 儲存桶：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs/audit?hl=zh-cn#admin-activity&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;管理員活動稽核日誌&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs/audit?hl=zh-cn#system-event&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;系統事件稽核日誌&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Google Workspace 管理員稽核日誌&lt;/li&gt;
&lt;li&gt;企業版群組稽核日誌&lt;/li&gt;
&lt;li&gt;登錄稽核日誌&lt;/li&gt;
&lt;li&gt;Access Transparency 日誌。如需瞭解如何啟用 Access Transparency 日誌，請參閱 &lt;a href=&quot;https://cloud.google.com/assured-workloads/access-transparency/docs/overview?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Access Transparency 日誌文件&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;code-default-code&quot; tabindex=&quot;-1&quot;&gt;&lt;code&gt;_Default&lt;/code&gt; 日誌儲存桶&lt;/h5&gt;
&lt;p&gt;除非您停用或以其他方式修改 &lt;code&gt;_Default&lt;/code&gt; 接收器，否則未儲存在 &lt;code&gt;_Required&lt;/code&gt; 儲存桶中的任何日誌條目都會被 &lt;code&gt;_Default&lt;/code&gt; 接收器路由到 &lt;code&gt;_Default&lt;/code&gt; 儲存桶。如需瞭解如何修改接收器，請參閱&lt;a href=&quot;https://cloud.google.com/logging/docs/export/configure_export_v2?hl=zh-cn#managing_sinks&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;管理接收器&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Cloud Logging 會自動將以下類型的日誌路由到 &lt;code&gt;_Default&lt;/code&gt; 儲存桶：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs/audit?hl=zh-cn#data-access&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;資料訪問稽核日誌&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs/audit?hl=zh-cn#policy_denied&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;政策拒絕稽核日誌&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除非您為 &lt;code&gt;_Default&lt;/code&gt; 儲存桶&lt;a href=&quot;https://cloud.google.com/logging/docs/buckets?hl=zh-cn#custom-retention&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;組態自訂保留&lt;/a&gt;，否則 Cloud Logging 會將日誌保留 30 天。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/stackdriver/pricing?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Google Cloud 的維運套件價格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/logging/quotas?hl=zh-cn#logs_retention_periods&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;日誌保留期限&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/logging/docs/routing/overview?hl=zh-cn#buckets&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;路由和儲存概覽&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/Price/180. GCP 監控費用/" />
        </entry>
        <entry>
            <title>
                126. GCP 硬碟費用比較
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/Price/126. GCP 硬碟費用比較/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;GCE&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Standard : $0.04 per GiB&lt;/li&gt;
&lt;li&gt;SSD : $0.17 per GiB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CloudStorage&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Standard ：適合短期儲存和經常存取的資料&lt;/li&gt;
&lt;li&gt;Nearline ： 適用於備份項目和一個月存取不到一次的資料&lt;/li&gt;
&lt;li&gt;Coldline：最適合用於災難復原，以及儲存「每季存取少於一次」的資料&lt;/li&gt;
&lt;li&gt;Archive ：適合以數位方式長期保存一年存取不到一次的資料&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面為每月每GB的空間費用&lt;/p&gt;
&lt;p&gt;|                 | Standard 儲存空間 | Nearline 儲存空間 | Coldline 儲存空間 | 封存儲存空間     |    |&lt;br /&gt;
|-----------------|---------------|---------------|---------------|------------|&lt;br /&gt;
| 台灣 (asia-east1) | $0.020 美元     | $0.010 美元     | $0.005 美元     | $0.0015 美元 |&lt;/p&gt;
&lt;p&gt;如果有網路流量，額外在算&lt;/p&gt;
&lt;p&gt;| 每月用量      | 輸出至世界各地 (亞洲和澳洲除外) | 輸出至亞洲地區 (中國除外，但含香港) | 輸出至中國地區 (香港除外) | 輸出至澳洲地區，從位於澳洲的 Cloud Storage 區域輸出 | 輸入 |   |   |   |   |&lt;br /&gt;
|-----------|-------------------|---------------------|----------------|-----------------------------------|----|&lt;br /&gt;
| 0 至 1 TB  | $0.12 美元          | $0.12 美元            | $0.23 美元       | $0.19 美元                          | 免費   |&lt;br /&gt;
| 1 至 10 TB | $0.11 美元          | $0.11 美元            | $0.22 美元       | $0.18 美元                          | 免費   |&lt;br /&gt;
| 10 TB 以上  | $0.08 美元          | $0.08 美元            | $0.20 美元       | $0.15 美元                          | 免費  |&lt;/p&gt;
&lt;p&gt;再補一下操作的費用，&lt;br /&gt;
單純看金額其實不高，但如果頻率高的話，&lt;br /&gt;
其實也不少。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;儲存空間級別1&lt;/th&gt;
&lt;th&gt;A 級作業  &lt;br /&gt;(每 1,000 次操作)&lt;/th&gt;
&lt;th&gt;B 級作業  &lt;br /&gt;(每 1,000 次操作)&lt;/th&gt;
&lt;th&gt;免費操作功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Standard Storage&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$0.0100 美元&lt;/td&gt;
&lt;td&gt;$0.0004 美元&lt;/td&gt;
&lt;td&gt;免費&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Nearline Storage&lt;/strong&gt; 和 &lt;strong&gt;Durable Reduced Availability (DRA) Storage&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$0.0200 美元&lt;/td&gt;
&lt;td&gt;$0.0010 美元&lt;/td&gt;
&lt;td&gt;免費&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Coldline Storage&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$0.0400 美元&lt;/td&gt;
&lt;td&gt;$0.0100 美元&lt;/td&gt;
&lt;td&gt;免費&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Archive Storage&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;$0.1000 美元&lt;/td&gt;
&lt;td&gt;$0.0500 美元&lt;/td&gt;
&lt;td&gt;免費&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果是使用async，基本想像得到的就有list、insert。可能還有其他的操作。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;API 或功能&lt;/th&gt;
&lt;th&gt;A 級作業&lt;/th&gt;
&lt;th&gt;B 級作業&lt;/th&gt;
&lt;th&gt;免費作業項目&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;JSON API 或 gRPC&lt;/td&gt;
&lt;td&gt;storage.&lt;em&gt;.insert1  &lt;br /&gt;storage.&lt;/em&gt;.patch  &lt;br /&gt;storage.&lt;em&gt;.update  &lt;br /&gt;storage.&lt;/em&gt;.setIamPolicy  &lt;br /&gt;storage.buckets.list  &lt;br /&gt;storage.buckets.lockRetentionPolicy  &lt;br /&gt;storage.notifications.delete  &lt;br /&gt;storage.objects.compose  &lt;br /&gt;storage.objects.copy  &lt;br /&gt;storage.objects.list  &lt;br /&gt;storage.objects.restore  &lt;br /&gt;storage.objects.rewrite1  &lt;br /&gt;storage.objects.watchAll  &lt;br /&gt;storage.projects.hmacKeys.create  &lt;br /&gt;storage.projects.hmacKeys.list  &lt;br /&gt;storage.*AccessControls.delete  &lt;br /&gt;storage.folders.list  &lt;br /&gt;storage.folders.rename&lt;/td&gt;
&lt;td&gt;storage.&lt;em&gt;.get  &lt;br /&gt;storage.&lt;/em&gt;.getIamPolicy  &lt;br /&gt;storage.*.testIamPermissions  &lt;br /&gt;storage.*AccessControls.list  &lt;br /&gt;storage.notifications.list  &lt;br /&gt;每則物件變更通知2  &lt;br /&gt;storage.buckets.getStorageLayout&lt;/td&gt;
&lt;td&gt;storage.channels.stop  &lt;br /&gt;storage.buckets.delete  &lt;br /&gt;storage.objects.delete  &lt;br /&gt;storage.projects.hmacKeys.delete  &lt;br /&gt;storage.folders.delete&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;XML API&lt;/td&gt;
&lt;td&gt;GET 服務  &lt;br /&gt;GET 值區 (列出值區中的物件時)  &lt;br /&gt;PUT  &lt;br /&gt;POST&lt;/td&gt;
&lt;td&gt;GET 值區 (擷取值區設定或列出正在進行中的多部分上傳作業時)  &lt;br /&gt;GET 物件  &lt;br /&gt;HEAD&lt;/td&gt;
&lt;td&gt;Delete&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://cloud.google.com/storage/docs/lifecycle?hl=zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;物件生命週期管理&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;SetStorageClass&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;中止未完成的多部分上傳作業  &lt;br /&gt;刪除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://cloud.google.com/storage/docs/autoclass?hl=zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;自動分類&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;以下儲存空間級別轉換：&lt;br /&gt;&lt;br /&gt;- 從 Coldline 改為 Standard&lt;br /&gt;- 從封存改為標準&lt;br /&gt;- Coldline 到 Nearline&lt;br /&gt;- 將資料封存至 Nearline&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;以下儲存空間級別轉換：&lt;br /&gt;&lt;br /&gt;- Nearline 到 Standard&lt;br /&gt;- Standard 轉換為 Nearline&lt;br /&gt;- Nearline 到 Coldline&lt;br /&gt;- Coldline 到 Archive&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://cloud.google.com/storage/docs/tags-and-labels?hl=zh-tw#tags&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;標記&lt;/a&gt;3&lt;/td&gt;
&lt;td&gt;附加標記  &lt;br /&gt;解除標記&lt;/td&gt;
&lt;td&gt;列出附加至值區的標記&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&quot;https://cloud.google.com/storage/docs/soft-delete?hl=zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;軟刪除&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;在一次大量還原作業中處理 1,000 個物件  &lt;br /&gt;還原虛刪除的物件&lt;/td&gt;
&lt;td&gt;列出虛刪除的物件&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/storage/pricing?hl=zh-tw#asia&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;價目表&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/Price/126. GCP 硬碟費用比較/" />
        </entry>
        <entry>
            <title>
                97. Anthos 初體驗
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/97. Anthos 初體驗/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;每個月增加 50 美&lt;/li&gt;
&lt;li&gt;create new cluster ,無法更改現有(Anthos)&lt;/li&gt;
&lt;li&gt;只能用workload identity&lt;/li&gt;
&lt;li&gt;cpu至少四個，total 要八個&lt;/li&gt;
&lt;li&gt;Anthos 跟 Anthos Service Mesh 不一樣&lt;br /&gt;
ref. &lt;a href=&quot;https://cloud.google.com/service-mesh/docs/ui-differences&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Anthos 與 Anthos Service Mesh 界面差異&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果在mac上，參照&lt;a href=&quot;https://cloud.google.com/service-mesh/docs/unified-install/install-dependent-tools&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;文件&lt;/a&gt;，執行的話會出現一些錯誤。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;mac不支援此指令，&lt;/li&gt;
&lt;li&gt;也不要使用cloudShell，會因為VPCSC 而出現錯誤&lt;/li&gt;
&lt;li&gt;最佳解法，使用linux系統&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt; docker  run -it --rm   -v &amp;quot;$HOME&amp;quot;/.config:/root/.config -v /Users/ezio_liu/Documents/kill:/data google/cloud-sdk:latest

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因為有將 gcp驗證 掛載到image內，所以不用在驗證一次。&lt;br /&gt;
可以使用下面指令，看人員有沒有驗證&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud auth list 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最後，使用下面指令安裝&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./asmcli install   &#92;
--project_id rd7-project &#92;
--cluster_name istio-test &#92;
--cluster_location asia-east1-b &#92;
--fleet_id rd7-project &#92;
--output_dir asmcli_output &#92;
--managed  &#92;
--ca mesh_ca
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;--managed 是使用 代管式anthos&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/97. Anthos 初體驗/" />
        </entry>
        <entry>
            <title>
                95.cloud build的問題
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/95.cloud build的問題/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;在建置cloud build時遇到問題，&lt;br /&gt;
經查詢後推測問題在於，&lt;br /&gt;
cloud build的google service當他在運作過程，&lt;br /&gt;
需要向私有專案內的gke cluster操作，&lt;br /&gt;
cloud build是使用google的浮動ip，&lt;br /&gt;
在此處應該是被block掉了所以無法完成cloud build建置&lt;/p&gt;
&lt;p&gt;錯誤訊息：Unable to connect to the server: dial tcp 124.111.27.75:443: i/o timeout&lt;/p&gt;
&lt;p&gt;(IP為cluster端點ip)&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/build/docs/troubleshooting#io_timeout_error&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;google錯誤排解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;現階段有三種方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自架CICD系統&lt;/li&gt;
&lt;li&gt;GKE 直接開放 0.0.0.0/0 &amp;gt; 這有安全疑慮&lt;/li&gt;
&lt;li&gt;使用 private conn &amp;gt; 這複雜度很高且不彈性&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/95.cloud build的問題/" />
        </entry>
        <entry>
            <title>
                9.GCP網路對外的方式
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/9.GCP網路對外的方式/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;這算是先前一直有問題，但不知道為什麼，也沒去查原因。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;為了要正確對應，讓其他機器開白名單，不得不弄清楚，到底怎麼一回事。&lt;br /&gt;
之前同事都說是走cloudNat，但我直接連去 vm  or pod裡面，&lt;br /&gt;
用curl &lt;a href=&quot;http://ifconfig.me/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ifconfig.me&lt;/a&gt; 抓到的ip都不是我所知道的ip，&lt;br /&gt;
(&lt;a href=&quot;http://ifconfig.me/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ifconfig.me&lt;/a&gt; 是一個網址，單純顯示目前連去網站的ip位置)&lt;/p&gt;
&lt;p&gt;CloudNAT 的基本概念，主要是可提供內部機器對外連線&lt;br /&gt;
ref. &lt;a href=&quot;https://cloud.google.com/nat/docs/overview&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Cloud NAT 概覽&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基本的設定方式，&lt;br /&gt;
ref. &lt;a href=&quot;https://cloud.google.com/nat/docs/using-nat&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 Cloud NAT&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GCE沒有問題，基本上沒有外部ip而且又沒設定cloudNAT的話，就是無法連接外網。&lt;br /&gt;
然而有外部ip位置的話，Google Cloud 會自動對來源與該接口的主內部 IP 地址匹配的數據包執行一對一 NAT。&lt;br /&gt;
但GKE就有點問題了，就算沒有設定外部ip，還是能夠對外，&lt;br /&gt;
而且抓到的ip位置，你不知道是從何而來，也不是CloudNAT的IP&lt;/p&gt;
&lt;p&gt;最後從&lt;a href=&quot;https://cloud.google.com/nat/docs/troubleshooting#internet-wo-nat&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;問題排查&lt;/a&gt;這邊找到了答案，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;確保您的 Google Kubernetes Engine (GKE) 集群是一個專用集群。非專用集群中的每個節點虛擬機都具有外部 IP 地址，因此每個節點都可以使用 Virtual Private Cloud (VPC) 網絡中下一個躍點為默認互聯網網關而不依賴 Cloud NAT 的路由。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;簡單說，如果沒有設定專有集群（私有叢集），本身的node是具有對外的ip，所以還沒到CloudNAT之前，&lt;br /&gt;
就直接從node節點出去了。這部分可以到pod裡面 抓取對外ip，然後去比對，這個pod所在的node的對外ip就知道了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters#console&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;建立私人叢集&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;2021-04-19&quot; tabindex=&quot;-1&quot;&gt;2021/04/19 更新&lt;/h1&gt;
&lt;p&gt;今天來算一下數學，&lt;/p&gt;
&lt;p&gt;上面有提到，當設成私有叢集或是VM，需要對外連線時，&lt;br /&gt;
需設定cloud nat ip，&lt;br /&gt;
當對外連線數量不足時，會發生許多奇怪的問題，&lt;br /&gt;
例如，佈署 deployment ，會發生image pull error ，pod無法啟動，一直重開...等等。&lt;/p&gt;
&lt;p&gt;[[9-fig.1.jpg]]&lt;/p&gt;
&lt;p&gt;每個 VM 執行個體的最低通訊埠數量 ：64&lt;br /&gt;
表示每台VM可以對外的連線數量。&lt;/p&gt;
&lt;p&gt;假設(fig.1)&lt;br /&gt;
對外的ip有兩個，&lt;br /&gt;
一個對外ip可以提供 64512的 port 給裡面的來源子網路與IP使用，&lt;br /&gt;
而我們上面設定 每個 VM 執行個體的最低通訊埠數量 為 64 ，&lt;br /&gt;
故 64512 * 2/64 = 2016 可提供的VM數量&lt;br /&gt;
表示 來源子網路與 IP 範圍 的VPC網路 可以提供給2016 個VM （包含 GCE 跟 GKE的節點） 使用。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/nat/docs/ports-and-addresses#port-reservation-examples&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Cloud NAT 地址和端口概覽&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/9.GCP網路對外的方式/" />
        </entry>
        <entry>
            <title>
                88.批次修改GCP的label
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/88.批次修改GCP的label/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;發現有一整批的資源沒有加過 label ，&lt;br /&gt;
GCE的硬碟、負載平衡的前端轉導規則..&lt;br /&gt;
有些條件不一樣，一個一個加會瘋掉。&lt;br /&gt;
工程師就是懶...寫sh吧&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;開始構思&quot; tabindex=&quot;-1&quot;&gt;開始構思&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;先把關鍵值拉出來 (1)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute forwarding-rules list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/88-fig.1.png&quot; alt=&quot;88-fig.1.png&quot; /&gt;&lt;br /&gt;
只有ip，要跑去每個叢集查資料，看這該歸屬哪個label，&lt;br /&gt;
太笨了，不行。&lt;/p&gt;
&lt;p&gt;先看一下forwarding-rules 有哪些資訊(2)，再把欄位顯示出來。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute forwarding-rules describe a0589a367cdc1470e839b05803958e2b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;裡面的description似乎蠻有用處的，可以幫忙釐清是哪個cluster&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/88-fig.2.jpg&quot; alt=&quot;88-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;用 --format (3)，顯示欄位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; gcloud compute forwarding-rules list  --format=&#39;table(name,IPAddress,description)&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/88-fig.3.jpg&quot; alt=&quot;88-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;開始寫bash&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;將name丟進 文字檔，&lt;br /&gt;
然後執行bash，bash的流程，迴圈讀檔案內容(4)，執行更新label指令(5)。這邊要注意，如果是ingress或是區域型的要額外加上 --global，&lt;br /&gt;
才能更新。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while read p; do
  echo &amp;quot;$p&amp;quot;; gcloud compute forwarding-rules update $p &#92;
    --update-labels=product=abc,env=prod,dept=rd; echo &amp;quot;done&amp;quot;;
done &amp;lt;lbfr.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/compute/forwarding-rules/list&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud compute forwarding-rules list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/compute/forwarding-rules/describe&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud compute forwarding-rules describe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/topic/formats&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud topic formats&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.compciv.org/topics/bash/loops/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;http://www.compciv.org/topics/bash/loops/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/compute/forwarding-rules/update&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud compute forwarding-rules update&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/88.批次修改GCP的label/" />
        </entry>
        <entry>
            <title>
                8.GCS使用方式
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/8.GCS使用方式/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;某個案子，要整個翻掉重做，這次要讓VM的機器跟GKE的pod能夠同時存取一個儲存空間，&lt;br /&gt;
預計使用Google Cloud Storage，踩了一個早上的坑。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;預計做兩個項目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在VM上面掛載gcs的資料夾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在GKE 上面的pod同時掛載 gcs的資料夾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在VM上面掛載gcs的資料夾&lt;br /&gt;
安裝方式，目前我的vm是 RedHat 所以用下面的方式，CentOS也是用同樣的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Configure the gcsfuse repo:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo tee /etc/yum.repos.d/gcsfuse.repo &amp;gt; /dev/null &amp;lt;&amp;lt;EOF
[gcsfuse]
name=gcsfuse (packages.cloud.google.com)
baseurl=https://packages.cloud.google.com/yum/repos/gcsfuse-el7-x86_64
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg
       https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Install gcsfuse:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;  sudo yum install gcsfuse
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成，其他安裝方式，請參考&lt;a href=&quot;https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/docs/installing.md&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GoogleCloudPlatform/gcsfuse/install.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;登入使用，&lt;br /&gt;
這邊先使用 gcloud auth login 做測試&lt;br /&gt;
先建立資料夾  mkdir upload&lt;br /&gt;
掛載  gcsfuse my-bucket upload&lt;br /&gt;
卸除掛載 fusermount -u upload&lt;/p&gt;
&lt;h3 id=&quot;debug&quot; tabindex=&quot;-1&quot;&gt;Debug用&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;gcsfuse --foreground --debug_gcs --debug_http --debug_fuse --debug_invariants --key-file=/home/user/Downloads/my-key.json mybucket /upload
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;google-application-credentials&quot; tabindex=&quot;-1&quot;&gt;永久加入GOOGLE_APPLICATION_CREDENTIALS變數&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;開啟 /etc/profiles
新增 export GOOGLE_APPLICATION_CREDENTIALS=&amp;quot;/home/user/Downloads/my-key.json&amp;quot;
修改檔案後要想馬上生效還要執行#
source /etc/profile不然只能在下次重進此使用者時生效。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://www.itread01.com/content/1547223515.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux系統環境變數和別名設定（永久生效和臨時生效）&lt;/a&gt;&lt;br /&gt;
附註，json檔案的取得在 IAM角色內的服務賬戶&lt;br /&gt;
ref.&lt;a href=&quot;https://cloud.google.com/iam/docs/creating-managing-service-account-keys&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;創建和管理服務帳號密鑰&lt;/a&gt;。&lt;br /&gt;
新增完GCS，記得把權限給服務賬戶。記得選擇完整權限（Fig. 1)&lt;/p&gt;
&lt;h3 id=&quot;自動掛載&quot; tabindex=&quot;-1&quot;&gt;自動掛載&lt;/h3&gt;
&lt;p&gt;有權限了已後，再來就是自動掛載了。&lt;br /&gt;
到/etc/fstab上，輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;my_bucket /home/ezio/upload gcsfuse key_file=key/key.json,rw,user,allow_other,uid=1008,gid=1009  0 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重開機測試看看，收工。&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://stackoverflow.com/questions/42638048/how-to-use-mount-command-in-fstab-file/42638136#42638136&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to use mount command in fstab file&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://serverfault.com/questions/1021950/gcsfuse-automount-on-a-non-root-user&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcsfuse automount on a non root user&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;查詢目前登入使用者的uid 跟 gid
id $(whoami)

如果要看全部使用者的話，
cat /etc/passwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;a href=&quot;http://linux.vbird.org/linux_basic/0410accountmanager/0410accountmanager-centos5.php#account_id&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux 的帳號與群組&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;在GKE 上面的pod同時掛載 gcs的資料夾&lt;br /&gt;
基本的方式，&lt;br /&gt;
先自己產生一個 image&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;FROM golang:1.14-alpine AS build-env
ENV GO111MODULE on

# WORKDIR /工作名錄名稱 當前的工作目錄名稱，若是不存在則會新建該目錄，
# 需要注意的是copy跟run的指令都是以WORKDIR為當前目錄下去跑的，
# 運用的時候需要注意相對位置。
WORKDIR $GOPATH/src

RUN go get -u github.com/googlecloudplatform/gcsfuse

COPY key.json .


FROM alpine:3.6
RUN apk add --no-cache ca-certificates fuse &amp;amp;&amp;amp; rm -rf /tmp/*
COPY --from=build-env /go/bin/gcsfuse /usr/local/bin
COPY --from=build-env /go/src/key.json /
WORKDIR /
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;佈署 Deployment&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: gcs-fuse
    version: v1
  namespace: debug
  name: gcsfuse-test
spec:
  replicas: 1
  selector:
    matchLabels:
      app: gcs-fuse
      version: v1
  template:
    metadata:
      labels:
        app: gcs-fuse
        version: v1
    spec:
      containers:
        - name: gcsfuse-test
          image: gcr.io/your-project/gcsfuse:v1.2
          # image: golang:1.14-alpine
          # command: [ &amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;--&amp;quot; ]
          # args: [ &amp;quot;while true; do sleep 600; done;&amp;quot; ]
          securityContext:
            privileged: true
          command:
            - &amp;quot;/bin/sh&amp;quot;
            - &amp;quot;-c&amp;quot;
            - &amp;quot;while true; do mkdir /upload ; gcsfuse --key-file=key.json your-bucket /folder; sleep 600; done; &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果跟現有的程式整合的話，&lt;br /&gt;
由於要執行多行指令，需使用shellScript的方式執行指令。&lt;br /&gt;
可能會遇到下列情況&lt;/p&gt;
&lt;h3 id=&quot;and-quot-exec-and-quot-init-sh-and-quot-permission-denied&quot; tabindex=&quot;-1&quot;&gt;&amp;quot;exec: &amp;quot;/init.sh&amp;quot;: permission denied&lt;/h3&gt;
&lt;p&gt;在Dockerfile上修改權限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RUN chmod +x /init.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://stackoverflow.com/questions/44687685/getting-permission-denied-in-docker-run&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;getting permission denied in docker run&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;exec-user-process-caused-and-quot-exec-format-error-and-quot&quot; tabindex=&quot;-1&quot;&gt;exec user process caused &amp;quot;exec format error&amp;quot;&lt;/h3&gt;
&lt;p&gt;有人說在sh的頂端加上&lt;br /&gt;
#!/bin/bash&lt;br /&gt;
但我試了沒用，在猜想可能是alpine linux沒有bash導致&lt;br /&gt;
所以改用下面這個&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ENTRYPOINT [&amp;quot;sh&amp;quot;,&amp;quot;/run.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://stackoverflow.com/questions/42494853/standard-init-linux-go178-exec-user-process-caused-exec-format-error&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;standard_init_linux.go:178: exec user process caused “exec format error”&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;sh-debug&quot; tabindex=&quot;-1&quot;&gt;執行sh時卡住，debug方式&lt;/h3&gt;
&lt;p&gt;用if else檢查&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if mkdir /upload; then
    echo &amp;quot;mkdir directory! Success&amp;quot; 1&amp;gt;&amp;amp;2
    gcsfuse --key-file=key.json yellow-video /upload
else
    echo &amp;quot;Could not mkdir directory!&amp;quot; 1&amp;gt;&amp;amp;2
    exit 1
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，最後找出來原因是因為先執行go的程式，導致後續卡住，所以先建立資料夾後，再執行go&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://www.opencli.com/linux/shell-script-exit-on-error&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Shell Script 遇到錯誤時自動退出離開&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/docs/authentication/getting-started&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;身份驗證入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.itread01.com/content/1547223515.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux系統環境變數和別名設定（永久生效和臨時生效）&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/8.GCS使用方式/" />
        </entry>
        <entry>
            <title>
                79. gcloud compute instance 筆記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/79. gcloud compute instance 筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;因為公司政策，&lt;br /&gt;
要把label全部統一，之前有些已經命名過一次的但名稱不對，&lt;br /&gt;
一個一個改又好麻煩，&lt;br /&gt;
來寫command吧&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;指令演化順序&lt;/p&gt;
&lt;p&gt;Step 1.&lt;br /&gt;
先用指令撈出 GCE的全部列表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute instances --project=project list --format=&#39;table(name,status,labels.list())&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Step 2.&lt;/p&gt;
&lt;p&gt;找出label只有特定字元的列表&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute instances --project=project list --format=&#39;table(name,status,labels.list())&#39; | grep product=abc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/79-fig.1.jpg&quot; alt=&quot;79-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;問題來了，如果我只要取name出來，作爲變數的話，&lt;br /&gt;
要怎麼做？&lt;br /&gt;
我也一下子想不出來，就先跑去看一下gcloud文件了。&lt;/p&gt;
&lt;p&gt;Step 3.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute instances --project=project list --filter=&amp;quot;labels.product:abc&amp;quot; --format=&amp;quot;table(name)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改用 &lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/topic/filters&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;filter&lt;/a&gt;去篩選，這樣就能只顯示名稱了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/79-fig.2.jpg&quot; alt=&quot;79-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Step 4.&lt;br /&gt;
加上for迴圈，將label.product改成 zzz&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for name in $(gcloud compute instances --project=project list --filter=&amp;quot;labels.product:abc&amp;quot; --format=&amp;quot;table(name)&amp;quot;); do
  gcloud compute instances update &amp;quot;$name&amp;quot; --update-labels product=zzz
done 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;附註：&lt;/p&gt;
&lt;p&gt;刪除label的指令&lt;br /&gt;
product 為 key值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute instances update beta-api01 --remove-labels product
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/compute/docs/labeling-resources#gcloud&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用標籤整理資&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud command&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/79. gcloud compute instance 筆記/" />
        </entry>
        <entry>
            <title>
                5. Google Cloud Function限制
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/5. Google Cloud Function限制/</id>
            <content type="html">
                &lt;h2 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;這次要生一個ffmpeg的環境出來，然後找阿找阿，&lt;br /&gt;
找到一篇文章，上面寫&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Google將Cloud Functions作業系統升級到了Ubuntu 18.04 LTS，擴大了可用函式庫的範圍，除了Imagemagick一直都有外，還多了Ffmpeg和Libcairo2系統函式庫，連無頭Chrome也有，使用者不只可以在Cloud Functions中處理影片，甚至還能進行網頁截圖。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref &lt;a href=&quot;https://www.ithome.com.tw/news/125258&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Google事件驅動無伺服器平臺Cloud Functions正式上線了!&lt;/a&gt;&lt;br /&gt;
然後不用架機器，就來看看這條路行不行的通吧&lt;/p&gt;
&lt;h2 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;找了一陣子，先注意到的是GCF的限制&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;timeout 預設1分鐘，最長9分鐘&lt;/li&gt;
&lt;li&gt;單一function可用memory為2G，超過會中斷&lt;br /&gt;
這兩個是我認為比較重要的部分，其他細項，&lt;br /&gt;
可參考&lt;br /&gt;
&lt;a href=&quot;https://firebase.google.com/docs/functions/quotas?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;配額和限制&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://medium.com/%E5%AE%85%E7%94%B7%E9%9B%9C%E5%AD%B8%E7%AD%86%E8%A8%98/%E6%B7%BA%E8%AB%87serverless-solution-%E4%BB%A5gcp-cloud-function%E7%82%BA%E4%BE%8B-6374bf74df98&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;淺談Serverless Solution — 以GCP Cloud Function為例&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;結論，拿來做影片轉檔的話...應該是沒辦法了。除非這影片夠小。&lt;/p&gt;
&lt;p&gt;不然只寫api看來是挺快的&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/5. Google Cloud Function限制/" />
        </entry>
        <entry>
            <title>
                46.列出GCE的所有VM
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/46.列出GCE的所有VM/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;如果要查特定的欄位，可以先列出instances 的結構，&lt;br /&gt;
看一下要什麼樣的資料。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute instances describe gke-xxxxxx-test-n2-8-819a6098-3b3r --zone=asia-east1-b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後就能湊出下面的語法了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute instances list --format=&amp;quot;table(
name,
zone.basename(),
networkInterfaces[].ipv6AccessConfigs[0].externalIpv6.notnull().list():label=EXTERNAL_IPV6,
networkInterfaces[].subnetwork)&amp;quot; | sort -k 5 | grep -E &#39;gateway.*test&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最前面的語法，是要取出子網路的名稱，以便計算該子網路內有幾台VM，&lt;br /&gt;
然後排序、比對 名稱裡面有  gateway而且後面是 test的VM。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://www.opencli.com/linux/grep-or-and-operators&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;grep 指令使用 or 及 and 查兩個條件以上&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/compute/instances/describe&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud compute instances describe&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/compute/instances/list&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud compute instances list&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/46.列出GCE的所有VM/" />
        </entry>
        <entry>
            <title>
                46.GCE機器列表內的CPU個數
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/46.GCE機器列表內的CPU個數/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;要算一下各服務所佔的比例，&lt;br /&gt;
大方向用VM的機器 cpu來算&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;如果用gcloud compute list 能夠列出機器的類型，但裡面的cpu數量還是不知道。&lt;/p&gt;
&lt;p&gt;找了一下發現有人寫好一個shell script，拿來改一下能夠直接列出cpu數量&lt;br /&gt;
跟連結的內容相比，我這邊多加了一個狀態。&lt;br /&gt;
因為有些機器是不開機的，當有任務時，才會開機，故大部分時間都是關機狀態。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Get instance name,zone for `${PROJECT}
for PAIR in $(&#92;
  gcloud compute instances list &#92;
  --project=${PROJECT} &#92;
  --format=&amp;quot;csv[no-heading](name,zone.scope(zones),status)&amp;quot;)
do
  # Parse result from above into instance and zone vars
  IFS=, read INSTANCE ZONE STATUS &amp;lt;&amp;lt;&amp;lt; ${PAIR}
  # Get the machine type value only
  MACHINE_TYPE=$(&#92;
    gcloud compute instances describe ${INSTANCE} &#92;
    --project=${PROJECT} &#92;
    --zone=${ZONE} &#92;
    --format=&amp;quot;value(machineType.scope(machineTypes))&amp;quot;)
  # If it&#39;s custom-${vCPUs}-${RAM} we&#39;ve sufficient info
  if [[ ${MACHINE_TYPE} == custom* ]]
  then
    IFS=- read CUSTOM CPU MEM &amp;lt;&amp;lt;&amp;lt; ${MACHINE_TYPE}
    printf &amp;quot;%s: vCPUs: %s; Mem: %s; Status: %s&#92;n&amp;quot; ${INSTANCE} ${CPU} ${MEM} ${STATUS}
  else
    # Otherwise, we need to call `machine-types describe`
    CPU_MEMORY=$(&#92;
      gcloud compute machine-types describe ${MACHINE_TYPE} &#92;
      --project=${PROJECT} &#92;
      --zone=${ZONE} &#92;
      --format=&amp;quot;csv[no-heading](guestCpus,memoryMb)&amp;quot;)
    IFS=, read CPU MEM &amp;lt;&amp;lt;&amp;lt; ${CPU_MEMORY}
    printf &amp;quot;%s: vCPUs: %s; Mem: %s; Status: %s&#92;n&amp;quot; ${INSTANCE} ${CPU} ${MEM} ${STATUS}
  fi
done


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.  &lt;a href=&quot;https://stackoverflow.com/questions/65888736/gcloud-command-to-display-vcpus-and-memory-assigned-to-instances&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud command to display vCPU&#39;s and Memory assigned to Instances&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/46.GCE機器列表內的CPU個數/" />
        </entry>
        <entry>
            <title>
                19. GCE硬碟增加容量大小
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/19. GCE硬碟增加容量大小/</id>
            <content type="html">
                &lt;h2 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;之前有加大過GCE的CPU跟ram，但怎麼加硬碟空間還真的不知道。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;先到GCE，開啟機器。選擇開機磁碟（可在開機的狀態下運作）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/19.fig-1.jpg&quot; alt=&quot;19.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;按下編輯，修改硬碟大小，儲存。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/19.fig-2.jpg&quot; alt=&quot;19.fig-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;
&lt;p&gt;重新整理畫面，會看到硬碟空間容量變了。但還沒完成，需要到機器裡面重新調整大小。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;lsblk 列出可用設備&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lsblk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINT&lt;br /&gt;
sda      8:0    0  35G  0 disk&lt;br /&gt;
└─sda1   8:1    0  30G  0 part /&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NAME：這是塊設備名。&lt;/li&gt;
&lt;li&gt;MAJ:MIN：本欄顯示主要和次要設備號。&lt;/li&gt;
&lt;li&gt;RM：本欄顯示設備是否可移動設備。注意，在設備sdb和sr0的RM值等於1，這說明他們是可移動設備。&lt;/li&gt;
&lt;li&gt;SIZE：本欄列出設備的容量大小信息。例如35G表明該設備大小為35GB，而1K表明該設備大小為1KB。&lt;/li&gt;
&lt;li&gt;RO：該項表明設備是否為只讀。在本案例中，所有設備的RO值為0，表明他們不是只讀的。&lt;/li&gt;
&lt;li&gt;TYPE：本欄顯示塊設備是否是磁盤或磁盤上的一個分區。在本例中，sda和sdb是磁盤，而sr0是只讀存儲（rom）。&lt;/li&gt;
&lt;li&gt;MOUNTPOINT：本欄指出設備掛載的掛載點。&lt;br /&gt;
ref. &lt;a href=&quot;https://man.linuxde.net/lsblk&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;lsblk命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;growpart 將全部多餘的空間給指定的分割區&lt;br /&gt;
extend  a partition	in a partition table to	fill available space&lt;br /&gt;
ubuntu 安裝方式：&lt;br /&gt;
&lt;code&gt;apt -y install cloud-guest-growpart&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2024/08/15更新&lt;br /&gt;
&lt;code&gt;apt -y install cloud-guest-utils&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;CentOS 安裝方式：&lt;br /&gt;
&lt;code&gt;yum -y install cloud-utils-growpart&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  growpart /dev/sda 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊的dev/sda 指的是disk,故sda與 1 中間有空格&lt;br /&gt;
ref. &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=growpart&amp;amp;manpath=Debian+8.1.0&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;growpart&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;p.s 如果出現 錯誤&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FAILED: sfdisk not found
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;請使用sudo growpart /dev/sda 1 的方式執行&lt;br /&gt;
或 &lt;code&gt;apt install -y fdisk&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;resize2fs 調整系統大小&lt;pre&gt;&lt;code&gt;  resize2fs /dev/sda1
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這邊的dev/sda1 指的是part ,故sda與 1 中間沒有空格&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.itread01.com/content/1541634723.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux基礎命令---resize2fs&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;df 檢查分割區大小&lt;pre&gt;&lt;code&gt;df -h
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;http://genesic.blogspot.com/2018/01/gcp.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcp 增加硬碟容量&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.timelog.to/a159164305&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;不關機、不拔硬碟擴充VM root 磁碟區 - growpart&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://docs.aws.amazon.com/zh_tw/AWSEC2/latest/UserGuide/recognize-expanded-volume-linux.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;調整磁碟區大小後擴展 Linux 檔案系統&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.skywebster.com/resize-ext-and-xfs-root-partition-without-lvm/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux 擴展ext2/3/4 xfs root分割區不用LVM&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果使用resize2fs 碰到錯誤訊息&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;resize2fs 1.45.6 (20-Mar-2020)&lt;br /&gt;
resize2fs: Bad magic number in super-block while trying to open /dev/sda2&lt;br /&gt;
Couldn&#39;t find valid filesystem superblock.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;表示你使用的可能是xfs系統，來查一下&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	mount 	
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/19.fig-3.jpg&quot; alt=&quot;19.fig-3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以必須改用下面指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xfs_growfs /dev/sda2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://blog.90.vc/archives/164&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;# xfs檔案系統擴容報resize2fs: Bad magic number in super-block while trying to open /dev/centos/root Couldn’t find valid filesystem superblock&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/19. GCE硬碟增加容量大小/" />
        </entry>
        <entry>
            <title>
                181. cloudstorage無法使用cloudflare轉址
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/181. cloudstorage無法使用cloudflare轉址/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;線上的圖片是使用GCP的Load balancer連到Google cloud storage，&lt;br /&gt;
之前測試沒問題，但後來 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/186.%20istio%E7%9A%84Authorization%20policy(%E7%99%BD%E5%90%8D%E5%96%AE)/#cloudflare&quot;&gt;186. istio的Authorization policy(白名單)#cloudflare轉發&lt;/a&gt; ，&lt;br /&gt;
client到origin server 都使用ssl連線後，就掛了，&lt;br /&gt;
因為Load balancer當初沒有設定SSL的憑證，導致無法連線。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;到GCP的憑證管理器，新增憑證。&lt;br /&gt;
一開始是沒有啓用的，必須先啓用&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/181-fig.2.jpg&quot; alt=&quot;181-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/181-fig.1.jpg&quot; alt=&quot;181-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;建立新憑證，不支援萬用字元&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/181-fig.3.jpg&quot; alt=&quot;181-fig.3.jpg&quot; /&gt;&lt;br /&gt;
這邊注意，建立完後，&lt;br /&gt;
可能需要等一陣子(幾小時）才會好，&lt;br /&gt;
建立完後一定要到LB綁定，呈現有使用者的狀態。&lt;br /&gt;
當好的時候，會看到狀態為『有效』。&lt;/p&gt;
&lt;p&gt;此時，再到Load Balancer那邊設定憑證，開啓https的入口即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/181-fig.4.jpg&quot; alt=&quot;181-fig.4.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;前面步驟，參考 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/140.%20gcs%20%E6%8E%9B%E8%BC%89domain/&quot;&gt;140. gcs 掛載domain&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/181. cloudstorage無法使用cloudflare轉址/" />
        </entry>
        <entry>
            <title>
                17. Gcloud AttributeError module importlib has no attribute util
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/17. Gcloud AttributeError module importlib has no attribute util/</id>
            <content type="html">
                &lt;h2 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/16.dustise%20sleep%20%E6%B8%AC%E8%A9%A6%E5%B7%A5%E5%85%B7%E7%B0%A1%E4%BB%8B/&quot;&gt;16.dustise sleep 測試工具簡介&lt;/a&gt; 上一篇，有講到httpie這個套件，簡單使用，我就直接在mac上裝了。&lt;br /&gt;
然後，gcloud,kubectl就掛了...&lt;/p&gt;
&lt;h2 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;錯誤碼是這樣，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  AttributeError: module &#39;importlib&#39; has no attribute &#39;util&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;後來一查，發現是kubectl 跟 python 3.9 的問題&lt;a href=&quot;https://github.com/kubernetes/kubectl/issues/970&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;AttributeError: module &#39;importlib&#39; has no attribute &#39;util&#39; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#970&quot;&gt;#970&lt;/a&gt;&lt;/a&gt;&lt;br /&gt;
本來是想直接升級kubectl就好&lt;a href=&quot;https://kubernetes.io/zh/docs/tasks/tools/install-kubectl/#install-with-homebrew-on-macos&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;在 macOS 上使用 Homebrew 安裝&lt;/a&gt;，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  brew upgrade kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;雖然升級完成了，&lt;br /&gt;
但查詢版本&lt;br /&gt;
kubectl version --client&lt;br /&gt;
出來的版本仍是舊的。&lt;/p&gt;
&lt;p&gt;後來才想到，我的kubectl 好像是跟gcloud 一起裝的，試了一下，連gcloud也是同樣的錯誤。&lt;br /&gt;
那就來升級gcloud吧。但只要輸入 gcloud components update 也是出現同樣的錯誤，那要怎麼升級...&lt;br /&gt;
所以，根據&lt;a href=&quot;https://stackoverflow.com/questions/64010263/attributeerror-module-importlib-has-no-attribute-util&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;這篇&lt;/a&gt;  先在terminal上面輸入，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export CLOUDSDK_PYTHON=python2   # 先指定使用其他python版本
gcloud components update          # 更新gcloud
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/17. Gcloud AttributeError module importlib has no attribute util/" />
        </entry>
        <entry>
            <title>
                164.gcloud install by bash
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/164.gcloud install by bash/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;因爲『懶』，所以要來搞個一個sh就能安裝完所有東西。&lt;br /&gt;
但在install gcloud就踩坑了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.google.com/sdk/docs/install-sdk?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;官方文件&lt;/a&gt;，這邊提到正常的安裝方式，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./google-cloud-sdk/install.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但這個是建立在人要在電腦前面輸入Y，於是改成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./google-cloud-sdk/install.sh --command-completion=true --path-update=true --quiet
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這樣才會在.bashrc 增加執行的參數。&lt;/p&gt;
&lt;p&gt;一開始沒有想到是沒有增加 .bashrc的關係，&lt;br /&gt;
只有一直出現找不到gcloud的錯誤，&lt;br /&gt;
最後確認&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/163.Shell%E7%9A%84%E5%8D%80%E5%88%A5%E5%8F%8A%E6%9F%A5%E8%A9%A2/&quot;&gt;163.Shell的區別及查詢&lt;/a&gt;的關係後，&lt;br /&gt;
才釐清是.bashrc沒加，&lt;br /&gt;
於是利用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./google-cloud-sdk/install.sh --help
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查詢有哪些參數可供使用。&lt;/p&gt;
&lt;h2 id=&quot;shell-script&quot; tabindex=&quot;-1&quot;&gt;完整shell script&lt;/h2&gt;
&lt;p&gt;完整install.sh如下，需使用root執行，不然在安裝gcloud會出錯，&lt;br /&gt;
update-cert.sh是另一個shell script，是用gsutil拿來抓gcs的資料用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl -O https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-cli-443.0.0-linux-x86_64.tar.gz
tar -xf google-cloud-cli-443.0.0-linux-x86_64.tar.gz
./google-cloud-sdk/install.sh --command-completion=true --path-update=true --quiet
source ~/.bashrc

gcloud auth activate-service-account view-bucket@project.iam.gserviceaccount.com --key-file=view-bucket.json

SCRIPTPATH=$(dirname &amp;quot;$(readlink -f $0)&amp;quot;)
chmod u+x update-cert.sh

echo &amp;quot;30 1 * * 1 root /bin/bash ${SCRIPTPATH}/update-cert.sh&amp;quot; &amp;gt;&amp;gt; /etc/crontab
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/31037279/gcloud-command-not-found-while-installing-google-cloud-sdk&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud command not found - while installing Google Cloud SDK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sdk/docs/install-sdk&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;install Google Cloud CLI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://andy6804tw.github.io/2020/07/21/linux-shell-script/#%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%B3%95&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [Shell Script] 執行sh檔案提示Permission denied&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://linux.vbird.org/linux_basic/centos7/0430cron.php&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;第十五章、例行性工作排程(crontab)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/164.gcloud install by bash/" />
        </entry>
        <entry>
            <title>
                161. GKE利用pubsub通知訊息到discord
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/161. GKE利用pubsub通知訊息到discord/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;本來以爲不需要，但GKE有時就會幫你升級master的版本，&lt;br /&gt;
神不知鬼不覺，就算用靜態版本也是。&lt;br /&gt;
雖然是不會影響到線上服務，&lt;br /&gt;
但還是最好知道一下是什麼時候升級的。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pub/Sub建立一個主題&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/161-fig.1.jpg&quot; alt=&quot;161-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GKE的叢集設定開啓通知，並選擇剛剛建立的主題&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/161-fig.2.jpg&quot; alt=&quot;161-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立Cloud Function&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/161-fig.3.jpg&quot; alt=&quot;161-fig.3.jpg&quot; /&gt;&lt;br /&gt;
環境選『第二代』，函式名稱自己命名。&lt;br /&gt;
觸發條件，『允許未經驗證的叫用』，再選擇 ADD TRIGER裏面的『Pub/Sub trigger』&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/161-fig.4.jpg&quot; alt=&quot;161-fig.4.jpg&quot; /&gt;&lt;br /&gt;
選擇剛剛建立的Pub/Sub主題&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/161-fig.5.jpg&quot; alt=&quot;161-fig.5.jpg&quot; /&gt;&lt;br /&gt;
在連線的地方，可選擇僅允許內部流量即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立程式碼&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/161-fig.6.jpg&quot; alt=&quot;161-fig.6.jpg&quot; /&gt;&lt;br /&gt;
選擇Go 1.20 ，進入點改成 sendDiscord&lt;br /&gt;
原始碼到&lt;a href=&quot;https://github.com/daimom/pubsub_notify&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;pubsub notify&lt;/a&gt;複製 function.go的程式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測試&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/161-fig.7.jpg&quot; alt=&quot;161-fig.7.jpg&quot; /&gt;&lt;br /&gt;
觸發GKE的升級後，就會發送訊息到Discord上面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;相關資訊&quot; tabindex=&quot;-1&quot;&gt;相關資訊&lt;/h2&gt;
&lt;h3 id=&quot;pub-sub&quot; tabindex=&quot;-1&quot;&gt;Pub/Sub價格&lt;/h3&gt;
&lt;p&gt;在每個日曆月，結算帳號的 &lt;strong&gt;Message Delivery Basic&lt;/strong&gt; SKU 的前 10 GiB 吞吐量免費&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/pubsub/pricing?hl=zh-cn#pubsub-pricing&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Pub/Sub 價格&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;pub-sub-1&quot; tabindex=&quot;-1&quot;&gt;Pub/Sub架構&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/161-fig.8.jpg&quot; alt=&quot;161-fig.8.jpg&quot; /&gt;&lt;br /&gt;
ref. &lt;a href=&quot;https://cloud.google.com/pubsub/docs/overview?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;什麼是 Pub/Sub？&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;the-request-was-not-authenticated&quot; tabindex=&quot;-1&quot;&gt;The request was not authenticated.&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The request was not authenticated. Either allow unauthenticated invocations or set the proper Authorization header. Read more at &lt;a href=&quot;https://cloud.google.com/run/docs/securing/authenticating&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://cloud.google.com/run/docs/securing/authenticating&lt;/a&gt; Additional troubleshooting documentation can be found at: &lt;a href=&quot;https://cloud.google.com/run/docs/troubleshooting#unauthorized-client&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://cloud.google.com/run/docs/troubleshooting#unauthorized-client&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果沒在 第三步驟，選擇『允許未經驗證的叫用』，事後需改到cloud run修改安全性。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/161-fig.9.jpg&quot; alt=&quot;161-fig.9.jpg&quot; /&gt;&lt;br /&gt;
從cloud function的連結到cloud run&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/161-fig.10.jpg&quot; alt=&quot;161-fig.10.jpg&quot; /&gt;&lt;br /&gt;
到安全性，將驗證改成『允許未經驗證的叫用』。&lt;br /&gt;
如果你仍然想要用需要驗證，&lt;br /&gt;
可能需要研究下，目前只允許內部流量調用。&lt;/p&gt;
&lt;h3 id=&quot;message-published-data&quot; tabindex=&quot;-1&quot;&gt;MessagePublishedData&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.google.com/eventarc/docs/cloudevents?hl=zh-cn#pubsub_1&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;pub/sub 事件的組成部分&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &amp;quot;subscription&amp;quot;: &amp;quot;projects/test-project/subscriptions/my-subscription&amp;quot;,
  &amp;quot;message&amp;quot;: {
    &amp;quot;attributes&amp;quot;: {
      &amp;quot;attr1&amp;quot;:&amp;quot;attr1-value&amp;quot;
    },
    &amp;quot;data&amp;quot;: &amp;quot;dGVzdCBtZXNzYWdlIDM=&amp;quot;,
    &amp;quot;messageId&amp;quot;: &amp;quot;message-id&amp;quot;,
    &amp;quot;publishTime&amp;quot;:&amp;quot;2021-02-05T04:06:14.109Z&amp;quot;,
    &amp;quot;orderingKey&amp;quot;: &amp;quot;ordering-key&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/161. GKE利用pubsub通知訊息到discord/" />
        </entry>
        <entry>
            <title>
                142.gcs cors設定
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/142.gcs cors設定/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;架構從本來的 NFS全部轉到GCS上了，&lt;br /&gt;
所以cors也要跟着設定&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;將下面檔案，存成json&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;[
    {
      &amp;quot;origin&amp;quot;: [&amp;quot;https://tester.abc.com&amp;quot;],
      &amp;quot;method&amp;quot;: [&amp;quot;GET&amp;quot;,&amp;quot;PUT&amp;quot;,&amp;quot;POST&amp;quot;,&amp;quot;HEAD&amp;quot;,&amp;quot;DELETE&amp;quot;,&amp;quot;PATCH&amp;quot;],
      &amp;quot;responseHeader&amp;quot;: [&amp;quot;Content-Type&amp;quot;, &amp;quot;DNT&amp;quot;,&amp;quot;X-CustomHeader&amp;quot;,&amp;quot;X-LANG,Keep-Alive&amp;quot;,&amp;quot;User-Agent&amp;quot;,&amp;quot;X-Requested-With&amp;quot;,&amp;quot;If-Modified-Since,Cache-Control&amp;quot;,&amp;quot;X-Api-Key,X-Device-Id&amp;quot;,&amp;quot;Access-Control-Allow-Origin&amp;quot;],
      &amp;quot;maxAgeSeconds&amp;quot;: 3600
    }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行，收工。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gsutil cors set example_cors_file.json gs://example_bucket
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但要注意，這個不會馬上生效，感覺要等超過10分鐘以上。&lt;/p&gt;
&lt;p&gt;~~補充，origin不能用 * 的萬用符號，之前測了沒有效果 ，&lt;br /&gt;
未來會不會改不清楚。 ~~&lt;/p&gt;
&lt;p&gt;測試時，可以用* ，直接用 &lt;code&gt;origin:*&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看bucket有沒有設定cors則用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gsutil cors get gs://example_bucket
or
gcloud storage buckets describe gs://example_bucket --format=&amp;quot;default(cors_config)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/142-fig.1.jpg&quot; alt=&quot;142-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果要用gcloud/api，請看下面連結&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/storage/docs/using-cors?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;設定和查看 CORS 組態&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;cors&quot; tabindex=&quot;-1&quot;&gt;Cors的工作原理&lt;/h3&gt;
&lt;p&gt;當瀏覽器向 Cloud Storage 發出簡單請求時，會發生以下過程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;瀏覽器將 &lt;code&gt;Origin&lt;/code&gt; 標頭新增到請求中。&lt;code&gt;Origin&lt;/code&gt; 標頭包含相應資源（該資源在尋求共享 Cloud Storage 儲存桶的資源）的來源，例如 &lt;code&gt;Origin:https://www.example.appspot.com&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cloud Storage 將請求的 HTTP 方法以及 &lt;code&gt;Origin&lt;/code&gt; 標頭的值與目標儲存桶的 CORS 組態中的&lt;strong&gt;方法&lt;/strong&gt;和&lt;strong&gt;來源&lt;/strong&gt;資訊進行比較，以查看是否存在匹配項。如果存在匹配項，Cloud Storage 將在響應中包含 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 標頭。&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 標頭包含初始請求的 &lt;code&gt;Origin&lt;/code&gt; 標頭的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;瀏覽器接收響應並檢查 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 值是否與原始請求中指定的網域匹配。如果它們匹配，則請求成功。如果它們不匹配，或者響應中不存在 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 標頭，則請求失敗。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/142.gcs cors設定/" />
        </entry>
        <entry>
            <title>
                141. gcs自動刪除檔案
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/141. gcs自動刪除檔案/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;本篇的目標，測試用的bucket，每隔一段時間就刪除檔案。&lt;br /&gt;
或是轉到更便宜的bucket。&lt;br /&gt;
先說個概念，一個bucket裏面，他的檔案類型可以是不一樣的。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;上面那句話不懂的話，直接看圖吧。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/141-fig.1.jpg&quot; alt=&quot;141-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;由於每個儲存類型的價格不一樣，量大的話還是能省不少錢。&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/Price/126.%20GCP%20%E7%A1%AC%E7%A2%9F%E8%B2%BB%E7%94%A8%E6%AF%94%E8%BC%83/&quot;&gt;126. GCP 硬碟費用比較&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到bucket裏面選擇 『生命週期』-&amp;gt;新增規則&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/141-fig.2.jpg&quot; alt=&quot;141-fig.2.jpg&quot; /&gt;&lt;br /&gt;
動作看要選擇哪一種&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/141-fig.3.jpg&quot; alt=&quot;141-fig.3.jpg&quot; /&gt;&lt;br /&gt;
選擇條件&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/141-fig.4.jpg&quot; alt=&quot;141-fig.4.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;要注意的地方是，設定完不是馬上生效，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;對儲存桶生命週期組態的更改可能需要長達 24 小時才能生效，在此期間，對象生命週期管理可能仍會根據舊組態執行操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;設定完後，再來就是等待他執行了。&lt;/p&gt;
&lt;p&gt;另外，如果有多個規則的話，&lt;br /&gt;
目前GCP的優先順序為&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果多個規則同時滿足單個對象的條件，則 Cloud Storage 將基於以下考慮，僅執行與其中一個規則關聯的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Delete&lt;/code&gt; 操作優先於任何 &lt;code&gt;SetStorageClass&lt;/code&gt; 操作。&lt;/li&gt;
&lt;li&gt;將對象切換至&lt;a href=&quot;https://cloud.google.com/storage/pricing?hl=zh-cn#storage-pricing&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;靜態儲存價格&lt;/a&gt;最低的儲存類別的 &lt;code&gt;SetStorageClass&lt;/code&gt; 操作優先。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;p.s 如果你也跑去chtGPT提問的話，可能也會碰到我這個答案，但目前看起來GCS沒有標記這個東西了。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/141-fig.5.jpg&quot; alt=&quot;141-fig.5.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/storage/docs/lifecycle?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;對象生命週期管理&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/141. gcs自動刪除檔案/" />
        </entry>
        <entry>
            <title>
                140. gcs 掛載domain
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/140. gcs 掛載domain/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;這篇文章要完成得部分有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立LB，連結到GCS&lt;/li&gt;
&lt;li&gt;設定cloud Armor白名單&lt;/li&gt;
&lt;li&gt;Certificate Manager 增加 ssl憑證&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h2 id=&quot;建立負載平衡&quot; tabindex=&quot;-1&quot;&gt;建立負載平衡&lt;/h2&gt;
&lt;p&gt;建立負載平衡 -&amp;gt; HTTP(S) 負載平衡&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/140-fig.1.jpg&quot; alt=&quot;140-fig.1.jpg&quot; /&gt;&lt;br /&gt;
不能用區域的，因為區域的不支援後端值區&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/140-fig.2.jpg&quot; alt=&quot;140-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;h5 id=&quot;前端設定&quot; tabindex=&quot;-1&quot;&gt;前端設定&lt;/h5&gt;
&lt;p&gt;這邊建議最好就直接建立一個ip，不要用臨時的。&lt;br /&gt;
如果通訊協定要用https，需要設定憑證，所以這邊先選擇http就好&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/140-fig.3.jpg&quot; alt=&quot;140-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;h5 id=&quot;後端設定&quot; tabindex=&quot;-1&quot;&gt;後端設定&lt;/h5&gt;
&lt;p&gt;建立值區&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/140-fig.4.jpg&quot; alt=&quot;140-fig.4.jpg&quot; /&gt;&lt;br /&gt;
第一個箭頭，選擇你要建立的值區&lt;br /&gt;
第二個箭頭，看要不要建CDN&lt;br /&gt;
第三個箭頭，是設定白名單(cloud Armor)用的，這邊先不設定，等等第二部分會說&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/140-fig.5.jpg&quot; alt=&quot;140-fig.5.jpg&quot; /&gt;&lt;/p&gt;
&lt;h5 id=&quot;主機與路徑規則&quot; tabindex=&quot;-1&quot;&gt;主機與路徑規則&lt;/h5&gt;
&lt;p&gt;預設會直接進入bucket，這邊要注意，記得要將bucket 設定為公開。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/140-fig.6.jpg&quot; alt=&quot;140-fig.6.jpg&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;cloud-armor&quot; tabindex=&quot;-1&quot;&gt;設定cloud Armor&lt;/h2&gt;
&lt;p&gt;上一部份有說到設定白名單(cloud Armor)&lt;/p&gt;
&lt;p&gt;網路安全性-&amp;gt; Cloud Armor&lt;br /&gt;
這邊要增加的設定是 Edge 安全性政策，不是後端安全性政策，&lt;br /&gt;
因為只有edge安全性政策支援後端儲存分區&lt;br /&gt;
ref. &lt;a href=&quot;https://cloud.google.com/armor/docs/security-policy-overview?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;安全政策的類型&lt;/a&gt;。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/140-fig.8.jpg&quot; alt=&quot;140-fig.8.jpg&quot; /&gt;&lt;br /&gt;
新增的時候，選擇 Edge安全性政策，如果沒看到這個選項，&lt;br /&gt;
你可能已經進到政策裏面的規則了。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/140-fig.9.jpg&quot; alt=&quot;140-fig.9.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;建立完成後，可以從目標去新增要新增的對象，或是到負載平衡那邊做修改。&lt;/p&gt;
&lt;h5 id=&quot;cloud-armor-1&quot; tabindex=&quot;-1&quot;&gt;cloud armor 目標新增&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/140-fig.10.jpg&quot; alt=&quot;140-fig.10.jpg&quot; /&gt;&lt;br /&gt;
選擇『負載平衡器後端值區』，再選擇你的bucket&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/140-fig.11.jpg&quot; alt=&quot;140-fig.11.jpg&quot; /&gt;&lt;/p&gt;
&lt;h5 id=&quot;負載平衡器修改&quot; tabindex=&quot;-1&quot;&gt;負載平衡器修改&lt;/h5&gt;
&lt;p&gt;後端設定 -&amp;gt; 修改&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/140-fig.12.jpg&quot; alt=&quot;140-fig.12.jpg&quot; /&gt;&lt;br /&gt;
箭頭處選擇剛剛新增的 cloud armor規則&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/140-fig.13.jpg&quot; alt=&quot;140-fig.13.jpg&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;certificate-manager&quot; tabindex=&quot;-1&quot;&gt;Certificate Manager 新增憑證&lt;/h2&gt;
&lt;p&gt;ssl憑證，在GCP上面是可以直接幫你管理的。&lt;br /&gt;
雖然不支援 Wildcard SSL Certificate&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/140-fig.14.jpg&quot; alt=&quot;140-fig.14.jpg&quot; /&gt;&lt;br /&gt;
憑證分成自己管理與google代管，&lt;br /&gt;
自己管理，時間到就要自己上傳新的憑證。&lt;br /&gt;
google管理，不用管，時間到會自己展延，前提是你必須要有該domain。&lt;br /&gt;
選擇google代管的憑證，輸入要管理的domain&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/140-fig.15.jpg&quot; alt=&quot;140-fig.15.jpg&quot; /&gt;&lt;br /&gt;
儲存後，回到畫面應該會看到正在佈建中(PROVISIONING)，&lt;br /&gt;
這個需要一點時間，最久可能要到60 分&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/140-fig.16.jpg&quot; alt=&quot;140-fig.16.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然後到dns伺服器上面綁定domain跟ip了，&lt;br /&gt;
我是使用cloudflare，就不截圖了。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/load-balancing/docs/ssl-certificates/google-managed-certs?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 Google 管理的 SSL 證書&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;設定好了以後，回到負載平衡的前端設定&lt;br /&gt;
第一個箭頭，可以選擇跟上面一樣的ip（但你必須先幫他建立）&lt;br /&gt;
第二個箭頭，選擇剛剛新增的ssl憑證，記得一定要新增，&lt;br /&gt;
不然我卡了三個多小時還沒部署完。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/140-fig.17.jpg&quot; alt=&quot;140-fig.17.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/certificate-manager/docs/deploy?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;部署概覽&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;綜合設定&quot; tabindex=&quot;-1&quot;&gt;綜合設定&lt;/h2&gt;
&lt;p&gt;假設有一個情境是希望domain後面一定要有files才能看圖的話，&lt;br /&gt;
需要用到『進階型主機與路徑規則(第一個箭頭)』&lt;br /&gt;
第二個箭頭設定domain&lt;br /&gt;
第三個箭頭新增新的路徑規則&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/140-fig.7.jpg&quot; alt=&quot;140-fig.7.jpg&quot; /&gt;&lt;br /&gt;
路徑前置字串重新編寫，將/files轉成 / 訪問bucket&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/140-fig.18.jpg&quot; alt=&quot;140-fig.18.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;另外要注意，由於每個規則都有一條預設的條件，&lt;br /&gt;
『任何不相符合的項目』，這個可以選擇要不要導轉到其他網站。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/140. gcs 掛載domain/" />
        </entry>
        <entry>
            <title>
                135. gsutil整批複製
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/135. gsutil整批複製/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;幫後端改圖片上傳的架構，直接把GCE(Google Compute Engine)的機器改成用GCS（GoogleCloudStorage），所以要把GCE的圖搬到GCS。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;首先要用到的是 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/135.%20gsutil%E6%95%B4%E6%89%B9%E8%A4%87%E8%A3%BD/&quot;&gt;關閉ssh連線後，仍可執行程式&lt;/a&gt; ，不然用gcloud 連線時間過久是會被切斷連線的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;1&quot; tabindex=&quot;-1&quot;&gt;情境 1  整批資料夾&lt;/h3&gt;
&lt;p&gt;將nfs資料夾裏面的所有檔案/資料夾複製到bucket裏面，&lt;br /&gt;
-m 是多工，-r 是複製底下資料夾的檔案&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gsutil  -m rsync -r nfs gs://systemfile-stage/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/storage/docs/gsutil/commands/rsync&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gsutil rsync &lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2&quot; tabindex=&quot;-1&quot;&gt;情境2 ，複製特定資料夾&lt;/h3&gt;
&lt;p&gt;需要先建立一個文字檔，將資料夾名稱寫入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rsync.txt

20220201
20220301
20220310
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;while read p;
do
  folder=$(echo &amp;quot;$p&amp;quot;);
  gsutil rsync -r nfs/$p gs://systemfile-stage/$p/
done &amp;lt; rsync.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;3&quot; tabindex=&quot;-1&quot;&gt;情境3，複製特定圖片&lt;/h3&gt;
&lt;p&gt;這邊只能根據你的來源隨機應變了，&lt;br /&gt;
我的文件格式為&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keepfile.csv

&amp;quot;files/20230217/104abc69-e612-4b6c-abe4-52b91b79562f.jpg&amp;quot;,&amp;quot;17/2/2023 19:27:46.79&amp;quot;
&amp;quot;files/20230217/7a30d9eb-5e7c-4eb8-93c9-a72e5bd74f78.jpg&amp;quot;,&amp;quot;17/2/2023 19:28:47.56&amp;quot;
&amp;quot;files/20230217/ea81d738-ff0c-416a-b6d9-3520fda8f0ed.jpg&amp;quot;,&amp;quot;17/2/2023 19:32:47.44&amp;quot;
&amp;quot;files/20230217/7a7e1c75-4bec-4831-9a58-fa9650a82df1.jpg&amp;quot;,&amp;quot;17/2/2023 19:33:24.94&amp;quot;
&amp;quot;files/20230217/cf495ecb-71a9-4d46-95f4-b051f260523a.jpg&amp;quot;,&amp;quot;17/2/2023 19:33:49.4&amp;quot;
&amp;quot;files/20230217/eb05163b-bc0f-4e3b-96d5-82b0bb4f3a8d.jpg&amp;quot;,&amp;quot;17/2/2023 19:34:41.463&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以，要改讀csv的格式，然後將路徑與檔案名稱拆開，&lt;br /&gt;
最後才複製圖片過去。但這個過成真的久，&lt;br /&gt;
如果可以最好是用rsync複製資料夾吧。&lt;/p&gt;
&lt;p&gt;$file的變數，拆解出來有&amp;quot; ，所以又用了&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/133.%20shell%20script%E5%AD%97%E4%B8%B2%E8%99%95%E7%90%86/&quot;&gt;133. shell script字串處理&lt;/a&gt;的方式，將&amp;quot;刪除。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while IFS=&amp;quot;,&amp;quot; read -r path date
do
  folder=$(echo &amp;quot;$path&amp;quot; | awk -F &#39;/&#39; &#39;{print $2}&#39;);
  file=$(echo &amp;quot;$path&amp;quot; | awk -F &#39;/&#39; &#39;{print $3}&#39;);
  gsutil cp -n nfs/$folder/${file%*&#92;&amp;quot;} gs://systemfile-stage/$folder/
done &amp;lt; keepfile-sort.csv
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.baeldung.com/linux/csv-parsing&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to Parse a CSV File in Bash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/storage/docs/gsutil/commands/cp&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gsutil cp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/135. gsutil整批複製/" />
        </entry>
        <entry>
            <title>
                130. Google IAP ssh失敗
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/130. Google IAP ssh失敗/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;為什麼會發生，俺不知道。&lt;br /&gt;
但好像是好之前硬碟空間不夠，我砍了資料夾的關係...&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;先看個錯誤訊息&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/130-fig.1.jpg&quot; alt=&quot;130-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;權限授權失敗，一般使用ssh連線的話，大部分都是server的ssh key出問題&lt;br /&gt;
可以先參考&lt;a href=&quot;https://medium.com/%E4%B8%80%E5%80%8B%E5%B0%8F%E5%B0%8F%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E9%9A%A8%E6%89%8B%E7%AD%86%E8%A8%98/gcp-%E9%81%87%E5%88%B0permission-denied-publickey-%E6%80%8E%E9%BA%BC%E8%BE%A6-e41e26ebdf47&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [GCP]遇到permission denied (publickey)怎麼辦？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以我才回想起，之前我好像去砍過資料夾。&lt;br /&gt;
所以先弄ssh能夠直連GCE的機器，再來細看裏面的狀況。&lt;/p&gt;
&lt;h3 id=&quot;ssh&quot; tabindex=&quot;-1&quot;&gt;SSH解法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;建立ssh key&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -C &amp;quot;ezio&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊使用ezio當作名稱&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;複製 public key&lt;br /&gt;
將 &lt;code&gt;~/.ssh/id_rsa.pub&lt;/code&gt;的內容複製&lt;br /&gt;
有 .pub的是公鑰  ，沒有的是 私鑰&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;貼上公鑰&lt;br /&gt;
到GCE的VM執行個體內，將剛剛取得的公鑰貼到 『安全殼層金鑰』&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/130-fig.2.jpg&quot; alt=&quot;130-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接用ssh連線&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	ssh ezio@32.12.32.12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般到這邊就結束了，但今天的主題是用IAP無法登入。&lt;br /&gt;
更詳細的ssh 用法，請參考下列網址&lt;br /&gt;
ref.&lt;br /&gt;
- &lt;a href=&quot;https://dotblogs.com.tw/as15774/2018/04/30/174737&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;### [Git] 多個SSH Key與帳號的設定(Mac) &lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://xenby.com/b/220-%E6%95%99%E5%AD%B8-%E7%94%A2%E7%94%9Fssh-key%E4%B8%A6%E4%B8%94%E9%80%8F%E9%81%8Ekey%E9%80%B2%E8%A1%8C%E5%85%8D%E5%AF%86%E7%A2%BC%E7%99%BB%E5%85%A5&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [教學] 產生SSH Key並且透過KEY進行免密碼登入&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;iap&quot; tabindex=&quot;-1&quot;&gt;IAP解法&lt;/h3&gt;
&lt;p&gt;能連進去了，終於確定裏面沒有我之前的資料夾。&lt;br /&gt;
所以應該是這樣導致無法登入？&lt;/p&gt;
&lt;p&gt;然後查了一下目前的使用者帳號&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat /etc/passwd | awk -F: &#39;{print $1}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有我mail的使用者帳號，&lt;br /&gt;
然後刪除！！！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;userdel -r daimom
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再來試試，用IAP登入，看能不能在VM上面重建一個使用者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute ssh --tunnel-through-iap  --project sms --zone asia-east1-b test-service01
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;還是同樣的權限失敗。&lt;/p&gt;
&lt;p&gt;最後，在GCE的設定畫面，將本來的安全殼層金鑰刪掉，強迫重建，&lt;br /&gt;
終於能連了&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/130-fig.3.jpg&quot; alt=&quot;130-fig.3.jpg&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/130. Google IAP ssh失敗/" />
        </entry>
        <entry>
            <title>
                13.騰訊雲連接GOOGLE雲
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/13.騰訊雲連接GOOGLE雲/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;又在搞新的東西了，這次要把騰訊雲（TKE）跟Google雲（GCP），做VPN對連，&lt;br /&gt;
這次一樣又弄了幾天....最後還是找了GOOGLE工程師協助。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;下面的步驟，基本上都是TKE跟GCP，互相切換設定。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;騰訊雲設定網關IP&lt;br /&gt;
私有網路-&amp;gt; VPN連接-&amp;gt;VPN網關&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;!&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.github.io/404&quot;&gt;13.fig-1.jpg&lt;/a&gt;&lt;br /&gt;
內容就照想輸入的打，輸入完成後會看到公網IP，為了方便溝通，就稱呼他為TKE的閘道IP。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;GCP設定VPN閘道&lt;br /&gt;
這邊的選項比較繁瑣，因為騰訊雲不支援IKEv2，同時也不支援BGP的協定，&lt;br /&gt;
所以Google要使用傳統VPN。&lt;br /&gt;
高可用性的VPN有些要求才能使用，請參考&lt;a href=&quot;https://cloud.google.com/network-connectivity/docs/vpn/how-to/moving-to-ha-vpn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;轉為高可用性 VPN&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/13.fig-2.jpg&quot; alt=&quot;13.fig-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/13.fig-2.jpg&quot; alt=&quot;13.fig-2.jpg&quot; /&gt;&lt;br /&gt;
從Fig.3 有連結可以切到 傳統VPN設定，&lt;br /&gt;
再來終於要開始設定GCP閘道IP了。&lt;br /&gt;
建立IP，這邊建立的就是GCP的閘道ip，這組就是要與 TKE的閘道IP 對聯的IP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/13.%20fig-4.jpg&quot; alt=&quot;13. fig-4.jpg&quot; /&gt;&lt;br /&gt;
其他的選項，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名稱： 自填&lt;/li&gt;
&lt;li&gt;網路： VPN 要連結的 Compute Engine 網路&lt;/li&gt;
&lt;li&gt;區域： 連結至 Compute Engine 網路的閘道所在地區&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;GCP的通道設定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/13.%20fig-5.jpg&quot; alt=&quot;13. fig-5.jpg&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名稱： 隨意&lt;/li&gt;
&lt;li&gt;遠端對等互連IP： TKE的閘道IP&lt;/li&gt;
&lt;li&gt;IKE版本：這邊選 IKEv1&lt;/li&gt;
&lt;li&gt;IKE預先共用金鑰： 可以自行輸入 或是 由系統產生，但要注意騰訊雲不支援 特殊符號（. / 之類的），&lt;br /&gt;
所以要注意自行產生的金鑰&lt;/li&gt;
&lt;li&gt;導向選項： 這邊選擇 『依據政策』&lt;br /&gt;
遠端網路ip範圍：輸入TKE的私有網路範圍，可以從『騰訊雲的私有網路-&amp;gt;私有網路』 看到 IPv4 CIDR (Fig.6)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/13.%20fig-6.jpg&quot; alt=&quot;13. fig-6.jpg&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;gcp&quot; tabindex=&quot;-1&quot;&gt;GCP的防火牆設定&lt;/h3&gt;
&lt;p&gt;可能需要配置防火牆規則，不確定。&lt;br /&gt;
ref. &lt;a href=&quot;https://cloud.google.com/network-connectivity/docs/vpn/how-to/configuring-firewall-rules&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;配置防火牆規則&lt;/a&gt;&lt;br /&gt;
4. 騰訊雲的對端網關設定&lt;br /&gt;
私有網路-&amp;gt;VPN連接-&amp;gt;對端網關&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/13.%20fig-7.jpg&quot; alt=&quot;13. fig-7.jpg&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名稱： 隨意&lt;/li&gt;
&lt;li&gt;公網IP: 這邊就是輸入 GCP的閘道ip&lt;/li&gt;
&lt;li&gt;標籤： 可以不打&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;騰訊雲的VPN通道設定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/13.%20fig-8.jpg&quot; alt=&quot;13. fig-8.jpg&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通道名稱：隨意&lt;/li&gt;
&lt;li&gt;地域： 連結至網路的區域&lt;/li&gt;
&lt;li&gt;VPN網關類型： 私有網路。 雲聯網指的是 騰訊雲內部各區域的私有網路互聯(ref.&lt;a href=&quot;https://cloud.tencent.com/document/product/877/18675&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;雲聯網產品概述&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;私有網路：  請看(Fig.6)&lt;/li&gt;
&lt;li&gt;VPN網關：  請看(Fig.1)&lt;/li&gt;
&lt;li&gt;對端網關：  請看(Fig.7)&lt;/li&gt;
&lt;li&gt;預共享金鑰： 請看(Fig.5) 的預先共享金鑰&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;SPD策略&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/13.fig-9.jpg&quot; alt=&quot;13.fig-9.jpg&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本端網段： 請看(Fig.6)&lt;/li&gt;
&lt;li&gt;對端網段： 請看(Fig.4)的網段&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;IKE、IPsec配置&lt;br /&gt;
需與下圖一摸一樣。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/13.fig-10.jpg&quot; alt=&quot;13.fig-10.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/network-connectivity/docs/vpn/concepts/supported-ike-ciphers&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;支持的 IKE 加密方式&lt;/a&gt;，此文內(IKEv1 加密方式的第二階段，指的就是 IPsec配置）&lt;/p&gt;
&lt;h3 id=&quot;ike&quot; tabindex=&quot;-1&quot;&gt;IKE 配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;版本： IKEv1&lt;/li&gt;
&lt;li&gt;加密算法： AES-128&lt;/li&gt;
&lt;li&gt;認證算法： SHA1&lt;/li&gt;
&lt;li&gt;協商模式： main&lt;/li&gt;
&lt;li&gt;DH group: DH2&lt;/li&gt;
&lt;li&gt;IKE SA Lifetime： 36600&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;i-psec&quot; tabindex=&quot;-1&quot;&gt;IPsec 配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;加密算法：AES-128&lt;/li&gt;
&lt;li&gt;認證算法：SHA1&lt;/li&gt;
&lt;li&gt;PFS： DH-GROUP2&lt;/li&gt;
&lt;li&gt;IPsec sa Lifetime：10800&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;結尾（不，還有路由要設定）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/13.fig-11.jpg&quot; alt=&quot;13.fig-11.jpg&quot; /&gt;&lt;br /&gt;
這邊會先看到VPN的通道狀態是 已聯通， 但如果實際去Ping機器，會發現還是不通。&lt;/p&gt;
&lt;ol start=&quot;9&quot;&gt;
&lt;li&gt;騰訊雲路由表設定&lt;br /&gt;
私有網路-&amp;gt;路由表-&amp;gt;默認路由表&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/13.%20fig-12.jpg&quot; alt=&quot;13. fig-12.jpg&quot; /&gt;&lt;br /&gt;
新增路由策略(Fig.13)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/13.%20fig-13.jpg&quot; alt=&quot;13. fig-13.jpg&quot; /&gt;&lt;br /&gt;
新增路由(Fig.14)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新增路由：這邊是從騰訊雲要跳去GCP的網段，所以這邊要輸入的是（Fig.9)的對端網段&lt;/li&gt;
&lt;li&gt;下一跳類型：選擇VPN網關&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/13.%20fig-14.jpg&quot; alt=&quot;13. fig-14.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;10&quot;&gt;
&lt;li&gt;結論&lt;br /&gt;
可能有人會想，為什麼騰訊雲要設定路由，&lt;br /&gt;
而GCP不用設定路由。&lt;br /&gt;
因為在設定(Fig.5)的時候，就已經幫你設定好了。&lt;br /&gt;
但如果走的是 依據路徑，那這塊就必須要自行設定了。&lt;br /&gt;
如果想要看路由表，可以到&lt;br /&gt;
GCP-&amp;gt;VPC網路-&amp;gt;路徑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/13.fig-15.jpg&quot; alt=&quot;13.fig-15.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/network-connectivity/docs/vpn/how-to/creating-static-vpns&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用靜態路由創建傳統 VPN&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/network-connectivity/docs/vpn/concepts/choosing-networks-routing#route-alignment&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;網絡和隧道路由&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://bbs.huaweicloud.com/forum/thread-19167-1-1.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;【VPN錦囊】 騰訊雲對接華為雲配置指南&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://cloud.tencent.com/developer/article/1731806?s=original-sharing&amp;amp;sharedUid=7435714&amp;amp;from=10680&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;通過VPN連接到VPC&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.gtwang.org/linux/mtr-linux-network-diagnostic-tool/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;MTR：Linux 網路診斷工具使用教學&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/13.騰訊雲連接GOOGLE雲/" />
        </entry>
        <entry>
            <title>
                129. nginx 掛載gcs
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/129. nginx 掛載gcs/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;今天要上QA測試了，然後我突然發現我之前測完沒留下筆記。&lt;br /&gt;
現在都快忘光了，還好最後有找回記憶。&lt;br /&gt;
來補一下了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;今天要做的是把GCS變成一個圖片上傳空間，&lt;br /&gt;
可以用nginx來訪問。&lt;/p&gt;
&lt;div class=&quot;transclusion internal-embed is-loaded&quot;&gt;&lt;a class=&quot;markdown-embed-link&quot; href=&quot;https://daimom.github.io/gcp/8-gcs/&quot; aria-label=&quot;Open link&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;svg-icon lucide-link&quot;&gt;&lt;path d=&quot;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;div class=&quot;markdown-embed&quot;&gt;
&lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;某個案子，要整個翻掉重做，這次要讓VM的機器跟GKE的pod能夠同時存取一個儲存空間，&lt;br /&gt;
預計使用Google Cloud Storage，踩了一個早上的坑。&lt;/p&gt;
&lt;h1 id=&quot;正文-1&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;預計做兩個項目&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在VM上面掛載gcs的資料夾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在GKE 上面的pod同時掛載 gcs的資料夾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在VM上面掛載gcs的資料夾&lt;br /&gt;
安裝方式，目前我的vm是 RedHat 所以用下面的方式，CentOS也是用同樣的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Configure the gcsfuse repo:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo tee /etc/yum.repos.d/gcsfuse.repo &amp;gt; /dev/null &amp;lt;&amp;lt;EOF
[gcsfuse]
name=gcsfuse (packages.cloud.google.com)
baseurl=https://packages.cloud.google.com/yum/repos/gcsfuse-el7-x86_64
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg
       https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Install gcsfuse:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;  sudo yum install gcsfuse
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成，其他安裝方式，請參考&lt;a href=&quot;https://github.com/GoogleCloudPlatform/gcsfuse/blob/master/docs/installing.md&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GoogleCloudPlatform/gcsfuse/install.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;登入使用，&lt;br /&gt;
這邊先使用 gcloud auth login 做測試&lt;br /&gt;
先建立資料夾  mkdir upload&lt;br /&gt;
掛載  gcsfuse my-bucket upload&lt;br /&gt;
卸除掛載 fusermount -u upload&lt;/p&gt;
&lt;h3 id=&quot;debug&quot; tabindex=&quot;-1&quot;&gt;Debug用&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;gcsfuse --foreground --debug_gcs --debug_http --debug_fuse --debug_invariants --key-file=/home/user/Downloads/my-key.json mybucket /upload
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;google-application-credentials&quot; tabindex=&quot;-1&quot;&gt;永久加入GOOGLE_APPLICATION_CREDENTIALS變數&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;開啟 /etc/profiles
新增 export GOOGLE_APPLICATION_CREDENTIALS=&amp;quot;/home/user/Downloads/my-key.json&amp;quot;
修改檔案後要想馬上生效還要執行#
source /etc/profile不然只能在下次重進此使用者時生效。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://www.itread01.com/content/1547223515.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux系統環境變數和別名設定（永久生效和臨時生效）&lt;/a&gt;&lt;br /&gt;
附註，json檔案的取得在 IAM角色內的服務賬戶&lt;br /&gt;
ref.&lt;a href=&quot;https://cloud.google.com/iam/docs/creating-managing-service-account-keys&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;創建和管理服務帳號密鑰&lt;/a&gt;。&lt;br /&gt;
新增完GCS，記得把權限給服務賬戶。記得選擇完整權限（Fig. 1)&lt;/p&gt;
&lt;h3 id=&quot;自動掛載&quot; tabindex=&quot;-1&quot;&gt;自動掛載&lt;/h3&gt;
&lt;p&gt;有權限了已後，再來就是自動掛載了。&lt;br /&gt;
到/etc/fstab上，輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;my_bucket /home/ezio/upload gcsfuse key_file=key/key.json,rw,user,allow_other,uid=1008,gid=1009  0 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重開機測試看看，收工。&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://stackoverflow.com/questions/42638048/how-to-use-mount-command-in-fstab-file/42638136#42638136&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to use mount command in fstab file&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://serverfault.com/questions/1021950/gcsfuse-automount-on-a-non-root-user&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcsfuse automount on a non root user&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;查詢目前登入使用者的uid 跟 gid
id $(whoami)

如果要看全部使用者的話，
cat /etc/passwd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;a href=&quot;http://linux.vbird.org/linux_basic/0410accountmanager/0410accountmanager-centos5.php#account_id&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux 的帳號與群組&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;在GKE 上面的pod同時掛載 gcs的資料夾&lt;br /&gt;
基本的方式，&lt;br /&gt;
先自己產生一個 image&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;FROM golang:1.14-alpine AS build-env
ENV GO111MODULE on

# WORKDIR /工作名錄名稱 當前的工作目錄名稱，若是不存在則會新建該目錄，
# 需要注意的是copy跟run的指令都是以WORKDIR為當前目錄下去跑的，
# 運用的時候需要注意相對位置。
WORKDIR $GOPATH/src

RUN go get -u github.com/googlecloudplatform/gcsfuse

COPY key.json .


FROM alpine:3.6
RUN apk add --no-cache ca-certificates fuse &amp;amp;&amp;amp; rm -rf /tmp/*
COPY --from=build-env /go/bin/gcsfuse /usr/local/bin
COPY --from=build-env /go/src/key.json /
WORKDIR /
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;佈署 Deployment&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: gcs-fuse
    version: v1
  namespace: debug
  name: gcsfuse-test
spec:
  replicas: 1
  selector:
    matchLabels:
      app: gcs-fuse
      version: v1
  template:
    metadata:
      labels:
        app: gcs-fuse
        version: v1
    spec:
      containers:
        - name: gcsfuse-test
          image: gcr.io/your-project/gcsfuse:v1.2
          # image: golang:1.14-alpine
          # command: [ &amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;--&amp;quot; ]
          # args: [ &amp;quot;while true; do sleep 600; done;&amp;quot; ]
          securityContext:
            privileged: true
          command:
            - &amp;quot;/bin/sh&amp;quot;
            - &amp;quot;-c&amp;quot;
            - &amp;quot;while true; do mkdir /upload ; gcsfuse --key-file=key.json your-bucket /folder; sleep 600; done; &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果跟現有的程式整合的話，&lt;br /&gt;
由於要執行多行指令，需使用shellScript的方式執行指令。&lt;br /&gt;
可能會遇到下列情況&lt;/p&gt;
&lt;h3 id=&quot;and-quot-exec-and-quot-init-sh-and-quot-permission-denied&quot; tabindex=&quot;-1&quot;&gt;&amp;quot;exec: &amp;quot;/init.sh&amp;quot;: permission denied&lt;/h3&gt;
&lt;p&gt;在Dockerfile上修改權限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RUN chmod +x /init.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://stackoverflow.com/questions/44687685/getting-permission-denied-in-docker-run&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;getting permission denied in docker run&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;exec-user-process-caused-and-quot-exec-format-error-and-quot&quot; tabindex=&quot;-1&quot;&gt;exec user process caused &amp;quot;exec format error&amp;quot;&lt;/h3&gt;
&lt;p&gt;有人說在sh的頂端加上&lt;br /&gt;
#!/bin/bash&lt;br /&gt;
但我試了沒用，在猜想可能是alpine linux沒有bash導致&lt;br /&gt;
所以改用下面這個&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ENTRYPOINT [&amp;quot;sh&amp;quot;,&amp;quot;/run.sh&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://stackoverflow.com/questions/42494853/standard-init-linux-go178-exec-user-process-caused-exec-format-error&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;standard_init_linux.go:178: exec user process caused “exec format error”&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;sh-debug&quot; tabindex=&quot;-1&quot;&gt;執行sh時卡住，debug方式&lt;/h3&gt;
&lt;p&gt;用if else檢查&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if mkdir /upload; then
    echo &amp;quot;mkdir directory! Success&amp;quot; 1&amp;gt;&amp;amp;2
    gcsfuse --key-file=key.json yellow-video /upload
else
    echo &amp;quot;Could not mkdir directory!&amp;quot; 1&amp;gt;&amp;amp;2
    exit 1
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，最後找出來原因是因為先執行go的程式，導致後續卡住，所以先建立資料夾後，再執行go&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://www.opencli.com/linux/shell-script-exit-on-error&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Shell Script 遇到錯誤時自動退出離開&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/docs/authentication/getting-started&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;身份驗證入門&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.itread01.com/content/1547223515.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux系統環境變數和別名設定（永久生效和臨時生效）&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;
 這篇有講到如何在deploy掛載GCS
通常就是要安裝一些東西。
&lt;p&gt;會使用到gcsfuse這個指令，&lt;br /&gt;
所以我選擇直接建一個image，&lt;br /&gt;
然後掛載的時候直接用那個image就好。&lt;/p&gt;
&lt;p&gt;gcs-download.json 是 要掛載GCS用的權限json檔&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM nginx:latest
WORKDIR /app

COPY gcs-download.json .
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#Start&quot;&gt;#Start&lt;/a&gt; CloudStorage
RUN apt update &amp;amp;&amp;amp; apt install -y gnupg lsb-release
RUN echo &amp;quot;deb https://packages.cloud.google.com/apt gcsfuse-$(lsb_release -c -s) main&amp;quot; |  tee /etc/apt/sources.list.d/gcsfuse.list
RUN curl https://packages.cloud.google.com/apt/doc/apt-key.gpg |  apt-key add -
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y gcsfuse
ENV GOOGLE_APPLICATION_CREDENTIALS=/app/gcs-download.json

WORKDIR /usr/share/nginx/html/files


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後部署的yaml，&lt;br /&gt;
這邊要注意的地方是&lt;br /&gt;
1.&lt;br /&gt;
nginx.conf  要加上 user root  ，&lt;br /&gt;
這是因爲gcs掛載資料夾是用root的角色，所以如果nginx不用root啓動，&lt;br /&gt;
會出現403的權限問題。&lt;br /&gt;
ref.  &lt;a href=&quot;https://www.linuxprobe.com/nginx-403-forbidden.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;四種解決Nginx出現403 forbidden 報錯的方法&lt;/a&gt;&lt;br /&gt;
2.&lt;br /&gt;
daemon off;  這部分指的是要讓nginx能夠在前景執行，不然pod會一直重開。&lt;br /&gt;
ref.  &lt;a href=&quot;https://www.cnblogs.com/JulianHuang/p/15753732.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;nginx -g &amp;quot;daemon off;&amp;quot; 你學廢了嗎？&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: ConfigMap
metadata:
  name: systemfile-nginx-config
  namespace: default
data:
  nginx.conf: |
    user  root;
    worker_processes  auto;

    error_log  /var/log/nginx/error.log notice;
    pid        /var/run/nginx.pid;


    events {
        worker_connections  1024;
    }


    http {
        include       /etc/nginx/mime.types;
        default_type  application/octet-stream;

        log_format  main  &#39;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &#39;
                          &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39;
                          &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&#39;;

        access_log  /var/log/nginx/access.log  main;

        sendfile        on;
        &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#tcp_nopush&quot;&gt;#tcp_nopush&lt;/a&gt;     on;

        keepalive_timeout  65;

        &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#gzip&quot;&gt;#gzip&lt;/a&gt;  on;

        include /etc/nginx/conf.d/*.conf;
    }

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: sms-systemfile-config
  namespace: default
data:
  default.conf: |
    server {
        listen           80  default_server;
        server_name      _;
        server_tokens    off;

        index index.html;

        location /files {
            alias        /usr/share/nginx/html/files;
            autoindex    on;
        }

        location / {
            root         /usr/share/nginx/html;
            index        index.html;
        }

        error_page       500 502 503 504  /50x.html;
        location = /50x.html {
            root         /usr/share/nginx/html;
        }
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: systemmanageservice-systemfile
  namespace: default
  labels:
    group: systemmanageservice
    app: systemfile
spec:
  replicas: 1
  revisionHistoryLimit: 5
  progressDeadlineSeconds: 15
  selector:
    matchLabels:
      group: systemmanageservice
      app: systemfile
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    type: RollingUpdate
  template:
    metadata:
      labels:
        group: systemmanageservice
        app: systemfile
    spec:
      containers:
        - name: systemmanageservice-systemfile
          image: gcs-nginx:0.0.2
          command:
            - /bin/bash
            - &#39;-c&#39;
            - &amp;gt;-
              gcsfuse systemfile-qa /usr/share/nginx/html/files &amp;amp;&amp;amp; nginx -g
              &amp;quot;daemon off;&amp;quot;;
          imagePullPolicy: Always # IfNotPresent, Always, Never
          securityContext:
            privileged: true
          ports:
            - name: http
              containerPort: 80
              protocol: TCP
          resources: {}
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
          volumeMounts:
            - name: config-volume
              mountPath: /etc/nginx/conf.d/default.conf
              subPath: default.conf
              readOnly: true
            - name: nginx-config-volume
              mountPath: /etc/nginx/nginx.conf
              subPath: nginx.conf
              readOnly: true              
      volumes:
        - name: config-volume
          configMap:
            name: sms-systemfile-config
            items:
              - key: default.conf
                path: default.conf
            defaultMode: 420
        - name: nginx-config-volume
          configMap:
            name: systemfile-nginx-config
            items:
              - key: nginx.conf
                path: nginx.conf
            defaultMode: 420
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      terminationGracePeriodSeconds: 30
      schedulerName: default-scheduler
      securityContext: {}

&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/129. nginx 掛載gcs/" />
        </entry>
        <entry>
            <title>
                128. 解決 the gcp auth plugin is deprecated in v1.22+
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/128. 解決 the gcp auth plugin is deprecated in v1.22+/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;每次下kubectl的指令總會跳這個錯誤出來，&lt;br /&gt;
不處理也沒什麼事，但就是都會出現。&lt;br /&gt;
今天...就解決吧&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;警告訊息通常是這樣，&lt;br /&gt;
但你deploy的服務都還是會跑。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WARNING: the gcp auth plugin is deprecated in v1.22+, unavailable in v1.26+; use gcloud instead.&lt;br /&gt;
To learn more, consult &lt;a href=&quot;https://cloud.google.com/blog/products/containers-kubernetes/kubectl-auth-changes-in-gke&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://cloud.google.com/blog/products/containers-kubernetes/kubectl-auth-changes-in-gke&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這是由於docker在安裝的時候，會順便將kubectl安裝進去，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;where kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以得到 kubectl的執行檔位置&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/usr/local/bin/kubectl&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查詢kubectl的softlink 位置，會查到kubectl的命令是跟docker連結的。&lt;br /&gt;
附註, &lt;code&gt;ll 跟 ls -la 同意&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ls -la /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先將本來的softlink刪除，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rm /usr/local/bin/kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安裝gcloud版本的kubectl&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud components install kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;裝完後如果還不認識指令，&lt;br /&gt;
需要額外處理。&lt;/p&gt;
&lt;p&gt;先檢查一下gcloud有沒有安裝好kubectl，&lt;br /&gt;
如果path有路徑就代表正常，不然需要重新製作softlink&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud info | grep -i kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/128.fig-1.jpg&quot; alt=&quot;128.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;製作softlink&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ln /usr/local/Caskroom/google-cloud-sdk/latest/google-cloud-sdk/bin/kubectl /usr/local/bin/kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://blog.marsen.me/2022/06/08/2022/the_gcp_auth_plugin_is_deprecated/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[實作筆記] 錯誤處理 the gcp auth plugin is deprecated&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://stackoverflow.com/questions/51429553/how-to-set-path-to-kubectl-when-installed-using-gcloud-components-install&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to set path to kubectl when installed using gcloud components install?&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/128. 解決 the gcp auth plugin is deprecated in v1.22+/" />
        </entry>
        <entry>
            <title>
                127. fuse device not found, try &#39;modprobe fuse&#39; first
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/127. fuse device not found, try &#39;modprobe fuse&#39; first/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;以前用GKE掛載gcs的時候發生錯誤，fuse device not found, try &#39;modprobe fuse&#39; first。解決方法。&lt;br /&gt;
現在GKE有了新的掛載GCS方法了，&lt;a href=&quot;https://cloud.google.com/blog/products/containers-kubernetes/announcing-cloud-storage-fuse-and-gke-csi-driver-for-aiml-workloads&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Announcing Cloud Storage FUSE and GKE CSI driver for AI/ML workloads&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;目前我沒采用此方式，請他們改用api的方式上傳檔案了，&lt;br /&gt;
要訪問的話，用Load balancing 指向GCS bucket。&lt;br /&gt;
這文章用方法應該不太適用，&lt;br /&gt;
而且此方法有缺點，當你檔案數量太多時，會掛載不起來。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;
apt install -y gnupg lsb-release
export GCSFUSE_REPO=gcsfuse-`lsb_release -c -s`
export GCSFUSE_REPO=gcsfuse-buster
echo &amp;quot;deb https://packages.cloud.google.com/apt $GCSFUSE_REPO main&amp;quot; |  tee /etc/apt/sources.list.d/gcsfuse.list
curl https://packages.cloud.google.com/apt/doc/apt-key.gpg |  apt-key add -
apt-get update
apt-get install -y gcsfuse
export GOOGLE_APPLICATION_CREDENTIALS=/home/gcs-download.json
gcsfuse sms_backend_backup ./gcs-mount

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/127.fig-1.jpg&quot; alt=&quot;127.fig-1.jpg&quot; /&gt;&lt;br /&gt;
需要用特權模式&lt;br /&gt;
在yaml檔裏面，加上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    securityContext:
      privileged: true
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/127. fuse device not found, try &#39;modprobe fuse&#39; first/" />
        </entry>
        <entry>
            <title>
                121.cloudCDN設定
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/121.cloudCDN設定/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;之前測完後就忘了寫，&lt;br /&gt;
但今天有人問我才想起來，&lt;br /&gt;
我到底跑去哪設定的！？&lt;br /&gt;
現在趕緊補一下&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;如果已經在GCP上面建立好了負載平衡，&lt;br /&gt;
那就到後端設定，看要針對哪個服務去開啓cdn就好了。&lt;br /&gt;
上面有個逾時的設定，看要設定多少，&lt;br /&gt;
當初同事是有說他測30秒就會斷線一次，&lt;br /&gt;
所以我有把這邊拉長。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/121-fig.1.png&quot; alt=&quot;121-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;這邊設定完後，在cloudCDN上面就會多一個設定出來。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/121-fig.2.jpg&quot; alt=&quot;121-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;也能用指令去查，啓用cdn時的欄位&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get BackendConfig
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-features#timeout&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;cloudCDN&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/121.cloudCDN設定/" />
        </entry>
        <entry>
            <title>
                120. 指令備份cloudSQL及下載
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/120. 指令備份cloudSQL及下載/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;有人不習慣ui操作，&lt;br /&gt;
加上他們是兩三個月用一次，&lt;br /&gt;
那就生個指令給他們用吧。&lt;/p&gt;
&lt;p&gt;做成自動化應該也可以，&lt;br /&gt;
只是要看一下權限要用誰的。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;主要的兩行指令，請將視角往下移&lt;/p&gt;
&lt;ol 來源=&quot;&quot;&gt;
&lt;li&gt;
&lt;p&gt;test-db01: cloudSQL的instance名稱&lt;br /&gt;
gs://data/desk-22-12-14.bak ：要存放cloudStorage的位置&lt;br /&gt;
Desk : 資料庫名稱&lt;/p&gt;
&lt;/li&gt;
&lt;li 目的=&quot;&quot;&gt;
&lt;p&gt;gcloud storage cp &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;gcloud beta sql export bak test-db01 gs://data/desk-22-12-14.bak &#92;
--database=Desk

gcloud storage cp  gs://data/desk-22-12-14.bak /Users/daimom/Downloads
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;執行 gcloud storage cp ，出現error   invalid choice storage&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;更新 gcloud components&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;gcloud components update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://stackoverflow.com/questions/42916677/gcloud-beta-functions-command-says-invalid-choice-functions&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud beta functions command says &amp;quot;Invalid choice functions&amp;quot;&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;權限問題&lt;br /&gt;
cloudSQL 備份權限&lt;br /&gt;
Cloud SQL Editor 角色和 &lt;code&gt;storage.objectAdmin&lt;/code&gt; IAM 角色&lt;br /&gt;
cloudStorage下載權限&lt;br /&gt;
這部分就需要到cloudStorage的bucket設定了&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/sql/docs/sqlserver/import-export/import-export-bak#gcloud&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 BAK 檔案匯出和匯入&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/storage/docs/downloading-objects?hl=zh-cn#downloading-an-object&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;從儲存桶下載對象&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/120. 指令備份cloudSQL及下載/" />
        </entry>
        <entry>
            <title>
                109.GCS臨時下載權限
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/109.GCS臨時下載權限/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;今天維護，後端同仁要cloudSQL的備份檔，&lt;br /&gt;
然後，因為他們都沒權限，只好丟去網路空間，給他們抓。&lt;br /&gt;
我就在想，沒道理阿，應該有個方法能夠開特定的檔案臨時給人用。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;由於GCS的權限是 &lt;a href=&quot;https://cloud.google.com/storage/docs/uniform-bucket-level-access&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;統一儲存分區級存取權&lt;/a&gt;，&lt;br /&gt;
所以不能細分檔案權限給別人用。&lt;br /&gt;
所以，開&lt;a href=&quot;https://cloud.google.com/storage/docs/access-control/signing-urls-with-helpers?hl=zh-cn&amp;amp;skip_cache=true%22&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;V4簽名&lt;/a&gt;，就能給別人訪問了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; gsutil signurl -d 1m gcs-download.json gs://ai-assist-data/&amp;quot;Cloud_SQL_Export_warehouse_2022-10-12 (06:03:23)&amp;quot;.bak
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1m 表示，只開放一分鐘的時間&lt;br /&gt;
gcs-download.json是SA，從IAM那邊找到一個有權限下載的帳號產生的金鑰。&lt;br /&gt;
gs 的網址，可以到詳細資料內取得 gsutil URI&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/109-fig.1.jpg&quot; alt=&quot;☁︎ GCP/109-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;這個執行後，會得到一串&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%98%81%EF%B8%8E%20GCP/109-fig.2.jpg&quot; alt=&quot;☁︎ GCP/109-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;把後面的https複製，就能拿來用了。&lt;/p&gt;
&lt;h2 id=&quot;錯誤處理&quot; tabindex=&quot;-1&quot;&gt;錯誤處理&lt;/h2&gt;
&lt;p&gt;如果在執行signurl的時候發生以下錯誤，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;CommandException: The signurl command requires the pyopenssl library (try pip install pyopenssl or easy_install pyopenssl)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pip3 install pyopenssl
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;其他方式&quot; tabindex=&quot;-1&quot;&gt;其他方式&lt;/h2&gt;
&lt;p&gt;將底下的檔案跑遞迴(-R)，通通設成public-read&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gsutil -m acl set -R -a public-read gs://bucket
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/109.GCS臨時下載權限/" />
        </entry>
        <entry>
            <title>
                0.GCP MOC
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/☁︎ GCP/0.GCP MOC/</id>
            <content type="html">
                &lt;h1 id=&quot;雲架構中心&quot; tabindex=&quot;-1&quot;&gt;雲架構中心&lt;/h1&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/architecture?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;### 雲架構中心&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;price&quot; tabindex=&quot;-1&quot;&gt;Price&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/Price/GCP%E8%B2%BB%E7%94%A8/&quot;&gt;GCP費用&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/Price/GCP%20CPU%E7%94%A8%E9%80%94/&quot;&gt;GCP CPU用途&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/Price/180.%20GCP%20%E7%9B%A3%E6%8E%A7%E8%B2%BB%E7%94%A8/&quot;&gt;180. GCP 監控費用&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/Price/126.%20GCP%20%E7%A1%AC%E7%A2%9F%E8%B2%BB%E7%94%A8%E6%AF%94%E8%BC%83/&quot;&gt;126. GCP 硬碟費用比較&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;gcp&quot; tabindex=&quot;-1&quot;&gt;GCP&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/88.%E6%89%B9%E6%AC%A1%E4%BF%AE%E6%94%B9GCP%E7%9A%84label/&quot;&gt;88.批次修改GCP的label&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/5.%20Google%20Cloud%20Function%E9%99%90%E5%88%B6/&quot;&gt;5. Google Cloud Function限制&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/95.cloud%20build%E7%9A%84%E5%95%8F%E9%A1%8C/&quot;&gt;95.cloud build的問題&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/97.%20Anthos%20%E5%88%9D%E9%AB%94%E9%A9%97/&quot;&gt;97. Anthos 初體驗&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/120.%20%E6%8C%87%E4%BB%A4%E5%82%99%E4%BB%BDcloudSQL%E5%8F%8A%E4%B8%8B%E8%BC%89/&quot;&gt;120. 指令備份cloudSQL及下載&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/121.cloudCDN%E8%A8%AD%E5%AE%9A/&quot;&gt;121.cloudCDN設定&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/128.%20%E8%A7%A3%E6%B1%BA%20the%20gcp%20auth%20plugin%20is%20deprecated%20in%20v1.22+/&quot;&gt;128. 解決 the gcp auth plugin is deprecated in v1.22+&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/161.%20GKE%E5%88%A9%E7%94%A8pubsub%E9%80%9A%E7%9F%A5%E8%A8%8A%E6%81%AF%E5%88%B0discord/&quot;&gt;161. GKE利用pubsub通知訊息到discord&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/164.gcloud%20install%20by%20bash/&quot;&gt;164.gcloud install by bash&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/181.%20cloudstorage%E7%84%A1%E6%B3%95%E4%BD%BF%E7%94%A8cloudflare%E8%BD%89%E5%9D%80/&quot;&gt;181. cloudstorage無法使用cloudflare轉址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;gce&quot; tabindex=&quot;-1&quot;&gt;GCE&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/19.%20GCE%E7%A1%AC%E7%A2%9F%E5%A2%9E%E5%8A%A0%E5%AE%B9%E9%87%8F%E5%A4%A7%E5%B0%8F/&quot;&gt;GCE硬碟增加容量大小&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/46.%E5%88%97%E5%87%BAGCE%E7%9A%84%E6%89%80%E6%9C%89VM/&quot;&gt;46.列出GCE的所有VM&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/46.GCE%E6%A9%9F%E5%99%A8%E5%88%97%E8%A1%A8%E5%85%A7%E7%9A%84CPU%E5%80%8B%E6%95%B8/&quot;&gt;46.GCE機器列表內的CPU個數&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/79.%20gcloud%20compute%20instance%20%E7%AD%86%E8%A8%98/&quot;&gt;GCE指令&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/130.%20Google%20IAP%20ssh%E5%A4%B1%E6%95%97/&quot;&gt;130. Google IAP ssh失敗&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;gcs&quot; tabindex=&quot;-1&quot;&gt;GCS&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/8.GCS%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/&quot;&gt;GCS使用方式&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/109.GCS%E8%87%A8%E6%99%82%E4%B8%8B%E8%BC%89%E6%AC%8A%E9%99%90/&quot;&gt;109.GCS臨時下載權限&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/127.%20fuse%20device%20not%20found,%20try%20&#39;modprobe%20fuse&#39;%20first/&quot;&gt;127. fuse device not found, try &#39;modprobe fuse&#39; first&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/129.%20nginx%20%E6%8E%9B%E8%BC%89gcs/&quot;&gt;129. nginx 掛載gcs&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/135.%20gsutil%E6%95%B4%E6%89%B9%E8%A4%87%E8%A3%BD/&quot;&gt;135. gsutil整批複製&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/140.%20gcs%20%E6%8E%9B%E8%BC%89domain/&quot;&gt;140. gcs 掛載domain&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/141.%20gcs%E8%87%AA%E5%8B%95%E5%88%AA%E9%99%A4%E6%AA%94%E6%A1%88/&quot;&gt;141. gcs自動刪除檔案&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;netwrok&quot; tabindex=&quot;-1&quot;&gt;Netwrok&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/9.GCP%E7%B6%B2%E8%B7%AF%E5%B0%8D%E5%A4%96%E7%9A%84%E6%96%B9%E5%BC%8F/&quot;&gt;GCP網路對外的方式&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/13.%E9%A8%B0%E8%A8%8A%E9%9B%B2%E9%80%A3%E6%8E%A5GOOGLE%E9%9B%B2/&quot;&gt;13.騰訊雲連接GOOGLE雲&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/17.%20Gcloud%20AttributeError%20module%20importlib%20has%20no%20attribute%20util/&quot;&gt;17. Gcloud AttributeError module importlib has no attribute util&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/☁︎ GCP/0.GCP MOC/" />
        </entry>
        <entry>
            <title>
                78. drone k8s-runner 進階設定
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⏱ Drone/78. drone k8s-runner 進階設定/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;再上篇 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8F%B1%20Drone/72.%20drone%20on%20GKE%20%E5%BB%BA%E7%AB%8B/&quot;&gt;72. drone on GKE 建立&lt;/a&gt;，有談到k8s runner，&lt;br /&gt;
那時候都在default 的 namespace上面運作，&lt;br /&gt;
所以沒什麼問題，&lt;br /&gt;
但一到了正式環境，要切專門的namespace，&lt;br /&gt;
就陣亡拉)))))&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;這篇會講到兩個東西，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RBAC(Role-based Access Control)&lt;/li&gt;
&lt;li&gt;drone k8s-runner policy&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;step-1&quot; tabindex=&quot;-1&quot;&gt;Step 1.&lt;/h3&gt;
&lt;p&gt;先從Cloud RBAC開始說起，&lt;/p&gt;
&lt;p&gt;基本概念如下圖&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/78-fig.1.png&quot; alt=&quot;78-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: default
  name: drone
rules:
- apiGroups:
  - &amp;quot;&amp;quot;
  resources:
  - secrets
  verbs:
  - create
  - delete
- apiGroups:
  - &amp;quot;&amp;quot;
  resources:
  - pods
  - pods/log
  verbs:
  - get
  - create
  - delete
  - list
  - watch
  - update

---

kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: drone
  namespace: default
subjects:
- kind: ServiceAccount
  name: default
  namespace: default
roleRef:
  kind: Role
  name: drone
  apiGroup: rbac.authorization.k8s.io
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;role ： 設定權限能做什麼事&lt;br /&gt;
roleBinding ： 要將哪個角色綁定權限到sa帳號&lt;/p&gt;
&lt;p&gt;這邊簡單說明roleBinding （因rolebinding的roleRef 無法指定ns)，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;將 role, namespace 在 default 的 drone 跟&lt;br /&gt;
serviceAccount的 namespace在 default 的 default 綁在一起，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更細項的說明，請參考 (1)~(4)&lt;/p&gt;
&lt;p&gt;當服務沒有指定是哪一個 『serviceAccountName』，就會使用預設的default 。&lt;/p&gt;
&lt;p&gt;所以，如果將namespace通通改成drone的話，會發生什麼事？&lt;br /&gt;
會先在drone的畫面看到 skip&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/78-fig.3.jpg&quot; alt=&quot;78-fig.3.jpg&quot; /&gt;&lt;br /&gt;
然後查看 k8s-runner的 log，會看到沒有權限，被拒絕執行。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/78-fig.2.jpg&quot; alt=&quot;78-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;step-2&quot; tabindex=&quot;-1&quot;&gt;Step 2.&lt;/h3&gt;
&lt;p&gt;再來要解決權限問題，&lt;br /&gt;
因為k8s-runner，預設都是使用 default(namespace)的default再建立pod。&lt;/p&gt;
&lt;p&gt;所以，現在有兩種做法（這邊會講第二種做法）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;role的權限，給他能夠在不同的ns也能佈署的權限（這部分應該是建立clusterRole，沒試過）。&lt;/li&gt;
&lt;li&gt;k8s-runner在pipeline時，要求在指定的namespace做動作。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;建立一個 policy(5) 的 yml，&lt;br /&gt;
底下的關鍵欄位，有在碰k8s的應該都很熟，&lt;br /&gt;
match這塊要再測試看看，這邊就先註解掉。&lt;br /&gt;
（文件上是說 ，可以用來定義多個policy用，&lt;br /&gt;
當有符合時，就執行下面的policy）&lt;/p&gt;
&lt;p&gt;這邊設定規則是，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;佈署時，佈署到drone的namespace ，&lt;br /&gt;
資源請求是 512Mi,節點選擇的label 是 disktype: ssd&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;kind: policy
name: drone

# match:
#   repo:
#   - &amp;quot;octocat/*&amp;quot;
#   - &amp;quot;octocat/hello-world&amp;quot;

metadata:
  namespace: drone

resources:
  request:
    memory: 512MiB
  # limit:
  #   cpu: 4000
  #   memory: 1GiB

node_selector:
  disktype: ssd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再來要在runner裡面掛載這個檔案，直接用 configMap將檔案載入。&lt;/p&gt;
&lt;p&gt;建立configmap&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; kubectl create configmap -n drone drone-policy --from-file=policy.yml --dry-run=client -o yaml | kubectl apply -f -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;k8s-runner內掛載configmap&lt;br /&gt;
要特別注意env ，&lt;br /&gt;
DRONE_POLICY_FILE(6)，需要指定你的yml位置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name:  drone-runner-k8s
  namespace: drone
  labels:
    drone:  runner-k8s
spec:
  replicas: 1
  selector:
    matchLabels:
      drone:  runner-k8s
  template:
    metadata:
      labels:
        drone:  runner-k8s
    spec:
      containers:
      - name: runner
        image: drone/drone-runner-kube:latest
        ports:
        - containerPort: 3000
        volumeMounts:
        - mountPath: /policy.yml
          name: policy
          subPath: policy.yml
        env:
        - name: DRONE_POLICY_FILE
          value: /policy.yml        
      volumes:
      - configMap:
          defaultMode: 420
          name: drone-policy
        name: policy  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;附註，如果node_selector，選擇的節點是ssd的硬碟的話，&lt;br /&gt;
時間會減少 35%。 但每個月會多13塊美金。&lt;/p&gt;
&lt;p&gt;再來下篇應該就是寫將drone完整導入istio的做法了&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh/docs/reference/access-authn-authz/rbac/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 RBAC 鑑權&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.orchome.com/1308&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes權限管理之RBAC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10252766?sc=rss.iron&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Day-28 瞭解 Namespace 與 Rbac&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://godleon.github.io/blog/Kubernetes/k8s-How-to-access-resource-legally/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Kubernetes] 如何取得合法可用的權限，讓 pod 與 API server 溝通&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.drone.io/runner/kubernetes/configuration/policies/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Policies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.drone.io/runner/kubernetes/configuration/reference/drone-policy-file/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;DRONE_POLICY_FILE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jimmysong.io/kubernetes-handbook/guide/configure-pod-service-account.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;配置 Pod 的 Service Account&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.github.io/⏱ Drone/78. drone k8s-runner 進階設定/" />
        </entry>
        <entry>
            <title>
                77. drone build Open Source Edition
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⏱ Drone/77. drone build Open Source Edition/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;在某一天，drone就跳出來了 『Your license limit is exceeded。』&lt;br /&gt;
當下真是嚇死我了，當天又是維護日，&lt;br /&gt;
一堆程式要上版，自動佈署掛掉就完了，要通通手動上。&lt;br /&gt;
還好，沒事，只是跳個通知在那邊，查了一些文件，&lt;br /&gt;
都沒說到期了會怎樣，就這樣過了兩個月，&lt;br /&gt;
也都沒事發生，本來想繼續撐下去的，&lt;br /&gt;
但有其他東西要用，就順便一起動了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/77-fig.1.jpg&quot; alt=&quot;77-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;官方文件有寫到關於權限的部分，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Your license limit is exceeded ，這個是因為你build 超過了5000次，然後你又是直接抓官方版本的image才會出現這個通知。（OS：一開始測試當然直接抓官方的image來用阿...）&lt;/li&gt;
&lt;li&gt;基本上只要是年收入沒到 1 million（美金）的公司，都能免費使用，但要自己打包image。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他細項，可自行參考&lt;a href=&quot;https://docs.drone.io/enterprise/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;官方網站&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;build-image&quot; tabindex=&quot;-1&quot;&gt;Build image&lt;/h3&gt;
&lt;p&gt;我們可以先從官方的github看看，他們是怎麼編譯的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/harness/drone/blob/v2.9.1/.drone.yml&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;drone.yml&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先執行， &lt;a href=&quot;https://github.com/harness/drone/blob/v2.9.1/scripts/build.sh&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;scripts/build.sh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;再根據 &lt;a href=&quot;https://github.com/harness/drone/blob/v2.9.1/docker/Dockerfile.agent.linux.amd64&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;docker/Dockerfile.server.linux.amd64&lt;/a&gt; 的dockerfile去打包程式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面這段，直接存成dockerfile去編譯吧，&lt;br /&gt;
版本號自行更改。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;補充說明，&quot; tabindex=&quot;-1&quot;&gt;補充說明，&lt;/h4&gt;
&lt;p&gt;docker 在編譯的時候，&lt;br /&gt;
每一行指令 (前面有加 RUN 或COPY..的這種算一行），&lt;br /&gt;
都算是一個新的image，可以看到sha256的數值都不一樣，&lt;br /&gt;
所以用 cd drone 切 路徑的話，要再同一行把要執行的command，&lt;br /&gt;
都執行完。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM golang AS Builder

ENV DRONE_VERSION v2.9.1
WORKDIR $GOPATH/src
RUN git clone  https://github.com/drone/drone --branch ${DRONE_VERSION} --single-branch
RUN cd drone &amp;amp;&amp;amp; pwd  &amp;amp;&amp;amp; go mod download &amp;amp;&amp;amp; &#92;
   go build -ldflags &amp;quot;-extldflags &#92;&amp;quot;-static&#92;&amp;quot;&amp;quot; -tags=&amp;quot;nolimit&amp;quot; github.com/drone/drone/cmd/drone-server


FROM alpine:3.13 AS Certs

RUN apk add -U --no-cache ca-certificates

FROM alpine:3.13
EXPOSE 80 443
VOLUME /data

RUN [ ! -e /etc/nsswitch.conf ] &amp;amp;&amp;amp; echo &#39;hosts: files dns&#39; &amp;gt; /etc/nsswitch.conf

ENV GODEBUG netdns=go
ENV XDG_CACHE_HOME /data
ENV DRONE_DATABASE_DRIVER sqlite3
ENV DRONE_DATABASE_DATASOURCE /data/database.sqlite
ENV DRONE_RUNNER_OS=linux
ENV DRONE_RUNNER_ARCH=amd64
ENV DRONE_SERVER_PORT=:80
ENV DRONE_SERVER_HOST=localhost
ENV DRONE_DATADOG_ENABLED=true
ENV DRONE_DATADOG_ENDPOINT=https://stats.drone.ci/api/v1/series

COPY --from=Certs /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
COPY --from=Builder go/src/drone/drone-server /bin/drone-server

ENTRYPOINT [&amp;quot;/bin/drone-server&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本來想用go get 的方式，直接把程式build出來，&lt;br /&gt;
但一直卡在go 的&lt;a href=&quot;https://mileslin.github.io/2020/08/Golang/%E5%88%B0%E5%BA%95-go-get-%E7%9A%84%E7%89%88%E8%99%9F%E6%80%8E%E9%BA%BC%E9%81%8B%E4%BD%9C%E7%9A%84/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;版號限制&lt;/a&gt;，看了一些文章都說要改裡面的程式。&lt;br /&gt;
但這東西寫完，基本上就不會再動了。&lt;br /&gt;
只好用git clone把程式先抓下來，再build了。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1814669&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用容器方式編譯無功能限制的 Drone CI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://c.biancheng.net/view/123.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;go get命令——一鍵獲取代碼、編譯並安裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://willh.gitbook.io/build-web-application-with-golang-zhtw/01.0/01.3&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;go 命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⏱ Drone/77. drone build Open Source Edition/" />
        </entry>
        <entry>
            <title>
                72. drone on GKE 建立
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⏱ Drone/72. drone on GKE 建立/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;gitlab的安裝方式，參考 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/GKE/71.gitlab%20on%20GKE%20%E7%81%BD%E5%AE%B3%E9%82%84%E5%8E%9F%E7%AD%86%E8%A8%98/&quot;&gt;71.gitlab on GKE 災害還原筆記&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再來是安裝drone的方式，&lt;br /&gt;
這邊之前沒寫文件，重試的時候搞了一陣子。&lt;/p&gt;
&lt;p&gt;要先知道 runner分成哪幾種，根據你的環境選擇你要的方式。&lt;/p&gt;
&lt;p&gt;在drone畫面，基本上都差不多。&lt;br /&gt;
有差異的點是再建置時，就直接看圖吧&lt;/p&gt;
&lt;p&gt;Drone Runner分成五種，適用於不同的情境&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Docker runner :是drone最常見的用法，pineline中的每一個step都起一個獨立的container運行特定任務，本文即是採用docker runner。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在建置時，會在該runner裡面執行docker，所以當下只會看到runner裡面的cpu跟ram使用量上升。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kubernetes runner:跟docker runner 的功能相似，只是改成Kubernetes 版本，如果你的服務要搭建在k8s上，就用這個。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/72-fig.2.jpg&quot; alt=&quot;72-fig.2.jpg&quot; /&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/72-fig.3.jpg&quot; alt=&quot;72-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;選擇kubernetes的版本，再建置時會在當下的叢集建立一個pod，&lt;br /&gt;
然後就會在裡面執行要跑得步驟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exec runner:用於你的專案不適合跑在容器內的狀況EX:MacOs專案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSH runner:直接以ssh 連線到遠端以default shell 執行pipeline流程，需要使用openssh 7.9 以上版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Digital Ocean runner :用於當你的pipeline需要權限可以操作整台虛擬機的情況，且不適合跑在容器內。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;角色&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;用戶&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Gitlab&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Drone Server&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Drone 主服務，提供Web界面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Drone Runner&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;我理解為實現各種操作的適配器，例如ssh、docker、k8s操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Drone Agent&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;操作主機 Docker API 的代理程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Docker Server&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;主機的 Doker 程序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/72-fig.1.jpg&quot; alt=&quot;72-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;發佈到GKE，&lt;a href=&quot;https://github.com/nytimes/drone-gke/blob/main/DOCS.md#template&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;參數說明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;發佈到GCR，&lt;a href=&quot;https://daimom.github.io/%5Bhttp://plugins.drone.io/drone-plugins/drone-gcr/%5D(http://plugins.drone.io/drone-plugins/drone-gcr/)&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;參數說明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再來就是要佈署 drone server跟 runner了。&lt;/p&gt;
&lt;h3 id=&quot;step-1&quot; tabindex=&quot;-1&quot;&gt;Step 1.&lt;/h3&gt;
&lt;p&gt;首先要到Gitlab，建立oAuth的id 跟token。&lt;br /&gt;
切記是在user Setting的 Application，&lt;br /&gt;
因為Gitlab是我建的，所以我有另一個Admin的區域，&lt;br /&gt;
不是在Admin裡面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/72-fig.4.jpg&quot; alt=&quot;72-fig.4.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/72-fig.5.jpg&quot; alt=&quot;72-fig.5.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;網頁不要關， Application ID 跟 Secret等等會用到。&lt;/p&gt;
&lt;br /&gt;
&lt;h3 id=&quot;step-2-drone-server&quot; tabindex=&quot;-1&quot;&gt;Step 2. drone Server&lt;/h3&gt;
&lt;br /&gt;
&lt;p&gt;將一些參數改成自己的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;yaml欄位&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;對應的欄位&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DRONE_GITLAB_CLIENT_ID&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Application ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DRONE_GITLAB_CLIENT_SECRET&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Secret&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DRONE_SERVER_HOST&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Callback URL 的domain&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DRONE_RPC_SECRET&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;自行建立，runner的secret需一致&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: gke-drone-server
  labels:
    app: drone
    drone: drone-server
    io.kompose.service: drone-server
spec:
  selector:
    matchLabels:
      app: drone
      drone: drone-server
      io.kompose.service: drone-server
  template:
    metadata:
      labels:
            app: drone
            drone: drone-server
            io.kompose.service: drone-server
    spec:
      containers:
      - env:
        - name: DRONE_GITLAB_CLIENT_ID    # OAuth 的 Application ID
          value: 5b2f90188137bab7b1c6959721feb6e55f1137919e5b4b5ce005bd5e15af536a      
        - name: DRONE_GITLAB_CLIENT_SECRET    # OAuth 的 Secret
          value: 4cc261149603b3df864677f5af37b55613f6f4d20dd65fbb3e4f77f0cbca9e15
        - name: DRONE_GITLAB_SERVER       # Gitlab Server
          value: http://35.234.26.234
        - name: DRONE_GIT_ALWAYS_AUTH     # Drone clone 時，是否每次都驗證
          value: &amp;quot;false&amp;quot;
        - name: DRONE_LOGS_COLOR          # Log 啟用顏色辨識
          value: &amp;quot;true&amp;quot;
        - name: DRONE_LOGS_DEBUG          # 選擇是否開啟 debug 模式
          value: &amp;quot;false&amp;quot;
        - name: DRONE_LOGS_PRETY
          value: &amp;quot;false&amp;quot;
        # - name: DRONE_LOGS_TRACE          &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#開啟log追蹤&quot;&gt;#開啟log追蹤&lt;/a&gt;
        #   value: &amp;quot;true&amp;quot;
        - name: DRONE_RUNNER_CAPACITY     # 表示一次可執行 n 個 job
          value: &amp;quot;3&amp;quot;
        - name: DRONE_SERVER_HOST         # Drone URL,不能加HTTP，解析會在加上HTTP
          value: 14.199.130.26
        - name: DRONE_SERVER_PROTO        # http 或者 https 連線設定
          value: http
        - name: DRONE_TLS_AUTOCERT        # 自動生成 ssl 證書，並接受 https 連線，末認為false
          value: &amp;quot;false&amp;quot;
        - name: DRONE_REGISTRATION_CLOSED # 啟用的話，管理員需在用戶登入前創建用戶
          value: &amp;quot;false&amp;quot;
        - name: DRONE_USER_CREATE         # 建立admin權限的使用者  cli登入用
          value: username:ezio,admin:true
        - name: DRONE_USER_FILTER         # 可操作 Drone 的用戶清單
          value: root,ezio
        - name: DRONE_RPC_SECRET
          value: 824de51510f08498fa770c7798e3cc9e
        image: drone/drone:2
        imagePullPolicy: &amp;quot;Always&amp;quot;
        name: drone-server        
        ports:
        - containerPort: 80
        resources: {}
        volumeMounts:
        - mountPath: /data
          name: drone-server-claim0
      restartPolicy: Always
      serviceAccountName: &amp;quot;&amp;quot;
      volumes:
      - name: drone-server-claim0
        persistentVolumeClaim:
          claimName: gke-drone-server-claim0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要其他git的安裝方式請參考 1. 的官方文件&lt;br /&gt;
ref.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://readme.drone.io/server/provider/gitlab/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Drone Gitlab&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;step-3-a-drone-runner-docker-runner&quot; tabindex=&quot;-1&quot;&gt;Step 3-a.  drone Runner - Docker Runner&lt;/h3&gt;
&lt;br /&gt;
&lt;p&gt;注意 DRONE_RPC_SECRET需與server一致。&lt;br /&gt;
這邊會用到 docker.sock，也是因為這個的關係，&lt;br /&gt;
才導致這次重新測試。&lt;/p&gt;
&lt;p&gt;k8s即將廢棄 Dockershim，改用containerd，&lt;br /&gt;
詳細內容就不多說了，有興趣的可參考 (1) 、 (2)&lt;/p&gt;
&lt;p&gt;雖然我實測出來的結果，&lt;br /&gt;
在containerd的node是可以用的。&lt;br /&gt;
有在想是不是因為核心還是 /var/run/docker.sock 個關係，&lt;br /&gt;
但隨著後續研究 docker.sock (3)，發覺應該是不能用的才對...&lt;br /&gt;
但為什麼能用還是搞不懂。但(4)的官方論壇有說，他不擔心這個問題，&lt;br /&gt;
實際上還真的沒問題...&lt;/p&gt;
&lt;p&gt;補充，&lt;br /&gt;
最近把node的 containerd 版本升到 1.20 後，Docker Runner就真的不能用了。應該是早期還在用舊版的containerd，所以才能跑。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: agent
spec:
  selector:
    matchLabels:
      drone: drone-agent
  replicas: 1
  template:
    spec:
      containers:
      - env:
        - name: DRONE_LOGS_DEBUG
          value: &amp;quot;false&amp;quot;
        # - name: DRONE_LOGS_TRACE          &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#開啟log追蹤&quot;&gt;#開啟log追蹤&lt;/a&gt;
        #   value: &amp;quot;true&amp;quot;
        - name: DRONE_RPC_SECRET
          value: 824de51510f08498fa770c7798e3cc9e
        - name: DRONE_RPC_HOST
          value: 14.199.130.26
        - name: DRONE_RPC_PROTO
          value: &amp;quot;http&amp;quot;
        - name: DRONE_RUNNER_CAPACITY
          value: &amp;quot;3&amp;quot;
        image: drone/drone-runner-docker:1
        imagePullPolicy: &amp;quot;&amp;quot;
        name: drone-agent
        resources: {}
        volumeMounts:
        - mountPath: /var/run/docker.sock
          name: docker-socket
      restartPolicy: Always
      serviceAccountName: &amp;quot;&amp;quot;
      volumes:
      - name: docker-socket
        hostPath:
          path: /var/run/docker.sock
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
1. &lt;a href=&quot;https://kubernetes.io/zh/docs/tasks/administer-cluster/migrating-from-dockershim/check-if-dockershim-deprecation-affects-you/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;檢查棄用 Dockershim 對你的影響&lt;/a&gt;&lt;br /&gt;
2. &lt;a href=&quot;https://kubernetes.io/zh/blog/2020/12/02/dockershim-faq/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;棄用 Dockershim 的常見問題&lt;/a&gt;&lt;br /&gt;
3. &lt;a href=&quot;https://ephrain.net/docker-%E6%8E%9B%E8%BC%89-var-run-docker-sock-%E7%9A%84%E7%94%A8%E6%84%8F%EF%BC%9F/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Docker] 掛載 /var/run/docker.sock 的用意？&lt;/a&gt;&lt;br /&gt;
4. &lt;a href=&quot;https://discourse.drone.io/t/docker-plugin-dockershim-deprecation-kubernetes-1-20/8850&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Drone Disscus -  Docker plugin &amp;amp; dockershim deprecation // Kubernetes 1.20+&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;step-3-b-drone-runner-kubernete-runner&quot; tabindex=&quot;-1&quot;&gt;Step 3-b.  drone Runner - kubernete Runner&lt;/h3&gt;
&lt;br /&gt;
&lt;p&gt;注意 DRONE_RPC_SECRET需與server一致。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: default
  name: drone
rules:
- apiGroups:
  - &amp;quot;&amp;quot;
  resources:
  - secrets
  verbs:
  - create
  - delete
- apiGroups:
  - &amp;quot;&amp;quot;
  resources:
  - pods
  - pods/log
  verbs:
  - get
  - create
  - delete
  - list
  - watch
  - update

---

kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: drone
  namespace: default
subjects:
- kind: ServiceAccount
  name: default
  namespace: default
roleRef:
  kind: Role
  name: drone
  apiGroup: rbac.authorization.k8s.io

---


apiVersion: apps/v1
kind: Deployment
metadata:
  name:  gke-drone-agent

  labels:
    app: drone
    drone: drone-agent
    io.kompose.service: drone-agent
spec:
  replicas: 1
  selector:
    matchLabels:
      app: drone
      drone: drone-agent
      io.kompose.service: drone-agent
  template:
    metadata:
      annotations:
        sidecar.istio.io/inject: &amp;quot;true&amp;quot;
      labels:
        app: drone
        drone: drone-agent
        io.kompose.service: drone-agent
    spec:
      containers:
      - name: runner
        image: drone/drone-runner-kube:latest
        ports:
        - containerPort: 3000
        env:
        - name: DRONE_RPC_SECRET
          value: 824de51510f08498fa770c7798e3cc9e
        - name: DRONE_RPC_HOST
          value: 14.199.130.26
        - name: DRONE_RPC_PROTO
          value: &amp;quot;http&amp;quot;
        - name: DRONE_RUNNER_CAPACITY
          value: &amp;quot;3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://docs.drone.io/runner/kubernetes/installation/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;KUBERNETES Runner&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;問題排除&quot; tabindex=&quot;-1&quot;&gt;問題排除&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;首先碰到的問題是，drone沒有反應，先檢查webhook&lt;br /&gt;
到專案底下的webhook選項，查看錯誤的訊息&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/72-fig.6.jpg&quot; alt=&quot;72-fig.6.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/72-fig.7.jpg&quot; alt=&quot;72-fig.7.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因為GKE的防火牆沒開的關係，導致webhook資料丟不過去。&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;
2.  drone無法連線到gitlab&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/72-fig.8.jpg&quot; alt=&quot;72-fig.8.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;本來以為是防火牆的關係，但直接連進去pod裡面，呼叫這個網址是正常的。&lt;/p&gt;
&lt;p&gt;後來看到 (2) 的討論，我跟他們狀況一樣，應該也是istio造成的。&lt;br /&gt;
原以為是 drone server或 runner，有安裝istio的關係，&lt;br /&gt;
還特別寫了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;template:
  metadata:
    annotations:
      sidecar.istio.io/inject: &amp;quot;false&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;來阻止 istio的注入(3)。&lt;/p&gt;
&lt;p&gt;後來想了又想，才驚覺，我要取消的應該是整個namespace的istio注入，&lt;br /&gt;
因為當新的 pipeline建立時，就已經注入了istio的sidecar，&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/72-fig.2.jpg&quot; alt=&quot;72-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以要先讓這個namespace通通不能自動注入，&lt;br /&gt;
指定其他的deploy會自動注入。&lt;br /&gt;
自動注入的規則，請參考 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/73.%20istio%20sidecar%20%E6%B3%A8%E5%85%A5%E8%A6%8F%E5%89%87/&quot;&gt;73. istio sidecar 注入規則&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;
&lt;p&gt;切換namespace，無法佈署&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref.&lt;br /&gt;
1. &lt;a href=&quot;https://docs.gitlab.com/ee/user/project/integrations/webhooks.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Gitlab Webhooks&lt;/a&gt;&lt;br /&gt;
2. &lt;a href=&quot;https://discourse.drone.io/t/drone-ci-pipeline-first-step-clone-failed-connection-refused/7626&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Drone CI pipeline first step clone failed: Connection refused&lt;/a&gt;&lt;br /&gt;
3. &lt;a href=&quot;https://istio.io/latest/zh/docs/setup/additional-setup/sidecar-injection/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;安裝 Sidecar&lt;/a&gt;&lt;br /&gt;
4. &lt;a href=&quot;https://istio.io/latest/docs/reference/config/annotations/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;istio -Resource Annotations&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⏱ Drone/72. drone on GKE 建立/" />
        </entry>
        <entry>
            <title>
                3. 撰寫drone.yml 筆記篇(未)
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⏱ Drone/3. 撰寫drone.yml 筆記篇(未)/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;換工作後，開始接觸k8s、GCP、GKE，再來是Drone。&lt;br /&gt;
k8s中又延伸了kustomize ，ymal的寫法、佈署方式。&lt;br /&gt;
GCP中的cloud armor、GCE ，然後GKE的架構&lt;br /&gt;
真的是....滿滿的坑阿。以上講到的，還處於懞懂中，&lt;br /&gt;
筆記不知道何年何月何日可寫&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;簡單說一下環境，在GKE上面佈署 drone 跟 gitlab，&lt;br /&gt;
當gitlab有條件觸發的話(例如在push 在master上)，會同時送出一個webhook給drone，&lt;br /&gt;
此時drone就會去gitlab  pull程式碼下來，做你想要的動作（例如，打包成image，把image送到gcr上面，再佈署到GKE上）。&lt;/p&gt;
&lt;p&gt;先來份yaml，建議可以先看一下yaml是什麼東西，這樣寫起來比較不會撞牆。&lt;br /&gt;
(ref. &lt;a href=&quot;https://zh.wikipedia.org/wiki/YAML&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://zh.wikipedia.org/wiki/YAML&lt;/a&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kind: pipeline
name: Pipeline(branch)

steps:      
- name: push2GCR(前哨)
  image: plugins/gcr
  settings:
    repo: gcr.io/rd7-project/landingpage
    tags:
      - latest
      - ${DRONE_COMMIT}
    # dockerfile: configs/beta/Dockerfile
    json_key:
      from_secret: GOOGLE_CREDENTIALS
    build_args:
      - website=beta

- name: deploy2GKE(前哨)
  image: nytimes/drone-gke
  environment:
    TOKEN:
      from_secret: GOOGLE_CREDENTIALS
  settings:
    project: rd7-project
    # 改拉參數傳入kube.yml內
    # template: configs/beta/.kube.yml
    vars:
      deployName: yaboxxx-landing-page-beta
      env: beta
    zone: asia-east1-a
    cluster: xbb-common
trigger:   
  # branch:
  #   - master
  ref:
    include:
      - refs/heads/master
  event:
    - push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分成三小塊來看，&lt;br /&gt;
如果以 --- 區分的話，那&lt;br /&gt;
kind: pipeline&lt;br /&gt;
name: Pipeline(branch)&lt;br /&gt;
是必須的。&lt;/p&gt;
&lt;p&gt;再來是 steps ，&lt;br /&gt;
根據步驟游上往下執行，如果要并行的話，則使用depend_on ，&lt;br /&gt;
這部分留到下次講。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;trigger ，這是觸發條件，表示在gitlab上面做了哪些動作，會觸發這個step（步驟）&lt;br /&gt;
這邊的觸發事件，常用到應該是 Branch、Reference 以及 Event&lt;br /&gt;
(ref. &lt;a href=&quot;https://docs.drone.io/pipeline/docker/syntax/trigger/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://docs.drone.io/pipeline/docker/syntax/trigger/&lt;/a&gt;)&lt;br /&gt;
Branch 跟 Event 比較好理解（但碰到Tag的事件又是另一回事了） 。&lt;br /&gt;
Reference 這個其實只要在你的git裡面下指令&lt;br /&gt;
tree .git/refs/&lt;br /&gt;
大概就會知道他在講些什麼，git的底層都是靠refs去用出來的&lt;br /&gt;
(&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;http://iissnan.com/progit/html/zh-tw/ch9_3.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;http://iissnan.com/progit/html/zh-tw/ch9_3.html&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://titangene.github.io/article/git-branch-ref.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://titangene.github.io/article/git-branch-ref.html&lt;/a&gt;&lt;br /&gt;
)&lt;br /&gt;
但要注意的是，drone 1.X，以後的版本不支援event的tag 與 branch 共存。&lt;br /&gt;
可以參考這篇&lt;br /&gt;
(&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://github.com/drone/drone/issues/2536&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://github.com/drone/drone/issues/2536&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://rabbit52.com/2019/11/drone-from-0-8-to-1-0/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://rabbit52.com/2019/11/drone-from-0-8-to-1-0/&lt;/a&gt;&lt;br /&gt;
)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;steps:&lt;br /&gt;
這部分則開始由上往下開始執行，&lt;br /&gt;
像上面的程式先做的是將程式打包後，上傳到GCR上面。&lt;br /&gt;
（最上面還有一段clone，會先做（這是drone預設的），將gitlab的程式複製到機器內，這樣才能做後面的上傳，&lt;br /&gt;
這一塊可以 參考 &lt;a href=&quot;https://docs.drone.io/pipeline/docker/syntax/cloning/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://docs.drone.io/pipeline/docker/syntax/cloning/&lt;/a&gt;  ）&lt;br /&gt;
上傳到GCR使用的 plugins/gcr ，這個image，裡面的參數請參考&lt;a href=&quot;http://plugins.drone.io/drone-plugins/drone-gcr/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;說明頁面&lt;/a&gt;&lt;br /&gt;
由於這邊需要上傳到GCR，故要先到Google 的 服務賬戶申請權限 ，除了需要push以外還必須要有 storage.buckets.get&lt;br /&gt;
這邊會取得一個json檔案，將內容塞入drone內的Sercets。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/3.%20fig-1.jpg&quot; alt=&quot;3. fig-1.jpg&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⏱ Drone/3. 撰寫drone.yml 筆記篇(未)/" />
        </entry>
        <entry>
            <title>
                119. Drone  plugin-Drone-docker 修改原始檔
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⏱ Drone/119. Drone  plugin-Drone-docker 修改原始檔/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;之前發現一個後端執行drone會發生的問題，&lt;br /&gt;
偶爾發生，但一段時間總會發生一次。&lt;br /&gt;
多個step同時build，會造成image錯亂。&lt;br /&gt;
好麻煩阿....&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;先來看幾張圖，應該就能瞭解我再說什麼了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/119-fig.1.jpg&quot; alt=&quot;119-fig.1.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/119-fig.2.jpg&quot; alt=&quot;119-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;首先看到第一張圖，他在執行docker build的時候，會用git commit的值，當作image的tag名稱。&lt;/p&gt;
&lt;p&gt;然後看第二張圖，直到build完image後，才會再根據你的tag去將image改成你要的tags&lt;/p&gt;
&lt;p&gt;所以我們來想一個情境，當A、B同時執行時，他們的git commit都一樣，&lt;br /&gt;
A已經build完了，正要執行最後一個步驟，將git commit tag改成正常的image tag 。&lt;br /&gt;
此時B也剛build完，所以他也產生了一個一模一樣的 commit tag的image，那A執行最後一個步驟時，他改得到底是誰的image？&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如果一個接一個step跑的話，時間大概需要 4分半，&lt;br /&gt;
但同步的話，只要1分半，時間快了三倍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以還是要想辦法解掉，本來有想幾個解法，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一次把程式都build一遍，放在同一個image內，&lt;br /&gt;
執行時，再根據參數看要執行哪個檔案。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;但是他們有一種情境是只要更新其中一個功能就好，那此時全部build就不太適合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;在drone step時，塞tag進去，但他只會在最後一個步驟，才會改image的tag ，這招也不行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;改plugin/gcr 了，在第一步驟時就把image的tag改掉，不要使用git commit，那就解掉這個問題了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;動手&quot; tabindex=&quot;-1&quot;&gt;動手&lt;/h2&gt;
&lt;p&gt;首先找到這個image的原始碼 &lt;a href=&quot;https://github.com/drone-plugins/drone-docker&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;drone-plugins/drone-docker&lt;/a&gt;，然後開始改吧。&lt;/p&gt;
&lt;p&gt;各環境main.go的package import docker 要先改掉，不改掉我不確定他會不會抓本機的package，我golang初學沒多久。&lt;/p&gt;
&lt;p&gt;修改前&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;import (
	&amp;quot;os&amp;quot;
	&amp;quot;runtime&amp;quot;

	&amp;quot;github.com/joho/godotenv&amp;quot;
	&amp;quot;github.com/sirupsen/logrus&amp;quot;
	&amp;quot;github.com/urfave/cli&amp;quot;

	docker &amp;quot;github.com/drone-plugins/drone-docker&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改後&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;import (
	&amp;quot;os&amp;quot;
	&amp;quot;runtime&amp;quot;

	&amp;quot;github.com/joho/godotenv&amp;quot;
	&amp;quot;github.com/sirupsen/logrus&amp;quot;
	&amp;quot;github.com/urfave/cli&amp;quot;

	docker &amp;quot;drone-docker&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後我在docker.go上面直接加了兩行，指定了tag，這不適合所有人，&lt;br /&gt;
因為你們的使用情境可能跟我不太一樣，我這邊是只要push到git後，drone會自動產生tag，所以如果不指定的話，我還是有tag的值可以取得。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;tag := build.Repo + &amp;quot;:&amp;quot; + build.Tags[0]

args := []string{
&amp;quot;build&amp;quot;,
&amp;quot;--rm=true&amp;quot;,
&amp;quot;-f&amp;quot;, build.Dockerfile,
&amp;quot;-t&amp;quot;, build.Name,
&amp;quot;-t&amp;quot;, tag,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，如果要知道plugin/gcr裏面有什麼環境變數可以拿來用的話，&lt;br /&gt;
可以在drone的step上面，執行export -p&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: publish-dev
  image: plugins/gcr
  pull: if-not-exists
  volumes:
    - name: docker
      path: /var/run/docker.sock   
  commands: 
    - export -p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行結果：&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/119-fig.3.jpg&quot; alt=&quot;119-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;改完後，執行下面的指令先產生go 的程式。&lt;br /&gt;
這個go的指令，我是從.drone.yaml抄出來的。&lt;br /&gt;
執行前記得先設定環境變數&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;export GOOS=linux
export GOARCH=amd64
export CGO_ENABLED=0
export GO111MODULE=on
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;go-build&quot; tabindex=&quot;-1&quot;&gt;Go build&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;go build -v -ldflags &amp;quot;-X main.version=${DRONE_COMMIT_SHA:0:8}&amp;quot; -a -tags netgo -o release/linux/amd64/drone-docker ./cmd/drone-docker
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-go&quot;&gt;go build -v -ldflags &amp;quot;-X main.version=${DRONE_COMMIT_SHA:0:8}&amp;quot; -a -tags netgo -o release/linux/amd64/drone-gcr ./cmd/drone-gcr
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;docker-build&quot; tabindex=&quot;-1&quot;&gt;Docker build&lt;/h3&gt;
&lt;p&gt;將go的執行檔打包進去docker image內，&lt;br /&gt;
先打包到本機的docker:linux-amd64，&lt;br /&gt;
因為docker-gcr的dockerfile會去抓docker:linux-amd64 當作image的基底再產生檔案&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker build &#92;
  --label org.label-schema.build-date=$(date -u +&amp;quot;%Y-%m-%dT%H:%M:%SZ&amp;quot;) &#92;
  --label org.label-schema.vcs-ref=$(git rev-parse --short HEAD) &#92;
  --file docker/docker/Dockerfile.linux.amd64 --tag plugins/docker:linux-amd64 .
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker build &#92;
  --label org.label-schema.build-date=$(date -u +&amp;quot;%Y-%m-%dT%H:%M:%SZ&amp;quot;) &#92;
  --label org.label-schema.vcs-ref=$(git rev-parse --short HEAD) &#92;
  --file docker/gcr/Dockerfile.linux.amd64 --tag asia-east1-docker.pkg.dev/rouge-sms/docker-public/gcr:0.0.13 .
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;完成&quot; tabindex=&quot;-1&quot;&gt;完成&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/119-fig.4.jpg&quot; alt=&quot;119-fig.4.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;上圖可以看到，在docker build時，會同時下兩個tag，&lt;br /&gt;
一個還是維持git commit的值，但另一個就是拿repository加版本號當作tag。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://discourse.drone.io/t/drone-step-name-not-available-as-substitution-in-environment/8389&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;DRONE_STEP_NAME not available as substitution in environment&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;查資料時剛好有碰到這個問題，drone_step_name一直抓不到，原因再文章內。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/drone-plugins/drone-docker/compare/f9d0b60cb05ff9e37787651be4c54bfff2fe9a08..d41b50e5aa5ec4baf57f94448c1e7ce6c8f6282a&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; 修復在多模組java項目中，平行打包鏡像時，鏡像因為同名稱被覆蓋的問題&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;昨天才看到有人發了個PR修復同名稱的問題，感覺跟我的頗像，但實際看了，覺得不太適合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⏱ Drone/119. Drone  plugin-Drone-docker 修改原始檔/" />
        </entry>
        <entry>
            <title>
                109. drone jsonnet 各種怪招
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⏱ Drone/109. drone jsonnet 各種怪招/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;本文章內容包含許多寫drone jsonnet會碰到的寫法。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在pipeline下comand的時候，有時會碰到多行指令湊在一起的情況，&lt;br /&gt;
在drone.yaml是直接這樣寫&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/109-fig.1.jpg&quot; alt=&quot;⏱ Drone/109-fig.1.jpg&quot; /&gt;&lt;br /&gt;
但如果要用jsonnet的話，要用&lt;code&gt;&#92;n&lt;/code&gt;換行，&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/109-fig.2.jpg&quot; alt=&quot;⏱ Drone/109-fig.2.jpg&quot; /&gt;&lt;br /&gt;
轉換後就會變成下圖&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/109-fig.3.jpg&quot; alt=&quot;109-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在執行command的時候，因為要先用&lt;code&gt;&amp;quot;&lt;/code&gt; 將指令包起來，如果裏面還要有&lt;code&gt;&amp;quot;&lt;/code&gt; 的話，必須在前面加上 &lt;code&gt;&#92;&lt;/code&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/109-fig.4.jpg&quot; alt=&quot;109-fig.4.jpg&quot; /&gt;&lt;br /&gt;
執行&lt;code&gt;drone jsonnet --stream --format&lt;/code&gt;後&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/109-fig.5.jpg&quot; alt=&quot;109-fig.5.jpg&quot; /&gt;&lt;br /&gt;
這是因爲 linux shell裏面，單引號跟雙引號的差別，詳細可看&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/133.%20shell%20script%E5%AD%97%E4%B8%B2%E8%99%95%E7%90%86/&quot;&gt;shell script 雙引號與單引號&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果碰到很長的一串指令，例如if else之類的，改使用  @&#39;&#39; 將程式包起來。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;@&#39;
if [ -z $${TAG_FROM} ]

then

echo &amp;quot;錯誤：無來源TAG。&amp;quot;;

exit 1

fi&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;如果字串過長，想要換行的話， 可在雙引號內 使用 兩個&#92; &lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/109-fig.6.jpg&quot; alt=&quot;109-fig.6.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;用curl時，有些參數要用&amp;quot; ，所以在單引號使用 &amp;quot; &amp;quot; 固定參數，要先用 @ &#39;&#39; 包起來&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;  @&#39;OAUTH2_TOKEN=$(curl -XGET $${TOTP_AUTH_URL} &#92;&#92;
       -H &amp;quot;accept: application/json&amp;quot; &#92;&#92;
       -H &amp;quot;TOTP-PIN-CODE: $${pin}&amp;quot; &#92;&#92;
       -H &amp;quot;TOTP-USER: $${user}&amp;quot;)&#39;, 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://book.king011.com/view/en-US/view/google-jsonnet/tutorial&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; jsonnet教學 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jsonnet.org/learning/tutorial.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;jsonnet 官方說明 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jsonnet.org/ref/stdlib.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; Standard Library&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⏱ Drone/109. drone jsonnet 各種怪招/" />
        </entry>
        <entry>
            <title>
                10.drone 使用 騰訊雲 K8S及 容器鏡像服務
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⏱ Drone/10.drone 使用 騰訊雲 K8S及 容器鏡像服務/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;科技始終來自於人性，現在要讓自動佈署可以支援到騰訊雲&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;1.發佈image到騰訊雲的容器鏡像服務&lt;/p&gt;
&lt;p&gt;直接先給 drone.yml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: push2TCR  
  image: plugins/docker
  settings:
    username:
      from_secret: TCR_user
    password:
      from_secret: TCR_PW
    build_args:
      - website=qa
      - location=tke  
    repo: tcr.tencentcloudcr.com/project/abc
    registry: tcr.tencentcloudcr.com
    tags:
    - latest
    - ${DRONE_COMMIT}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊使用的docker image 請參考 &lt;a href=&quot;http://plugins.drone.io/drone-plugins/drone-docker/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Docker&lt;/a&gt;&lt;br /&gt;
要注意的地方在，如果直接把username跟 password 打在上面的話，&lt;br /&gt;
會發生驗證失敗。&lt;br /&gt;
需要將帳號密碼放到drone裡面的 Secrets，&lt;br /&gt;
一開始也可以使用 command 直接看有沒有成功登入。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: push2TCR  
  image: plugins/docker
  commands:
    - docker login tcr.tencentcloudcr.com --username 123456789 --password token
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，當初在設定的時候，有限定ip才能連線，這部分記得要打開&lt;br /&gt;
，如果沒有就不用在意了。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/10.fig-1.jpg&quot; alt=&quot;10.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;2.佈署到騰訊雲&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kind: pipeline
name: TKEPipeline(QA)

platform:
  os: linux
  arch: amd64

steps:

- name: deploy2TKE-QA
  image: danielgormly/drone-plugin-kube:0.0.2
  settings:
    template: tke.yml
    server: https://loud.com
    ca:
      from_secret: TKE_CA
    token:
      from_secret:  TKE_TOKEN
    namespace: demo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;server 跟  ca token，需看騰訊雲集群上的設定&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/10.fig-2.jpg&quot; alt=&quot;10.fig-2.jpg&quot; /&gt;&lt;br /&gt;
這個image不像GKE一樣有參數可以丟進去，只有固定的幾個參數&lt;br /&gt;
ref. &lt;a href=&quot;https://github.com/danielgormly/drone-plugin-kube&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;danielgormly/drone-plugin-kube&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所幸這個有放在github上，還能夠根據自己的需求更改內容，增加參數。&lt;br /&gt;
重新編譯後，如果不是上傳到公開的Container Registry ，而是傳到私有的CR就必須加上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;image_pull_secrets:
- TKE_LOGIN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這個與image 同樣的層級，不然會導致pull image失敗&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8F%B1%20Drone/10.fig-3.jpg&quot; alt=&quot;10.fig-3.jpg&quot; /&gt;&lt;br /&gt;
ref.&lt;a href=&quot;https://discourse.drone.io/t/how-to-pull-private-images-with-1-0/3155&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to pull private images with 1.0&lt;/a&gt;，&lt;/p&gt;
&lt;p&gt;至於TKE_LOGIN的內容（這個也必須加在drone的Secrets內），&lt;br /&gt;
通常是在 $HOME/.docker/config.json 內，會長得像&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
	&amp;quot;auths&amp;quot;: {
		&amp;quot;https://index.docker.io/v1/&amp;quot;: {
			&amp;quot;auth&amp;quot;: &amp;quot;YW11cmRhY2E6c3VwZXJzZWNyZXRwYXNzd29yZA==&amp;quot;
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，我的只有&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
	&amp;quot;auths&amp;quot;: {
		&amp;quot;https://index.docker.io/v1/&amp;quot;: {}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以下面那個就必須自己產生了，&lt;br /&gt;
產生的方式如下&lt;br /&gt;
echo -n &#39;username:password&#39; | base64&lt;br /&gt;
把username與 password 輸入，轉成base64，再貼上去至程式碼內，並儲存至drone的Secrets&lt;br /&gt;
ref.&lt;a href=&quot;https://stackoverflow.com/questions/43441454/docker-login-auth-token&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Docker login auth token&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;至於修改這個image，要加入參數的話，&lt;br /&gt;
目前看應該是 增加 main.go 跟 plugin 的 Kubeconfig 參數，然後重新編譯(&lt;a href=&quot;http://build.sh/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;build.sh&lt;/a&gt;)即可&lt;/p&gt;
&lt;p&gt;p.s. 在騰訊雲的pod(Alpine Linux)內安裝軟體，需替換鏡像源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sed -i &#39;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&#39; /etc/apk/repositories
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
支援k8s的各種指令&lt;a href=&quot;https://github.com/Sh4d1/drone-kubernetes&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Sh4d1/drone-kubernetes&lt;/a&gt;&lt;br /&gt;
可直接在drone上下kubectl指令&lt;a href=&quot;https://github.com/sinlead/drone-kubectl&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;sinlead/drone-kubectl&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://containerization-automation.readthedocs.io/zh_CN/latest/docker/advanced/%5Balpine%5D%E6%BA%90%E9%85%8D%E7%BD%AE/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;alpine源配置&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⏱ Drone/10.drone 使用 騰訊雲 K8S及 容器鏡像服務/" />
        </entry>
        <entry>
            <title>
                0.Drone MOC
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⏱ Drone/0.Drone MOC/</id>
            <content type="html">
                &lt;h1 id=&quot;建置&quot; tabindex=&quot;-1&quot;&gt;建置&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8F%B1%20Drone/72.%20drone%20on%20GKE%20%E5%BB%BA%E7%AB%8B/&quot;&gt;72. drone on GKE 建立&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8F%B1%20Drone/10.drone%20%E4%BD%BF%E7%94%A8%20%E9%A8%B0%E8%A8%8A%E9%9B%B2%20K8S%E5%8F%8A%20%E5%AE%B9%E5%99%A8%E9%8F%A1%E5%83%8F%E6%9C%8D%E5%8B%99/&quot;&gt;10.drone 使用 騰訊雲 K8S及 容器鏡像服務&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8F%B1%20Drone/77.%20drone%20build%20Open%20Source%20Edition/&quot;&gt;77. drone build Open Source Edition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8F%B1%20Drone/78.%20drone%20k8s-runner%20%E9%80%B2%E9%9A%8E%E8%A8%AD%E5%AE%9A/&quot;&gt;78. drone k8s-runner 進階設定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;編寫&quot; tabindex=&quot;-1&quot;&gt;編寫&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.github.io/404&quot;&gt;3. 撰寫drone.yml 筆記篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8F%B1%20Drone/109.%20drone%20jsonnet%20%E5%90%84%E7%A8%AE%E6%80%AA%E6%8B%9B/&quot;&gt;109. drone jsonnet 各種怪招&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8F%B1%20Drone/119.%20Drone%20%20plugin-Drone-docker%20%E4%BF%AE%E6%94%B9%E5%8E%9F%E5%A7%8B%E6%AA%94/&quot;&gt;119. Drone  plugin-Drone-docker 修改原始檔&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⏱ Drone/0.Drone MOC/" />
        </entry>
        <entry>
            <title>
                98. k8s中的command與dockerfile的 CMD
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/Yaml/98. k8s中的command與dockerfile的 CMD/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;忘記是什麼原因，&lt;/p&gt;
&lt;p&gt;讓我跑去查這兩個的差異&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;dockerfile中的指令&lt;/p&gt;
&lt;p&gt;CMD 、 ENTRYPOINT&lt;/p&gt;
&lt;p&gt;k8s 中的yaml 中也有&lt;/p&gt;
&lt;p&gt;command 、args&lt;/p&gt;
&lt;p&gt;先來分辨 CMD 與 ENTRYPOINT的差別&lt;/p&gt;
&lt;h3 id=&quot;cmd&quot; tabindex=&quot;-1&quot;&gt;CMD&lt;/h3&gt;
&lt;p&gt;先上個Dockerfile&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM golang:1.16-alpine AS build-env

CMD [&amp;quot;/bin/sh&amp;quot;,&amp;quot;-c&amp;quot;,&amp;quot;echo $HOME&amp;quot;]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這個build完後，直接執行會顯示 /root，如果用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run golang:1.16 /bin/sh -c &amp;quot;echo $SHELL&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;，會直接執行剛剛的指令。&lt;br /&gt;
原因是，CMD 跟 外面接受的指令會互相覆蓋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/98-fig-1.jpg&quot; alt=&quot;98-fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;entrypoint&quot; tabindex=&quot;-1&quot;&gt;ENTRYPOINT&lt;/h3&gt;
&lt;p&gt;Dockerfile&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM golang:1.16-alpine AS build-env

ENTRYPOINT [&amp;quot;/bin/sh&amp;quot;,&amp;quot;-c&amp;quot;,&amp;quot;echo $HOME&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同樣也直接執行會顯示 /root ，&lt;br /&gt;
如果用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run golang:1.17 /bin/sh -c &amp;quot;echo $SHELL&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;還是顯示 /root&lt;br /&gt;
原因是，使用entrypoint的話，指令不會互相覆蓋。&lt;/p&gt;
&lt;p&gt;反而是被當成參數加在後面。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://myapollo.com.tw/zh-tw/docker-cmd-vs-entrypoint/&quot; title=&quot;Docker CMD 與 ENTRYPOINT 說明詳解&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Docker CMD 與 ENTRYPOINT 說明詳解&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;兩者互動表&quot; tabindex=&quot;-1&quot;&gt;兩者互動表&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;No ENTRYPOINT&lt;/th&gt;
&lt;th&gt;ENTRYPOINT exec_entry p1_entry&lt;/th&gt;
&lt;th&gt;ENTRYPOINT [“exec_entry”, “p1_entry”]&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;No CMD&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;error, not allowed&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;/bin/sh -c exec_entry p1_entry&lt;/td&gt;
&lt;td&gt;exec_entry p1_entry&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;CMD [“exec_cmd”, “p1_cmd”]&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;exec_cmd p1_cmd&lt;/td&gt;
&lt;td&gt;/bin/sh -c exec_entry p1_entry&lt;/td&gt;
&lt;td&gt;exec_entry p1_entry exec_cmd p1_cmd&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;CMD exec_cmd p1_cmd&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;/bin/sh -c exec_cmd p1_cmd&lt;/td&gt;
&lt;td&gt;/bin/sh -c exec_entry p1_entry&lt;/td&gt;
&lt;td&gt;exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Understand how CMD and ENTRYPOINT interact&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://myapollo.com.tw/blog/docker-cmd-vs-entrypoint/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Docker CMD 與 ENTRYPOINT 說明詳解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;k8-s-yaml-command&quot; tabindex=&quot;-1&quot;&gt;K8S yaml  command&lt;/h3&gt;
&lt;p&gt;佈署個cronJob來測試&lt;/p&gt;
&lt;p&gt;這次掛載的映像檔是使用 dockerfile『command』的映像檔&lt;br /&gt;
跟上面測試方法一樣，先不加command看結果是什麼&lt;br /&gt;
加了後結果又會是什麼。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;  spec:
    containers:
    - command:
      - /bin/sh
      - -c
      - echo $PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/98-fig.2.jpg&quot; alt=&quot;98-fig.2.jpg&quot; /&gt;&lt;br /&gt;
11:57 那個沒有加command，所以會看到顯示root&lt;br /&gt;
12:03 加了上面的command，指令覆蓋，所以顯示$PATH的內容&lt;/p&gt;
&lt;p&gt;p.s 如果不用command改用args，指令覆蓋。&lt;/p&gt;
&lt;h3 id=&quot;k8-s-yaml-args&quot; tabindex=&quot;-1&quot;&gt;K8S yaml args&lt;/h3&gt;
&lt;p&gt;這次掛載的映像檔是使用 dockerfile『ENTRYPOINT』的映像檔&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;  spec:
    containers:
    - args:
      - /bin/sh
      - -c
      - echo $PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/98-fig.3.jpg&quot; alt=&quot;98-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;13:44 不加任何參數，顯示 /root&lt;br /&gt;
13:45 加了args，還是顯示/root，指令無覆蓋&lt;/p&gt;
&lt;p&gt;args的主要用途是，當dockerfile 為 ENTRYPOINT時，&lt;br /&gt;
使用args會將其視爲參數傳入到image內。&lt;/p&gt;
&lt;p&gt;ps. 如果改使用 command ，則覆蓋&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://kung-fu-master.github.io/2021/03/13/microService/kubernetes/k8s_command_args_entrypoint_cmd%E5%8C%BA%E5%88%AB/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;k8s command, args, entrypoint, cmd 區別&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h3&gt;
&lt;p&gt;Docker&lt;/p&gt;
&lt;p&gt;ENTRYPOINT 主要是將整個container當做可執行檔來用。&lt;br /&gt;
CMD 則比較類似一台VM&lt;/p&gt;
&lt;p&gt;K8S&lt;/p&gt;
&lt;p&gt;command  ： 指令都是覆蓋&lt;br /&gt;
args ： 外加的參數，可與command一起使用，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;  spec:
    containers:
    - args:
      - -a
      command:
      - /bin/sh
      - -c
      - uname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;command對應的是 Dockerfile內的 ENTRYPOINT&lt;br /&gt;
args對應的是 Dockerfile內的的CMD&lt;/p&gt;
&lt;p&gt;如果Dockerfile只有 cmd，k8s可以只用 command取代。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/Yaml/98. k8s中的command與dockerfile的 CMD/" />
        </entry>
        <entry>
            <title>
                94. k8s 細節補充
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/Yaml/94. k8s 細節補充/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近幫其他組的同事看問題時，&lt;/p&gt;
&lt;p&gt;發現有些東西是我沒看過的，&lt;/p&gt;
&lt;p&gt;就整合再一起，寫起來當備忘拉。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;deployment 的 lifecycle&lt;/p&gt;
&lt;p&gt;postStart 在container創建後，立即發送postStart事件。&lt;br /&gt;
preStop 在 container結束前，立即發送preStop事件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: Pod
metadata:
  name: lifecycle-demo
spec:
  containers:
  - name: lifecycle-demo-container
    image: nginx
    lifecycle:
      postStart:
        exec:
          command: [&amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;echo Hello from the postStart handler &amp;gt; /usr/share/message&amp;quot;]
      preStop:
        exec:
          command: [&amp;quot;/bin/sh&amp;quot;,&amp;quot;-c&amp;quot;,&amp;quot;nginx -s quit; while killall -0 nginx; do sleep 1; done&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://kubernetes.io/zh/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;為容器的生命週期事件設置處理函數&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;pod的終止&lt;br /&gt;
通常情況下，container會發送TERM信號到每個container中，&lt;br /&gt;
當超出了正常終止期限，則會向其他的processor發送KILL信號&lt;br /&gt;
ref. &lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Pod 的終止&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;探針&lt;br /&gt;
livenessProbe ：判斷container是否正常&lt;br /&gt;
readinessProbe：判斷服務是否正常&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;查詢kubectl resouce 簡寫&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubectl api-resources
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;類似下列資源都可用縮寫&lt;br /&gt;
configmap = cm&lt;br /&gt;
deployment=deploy&lt;br /&gt;
pod = po&lt;br /&gt;
persistentvolumeclaims = pvc&lt;/p&gt;
&lt;p&gt;ref .&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10236404&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;【從題目中學習k8s】-【Day8】K8s常用指令 (Cheat Sheet)&amp;amp;解題技巧&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;k8s的 command ，bash -c 意思&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;        command: [&amp;quot;/bin/bash&amp;quot;,&amp;quot;-c&amp;quot;]
        args: [ &amp;quot;service cron start; while true; do sleep 30; done;&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很常看到 bash -c ，這個表示從後面的字串中 讀取命令來使用。&lt;/p&gt;
&lt;p&gt;ps. bash 跟 sh 不一樣，sh通常是指dash。&lt;br /&gt;
可用下列指令，查看目前使用的shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo $SHELL
or
ls -l /bin/sh

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;ref-br-a-href-https-www-computerhope-com-unix-ubash-htm-target-blank-class-external-link-the-bash-shell-a-br-a-href-https-www-wongwonggoods-com-linux-bin-bash-bin-sh-target-blank-class-external-link-bash-bin-bash-bin-sh-script-sh-bash-a&quot; tabindex=&quot;-1&quot;&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://www.computerhope.com/unix/ubash.htm&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;The bash shell&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://www.wongwonggoods.com/linux/bin-bash-bin-sh/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;【Bash】什麼是 #!/bin/bash, #!/bin/sh，為什麼要加在 script 前面 (問題解決：sh, bash 的不同)&lt;/a&gt;&lt;/h2&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;使用指令建立基本的 yaml&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubectl run nginx-kusc00101 --image=nginx --restart=Never --dry-run=client -o yaml&amp;gt; q1.pod
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有基本指令後再去裡面修修改改。&lt;/p&gt;
&lt;p&gt;如果要直接取得現有的yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   kubectl get deploy  yiyuan-landingpage-qa -n istio-yiyuan -o yaml &amp;gt; yiyuan.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/Yaml/94. k8s 細節補充/" />
        </entry>
        <entry>
            <title>
                87.kustomize 共用label(optional）
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/Yaml/87.kustomize 共用label(optional）/</id>
            <content type="html">
                &lt;h2 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;要把別人寫的yaml拆開，然後整併到自己的image，&lt;br /&gt;
才發現service的 base 怎麼沒寫selector ，&lt;br /&gt;
但佈署時卻有mapping到。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;原因在kustomize的 共用屬性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;commonLabels:
  app: token-proxy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這個會自動在各個resource上面增加label，&lt;br /&gt;
如果這邊拔掉的話，&lt;br /&gt;
需要在Deployment以及service上面增加label。&lt;/p&gt;
&lt;p&gt;但在一些文章也有人討論到這個問題，&lt;br /&gt;
如果我不要讓他強制增加的話，&lt;br /&gt;
該怎麼做？&lt;/p&gt;
&lt;p&gt;kustomize有新的參數可供設定(1)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;commonLabels:
- path: metadata/labels
  create: true

- path: spec/selector
  create: true
  version: v1
  kind: Service

- path: spec/selector/matchLabels
  create: true
  kind: Deployment
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外，還有 下列新增的可供參考。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;annotations&lt;/li&gt;
&lt;li&gt;images&lt;/li&gt;
&lt;li&gt;labels&lt;/li&gt;
&lt;li&gt;name reference&lt;/li&gt;
&lt;li&gt;namespace&lt;/li&gt;
&lt;li&gt;prefix/suffix&lt;/li&gt;
&lt;li&gt;variable reference&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;br /&gt;
1 .&lt;a href=&quot;https://github.com/kubernetes-sigs/kustomize/tree/master/examples/transformerconfigs#labels-transformer&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;transformerconfigs&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/Yaml/87.kustomize 共用label(optional）/" />
        </entry>
        <entry>
            <title>
                85. gke-cronjob筆記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/Yaml/85. gke-cronjob筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;之前同事是直接自己土炮用golang寫timer，&lt;br /&gt;
不過如果碰到執行時間過長，重複執行的話，&lt;br /&gt;
就要判斷一堆狀態，決定要不要做，&lt;br /&gt;
那就改用k8s的cronJob了吧。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;文件看一看(1) (2)，好像就差不多了。&lt;br /&gt;
下面是測試，每兩分鐘執行一次，&lt;br /&gt;
但如果執行時間過長，是不是會在執行。&lt;br /&gt;
這邊關掉的是併發以及 暫停後續執行，&lt;br /&gt;
另外注意，gcp的cronjob是每10秒檢查一次狀態。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: batch/v1beta1     # k8s after version 1.21 ,apiVersion: batch/v1
kind: CronJob
metadata:
  name: hello
spec:
  schedule: &amp;quot;*/2 * * * *&amp;quot;             # min hour day Mon week
  concurrencyPolicy: Forbid           # 並發政策 
  startingDeadlineSeconds: 60        # 截止時限
  suspend: true                       # 暫停後續執行
  successfulJobsHistoryLimit: 3       # 歷史限制: 保存成功的數量
  failedJobsHistoryLimit: 1           # 歷史限制： 保存失敗的數量
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: hello
            image: busybox
            args:
            - /bin/sh
            - -c
            - echo &amp;quot;start&amp;quot;; date; echo &amp;quot;Hello, World! Sleep 150s&amp;quot;; sleep 150s; date;
          restartPolicy: OnFailure
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
1.  &lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/cronjobs&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GCP-CronJob&lt;/a&gt;&lt;br /&gt;
2. &lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/workloads/controllers/cron-jobs/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;k8s-CronJob&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/Yaml/85. gke-cronjob筆記/" />
        </entry>
        <entry>
            <title>
                74. kubernetes 批次檢查yaml特定字元
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/Yaml/74. kubernetes 批次檢查yaml特定字元/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;因為dockershim的問題，&lt;br /&gt;
這次要搬cluster的node了。&lt;br /&gt;
但我根本忘記有哪個yaml有寫到 nodeSelector了，&lt;br /&gt;
一個一個看又好懶...怎麼辦？&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;想起來之前在檢查  docker.sock的時候，有用指令檢查過這個yaml (1)裡面，&lt;br /&gt;
有沒有 /docker.sock&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get pods --all-namespaces &#92;
-o=jsonpath=&#39;{range .items[*]}{&amp;quot;&#92;n&amp;quot;}{.metadata.namespace}{&amp;quot;:&#92;t&amp;quot;}{.metadata.name}{&amp;quot;:&#92;t&amp;quot;}{range .spec.volumes[*]}{.hostPath.path}{&amp;quot;, &amp;quot;}{end}{end}&#39; &#92;
| sort &#92;
| grep &#39;/var/run/docker.sock&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這段最後面兩個就不用看了，sort 跟 grep 是 linux的指令。&lt;/p&gt;
&lt;p&gt;主要針對 -o jsonpath 來看，詳細指令　 參考(2)&lt;/p&gt;
&lt;p&gt;當要取得複數資料時，用 range 來取資料。&lt;br /&gt;
然後...參考 pod的yaml看要取得哪些欄位來用吧。&lt;/p&gt;
&lt;p&gt;下面範例為取得 全部的 nodeSelectord&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get pods -A　 &#92;
-o=jsonpath=&#39;{range .items[*]}{&amp;quot;&#92;n&amp;quot;}{.metadata.namespace}{&amp;quot;:&#92;t&amp;quot;}{.metadata.name}{&amp;quot;:&#92;t&amp;quot;}{.spec.nodeSelector}{end}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/Yaml/74-fig.1.jpg&quot; alt=&quot;74-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;再排序一下，就可以很快的知道有哪些yaml有用到 nodeSelector了。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
1. &lt;a href=&quot;https://kubernetes.io/zh/docs/tasks/administer-cluster/migrating-from-dockershim/migrating-telemetry-and-security-agents/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;從 dockershim 遷移遙測和安全代理&lt;/a&gt;&lt;br /&gt;
2. &lt;a href=&quot;http://kubernetes.kansea.com/docs/user-guide/jsonpath/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;JSONpath 幫助&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/Yaml/74. kubernetes 批次檢查yaml特定字元/" />
        </entry>
        <entry>
            <title>
                2. k8s yaml撰寫 volume 踩坑篇
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/Yaml/2. k8s yaml撰寫 volume 踩坑篇/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;昨天接到一個任務，要把一個純html，放到nginx上面。&lt;br /&gt;
然後就開始踩坑之旅了&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;這邊寫的都是GKE 的佈署方式，&lt;br /&gt;
關於GKE  文章實在太多了，我也不知道何年何月何日才有那個技術存量可以把它寫成文章。&lt;/p&gt;
&lt;p&gt;目前使用的是 kustomize的方式佈署網站，&lt;br /&gt;
目前也在架設drone，日後走的是自動佈署，&lt;br /&gt;
但是第一次佈署還是要自己來的。&lt;/p&gt;
&lt;p&gt;基本的流程是，將網頁包成一個 docker image，&lt;br /&gt;
(不論是php 或是 html， Go 則是本身有服務可以掛載，比較簡單點。)&lt;br /&gt;
再將此image設定成 initContainers ，&lt;br /&gt;
將此image的資料夾，掛載成volume，讓nginx可以直接掛載此資料夾。&lt;/p&gt;
&lt;p&gt;這次踩的坑有兩個，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;網站程式，是別人傳給我的，所以檔案權限，everyone都是 無法存取。&lt;br /&gt;
所以要把裡面的所有檔案改成 755 rwxr-xr-x ，nginx圖片才能夠讀取。&lt;br /&gt;
我懶的一個一個改，所以下指令一次把整個資料夾內容都改掉，當初安全點是設定777&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;chmod -R 755 resource
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(ref. &lt;a href=&quot;https://www.jianshu.com/p/6c52260b1ff3&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://www.jianshu.com/p/6c52260b1ff3&lt;/a&gt;)&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;在寫yaml的時候，沒有搞清楚 volume的用途&lt;br /&gt;
導致一直出現rsync的錯誤。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;initContainers:
- command:
  - sh
  - -c
  - |
    rsync -avrh --delete /source/* /app
  image: gcr.io/project/busybox-web:v2.7
  imagePullPolicy: Always
  name: source
  volumeMounts:
  - mountPath: /app
    name: source
volumes:
- emptyDir: {}
  name: source
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;volumeMounts: 這段的意思是 定義一個叫 soure的新磁區，掛載在 busybox-web容器裡的 /app 的path上面。&lt;br /&gt;
volumes: 的意思是定義磁碟區，emptyDir是伴隨著pod的生命，當pod消失資料也會跟著消失&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;nginx.conf 改完後，要重啟pod ，因為nginx.conf 是寫在 k8s的 configMapGenerator，&lt;br /&gt;
所以更改裡面的設定後，不會重啟pod ，裡面的服務就不會重新抓取conf。&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/Yaml/2. k8s yaml撰寫 volume 踩坑篇/" />
        </entry>
        <entry>
            <title>
                136. 一步步篩選k8s的deploy內容
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/Yaml/136. 一步步篩選k8s的deploy內容/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;要抓一下，目前ingress裏面的所有白名單資訊，&lt;br /&gt;
但一個一個開起來看又很麻煩，&lt;br /&gt;
就寫code filter吧&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;先取得json，先指定一個服務，不然會太亂&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubectl get ingress websocketclient -o json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/Yaml/136-fig.1.jpg&quot; alt=&quot;136-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;然後開始看json 格式開始拆解，這次目的是要取得&lt;br /&gt;
&lt;code&gt;nginx.ingress.kubernetes.io/whitelist-source-range&lt;/code&gt;的值，&lt;br /&gt;
這邊會碰到一個問題，因為有特殊符號 . 跟 / ，所以要用 &#92; ，將它視爲一個整體。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubectl get ingress -n default -o=jsonpath=&#39;{range .items[*]}{&amp;quot;&#92;n&amp;quot;}{.metadata.name}{&amp;quot;&#92;t&amp;quot;}{.metadata.annotations.nginx&#92;.ingress&#92;.kubernetes&#92;.io&#92;/whitelist-source-range}{end}&#39; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/Yaml/136-fig.2.jpg&quot; alt=&quot;136-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/reference/kubectl/jsonpath/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;JSONPath Support&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/64014047/extract-information-of-kubernetes-annotations-with-jsonpath&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Extract information of kubernetes annotations with jsonpath&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/Yaml/136. 一步步篩選k8s的deploy內容/" />
        </entry>
        <entry>
            <title>
                12. k8s YAML 小細節
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/Yaml/12. k8s YAML 小細節/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近寫yaml，有時常會忘記這個的功能是什麼，就記一下吧&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Service 的Port功能&lt;br /&gt;
Port exposes the Kubernetes service on the specified port within the cluster. Other pods within the cluster can communicate with this server on the specified port.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;TargetPort is the port on which the service will send requests to, that your pod will be listening on. Your application in the container will need to be listening on this port also.&lt;/p&gt;
&lt;p&gt;NodePort exposes a service externally to the cluster by means of the target nodes IP address and the NodePort. NodePort is the default setting if the port field is not specified.&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;探針檢查&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;livenessProbe:
  initialDelaySeconds: 10
  periodSeconds: 10
  successThreshold: 1
  failureThreshold: 3
  tcpSocket:
    port: 80
readinessProbe:
  initialDelaySeconds: 30
  periodSeconds: 10
  successThreshold: 1
  failureThreshold: 3
  tcpSocket:
    port: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;pull image 認證&lt;br /&gt;
如果要佈署的image是屬於 私密的，&lt;br /&gt;
需要加上&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;imagePullSecrets:
  - name: regcred
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要先注入Secred&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl create secret generic regcred --from-file=./username.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Service 服務類型&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ClusterIP
&lt;ul&gt;
&lt;li&gt;一個集群內的服務，集群內的其它應用都可以訪問該服務。集群外部無法訪問它。 這也是默認的 ServiceType。&lt;/li&gt;
&lt;li&gt;可以使用proxy 的本機 port轉移，來訪問服務。像 (Fig.1)&lt;br /&gt;
[[12.fig-1.jpg]]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NodePort
&lt;ul&gt;
&lt;li&gt;在所有節點（虛擬機）上開放一個特定端口，任何發送到該端口的流量都被轉發到對應服務。&lt;/li&gt;
&lt;li&gt;在 1 的service port，就是指這個部分。&lt;/li&gt;
&lt;li&gt;需使用K8s的叢集主機加上port，去訪問服務。 (Fig.2)&lt;br /&gt;
[[12.fig-2.jpg]]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LoadBalancer
&lt;ul&gt;
&lt;li&gt;LoadBalancer 服務是暴露服務到 internet 的標準方式。在 GKE 上，這種方式會啟動一個 Network Load Balancer，它將給你一個單獨的 IP 地址，轉發所有流量到你的服務。&lt;/li&gt;
&lt;li&gt;一個外部ip，直接訪問即可，有時需注意防火牆有沒有擋住。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;http://dockone.io/article/4884&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes的三種外部訪問方式：NodePort、LoadBalancer 和 Ingress&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/services-networking/service/#nodeport&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes 服務&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;kube dns&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;pod-dns-record&quot; tabindex=&quot;-1&quot;&gt;Pod DNS record&lt;/h3&gt;
&lt;p&gt;[[12.fig-3.jpg]]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  172-17-0-6.default.pod.cluster.local
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;172-17-0-6: Pod IP&lt;/li&gt;
&lt;li&gt;default: Namespace Name&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;service-dns-record&quot; tabindex=&quot;-1&quot;&gt;Service DNS record&lt;/h3&gt;
&lt;p&gt;[[12.fig-4.jpg]]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  nginx.default.svc.cluster.local
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;nginx: Service Name&lt;/li&gt;
&lt;li&gt;default:  Namespace Name&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;service-discovery&quot; tabindex=&quot;-1&quot;&gt;Service Discovery&lt;/h3&gt;
&lt;p&gt;[[12.fig-5.jpg]]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  web-0.nginx.default.svc.cluster.local
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;web-0: Pod Name&lt;/li&gt;
&lt;li&gt;nginx: Service Name&lt;/li&gt;
&lt;li&gt;default: Namespace Name&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Auto Scaling（自動擴展）&lt;br /&gt;
在Auto Scaling 裡面，有一個設定是根據cpu的使用量大小去增加Pod，&lt;br /&gt;
假設&lt;br /&gt;
targetCPUUtilizationPercentage:10&lt;br /&gt;
在deploy 裡的request CPU 設定 200m&lt;br /&gt;
表示，當cpu的使用率在 20m(200m * 10% = 20m )時，會自動擴展&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果要使用其他的指標，api 需改用 autoscaling/v2beta2&lt;br /&gt;
這邊還沒測試過，有需要的可至相關網頁查詢&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://medium.com/andy-blog/kubernetes-%E9%82%A3%E4%BA%9B%E4%BA%8B-auto-scaling-7b887f61fdec&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes 那些事 — Auto Scaling&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.mdeditor.tw/pl/p7hU/zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes--k8s--進階--全面瞭解HPA--部署HPA實現高可用和成本控制&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.openshift.com/blog/kubernetes-1-8-now-custom-metrics&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes 1.8: Now with 100% Daily Value of Custom Metrics&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/Yaml/12. k8s YAML 小細節/" />
        </entry>
        <entry>
            <title>
                82. Terraform vs Ansible
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/Terraform/82. Terraform vs Ansible/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;本來想直接用表格闡述兩邊不同的地方，&lt;br /&gt;
但發現我不知道從何下手。&lt;br /&gt;
只好先用條列代替了，&lt;br /&gt;
這兩套我都沒用過，因為...我直接從GKE開始XD。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;Terraform&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;聲明性代碼：程式碼的結果就是最終狀態&lt;/li&gt;
&lt;li&gt;協作(Orchestration)：確保環境持續處於『理想狀態』，當服務不能用時，會砍掉重建。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ansible&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程式性代碼：每一次的狀態都是獨立的&lt;/li&gt;
&lt;li&gt;配置管理工具(Configuration Management)： 是一套流程和程序，執行時不會重置系統，會在機器上修復問題或升級服務。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h2&gt;
&lt;p&gt;目前看起來，&lt;/p&gt;
&lt;p&gt;Ansible主要偏向自動化管理工具但同時具備一定程度上的環境　建立。&lt;/p&gt;
&lt;p&gt;Terraform 就是單純的  環境建立工具&lt;/p&gt;
&lt;p&gt;如果走向k8s服務的話，學TerraForm就好了。&lt;br /&gt;
用來建立cluster、loadbalancer...。&lt;br /&gt;
由於 k8s的服務都已經容器化了，使用Ansible也沒什麼意義，&lt;br /&gt;
重開服務又消失了。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://linuxhandbook.com/terraform-vs-ansible/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Terraform vs Ansible: What&#39;s the difference and which one you should use?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.lsbin.com/13252.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Ansible vs Terraform vs Puppet差異比較：有什麼區別？選擇哪個？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/gemini-open-cloud/%E6%9E%B6%E6%A7%8B%E7%A8%8B%E5%BC%8F%E7%A2%BC-iii-devops-%E5%AF%A6%E6%96%BD%E5%B7%A5%E5%85%B7-873301f662e7&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;架構程式碼的實施工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/6844903908213522445&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [DevOps系列] 為什麼我們使用Terraform 而不使用Puppet, Ansible&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://spacelift.io/blog/ansible-vs-terraform&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Terraform vs. Ansible : Key Differences and Comparison of Tools&lt;/a&gt;，感覺這篇寫的最好，但結論就...&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/Terraform/82. Terraform vs Ansible/" />
        </entry>
        <entry>
            <title>
                189. 導入Terraform
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/Terraform/189. 導入Terraform/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;前面有稍微提到幾篇是terraform的使用方式，&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Terraform/148.%20Terraform%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/&quot;&gt;148. Terraform的基本概念&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Terraform/149.%20terraform%20%E9%83%A8%E7%BD%B2VM%EF%BC%8C%E5%95%93%E5%8B%95docker%E5%AE%89%E8%A3%9Dmetadata_startup_script/&quot;&gt;149. terraform 部署VM，啓動docker安裝metadata_startup_script&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Terraform/183.%20Terrafrom%20%E5%BB%BA%E7%AB%8Bprivate%20cluster/&quot;&gt;183. Terrafrom 建立private cluster&lt;/a&gt;&lt;br /&gt;
再來把剩下碰到的補一補了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;建立完了private cluster，後續要建立SQL 跟 redis的話，該怎麼建？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外開一個資料夾，重新&lt;code&gt;terraform init&lt;/code&gt;，但要注意，&lt;br /&gt;
你的backend.hcl是怎麼寫的。&lt;/p&gt;
&lt;p&gt;舉例來說，&lt;br /&gt;
private cluster的bucket.hcl是這樣&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   bucket  = &amp;quot;terraform-devops&amp;quot;
   prefix  = &amp;quot;terraform/state&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果，另一個資料夾裏面的bucket.hcl也相同，&lt;br /&gt;
那在產生計劃時，就會把你剛剛建好的private cluster給刪除，&lt;br /&gt;
因爲他檢查的是tfstate跟你目前計劃有哪些差別。&lt;/p&gt;
&lt;p&gt;所以，需要更改prefix&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   bucket  = &amp;quot;terraform-devops&amp;quot;
   prefix  = &amp;quot;terraform/other&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這樣在bucket裏面，就會存成兩個不同的tfstate&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/Terraform/189-fig.1.jpg&quot; alt=&quot;189-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;terrafrom使用迴圈，減少重複的程式碼&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;建立兩個bucket，並開啓allUser read&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;variable &amp;quot;bucket_names&amp;quot; {
  type    = list(string)
  default = [&amp;quot;A-legacy&amp;quot;, &amp;quot;B-legacy&amp;quot;]
}
resource &amp;quot;google_storage_bucket&amp;quot; &amp;quot;frontend_bucket&amp;quot; {
  uniform_bucket_level_access = true
  for_each = { for name in toset(var.bucket_names) : name =&amp;gt; name }
  name          = each.value
  force_destroy = false
  location      = &amp;quot;asia-east1&amp;quot;
  storage_class = &amp;quot;STANDARD&amp;quot;
  # public_access_prevention = &amp;quot;inherited&amp;quot;  

  //物件版本管理
  versioning {  
    enabled = false
  }
}
resource &amp;quot;google_storage_bucket_iam_binding&amp;quot; &amp;quot;binding&amp;quot; {
  for_each = google_storage_bucket.frontend_bucket

  bucket = each.value.name
  role = &amp;quot;roles/storage.legacyObjectReader&amp;quot;
  members = [
    &amp;quot;allUsers&amp;quot;,
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.hashicorp.com/terraform/language/meta-arguments/for_each&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;The for_each Meta-Argument&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/storage/docs/public-access-prevention?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;禁止公開訪問&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/storage_bucket_iam&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;IAM policy for Cloud Storage Bucket&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;讀取之前的設定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在建立private cluster的時候，就已經建好了vpc ，&lt;br /&gt;
相同的網路，我想在建立mssql 時使用，&lt;/p&gt;
&lt;p&gt;使用data呼叫這個VPC。&lt;br /&gt;
這個範例是拿來建立vpc裏面的私人服務連線的位置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;data &amp;quot;google_compute_network&amp;quot; &amp;quot;private-network&amp;quot; {
  name = &amp;quot;basic&amp;quot;
}

resource &amp;quot;google_compute_global_address&amp;quot; &amp;quot;private_ip_address&amp;quot; {
  depends_on = [ google_project_service.project ]
  name          = &amp;quot;private-ip-address&amp;quot;
  purpose       = &amp;quot;VPC_PEERING&amp;quot;
  address_type  = &amp;quot;INTERNAL&amp;quot;
  prefix_length = 16
  network       = data.google_compute_network.private-network.id
}
resource &amp;quot;google_service_networking_connection&amp;quot; &amp;quot;private_vpc_connection&amp;quot; {

  network                 = data.google_compute_network.private-network.id
  service                 = &amp;quot;servicenetworking.googleapis.com&amp;quot;
  reserved_peering_ranges = [google_compute_global_address.private_ip_address.name]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/Terraform/189-fig.2.jpg&quot; alt=&quot;189-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;設定.gitignore&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;
# Local .terraform directories
**/.terraform/*

# .tfstate files
*.tfstate
*.tfstate.*

# Crash log files
crash.log
crash.*.log

# Exclude all .tfvars files, which are likely to contain sensitive data, such as
# password, private keys, and other secrets. These should not be part of version 
# control as they are data points which are potentially sensitive and subject 
# to change depending on the environment.
# *.tfvars
# *.tfvars.json

# Ignore override files as they are usually used to override resources locally and so
# are not checked in
override.tf
override.tf.json
*_override.tf
*_override.tf.json

# Include override files you do wish to add to version control using negated pattern
# !example_override.tf

# Include tfplan files to ignore the plan output of command: terraform plan -out=tfplan
# example: *tfplan*

# Ignore CLI configuration files
.terraformrc
terraform.rc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.  &lt;a href=&quot;https://github.com/github/gitignore&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gitignore&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;結尾&quot; tabindex=&quot;-1&quot;&gt;結尾&lt;/h4&gt;
&lt;p&gt;基礎概念介紹&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://lonegunmanb.github.io/introduction-terraform/2.1.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E2%80%94%E2%80%94Provider.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Terraform基礎概念——Provider&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/docs/terraform/best-practices-for-terraform?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GCP-使用 Terraform 的最佳實踐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://heretse.medium.com/%E5%A4%A7%E5%AE%B6%E9%83%BD%E5%9C%A8%E7%94%A8-terraform-%E5%AF%A6%E4%BD%9C-iac-%E7%82%BA%E4%BB%80%E9%BA%BC%E4%B8%8D%E5%B0%87%E7%A8%8B%E5%BC%8F%E5%AF%AB%E5%BE%97%E6%9B%B4%E7%B0%A1%E6%BD%94%E6%98%93%E8%AE%80%E5%91%A2-a736db1f6ef2&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;大家都在用 Terraform 實作 IaC 為什麼不將程式寫得更簡潔易讀呢？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://shazi7804.github.io/terraform-manage-guide/basic/locals.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Locals&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/Terraform/189. 導入Terraform/" />
        </entry>
        <entry>
            <title>
                183. Terrafrom 建立private cluster
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/Terraform/183. Terrafrom 建立private cluster/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;要重建一個新的project，然後把舊的服務搬過去。&lt;br /&gt;
初步估計就一堆東西，正好拿來練一下terraform了&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;服務列表&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Create Project&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Create Cluster&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Create VPC&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Create CLoudSQL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Create Memorystore&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Create CloudStorage&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Copy file to CloudStorage&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;後端修改config&amp;amp;publish&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Creaet RabbitMQ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Create Nginx ingress&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;前端服務部署&amp;amp;測試&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;後端服務部署&amp;amp;測試&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Network policy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Obserbility service&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EFK logs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;前後端 CI/CD 修改 &amp;amp; IAM權限&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Project沒辦法用terraform，因爲那不是我操作的。&lt;br /&gt;
也不知道那個能不能用terraform 。&lt;/p&gt;
&lt;p&gt;這篇會建立一個bucket、vpc 、private cluster以及cloud NAT。&lt;br /&gt;
下面會用tf 來稱呼terraform&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立bucket&lt;br /&gt;
因爲狀態關係，就乾脆用gcs統一狀態了，可參考&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Terraform/148.%20Terraform%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/&quot;&gt;148. Terraform的基本概念&lt;/a&gt;&lt;br /&gt;
&lt;code&gt;new&#92;gcs&#92;main.tf&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;terraform {
  required_providers {
    google = {
      source = &amp;quot;hashicorp/google&amp;quot;
      version = &amp;quot;4.63.1&amp;quot;
    }
  }
}

provider &amp;quot;google&amp;quot; {
  project = &amp;quot;ezio-sms-o&amp;quot;
}


resource &amp;quot;random_id&amp;quot; &amp;quot;bucket_prefix&amp;quot; {
  byte_length = 3
}

resource &amp;quot;google_storage_bucket&amp;quot; &amp;quot;tfstate_bucket&amp;quot; {
  name          = &amp;quot;${random_id.bucket_prefix.hex}-terraform-devops&amp;quot;
  force_destroy = false
  location      = &amp;quot;asia-east1&amp;quot;
  storage_class = &amp;quot;Nearline&amp;quot;
  
  //物件版本管理
  versioning {  
    enabled = false
  }
}

output &amp;quot;bucket_name&amp;quot;{
  description = &amp;quot;get bucket name&amp;quot;
  value = google_storage_bucket.tfstate_bucket.name
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;記下bucket name與預計要用的前綴，然後寫在backend.hcl，&lt;br /&gt;
等等下面會用到。&lt;br /&gt;
&lt;code&gt;new&#92;backend.hcl&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   bucket  = &amp;quot;cb0392-terraform-devops&amp;quot;
   prefix  = &amp;quot;terraform/state&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;建vpc 與cloudNAT&lt;br /&gt;
&lt;code&gt;new&#92;gke&#92;main.tf&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;terraform {
  required_providers {
    google = {
      source  = &amp;quot;hashicorp/google&amp;quot;
      version = &amp;quot;5.4.0&amp;quot;
    }
  }
  backend &amp;quot;gcs&amp;quot; {

  }
}

provider &amp;quot;google&amp;quot; {
  project = &amp;quot;ezio-sms-o&amp;quot;
  zone    = &amp;quot;asia-east1-b&amp;quot;
}

# VPC
resource &amp;quot;google_compute_network&amp;quot; &amp;quot;basic&amp;quot; {
  name                            = &amp;quot;basic&amp;quot;
  auto_create_subnetworks         = false
  # delete_default_routes_on_create = false
  routing_mode                    = &amp;quot;REGIONAL&amp;quot;
}

resource &amp;quot;google_compute_subnetwork&amp;quot; &amp;quot;basic&amp;quot; {
  name                     = &amp;quot;basic-subnet&amp;quot;
  ip_cidr_range            = var.subnet_cidr
  region                   = var.gcp_region
  network                  = google_compute_network.basic.id
  private_ip_google_access = true

  secondary_ip_range {
    range_name    = &amp;quot;gke-pod-range&amp;quot;
    ip_cidr_range = var.pod_cidr
  }
  secondary_ip_range {
    range_name    = &amp;quot;gke-service-range&amp;quot;
    ip_cidr_range = var.service_cidr
  }
}

# Cloud NAT
resource &amp;quot;google_compute_router&amp;quot; &amp;quot;default_cloudnat&amp;quot; {
  name    = &amp;quot;default-nat&amp;quot;
  region  = var.gcp_region
  network = google_compute_network.basic.id
}

resource &amp;quot;google_compute_router_nat&amp;quot; &amp;quot;default_cloudnat&amp;quot; {
  name   = &amp;quot;nat&amp;quot;
  router = google_compute_router.default_cloudnat.name
  region = var.gcp_region

  source_subnetwork_ip_ranges_to_nat = &amp;quot;LIST_OF_SUBNETWORKS&amp;quot;
  nat_ip_allocate_option             = &amp;quot;MANUAL_ONLY&amp;quot;

  subnetwork {
    name                    = google_compute_subnetwork.basic.id
    source_ip_ranges_to_nat = [&amp;quot;ALL_IP_RANGES&amp;quot;]
  }

  nat_ips = [google_compute_address.nat.self_link]
}

resource &amp;quot;google_compute_address&amp;quot; &amp;quot;nat&amp;quot; {
  name         = &amp;quot;nat&amp;quot;
  address_type = &amp;quot;EXTERNAL&amp;quot;
  network_tier = &amp;quot;PREMIUM&amp;quot;
  region       = var.gcp_region

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;變數的設定，也請參考&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Terraform/148.%20Terraform%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/&quot;&gt;148. Terraform的基本概念&lt;/a&gt;&lt;br /&gt;
&lt;code&gt;new&#92;gke&#92;terraform.tf&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;variable &amp;quot;project_id&amp;quot; {
  default = &amp;quot;ezio-sms-o&amp;quot;
}
variable &amp;quot;gcp_region&amp;quot; {
  default = &amp;quot;asia-east1&amp;quot;
}
variable &amp;quot;gcp_zone&amp;quot; {
  type    = list(string)
  default = [&amp;quot;asia-east1-b&amp;quot;]
}
variable &amp;quot;gke_name&amp;quot; {
  default = &amp;quot;fixed&amp;quot;
}

variable &amp;quot;subnet_cidr&amp;quot; {
  default = &amp;quot;10.10.0.0/16&amp;quot;
}

variable &amp;quot;pod_cidr&amp;quot; {
  default = &amp;quot;192.168.8.0/21&amp;quot;
}

variable &amp;quot;service_cidr&amp;quot; {
  default = &amp;quot;192.168.16.0/21&amp;quot;
}

variable &amp;quot;master_cidr&amp;quot; {
  default = &amp;quot;10.0.2.0/28&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://alanzhan.dev/post/2023-03-12-terraform-private-gke/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;透過 Terraform 建立私有 GKE Cluster&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cloudskillsboost.google/focuses/15842?locale=zh_TW&amp;amp;parent=catalog&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;# 使用基礎架構即程式碼工具 Terraform&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_network&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;google_compute_network&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;建立GKE&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這部分算是查最久的，用到了terraform的module概念。&lt;br /&gt;
可以先看這篇 &lt;a href=&quot;https://godleon.github.io/blog/DevOps/terraform-getting-started/#%E4%BD%BF%E7%94%A8-module&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Terraform] 入門學習筆記&lt;/a&gt;，瞭解一下什麼是module。&lt;/p&gt;
&lt;p&gt;然後再來就是看官方文件了。&lt;br /&gt;
&lt;code&gt;new&#92;gke&#92;main.tf&lt;/code&gt;&lt;br /&gt;
沒錯跟上面vpc的檔案一樣，因爲是同一份文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# GKE
module &amp;quot;gke&amp;quot; {
  source  = &amp;quot;terraform-google-modules/kubernetes-engine/google//modules/private-cluster&amp;quot;
  version = &amp;quot;29.0.0&amp;quot;
  project_id                 = var.project_id
  name                       = var.gke_name
  # 區域性
  regional                   = false
  region                     = var.gcp_region
  zones                      = var.gcp_zone
  network                    = google_compute_network.basic.name
  subnetwork                 = google_compute_subnetwork.basic.name
  ip_range_pods              = google_compute_subnetwork.basic.secondary_ip_range[0].range_name
  ip_range_services          = google_compute_subnetwork.basic.secondary_ip_range[1].range_name
  http_load_balancing        = true
  network_policy             = false
  horizontal_pod_autoscaling = true
  filestore_csi_driver       = false
  # private cluster
  enable_private_endpoint    = false
  enable_private_nodes       = true
  master_global_access_enabled  = false
  master_ipv4_cidr_block     = &amp;quot;10.0.0.0/28&amp;quot;
  # gke version
  release_channel            = &amp;quot;UNSPECIFIED&amp;quot;
  remove_default_node_pool   = true
  # log record
  logging_enabled_components = [&amp;quot;SYSTEM_COMPONENTS&amp;quot;]
  create_service_account     = false

  node_pools = [
    {
      autoscaling               = false
      node_count                = 2
      name                      = &amp;quot;default-node-pool&amp;quot;
      machine_type              = &amp;quot;e2-custom-4-12288&amp;quot;
      local_ssd_count           = 0
      spot                      = false
      disk_size_gb              = 100
      disk_type                 = &amp;quot;pd-standard&amp;quot;
      image_type                = &amp;quot;COS_CONTAINERD&amp;quot;
      enable_gcfs               = false
      enable_gvnic              = false
      logging_variant           = &amp;quot;DEFAULT&amp;quot;
      auto_repair               = true
      auto_upgrade              = false
      preemptible               = false
      initial_node_count        = 80
    },
  ]

  node_pools_oauth_scopes = {
    all = [
		&amp;quot;https://www.googleapis.com/auth/logging.write&amp;quot;,
		&amp;quot;https://www.googleapis.com/auth/monitoring&amp;quot;,
		&amp;quot;https://www.googleapis.com/auth/devstorage.read_only&amp;quot;,
		&amp;quot;https://www.googleapis.com/auth/service.management.readonly&amp;quot;,
		&amp;quot;https://www.googleapis.com/auth/servicecontrol&amp;quot;,
		&amp;quot;https://www.googleapis.com/auth/trace.append&amp;quot;
    ]
  }

  node_pools_labels = {
    all = {}

    default-node-pool = {
      default-node-pool = true
    }
  }

  node_pools_metadata = {
    all = {}

    default-node-pool = {
      node-pool-metadata-custom-value = &amp;quot;fixed-node-pool&amp;quot;
    }
  }

  node_pools_taints = {
    all = []

    default-node-pool = [
      {
        key    = &amp;quot;default-node-pool&amp;quot;
        value  = true
        effect = &amp;quot;PREFER_NO_SCHEDULE&amp;quot;
      },
    ]
  }

  node_pools_tags = {
    all = []

    default-node-pool = [
      &amp;quot;default-node-pool&amp;quot;,
    ]
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;簡單說一下module的用法，&lt;br /&gt;
當第一次用module時，需要初始化，加上指定gcs儲存tfstat&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tf init -backend-config=../backend.hcl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之後要使用submodule的話，不用再初始化，只要get&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tf get
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要建立private cluster的話，需要使用submodule，&lt;br /&gt;
可從&lt;a href=&quot;https://registry.terraform.io/modules/terraform-google-modules/kubernetes-engine/google/latest?tab=inputs&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kubernetes-engine&lt;/a&gt; 到 submodule的 &lt;a href=&quot;https://registry.terraform.io/modules/terraform-google-modules/kubernetes-engine/google/latest/submodules/private-cluster?tab=inputs&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;private-cluster&lt;/a&gt;，&lt;/p&gt;
&lt;p&gt;有些參數不知道是建立GKE的哪個設定，&lt;br /&gt;
可以多利用&lt;code&gt;tf validate&lt;/code&gt; 驗證，&lt;br /&gt;
但有時是部署時才會發生錯誤。&lt;br /&gt;
我後來是直接手動把cluster砍掉，再&lt;code&gt;tf apply&lt;/code&gt;比較快。&lt;/p&gt;
&lt;p&gt;本來也有想過不要用module，直接實作。&lt;br /&gt;
但看了官方文件&lt;a href=&quot;https://registry.terraform.io/providers/hashicorp/google/latest/docs/guides/using_gke_with_terraform&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; Using GKE with Terraform&lt;/a&gt;，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Additionally, you may consider using Google&#39;s &lt;a href=&quot;https://registry.terraform.io/modules/terraform-google-modules/kubernetes-engine/google&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;&lt;code&gt;kubernetes-engine&lt;/code&gt;&lt;/a&gt; module, which implements many of these practices for you&lt;br /&gt;
就試試看了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意，submodule與主要module的source不一樣，有些參數在主module是沒有的。&lt;/p&gt;
&lt;h4 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h4&gt;
&lt;p&gt;部署GKE時，發現我沒辦法從Google Artifact Registry 下載image。&lt;br /&gt;
最後發現是 沒有設定 存取權範圍，&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/access-scopes&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Access scopes in GKE&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/Terraform/183-fig.1.jpg&quot; alt=&quot;183-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;這個需要在 &lt;code&gt;node_pools_oauth_scopes&lt;/code&gt; 裏面補上允許的api網址。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/Terraform/183. Terrafrom 建立private cluster/" />
        </entry>
        <entry>
            <title>
                149. terraform 部署VM，啓動docker安裝metadata_startup_script
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/Terraform/149. terraform 部署VM，啓動docker安裝metadata_startup_script/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;由於前人弄向Let&#39;s encrypt 申請的ssl憑證，偶爾會出問題，&lt;br /&gt;
步驟繁瑣，常常改了這個，忘記要重啓那個，那就重新做一套吧。&lt;br /&gt;
為了我想偷懶..(^__^)&lt;br /&gt;
但在那之前，先生個機器來測試看看。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;第一次用terraform部署vm機器，&lt;br /&gt;
這邊要注意的是 backend &amp;quot;gcs&amp;quot;，&lt;br /&gt;
我直接將tfstate傳到gcs上面了，可以參考上一篇&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Terraform/148.%20Terraform%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/&quot;&gt;148. Terraform的基本概念&lt;/a&gt;。&lt;br /&gt;
底下的metadata_startup_script，&lt;br /&gt;
指令很長，導致我不想放在同一行，&lt;br /&gt;
跑去問了下chatGPT，能使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;&amp;lt;-EOT
 EOT
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這種方式將程式碼包在一起，就比較方便閱讀了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    terraform {
      required_providers {
        google = {
          source = &amp;quot;hashicorp/google&amp;quot;
          version = &amp;quot;4.63.1&amp;quot;
        }
      }
      backend &amp;quot;gcs&amp;quot; {

      }
    }
    
    provider &amp;quot;google&amp;quot; {
      project = &amp;quot;abc&amp;quot;
    }

    resource &amp;quot;google_compute_instance&amp;quot; &amp;quot;certificate-vm&amp;quot; {
      name         = &amp;quot;ca-service&amp;quot;
      machine_type = &amp;quot;f1-micro&amp;quot;
      zone         = &amp;quot;asia-east1-b&amp;quot;
      tags         = [&amp;quot;allow-admin-ip&amp;quot;]

      boot_disk {
        initialize_params {
          image = &amp;quot;debian-cloud/debian-11&amp;quot;
        }
      }

      # Install Docker
      metadata_startup_script = &amp;lt;&amp;lt;-EOT
        sudo apt-get update; sudo apt-get install ca-certificates curl gnupg; 
        sudo install -m 0755 -d /etc/apt/keyrings; 
        curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg; 
        sudo chmod a+r /etc/apt/keyrings/docker.gpg; 
        echo &amp;quot;deb [arch=&amp;quot;$(dpkg --print-architecture)&amp;quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian &#92;
        &amp;quot;$(. /etc/os-release &amp;amp;&amp;amp; echo &amp;quot;$VERSION_CODENAME&amp;quot;)&amp;quot; stable&amp;quot; | &#92;
        sudo tee /etc/apt/sources.list.d/docker.list &amp;gt; /dev/null ; 
        sudo apt-get update;
        sudo apt-get -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin;
      EOT

      network_interface {
        # subnetwork = google_compute_subnetwork.default.id
        subnetwork = &amp;quot;default&amp;quot;
        access_config {
          # Include this section to give the VM an external IP address
        }
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;troubleshooting&lt;/h1&gt;
&lt;p&gt;如果執行了startup-script，但沒跑，該怎麼除錯？&lt;br /&gt;
到vm裏面執行下面指令，就可以查log了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo journalctl -u google-startup-scripts.service
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://docs.docker.com/engine/install/debian/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Install Docker Engine on Debian&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/Terraform/149. terraform 部署VM，啓動docker安裝metadata_startup_script/" />
        </entry>
        <entry>
            <title>
                148. Terraform的基本概念
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/Terraform/148. Terraform的基本概念/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;經歷上一篇的失敗，&lt;br /&gt;
還是先從基本觀念開始吧。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h4 id=&quot;tf&quot; tabindex=&quot;-1&quot;&gt;tf基本組成&lt;/h4&gt;
&lt;p&gt;下面指令輸入時，會用tf取代terraform&lt;/p&gt;
&lt;h6 id=&quot;宣告&quot; tabindex=&quot;-1&quot;&gt;宣告&lt;/h6&gt;
&lt;ol&gt;
&lt;li&gt;terraform&lt;br /&gt;
宣告terraform以及環境的版本&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;terraform {
  required_version = &amp;quot;~&amp;gt;0.13.5&amp;quot;
  required_providers {
    ucloud = {
      source  = &amp;quot;ucloud/ucloud&amp;quot;
      version = &amp;quot;~&amp;gt;1.22.0&amp;quot;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;provider&lt;br /&gt;
呼叫該環境api時需要的參數&lt;br /&gt;
k8s&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;provider &amp;quot;kubernetes&amp;quot; {
  config_path = &amp;quot;~/.kube/config&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ucloud&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;provider &amp;quot;ucloud&amp;quot; {
  public_key  = &amp;quot;JInqRnkSY8eAmxKFRxW9kVANYThg1pcvjD2Aw5f5p&amp;quot;
  private_key = &amp;quot;IlJn6GlmanYI1iDVEtrPyt5R9noAGz41B8q5TML7abqD8e4YjVdylwaKWdY61J5TcA&amp;quot;
  project_id  = &amp;quot;org-tgqbvi&amp;quot;
  region      = &amp;quot;cn-bj2&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h6 id=&quot;定義&quot; tabindex=&quot;-1&quot;&gt;定義&lt;/h6&gt;
&lt;ol&gt;
&lt;li&gt;data&lt;br /&gt;
取得terraform以外的資訊，不同的proivder提供不同的data sources。&lt;br /&gt;
&lt;a href=&quot;https://registry.terraform.io/browse/providers&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;provider 列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;data &amp;quot;ucloud_security_groups&amp;quot; &amp;quot;default&amp;quot; {
  type = &amp;quot;recommend_web&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;resource&lt;br /&gt;
要建立的資源&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	resource &amp;quot;ucloud_eip&amp;quot; &amp;quot;web-eip&amp;quot; {
	  internet_type = &amp;quot;bgp&amp;quot;
	  charge_mode   = &amp;quot;bandwidth&amp;quot;
	  charge_type   = &amp;quot;dynamic&amp;quot;
	  name          = &amp;quot;web-eip&amp;quot;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;output&lt;br /&gt;
輸出&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;		output &amp;quot;eip&amp;quot; {
		  value = ucloud_eip.web-eip.public_ip
		} 
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;tfstate&quot; tabindex=&quot;-1&quot;&gt;狀態檔案(tfstate)&lt;/h4&gt;
&lt;p&gt;當terrform要執行變更時，會產生tfstate的檔案，&lt;br /&gt;
上面記載了目前雲上的資源狀態，此檔案不建議編輯，&lt;br /&gt;
當有任何資源變更時，會同步判斷目前雲上的資源狀態是否一致。&lt;br /&gt;
可使用以下指令，匯入目前雲端上的資源狀態&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; terraform import kubernetes_deployment.websocketclient default/websocketclient
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;kubernetes_deployment.websocketclient 為tf的資源名稱&lt;br /&gt;
default/websocketclient 是雲上的資源&lt;/p&gt;
&lt;p&gt;此tfstate的檔案是明碼，且多人使用會造成簽入時發生衝突，&lt;br /&gt;
所以要透過backend來解決這個問題&lt;/p&gt;
&lt;p&gt;檔案裏面會看到一些狀態，代表的意思如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; 代表新增的資源 (Resource added)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt; 代表刪除的資源 (Resource deleted)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt; 代表修改的資源 (Resource modified)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt; 代表資源參數的值沒有改變，只是調整了排序 (Resource parameter unchanged, only ordering changed)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-/+&lt;/code&gt; 同時出現，表示毀壞性變更，先刪除後建立&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/Terraform/148-fig.2.jpg&quot; alt=&quot;148-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.cloudskillsboost.google/focuses/15842?locale=zh_TW&amp;amp;parent=catalog&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用基礎架構即程式碼工具 Terraform&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;backend&quot; tabindex=&quot;-1&quot;&gt;遠端狀態儲存機制(Backend)&lt;/h4&gt;
&lt;p&gt;Terraform Remote Backend分為兩種：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;標準：支援遠端狀態儲存與狀態鎖
&lt;blockquote&gt;
&lt;p&gt;狀態鎖是指，當針對一個tfstate進行變更操作時，可以針對該狀態檔案新增一把全域鎖，確保同一時間只能有一個變更被執行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;增強：在標準的基礎上支援遠端操作(在遠端伺服器上執行plan、apply等操作)
&lt;blockquote&gt;
&lt;p&gt;只存在於Terraform Cloud&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前支援的backend list&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/Terraform/148-fig.1.jpg&quot; alt=&quot;148-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;要共用 backend的話，&lt;br /&gt;
先建立一個 backend.hcl&lt;br /&gt;
裏面輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   bucket  = &amp;quot;98c2c8-terraform-backend&amp;quot;
   prefix  = &amp;quot;terraform/state&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的prefix代表的意思為&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GCS prefix inside the bucket. Named states for workspaces are stored in an object called &lt;code&gt;&amp;lt;prefix&amp;gt;/&amp;lt;name&amp;gt;.tfstate&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在main.tf的required_providers後面填上 backend &amp;quot;gcs&amp;quot; { }，&lt;br /&gt;
格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;terraform {
  required_providers {
    google = {
      source = &amp;quot;hashicorp/google&amp;quot;
      version = &amp;quot;4.63.1&amp;quot;
    }
  }
  backend &amp;quot;gcs&amp;quot; {

  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後在初始化的時候，輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;terraform init -backend-config=backend.hcl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://lonegunmanb.github.io/introduction-terraform/2.2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html#backend%E9%85%8D%E7%BD%AE%E7%9A%84%E5%8A%A8%E6%80%81%E8%B5%8B%E5%80%BC&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Backend組態的動態賦值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.hashicorp.com/terraform/language/settings/backends/gcs&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;tf-gcs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;workspace&quot; tabindex=&quot;-1&quot;&gt;建立workspace&lt;/h4&gt;
&lt;p&gt;相比起多資料夾隔離的方式來說，基於Workspace的隔離更加簡單，只需要保存一份程式碼，在程式碼中不需要為Workspace編寫額外程式碼，用命令列就可以在不同工作區之間來回切換。&lt;/p&gt;
&lt;p&gt;下列指令分別爲，建立、列表、選擇及顯示目前的workspace&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;terraform workspace new qa
terraform workspace list
terraform workspace select qa
terraform worspace show

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://lonegunmanb.github.io/introduction-terraform/2.2.Terraform%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;狀態管理&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;terraform&quot; tabindex=&quot;-1&quot;&gt;檢查terraform 的計劃&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;terraform plan -out=out.tfplan
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;-out的指定計畫的輸出檔，確保您所檢閱的方案就是所套用的方案。&lt;br /&gt;
之後使用apply執行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;terraform apply out.tfplan
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立完成後，使用show看目前狀態&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;terraform show
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;count&quot; tabindex=&quot;-1&quot;&gt;count&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;舉例來說, 兩個VM是一隻狗一隻貓，&lt;a href=&quot;http://xn--dog-ww0f445bb75d.tf/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;那就是dog.tf&lt;/a&gt; &lt;a href=&quot;http://cat.tf/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;cat.tf&lt;/a&gt;&lt;br /&gt;
如果是兩隻狗 就可以寫一個 &lt;a href=&quot;http://dog.tf/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;dog.tf&lt;/a&gt;&lt;br /&gt;
裡面用&lt;br /&gt;
resources ec2&lt;br /&gt;
Count = 2&lt;br /&gt;
這樣&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;console&quot; tabindex=&quot;-1&quot;&gt;console&lt;/h3&gt;
&lt;p&gt;執行 console ，看程式執行結果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;terraform console 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;cidrsubnet 後面的第二個參數表示二進位要位移多少，第三個參數表示，要設定位移的數字為多少。&lt;/p&gt;
&lt;p&gt;例如 10  =  1010&lt;br /&gt;
位移4bit，所以是 1010 0000  = 160&lt;br /&gt;
6 =  0110&lt;br /&gt;
位移4bit ，所以是 0110 0000 = 96&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tf console
&amp;gt; cidrsubnet(&amp;quot;10.1.0.0/24&amp;quot;,4,0)
&amp;quot;10.1.0.0/28&amp;quot;
&amp;gt; cidrsubnet(&amp;quot;10.1.0.0/24&amp;quot;,4,10)
&amp;quot;10.1.0.160/28&amp;quot;
&amp;gt; cidrsubnet(&amp;quot;10.1.0.0/24&amp;quot;,4,6)
&amp;quot;10.1.0.96/28&amp;quot;
&amp;gt; cidrsubnet(&amp;quot;10.1.0.0/24&amp;quot;,4,12)
&amp;quot;10.1.0.192/28&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://ntwobike.medium.com/how-cidrsubnet-works-in-terraform-f6ccd8e1838f&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How cidrsubnet works in Terraform&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;variable&quot; tabindex=&quot;-1&quot;&gt;variable變數宣告&lt;/h3&gt;
&lt;p&gt;先知道變數的繼承順序，&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;種類&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;範例&lt;/th&gt;
&lt;th&gt;優先&lt;/th&gt;
&lt;th&gt;建議使用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;命令列參數&lt;/td&gt;
&lt;td&gt;輸入命令時，指定變數&lt;/td&gt;
&lt;td&gt;&lt;code&gt; tf apply -var=&amp;quot;gcp_region=asia-east&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;特殊情況&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;環境變數&lt;/td&gt;
&lt;td&gt;使用 TF_VAR_ 環境變數定義&lt;/td&gt;
&lt;td&gt;&lt;code&gt;TF_VAR_gcp_region=asia_east2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;變數文件&lt;/td&gt;
&lt;td&gt;使用tfvars變數文件定義&lt;/td&gt;
&lt;td&gt;&lt;code&gt;gcp_region=asia_east2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;開發者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;設定文件&lt;/td&gt;
&lt;td&gt;使用variables區塊定義&lt;/td&gt;
&lt;td&gt;&lt;code&gt;variable &amp;quot;gcp_region&amp;quot; {default = &amp;quot;asia-east1&amp;quot;}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;程式碼&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;tf的變數要先宣告，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-variable.tf&quot;&gt;variable &amp;quot;gcp_region&amp;quot; {
  default = &amp;quot;asia-east1&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果後續要改值，可以改成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-terraform.tfvars&quot;&gt;gcp_region = &amp;quot;asia-east2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要測試，可以執行 &lt;code&gt;terraform console&lt;/code&gt;&lt;br /&gt;
再輸入變數名稱驗證。&lt;/p&gt;
&lt;p&gt;變數文件載入方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;檔案名稱為 &lt;code&gt;terraform.tfvars&lt;/code&gt; or &lt;code&gt;terraform.tfvars.json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;副檔名為 &lt;code&gt;.auto.tfvars&lt;/code&gt; or &lt;code&gt;.auto.tfvars&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;必須在同一個&lt;code&gt;tf init&lt;/code&gt;的資料夾內。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/Terraform/148-fig.4.jpg&quot; alt=&quot;148-fig.4.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;還有其他載入方式，在apply 時載入變數檔，或是環境變數載入。&lt;br /&gt;
詳細參考&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://godleon.github.io/blog/DevOps/terraform-input-variables/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Terraform] Input Variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.oracle.com/zh-TW/learn/technical-articles/4-variables&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Terraform 變數&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Fn3M8ll5sC4&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;(Youtube)Terraform 從零開始 基礎 | 9-Variables（變數）的種類與使用順序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;常用指令&quot; tabindex=&quot;-1&quot;&gt;常用指令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tf console&lt;/code&gt; 可以經由這邊去驗證變數&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/Terraform/148-fig.3.jpg&quot; alt=&quot;148-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tf fmt&lt;/code&gt; &lt;a href=&quot;http://xn--main-kk0g674d1vo.tf/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;格式化main.tf&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;tf validate&lt;/code&gt; 驗證terraform&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/Terraform/148. Terraform的基本概念/" />
        </entry>
        <entry>
            <title>
                147. 用chatGPT學Terraform
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/Terraform/147. 用chatGPT學Terraform/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;終於要來試試看terraorm了，&lt;br /&gt;
現在公司好像很少全部k8s，&lt;br /&gt;
大部分還是用虛擬機，這樣變成還是要把terraform學一下。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h4 id=&quot;terraform-ansible&quot; tabindex=&quot;-1&quot;&gt;Terraform跟ansible的差異&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;差異點&lt;/th&gt;
&lt;th&gt;Terraform&lt;/th&gt;
&lt;th&gt;Ansible&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;組態檔案管理 vs 組態&lt;/td&gt;
&lt;td&gt;Terraform使用組態檔案管理基礎設施，描述其狀態，而不是配置。&lt;/td&gt;
&lt;td&gt;Ansible基於主機的管理，直接配置基礎設施。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可變基礎設施 vs 不可變基礎設施&lt;/td&gt;
&lt;td&gt;Terraform以可變的方式管理基礎設施，可以對基礎設施進行更改。&lt;/td&gt;
&lt;td&gt;Ansible通常將基礎設施視為不可變的，一旦配置，它們就不再更改。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;過程式的 vs 聲明式的&lt;/td&gt;
&lt;td&gt;Terraform是過程式的，會循序漸進地執行創建、修改和刪除操作。&lt;/td&gt;
&lt;td&gt;Ansible是聲明式的，描述了期望的最終狀態，而不是執行一系列步驟來實現它。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Master vs Masterless&lt;/td&gt;
&lt;td&gt;Terraform通常使用單一主節點管理基礎設施狀態。&lt;/td&gt;
&lt;td&gt;Ansible可以在主節點和無主節點（即agentless）模式下運行。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Agent vs Agentless&lt;/td&gt;
&lt;td&gt;Terraform不需要在目標基礎設施上安裝任何代理。&lt;/td&gt;
&lt;td&gt;Ansible需要在目標基礎設施上安裝一個代理。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;成熟 vs 前沿&lt;/td&gt;
&lt;td&gt;Terraform是成熟的基礎設施自動化工具，已被廣泛使用。&lt;/td&gt;
&lt;td&gt;Ansible是一個新興的基礎設施自動化工具，並且正在積極發展。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;綜合使用多種工具&lt;/td&gt;
&lt;td&gt;Terraform與其他工具集成，如Packer、Docker和AWS CloudFormation等。&lt;/td&gt;
&lt;td&gt;Ansible與其他工具集成，如Jenkins、Docker和Kubernetes等。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;安裝&quot; tabindex=&quot;-1&quot;&gt;安裝&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.hashicorp.com/terraform/downloads&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;官網&lt;/a&gt;安裝最快了，上面有各個平臺的安裝方式。&lt;/p&gt;
&lt;h4 id=&quot;詠唱&quot; tabindex=&quot;-1&quot;&gt;詠唱&lt;/h4&gt;
&lt;p&gt;我先問了一下chatGPT怎麼學Terraform，然後給了我很標準的答案。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;閱讀Terraform官方文檔，熟悉其基礎結構、功能和概念。&lt;/li&gt;
&lt;li&gt;安裝Terraform，並學習如何使用它來創建基礎設施。&lt;/li&gt;
&lt;li&gt;開始使用Terraform的示例項目，並嘗試使用它們創建簡單的基礎設施。&lt;/li&gt;
&lt;li&gt;學習如何使用Terraform管理不同的基礎設施提供者，如AWS、Azure、Google Cloud等。&lt;/li&gt;
&lt;li&gt;閱讀Terraform的模塊化文檔，並學習如何使用模塊化設計來管理複雜的基礎設施。&lt;/li&gt;
&lt;li&gt;學習如何使用Terraform命令列工具來測試和調試基礎設施代碼。&lt;/li&gt;
&lt;li&gt;研究Terraform的最佳實踐，包括如何管理機密、編寫可重用的代碼和設計可擴展的基礎設施。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我還是直接從實際案例來看好了，&lt;/p&gt;
&lt;p&gt;Q: 幫我建立一個部署deployment的terrform程式碼&lt;br /&gt;
A:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 定義Kubernetes provider
provider &amp;quot;kubernetes&amp;quot; {
  config_context_cluster = &amp;quot;my-cluster&amp;quot;
}

# 定義deployment
resource &amp;quot;kubernetes_deployment&amp;quot; &amp;quot;my_deployment&amp;quot; {
  metadata {
    name = &amp;quot;my-deployment&amp;quot;
    labels = {
      app = &amp;quot;my-app&amp;quot;
    }
  }

  spec {
    replicas = 3

    selector {
      match_labels = {
        app = &amp;quot;my-app&amp;quot;
      }
    }

    template {
      metadata {
        labels = {
          app = &amp;quot;my-app&amp;quot;
        }
      }

      spec {
        container {
          image = &amp;quot;my-image:latest&amp;quot;
          name  = &amp;quot;my-container&amp;quot;
        }
      }
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看了一下他提供的程式碼，有點問題，然後接着問&lt;br /&gt;
Q：resouce 宣告 kubernetes_deployment my_deployment 是要跟deployment的name一樣嗎&lt;br /&gt;
A:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;是的，&lt;code&gt;kubernetes_deployment&lt;/code&gt;的&lt;code&gt;metadata&lt;/code&gt;區塊中的&lt;code&gt;name&lt;/code&gt;屬性會定義Kubernetes deployment的名稱，您需要將其設定為與實際的deployment名稱相同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然後在後續的對談過程中，發現另一個指令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;terraform import 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再緊接着問，這個的功用是什麼。&lt;/p&gt;
&lt;p&gt;A:&lt;br /&gt;
&lt;code&gt;terraform import&lt;/code&gt;是Terraform提供的一個命令，用於將現有的資源引入Terraform管理的狀態中。使用&lt;code&gt;terraform import&lt;/code&gt;可以讓Terraform瞭解現有資源的狀態，並允許你使用Terraform管理這些資源，並在需要時進行更改。&lt;/p&gt;
&lt;p&gt;通常情況下，Terraform會從頭開始創建和管理所有資源。然而，在實際環境中，有時候會存在一些已經存在的資源，這些資源可能是手動創建的，或者是由其他工具創建的。這些資源可能包括Kubernetes deployment、AWS EC2實例、GCP虛擬機等等。在這種情況下，使用&lt;code&gt;terraform import&lt;/code&gt;命令可以將這些現有資源引入到Terraform管理的狀態中，以便Terraform能夠管理它們。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;terraform import&lt;/code&gt;命令時，需要指定要引入的資源的類型和ID，以及要對應到Terraform的哪個資源。Terraform將使用提供的資源類型和ID尋找現有資源的狀態，並將其對應到Terraform組態檔案中的相應資源。一旦資源成功被引入，Terraform就可以開始管理它們，並將它們的狀態保存到狀態檔案中，這樣就可以使用&lt;code&gt;terraform plan&lt;/code&gt;、&lt;code&gt;terraform apply&lt;/code&gt;等命令進行更改。&lt;/p&gt;
&lt;p&gt;如果不知道怎麼用沒關係，&lt;br /&gt;
再問一下，&lt;br /&gt;
Q：該怎麼使用terraform import&lt;br /&gt;
A：&lt;br /&gt;
使用&lt;code&gt;terraform import&lt;/code&gt;命令引入現有資源到Terraform管理的狀態中，通常需要以下步驟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在Terraform組態檔案中定義資源的組態，例如使用&lt;code&gt;kubernetes_deployment&lt;/code&gt;定義Kubernetes deployment的組態。&lt;/li&gt;
&lt;li&gt;執行&lt;code&gt;terraform init&lt;/code&gt;初始化Terraform，以設置Terraform的工作目錄和相關外掛。&lt;/li&gt;
&lt;li&gt;執行&lt;code&gt;terraform import&lt;/code&gt;命令引入現有資源。例如，要引入Kubernetes deployment，可以使用以下命令：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;terraform import kubernetes_deployment.systemservice deployment2k7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這裡的&lt;code&gt;kubernetes_deployment.systemservice&lt;/code&gt;指的是在Terraform組態檔案中定義的Kubernetes deployment資源，&lt;code&gt;deployment2k7&lt;/code&gt;則是現有Kubernetes deployment的名稱或ID。通過這樣的方式，Terraform就會將現有的Kubernetes deployment引入到Terraform管理的狀態中。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;檢查Terraform的狀態，使用&lt;code&gt;terraform state list&lt;/code&gt;命令可以列出Terraform目前管理的所有資源，可以確認引入的資源是否已經被成功管理。&lt;/li&gt;
&lt;li&gt;更新Terraform組態檔案，通過&lt;code&gt;terraform plan&lt;/code&gt;和&lt;code&gt;terraform apply&lt;/code&gt;命令對資源進行更改。當Terraform管理現有資源時，它會比較Terraform組態檔案和現有資源的狀態，並生成一個計劃，顯示要將資源帶到Terraform所需的更改。通過執行&lt;code&gt;terraform apply&lt;/code&gt;命令，Terraform就可以將這些更改應用到現有的資源中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h4&gt;
&lt;p&gt;光看沒有用，最重要的還是實作，&lt;br /&gt;
一開始沒碰terraform是不知道寫壞了，會不會影響線上的服務，&lt;br /&gt;
現在我能夠先import，看目前服務建設的程式後，再來修改。&lt;/p&gt;
&lt;h3 id=&quot;感想&quot; tabindex=&quot;-1&quot;&gt;感想&lt;/h3&gt;
&lt;p&gt;實作後完全崩掉，有很多東西還是要從頭開始看一下。&lt;br /&gt;
像是， terraform 的backend ，跟tfstate 這些觀念。&lt;br /&gt;
上面也有提到引入資源，但實際上可能跟你想得不太一樣，&lt;br /&gt;
引入後是變成一個tfstate，而不是tf，&lt;br /&gt;
那tf 跟 tfstate又有什麼不同呢？&lt;/p&gt;
&lt;p&gt;我們還是看下一篇，從頭來過吧。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kknews.cc/zh-tw/code/amvkzax.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;為什麼我們使用Terraform 而不使用Puppet, Ansible &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/Terraform/147. 用chatGPT學Terraform/" />
        </entry>
        <entry>
            <title>
                71.gitlab on GKE 災害還原筆記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/GKE/71.gitlab on GKE 災害還原筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;之前一直沒寫的gitlab yaml，再文章的最下方。&lt;br /&gt;
本片文章都是使用這個yaml做建立及佈署。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;Step 0.&lt;/p&gt;
&lt;p&gt;之前一直沒寫的gitlab yaml，再文章的最下方。&lt;br /&gt;
本片文章都是使用這個yaml做建立及佈署。&lt;/p&gt;
&lt;p&gt;Step 1.&lt;/p&gt;
&lt;p&gt;先參考上篇 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/GKE/70.%20GKE%20pvc%E9%82%84%E5%8E%9F/&quot;&gt;70. GKE pvc還原&lt;/a&gt;，建立好PVC。&lt;/p&gt;
&lt;p&gt;主要複製Gitlab的位置為&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: config
  mountPath: /etc/gitlab
- name: gitlab-data
  mountPath: /var/opt/gitlab/git-data
- name: postgres-data
  mountPath: /var/opt/gitlab/postgresql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由於我之前建立的image為 last版本（應該是快一年前的事），&lt;br /&gt;
這次我用last版本的話，版本超前太多，導致一直重開機。&lt;/p&gt;
&lt;p&gt;後來查我的gitlab版本為 14.0.1，&lt;br /&gt;
但裝上去後一直碰到這個錯誤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;relation &amp;quot;services&amp;quot; does not exist after upgrade to 14.2.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解決方式：&lt;br /&gt;
後來將版本升級到 14.1.1 後就好了。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gitlab.com/gitlab-org/omnibus-gitlab/-/issues/6352&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ERROR: relation &amp;quot;services&amp;quot; does not exist after upgrade to 14.2.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Step 2.&lt;/p&gt;
&lt;p&gt;用本來的帳號密碼能登入，沒問題。&lt;br /&gt;
增加新的git remote 位置，&lt;br /&gt;
然後試著推一個版本上去時，又出現錯誤了。這次比較好理解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;remote: HTTP Basic: Access denied&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解決方式：&lt;br /&gt;
跑去另一個空目錄，git clone ，會要輸入帳號密碼，輸入後就好了。&lt;/p&gt;
&lt;p&gt;Step 3.&lt;/p&gt;
&lt;p&gt;如果看過之前的文章，可能知道我有在用istio，&lt;br /&gt;
會碰到要用一個ip暴露不同的服務。&lt;/p&gt;
&lt;p&gt;解決方式：&lt;br /&gt;
external_url &amp;quot;http://{ip}/gitlab&amp;quot;&lt;br /&gt;
virtualservice直接改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spec:
  hosts: []
  http:
    - match:
        - uri:
            prefix: /gitlab
      name: gitlab
      route:
        - destination:
            host: gitlab-svc.default.svc.cluster.local
            port:
              number: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.gitlab.com/omnibus/settings/configuration.html#configure-a-relative-url-for-gitlab&quot; title=&quot;Permalink&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Configure a relative URL for GitLab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;gitlab-yaml&quot; tabindex=&quot;-1&quot;&gt;Gitlab yaml&lt;/h3&gt;
&lt;p&gt;現在也有&lt;a href=&quot;https://docs.gitlab.com/charts/installation/operator.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gitlab operator&lt;/a&gt;跟 &lt;a href=&quot;https://docs.gitlab.com/charts/installation/deployment.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;helm&lt;/a&gt; 可以做，有興趣的可以參考一下官方文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: gitlab-svc
spec:
  ports:
  - name: &amp;quot;web&amp;quot;
    port: 80
    targetPort: 80
  - name: &amp;quot;ssh&amp;quot;
    port: 22
    targetPort: 22
  - name: &amp;quot;ssl&amp;quot;
    port: 443
    targetPort: 443
  selector:
    io.kompose.service: web
    drone: gitlab
  type: LoadBalancer
  loadBalancerIP: 123.123.123.123
  loadBalancerSourceRanges:
  - 192.168.0.0/16
  - 172.16.0.0/12
  - 10.0.0.0/8


---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: gitlab
  labels:
    io.kompose.service: web
spec:
  replicas: 1
  selector:
    matchLabels:      
      io.kompose.service: web
  template:
    metadata:
      labels:
        io.kompose.service: web
    spec:
      containers:
      - env:
        - name: GITLAB_TIMEZONE
          value: Taipei
        - name: GITLAB_OMNIBUS_CONFIG
          value: |            
            external_url &amp;quot;http://123.123.123.123/gitlab&amp;quot;
            gitlab_rails[&#39;gitlab_default_projects_features_builds&#39;] = false
        image: gitlab/gitlab-ce:14.1.1-ce.0
        name: web
        ports:
        - containerPort: 80
        resources: {}
        volumeMounts:
        - name: config
          mountPath: /etc/gitlab
        - name: gitlab-data
          mountPath: /var/opt/gitlab/git-data
        - name: postgres-data
          mountPath: /var/opt/gitlab/postgresql
      restartPolicy: Always
      serviceAccountName: &amp;quot;&amp;quot;
      volumes:
      - name: config
        persistentVolumeClaim:
          claimName: gke-drone-web-claim0
      - name: gitlab-data
        persistentVolumeClaim:
          claimName: gke-drone-repository-data
      - name: postgres-data
        persistentVolumeClaim:
          claimName: gke-drone-gitlab-postgresql
      
        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PVC的建立，請參考&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/GKE/70.%20GKE%20pvc%E9%82%84%E5%8E%9F/&quot;&gt;70. GKE pvc還原&lt;/a&gt;，如要建立空的，&lt;br /&gt;
參考下方yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  creationTimestamp: null
  labels:
    io.kompose.service: web-claim0
  name: gke-drone-web-claim0
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
status: {}
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  labels:
    gitlab-data: gitlab
  name: gke-drone-repository-data
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 100Gi
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  labels:
    gitlab-data: postgresql
  name: gke-drone-gitlab-postgresql
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 100Gi  
 
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/GKE/71.gitlab on GKE 災害還原筆記/" />
        </entry>
        <entry>
            <title>
                70. GKE pvc還原
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/GKE/70. GKE pvc還原/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;之前的Gitlab建在GKE的公開叢集上，&lt;/p&gt;
&lt;p&gt;雖然有限定IP訪問，一直要改到私有叢集上，&lt;/p&gt;
&lt;p&gt;但一直沒時間動，現在終於有空弄了，首先要解決的是資料還原的問題。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;首先在GCE上面複製一個磁碟，&lt;br /&gt;
可以先從GKE上面的pod找到當初建立的pvc名稱，&lt;br /&gt;
再根據這個名稱去找。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/70-fig.1.jpg&quot; alt=&quot;70-fig.1.jpg&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/70-fig.2.jpg&quot; alt=&quot;70-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;再來就建立pv 跟 pvc了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: test-pv
  namespace: default
spec:
  # persistentVolumeReclaimPolicy: Delete
  storageClassName: &amp;quot;standard&amp;quot;
  capacity:
    storage: 300G
  accessModes:
    - ReadWriteOnce
  claimRef:
    namespace: default
    name: test-upload
  gcePersistentDisk:
    pdName: test-upload
    fsType: ext4
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: test-upload
  namespace: default
spec:
  storageClassName: &amp;quot;standard&amp;quot;
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 300G

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pv的 gcePersistentDisk ，是剛剛複製的硬碟名稱。&lt;/p&gt;
&lt;p&gt;將裡面的參數改一改，&lt;br /&gt;
要建立的 name,namespace,storage, claimRef ，&lt;br /&gt;
結束。&lt;/p&gt;
&lt;p&gt;deployment使用正常方式直接掛載即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  template:
    metadata:
      creationTimestamp: null
      labels:
        app: video-admin
        version: v1
    spec:
      containers:
      - name: video
        ...
        volumeMounts:
        - mountPath: /upload
          name: source
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      terminationGracePeriodSeconds: 30
      volumes:
      - name: source
        persistentVolumeClaim:
          claimName: test-upload
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是statefuleSet的話，&lt;br /&gt;
pv的名稱需要改成 statefulSet的命名規則。&lt;br /&gt;
statefulSet不會用到pvc。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;VC_TEMPLATE_NAME-STATEFULSET_NAME-REPLICA_INDEX
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;VC_TEMPLATE_NAME&lt;/code&gt;：新 PersistentVolumeClaim 模板的名稱。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;STATEFULSET_NAME&lt;/code&gt;：新 StatefulSet 的名稱。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;REPLICA_INDEX&lt;/code&gt;：StatefulSet 副本的索引。此示例使用的是 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;pvc-pv&quot; tabindex=&quot;-1&quot;&gt;注意，刪除pvc時，最好將pv也刪除，避免發生未知情況。&lt;/h3&gt;
&lt;p&gt;如碰到下圖情況，表示pv有問題，請刪除重建。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/70-fig.3.jpg&quot; alt=&quot;70-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/persistent-volumes/preexisting-pd&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;將原有永久性磁盤用作 PersistentVolume&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/concepts/persistent-volumes&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;永久性卷和動態預配&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/GKE/70. GKE pvc還原/" />
        </entry>
        <entry>
            <title>
                56. GKE記錄 nginx log
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/GKE/56. GKE記錄 nginx log/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;因前陣子被人用DDOS攻擊，&lt;/p&gt;
&lt;p&gt;然後公司有一個單位就跑出來了，說他們要nginx的log，&lt;/p&gt;
&lt;p&gt;發生當下才能作為分析用途。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;nginx 版本  1.21.4&lt;/p&gt;
&lt;p&gt;更改nginx config ，&lt;br /&gt;
將&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;       access_log  /dev/stdout   main;
        error_log /dev/stderr;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;放在  http 底下的 service內。&lt;/p&gt;
&lt;p&gt;這樣就會把log 訊息，使用標準輸出的方式列印到機器上。&lt;br /&gt;
GKE就能抓到記錄了。&lt;/p&gt;
&lt;p&gt;然後使用 ECK的filebeat ，預設是會去抓各個log的資料。&lt;br /&gt;
但前提是要有標準輸出，所以這邊就不用設定了。&lt;/p&gt;
&lt;p&gt;完整config 如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#user&quot;&gt;#user&lt;/a&gt;  nobody;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  &#39;$remote_addr - $remote_user [$time_local] , &#39;
                      &#39;http-host: &amp;quot;$http_host&amp;quot; , URL: &amp;quot;$request&amp;quot;  , request-status : &amp;quot;$status&amp;quot;  ,   &#39;
                      &#39;body-byte: $body_bytes_sent  ,http-referer: &amp;quot;$http_referer&amp;quot;  ,&#39;
                      &#39;user-agent: &amp;quot;$http_user_agent&amp;quot; , X-Forwarded-For : &amp;quot;$http_x_forwarded_for&amp;quot; ,  &#39;
                      &#39; request-time: &amp;quot;$request_time&amp;quot;  , response_time : &amp;quot;$upstream_response_time&amp;quot;  &#39;;




    sendfile        on;
    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#tcp_nopush&quot;&gt;#tcp_nopush&lt;/a&gt;     on;

    keepalive_timeout  65;

    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#gzip&quot;&gt;#gzip&lt;/a&gt;  on;
    
    server {
        listen 80;
        listen [::]:80;
        root   /app;
        listen 443 ssl;
        listen [::]:443 ssl;
        
        server_name _;

        ssl off;
        ssl_certificate /etc/nginx/nginxssl.crt;
        ssl_certificate_key /etc/nginx/nginxssl.key;

        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        ssl_prefer_server_ciphers on;

        access_log  /dev/stdout   main;
        error_log /dev/stderr;
       

        location / {
            try_files $uri /index.php$is_args$query_string;
        }
    
        location ~ &#92;.php$ {
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi_params;
        }
    }

}


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_36750623/article/details/85008043&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Nginx配置中的log_format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://benjr.tw/22380&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Linux – Nginx log 格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/weifeng1463/p/10277178.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;docker運行nginx為什麼要使用 daemon off&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/22541333/have-nginx-access-log-and-error-log-log-to-stdout-and-stderr-of-master-process&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Have nginx access_log and error_log log to STDOUT and STDERR of master process&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/GKE/56. GKE記錄 nginx log/" />
        </entry>
        <entry>
            <title>
                50.GKE workload Identity 實地演練
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/GKE/50.GKE workload Identity 實地演練/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;某位大神說，GKE使用 IAM的角色認證安全性不太夠，&lt;/p&gt;
&lt;p&gt;所以希望未來都改用這種，workload Ideneity，&lt;/p&gt;
&lt;p&gt;就開始了採坑之旅，是說這個坑沒想像中的深。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;查詢cluster是否有 workload Identity&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud container clusters describe yaboxxx-test -z asia-east1-b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/50-fig.1.jpg&quot; alt=&quot;50-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;建議最好直接加上地區，不然看錯誤訊息也是可以。&lt;br /&gt;
會說在某個地區找不到此cluster&lt;/p&gt;
&lt;p&gt;修改cluster ，啟用 Workload Identity&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud container clusters update istio-test -z asia-east1-b &#92;    --workload-pool=rd7-project.svc.id.goog
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改 node-pool&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud container node-pools update defaultpool -z asia-east1-b &#92;    --cluster=istio-test &#92;    --workload-metadata=GKE_METADATA
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果成功的話，會看到&lt;br /&gt;
GKE 中繼資料伺服器 ： 已啟用&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/50-fig.2.jpg&quot; alt=&quot;50-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;建立ns&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl create ns token-proxy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立kubernetes 帳號&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; kubectl create serviceaccount -n token-proxy proxy-user
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;申請 Google service accout的 IAM 服務帳號，&lt;br /&gt;
然後綁定 kubernetes service account 與 Google service account 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud iam service-accounts add-iam-policy-binding &#92;    --role roles/iam.workloadIdentityUser &#92;    --member &amp;quot;serviceAccount: project.svc.id.goog[token-proxy/proxy-user]&amp;quot; &#92;    token-proxy@rd7-project.iam.gserviceaccount.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/50-fig.3.jpg&quot; alt=&quot;50-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在 kubernet service account上面，增加註釋&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl annotate serviceaccount &#92;    --namespace token-proxy proxy-user &#92;    iam.gke.io/gcp-service-account=token-proxy@rd7-project.iam.gserviceaccount.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 Workload Identity&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/GKE/50.GKE workload Identity 實地演練/" />
        </entry>
        <entry>
            <title>
                44.srs 影音串流 on GKE
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/GKE/44.srs 影音串流 on GKE/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;首先介紹一下srs，這個就是一個影音串流，&lt;br /&gt;
本來是乖乖再用EFK on GKE，然後說網路有問題，&lt;br /&gt;
就又被抓去協助了，想裝死還不行 T_T  ，&lt;br /&gt;
我的東西還不夠多嗎  (╯‵□′)╯︵┴─┴&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;這次主要是協助除錯，&lt;br /&gt;
所以下面就直接列出碰到的問題點。&lt;br /&gt;
由於我沒玩過直撥，有些概念是後來才知道的。&lt;br /&gt;
也會順便列在下面。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;webrtc推流時，出現 getUserMedia  error&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要到chrome上面修改設定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.clarence.tw/wp-content/uploads/2020/10/%E6%88%AA%E5%9C%96-2020-10-29-%E4%B8%8B%E5%8D%8812.50.41-1024x653.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://blog.clarence.tw/2020/10/29/solve-the-undefined-problem-of-getusermedia/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;解決 ‘GETUSERMEDIA’ OF UNDEFINED 問題&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;rtmp 推拉&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;走TCP的協定&lt;br /&gt;
使用rtmp播放的話，所有的連線都會在伺服器上面留一份。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;webrtc播放&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要到srs 4.0.14以後的版本&lt;br /&gt;
有TCP跟 UDP的協定，&lt;br /&gt;
伺服器只負責對 直撥者跟觀看者做驗證，&lt;br /&gt;
webrtc，是直撥者跟觀看者直接連線，也就是點對點的連接方式。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.yasssssblog.com/2020/09/15/ithome-30-01-webrtc/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;何謂WebRTC&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;webrtc觀看方式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也是這一部分的網路架構，導致我不得不跳下去協助處理。&lt;br /&gt;
因為GKE的service 負載平衡目前還不支援混合的網路架構，&lt;br /&gt;
也就是TCP跟 UDP 混合使用。只能使用單一個協定。&lt;br /&gt;
所以沒辦法像傳統機器一樣，直接一個ip，同時開啟TCP跟UDP的網路協定。&lt;/p&gt;
&lt;p&gt;所以會變成 TCP 一個IP，UDP又是一個IP(fig.1)，&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/44-fig.1.jpg&quot; alt=&quot;44-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;此時在SRS上面的 Candidate ，必須要設定 *&lt;br /&gt;
然後再推流的時候，推流網址要更改成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;webrtc://35.2.3.1/live/ray123?eip=35.3.3.50
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;35.2.3.1 是 只開TCP的外網位置。&lt;br /&gt;
35.3.3.50 是 只開UDP的外網位置。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://github.com/ossrs/srs/wiki/v4_CN_WebRTC#config-candidate&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;v4_CN_WebRTC&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.cxymm.net/article/wltsysterm/119380486&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[SRS+docker]實現直播服務器 3 基於webRTC協議的srs低延遲直播研究_wltsysterm的博客-程序員秘密&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;其他參考文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;當然最好的方式，是把裡面的文件大約掃過一下。&lt;br /&gt;
但這資料有點多，我也只挑了幾個重點看。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ossrs/srs/wiki/v4_CN_K8s&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;v4_CN_K8S&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1588947&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;當SRS遇到K8s：如何實現高可用、回滾與灰度發布？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://shengyu7697.github.io/linux-nc/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 Linux nc 測試UDP有沒有通&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gitee.com/ossrs/srs/wikis/Home&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SRS全文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ossrs/srs/blob/4.0release/trunk/conf/full.conf&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SRS full.conf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/GKE/44.srs 影音串流 on GKE/" />
        </entry>
        <entry>
            <title>
                41.GKE節點無法自動縮小
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/GKE/41.GKE節點無法自動縮小/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;果然東西穩定之後，上面的都會想要costDown，&lt;br /&gt;
不過這也算是當初建立的人沒設定好，&lt;br /&gt;
會發生這個情況，後續也查明了，當初在每個節點上只允許放64個pod，&lt;br /&gt;
所以就算放滿，也吃不到那麼多。&lt;br /&gt;
但沒有自動縮小，這其實也是個問題，但要自動縮小，&lt;br /&gt;
還要看這個服務是否合適...。&lt;/p&gt;
&lt;p&gt;反正我之後反而沒在糾結這個狀況了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;最近發現一個東西，在GKE上面的節點，cpu分配很奇怪。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/41-fig.1.jpg&quot; alt=&quot;41-fig.1.jpg&quot; /&gt;&lt;br /&gt;
(fig.1)&lt;/p&gt;
&lt;p&gt;每個node的節點都只佔了一半的CPU就去開新的節點了。&lt;br /&gt;
本來懷疑是自動擴展有問題，&lt;br /&gt;
後來發現應該是自動縮小有問題。&lt;/p&gt;
&lt;p&gt;這個狀況在新建一個叢集，然後設定節點自動伸縮就會發生了。&lt;/p&gt;
&lt;p&gt;一般來說，節點只要沒有pod在裡面，大約只要十分鐘就會把多餘的節點移除了。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-autoscaler#how_cluster_autoscaler_works&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;集群自動擴縮程序的工作原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但新建了一個節點池，裡面都空的。他並沒有縮小到最小節點。&lt;/p&gt;
&lt;p&gt;詢問後得知，須先看一下log才能知道為什麼沒有自動縮小。&lt;/p&gt;
&lt;p&gt;首先開啟 GCP的日誌查看器，&lt;br /&gt;
a. 資源選擇 Kubernetes Cluster&lt;br /&gt;
b. 日誌類型列表選擇&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;container.googleapis.com/cluster-autoscaler-visibility
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;c. 再選擇要查看的cluster name&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/41-fig.2.jpg&quot; alt=&quot;41-fig.2.jpg&quot; /&gt;&lt;br /&gt;
(fig.2)&lt;/p&gt;
&lt;p&gt;d. 展開 noDecisionStatus&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/41-fig.3.jpg&quot; alt=&quot;41-fig.3.jpg&quot; /&gt;&lt;br /&gt;
(fig.3)&lt;/p&gt;
&lt;p&gt;看到錯誤了，就是這個害得pod無法自動縮減。&lt;br /&gt;
這邊的錯誤訊息是&lt;br /&gt;
node.pod.has.local.storage，&lt;br /&gt;
新建節點無法縮減會出現的錯誤訊息通常是&lt;br /&gt;
node.kube.system.unmovable&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/41-fig.4.jpg&quot; alt=&quot;41-fig.4.jpg&quot; /&gt;&lt;br /&gt;
(fig.4)&lt;/p&gt;
&lt;p&gt;碰到 node.pod.has.local.storage的解法是在deploy的yaml上面加上註釋，位置位於 metadata底下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;annotations:
	cluster-autoscaler.kubernetes.io/safe-to-evict: &amp;quot;true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/41-fig.5.jpg&quot; alt=&quot;41-fig.5.jpg&quot; /&gt;&lt;br /&gt;
(fig.5)&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/cluster-autoscaler-visibility#cluster-not-scalingdown&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;集群未縱向縮容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/63871413/how-to-make-sure-kubernetes-autoscaler-not-deleting-the-nodes-which-runs-specifi&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to make sure Kubernetes autoscaler not deleting the nodes which runs specific pod&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至於碰到 node.kube.system.unmovable 的解法，&lt;br /&gt;
需建立 PDB ，讓在 namespace 的 kube-system可以被驅逐。PDB是什麼可參考  &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/42.k8s%20PDB%EF%BC%88pod%E4%B8%AD%E6%96%B7%E9%A0%90%E7%AE%97%EF%BC%89/&quot;&gt;42.k8s PDB（pod中斷預算）&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl create poddisruptionbudget &amp;lt;pdb name&amp;gt; --namespace=kube-system --selector app=&amp;lt;app name&amp;gt; --max-unavailable 1

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要注意，selector的label不一定是app開頭，&lt;br /&gt;
要看各deploy裡面的設定。&lt;br /&gt;
最近碰到在GKE的kube-system裡面pod label，&lt;br /&gt;
反而是叫 k8s-app:kube-dns，selector可以隨意選擇，只要有辦法對到deploy即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/41-fig.6.jpg&quot; alt=&quot;41-fig.6.jpg&quot; /&gt;&lt;br /&gt;
(fig.6)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#how-to-set-pdbs-to-enable-ca-to-move-kube-system-pods&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How to set PDBs to enable CA to move kube-system pods?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但後來有發現一個問題，當解了一個 node.kube.system.unmovable ，後續可能會出現 node.pod.has.local.storage的問題，&lt;br /&gt;
這樣會變成必須針對每個deploy都額外做設定。&lt;/p&gt;
&lt;p&gt;所以最後我選擇了，直接手動驅逐節點內的pod，&lt;br /&gt;
但pdb的設定要先看一下，&lt;br /&gt;
istio在安裝時，ingressgateway會同時設定pdb，&lt;br /&gt;
當pod只有1個的時候，是沒辦法驅逐的，&lt;br /&gt;
所以最好是預設ingressgateway 為 2個pod，這樣才能避免pdb的干擾，而導致無法驅逐。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl drain [node-name] --force --ignore-daemonsets --delete-local-data
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;drain的參數&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--force&lt;/code&gt;&lt;br /&gt;
當一些pod不是經 ReplicationController, ReplicaSet, Job, DaemonSet 或者 StatefulSet 管理時&lt;br /&gt;
就需要用&lt;code&gt;--force&lt;/code&gt;來強制執行 (例如:&lt;strong&gt;kube-proxy&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--ignore-daemonsets&lt;/code&gt;&lt;br /&gt;
無視DaemonSet管理下的Pod&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--delete-local-data&lt;/code&gt;&lt;br /&gt;
如果有mount local volumn的pod，會強制殺掉該pod並把資料清除掉&lt;br /&gt;
另外如果跟本身的配置訊息有衝突時，drain就不會執行&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.nandiheath.com/2018/09/19/k8s-drain-pod-inside-node/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes中清空一個node的所有pod&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/tutorials/migrating-node-pool&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;文件-遷移工作負載&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/GKE/41.GKE節點無法自動縮小/" />
        </entry>
        <entry>
            <title>
                4. GKE使用GPU
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/GKE/4. GKE使用GPU/</id>
            <content type="html">
                &lt;h2 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;接了一個工作，要幫人在GKE上面生一個能夠使用GPU的叢集，並且佈署。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;要使用Google上面的 GPU，GKE版本要到1.9以上，&lt;br /&gt;
節點池要到1.11.3以上。&lt;br /&gt;
另外，GPU只支援通用N1的機器支援，其他細項 請詳閱 &lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/gpus?_ga=2.80461332.-2097975552.1599111033#availability&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Google 運行 GPU&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可用性建議先用&lt;br /&gt;
gcloud compute accelerator-types list&lt;br /&gt;
看一下你的區域支援哪些顯卡，&lt;br /&gt;
像我這邊的是  asia-east1-a ，就只支援特定顯卡。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/4.%20fig-1.jpg&quot; alt=&quot;4. fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;到 &lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/gpus?_ga=2.80461332.-2097975552.1599111033#installing_drivers&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;安裝 NVIDIA GPU 設備驅動程序&lt;/a&gt;，這邊基本上都沒問題。&lt;/p&gt;
&lt;p&gt;kubectl apply -f &lt;a href=&quot;https://raw.githubusercontent.com/GoogleCloudPlatform/container-engine-accelerators/master/nvidia-driver-installer/cos/daemonset-preloaded.yaml&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://raw.githubusercontent.com/GoogleCloudPlatform/container-engine-accelerators/master/nvidia-driver-installer/cos/daemonset-preloaded.yaml&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這主要會裝在每個節點上的Daemonset，當pod起來後，會自動在pod上面安裝驅動程式。&lt;br /&gt;
所以必須檢查一下，看pod是否有起來。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/4.%20fig-2.jpg&quot; alt=&quot;4. fig-2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;也可以執行&lt;br /&gt;
kubectl describe node -l &lt;a href=&quot;http://cloud.google.com/gke-accelerator&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;cloud.google.com/gke-accelerator&lt;/a&gt; | grep &lt;a href=&quot;http://nvidia.com/gpu&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;nvidia.com/gpu&lt;/a&gt;&lt;br /&gt;
看顯卡的使用情況&lt;/p&gt;
&lt;p&gt;當執行下一步驟&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/gpus?_ga=2.80461332.-2097975552.1599111033#pods_gpus&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;配置 Pod 以使用 GPU&lt;/a&gt;時，這邊就會有問題了。&lt;br /&gt;
他的image(nvidia/cuda:10.0-runtime-ubuntu18.04)會無法啟動，一直在crashLoopbackoff。&lt;/p&gt;
&lt;p&gt;更新&lt;br /&gt;
在12/24有開工單詢問，他們那邊給出了解法。後續應該會改他們的文件。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/4.%20fig-4.jpg&quot; alt=&quot;4. fig-4.jpg&quot; /&gt;&lt;br /&gt;
google的回覆如下&lt;/p&gt;
&lt;p&gt;按照文檔簡單使用“command: [&amp;quot;/bin/bash&amp;quot;]”測試。此時bash執行後立刻退出，故pod被重啟。&lt;br /&gt;
你們可以嘗試使用以下死循環避免這個問題：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        command: [ &amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;--&amp;quot; ]
        args: [ &amp;quot;while true; do sleep 600; done;&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以，可以改成下面的YAML，就能正常執行了。&lt;/p&gt;
&lt;p&gt;apiVersion: v1&lt;br /&gt;
kind: Pod&lt;br /&gt;
metadata:&lt;br /&gt;
name: gpu-pod&lt;br /&gt;
spec:&lt;br /&gt;
containers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name: digits-container&lt;br /&gt;
image: nvidia/cuda:10.0-runtime-ubuntu18.04&lt;br /&gt;
command: [ &amp;quot;/bin/sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;--&amp;quot; ]&lt;br /&gt;
args: [ &amp;quot;while true; do sleep 600; done;&amp;quot; ]&lt;br /&gt;
resources:&lt;br /&gt;
limits:&lt;br /&gt;
&lt;a href=&quot;http://nvidia.com/gpu:&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;nvidia.com/gpu:&lt;/a&gt; 1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下也可以使用&lt;br /&gt;
最後的解法是，不要用他的image。&lt;br /&gt;
完整 YAML&lt;/p&gt;
&lt;p&gt;apiVersion: v1&lt;br /&gt;
kind: Pod&lt;br /&gt;
metadata:&lt;br /&gt;
name: gpu-pod&lt;br /&gt;
spec:&lt;br /&gt;
containers:&lt;br /&gt;
- name: digits-container&lt;br /&gt;
image: nvidia/digits:6.0&lt;br /&gt;
resources:&lt;br /&gt;
limits:&lt;br /&gt;
&lt;a href=&quot;http://nvidia.com/gpu:&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;nvidia.com/gpu:&lt;/a&gt; 1&lt;/p&gt;
&lt;p&gt;佈署完後，執行&lt;br /&gt;
kubectl exec gpu-pod  -- nvidia-smi&lt;br /&gt;
這段話的意思是，在gpu-pod裡面執行 nvidia-smi的指令&lt;br /&gt;
正常的話，會顯示如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/4.%20fig-3.jpg&quot; alt=&quot;4. fig-3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;下面參考的文件，可以看看，但目前只需要做到上面那段『安裝 NVIDIA GPU 設備驅動程序』的指令即可&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://github.com/NVIDIA/k8s-device-plugin/issues/106&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;CrashLoopBackOff message wen running GPU Jobs example and others&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://gist.github.com/danisla/77afbb88f215d116f1905f723d3d879d&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GPU Sharing on GKE DaemonSet&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.hwchiu.com/gpu-gke.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Install GPU in GKE(Google Kubernetes Engine)（中）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查詢各有哪些VM使用GPU的指令&lt;br /&gt;
gcloud compute instances list --format=&amp;quot;table(guestAccelerators.acceleratorCount, name)&amp;quot;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/GKE/4. GKE使用GPU/" />
        </entry>
        <entry>
            <title>
                39.solrCloud的初體驗
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/GKE/39.solrCloud的初體驗/</id>
            <content type="html">
                &lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;傻瓜操作，都是在UI上面執行。&lt;br /&gt;
但solr都是使用api的方式做動作。&lt;br /&gt;
所以下面的操作改成api是也可行的。&lt;/p&gt;
&lt;h2 id=&quot;基本篇&quot; tabindex=&quot;-1&quot;&gt;基本篇&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;新增資料&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/39-fig.1.jpg&quot; alt=&quot;39-fig.1.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;查詢資料&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/39-fig.2.jpg&quot; alt=&quot;39-fig.2.jpg&quot; /&gt;&lt;br /&gt;
基本的查詢方式，&lt;br /&gt;
如果要查筆數的話，將rows 改成 0 ，就會列出所有筆數。&lt;br /&gt;
但不會顯示任何資料。&lt;/li&gt;
&lt;li&gt;刪除所有資料&lt;br /&gt;
如果要刪除單筆，只要修改條件即可&lt;br /&gt;
將 &lt;em&gt;:&lt;/em&gt; 改成要搜尋的條件，&lt;br /&gt;
(e.g. videoId: 28748)&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/39-fig.3.jpg&quot; alt=&quot;39-fig.3.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	&amp;lt;delete&amp;gt;&amp;lt;query&amp;gt;*:*&amp;lt;/query&amp;gt;&amp;lt;/delete&amp;gt;  
	&amp;lt;commit/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://www.itread01.com/content/1548988760.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;solr刪除資料的四種方法&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.w3cschool.cn/solr_doc&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Solr官方文檔&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;進階篇&quot; tabindex=&quot;-1&quot;&gt;進階篇&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查詢指令&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/39-fig.4.jpg&quot; alt=&quot;39-fig.4.jpg&quot; /&gt;&lt;br /&gt;
ref.&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/wbcg111/article/details/47863261&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Solr 查詢參數&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/496373/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;solr搜尋詳解&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.w3cschool.cn/solr_doc/solr_doc-kcas2fx9.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Solr查詢界面&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看collection的架構&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	http http://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/solr/&amp;lt;collectionName&amp;gt;/schema/fields
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://solr.apache.org/guide/6_6/schema-api.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Schema API&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;搜尋中文字，欄位結構 text_general vs string&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般我們搜尋中文要額外安裝中文分詞，這樣搜尋關鍵字的時候，才會正確。&lt;br /&gt;
沒裝的話，會有下面的情況。&lt;br /&gt;
例如，搜尋 『中文』 ，但這樣會將欄位裡面除了有『中文』的資料撈出來以外，還會將資料中有『中』的字取出。&lt;/p&gt;
&lt;p&gt;但後來同事有發現另一種解法，建立結構的時候，不能選擇 text_general，必須要選 string。&lt;/p&gt;
&lt;p&gt;如果使用string的話，要注意的是只接受完整的文字搜尋。也就是一串文字中，搜尋的關鍵字要完全符合才會顯示。&lt;/p&gt;
&lt;p&gt;而text_general，可接受部分的文字搜尋，但缺點就是搜尋中文時，會有上面的狀況。&lt;/p&gt;
&lt;p&gt;結構使用string的話，如果改使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	*中文*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這種搜尋方式，就只會搜尋資料中有『中文』關鍵字的資料，字串不會被拆開查詢。&lt;/p&gt;
&lt;p&gt;本來是要使用&lt;a href=&quot;https://wiki.shileizcc.com/confluence/pages/viewpage.action?pageId=40567076&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;中文分詞&lt;/a&gt;，但後來也不用了。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;solr的外掛套件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本來官方是提供&lt;a href=&quot;https://solr.apache.org/guide/6_6/adding-custom-plugins-in-solrcloud-mode.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;blob store API安裝套件&lt;/a&gt;，&lt;br /&gt;
但在 solrCloud 8.4 ，有多出了一個功能 package managr&lt;br /&gt;
可使用簡單且快速的方式安裝plugin。&lt;/p&gt;
&lt;p&gt;但因為上面的第三點，所以也不用研究這塊了。&lt;br /&gt;
留下一些參考網址，留着以後查詢。&lt;/p&gt;
&lt;p&gt;初步看都是在solr 啟動時要加一個指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-Denable.packages=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這個應該是在yaml佈署的時候，就要加上去了。&lt;br /&gt;
yaml佈署時，&lt;a href=&quot;https://kubernetes.io/zh/docs/tasks/inject-data-application/define-command-argument-container/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;為容器設置啟動時要執行的命令和參數&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也有在猜測，未來應該是可以直接使用 solr operator安裝的時候一並設定，但目前參數沒有看到，看未來會不會新增。&lt;a href=&quot;https://artifacthub.io/packages/helm/apache-solr/solr-operator/0.3.0&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Solr Operator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://solr.apache.org/guide/8_4/package-manager.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Package Management&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://solr.pl/en/2020/04/13/solr-8-4-0-plugin-management/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Solr 8.4.0 – Plugin Management&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sematext.com/blog/solr-plugins-system/#toc-solr-plugin-management-0&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Working with Solr Plugins System&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.w3cschool.cn/solr_doc/solr_doc-ez8q2i2v.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;在SolrCloud模式下添加自定義插件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/GKE/39.solrCloud的初體驗/" />
        </entry>
        <entry>
            <title>
                37.SolrCloud on GKE
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/GKE/37.SolrCloud on GKE/</id>
            <content type="html">
                &lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h2 id=&quot;solr&quot; tabindex=&quot;-1&quot;&gt;Solr的架構&lt;/h2&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.itread01.com/content/1550200885.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;淺談Solr叢集架構&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;完整架構&lt;br /&gt;
&lt;img src=&quot;https://solr.apache.org/images/operator/k8s-primary-components.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
SolrCloud是基於 Solr 與 &lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://daimom.github.io/404&quot;&gt;blog.36.分佈式系統-Zookeeper&lt;/a&gt;搜尋方案。&lt;/p&gt;
&lt;p&gt;特色功能有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集中式的配置資訊&lt;/li&gt;
&lt;li&gt;自動容錯&lt;/li&gt;
&lt;li&gt;近實時搜尋&lt;/li&gt;
&lt;li&gt;查詢時自動負載平衡&lt;/li&gt;
&lt;li&gt;自動分發&lt;/li&gt;
&lt;li&gt;日誌跟蹤&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;solrCloud的架構，可以看看以下幾篇。&lt;br /&gt;
ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://solr.apache.org/operator/articles/explore-v030-gke.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Exploring the Apache Solr Operator v0.3.0 on GKE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/Hello_World_QWP/article/details/98726379&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SolrCloud分佈式企業搜索引擎架構原理解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itread01.com/content/1548041589.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;solrCloud架構&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_41030039/article/details/100539704&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SolrCloud集群架構&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這邊直接開始安裝吧。&lt;/p&gt;
&lt;p&gt;首先確定你的電腦有helm ，我試著找有沒有單純可以用 kubectl apply的方式安裝，但沒找到。所以，用helm吧。&lt;br /&gt;
ref.&lt;a href=&quot;https://artifacthub.io/packages/helm/apache-solr/solr-operator&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;solr-operator&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先增加solr的倉庫&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	helm repo add apache-solr https://solr.apache.org/charts

	helm repo update	
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;安裝 solr-operator，指定安裝在 solr的 namespace，避免istio的istio-proxy安裝進去&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;
	kubectl create -f https://solr.apache.org/operator/downloads/crds/v0.3.0/all-with-dependencies.yaml

	helm install solr-operator apache-solr/solr-operator &#92;
  --version 0.3.0 --namespace solr

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;operator 安裝完成 (fig.1)&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/37-fig.1.jpg&quot; alt=&quot;37-fig.1.jpg&quot; /&gt;&lt;br /&gt;
(fig.1)&lt;br /&gt;
3. solrCloud.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: solr.apache.org/v1beta1
kind: SolrCloud
metadata:
  name: video
  namespace: solr
spec:
  customSolrKubeOptions:
    podOptions:
      resources:
        limits:
          memory: 3Gi
        requests:
          cpu: 700m
          memory: 3Gi
  dataStorage:
    persistent:
      pvcTemplate:
        spec:
          resources:
            requests:
              storage: 2Gi
      reclaimPolicy: Delete
  replicas: 3
  solrImage:
    repository: solr
    tag: 8.8.2
  solrJavaMem: -Xms500M -Xmx500M
  updateStrategy:
    method: StatefulSet
  zookeeperRef:
    provided:
      chroot: /explore
      image:
        pullPolicy: IfNotPresent
        repository: pravega/zookeeper
        tag: 0.2.9
      persistence:
        reclaimPolicy: Delete
        spec:
          accessModes:
          - ReadWriteOnce
          resources:
            requests:
              storage: 2Gi
      replicas: 3
      zookeeperPodPolicy:
        resources:
          limits:
            memory: 500Mi
          requests:
            cpu: 250m
            memory: 500Mi
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;佈署 solrCloud.yaml，這邊的系統資源要求頗高，資源不夠請多開一些cpu 或 memory。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;	kubectl apply -f solrCloud.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;由於我是直接佈署在istio上面，所以開啟網頁的話，我是直接新增 virtualService的設定。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kind: VirtualService
metadata:
  name: istio-virtualservice-tools
  namespace: tools
spec:
  hosts:
  - &amp;quot;*&amp;quot;
  gateways:
    - istio-gateway-tools.istio-system.svc.cluster.local
  http:
  - match:
        - uri:
            exact: /
        - uri:
            prefix: /solr
    name: solr
    route:
        - destination:
            host: video-solrcloud-common.solr.svc.cluster.local
            port:
              number: 80  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以直接在本機上使用port-forward轉發開啟網頁。如以下指令，開啟 網頁 &lt;a href=&quot;http://localhost:8080/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;http://localhost:8080&lt;/a&gt;   (fig.2)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	kubectl port-forward service/video-solrcloud-common -n solr 8080:80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/37-fig.2.jpg&quot; alt=&quot;37-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;solr-cloud&quot; tabindex=&quot;-1&quot;&gt;監控 solrCloud&lt;/h1&gt;
&lt;p&gt;本來的solrCloud舊有簡易的監控畫面了，&lt;br /&gt;
這部分是看記憶體的使用量。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/37-fig.3.jpg&quot; alt=&quot;37-fig.3.jpg&quot; /&gt;&lt;br /&gt;
但可有發現資料並不是非常得多。&lt;br /&gt;
之前在GKE的叢集上已經有架設prometheus了，&lt;br /&gt;
所以這次也要將資料丟進去prometheus裡面。&lt;/p&gt;
&lt;p&gt;這邊要先export solr的metric，&lt;br /&gt;
官方 github上面有建議的方法 ，但需安裝 prometheus operator。如果沒有安裝，prometheus 在探索metrics時，是找不到這個exporter的。&lt;br /&gt;
ref.&lt;a href=&quot;https://apache.github.io/solr-operator/docs/solr-prometheus-exporter/#deploy-prometheus-exporter-for-solr-metrics&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Deploy Prometheus Exporter for Solr Metrics&lt;/a&gt;，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: solr.apache.org/v1beta1
kind: SolrPrometheusExporter
metadata:
 labels:
   controller-tools.k8s.io: &amp;quot;1.0&amp;quot;
 name: explore-prom-exporter
 namespace: solr
spec:
 customKubeOptions:
   podOptions:
     resources:
       requests:
         cpu: 300m
         memory: 800Mi
 solrReference:
   cloud:
     name: &amp;quot;video&amp;quot;
 numThreads: 6
 image:
   repository: solr
   tag: 8.8.2
---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
 name: solr-metrics
 labels:
   release: prometheus-stack
spec:
 selector:
   matchLabels:
     solr-prometheus-exporter: explore-prom-exporter
 namespaceSelector:
   matchNames:
   - solr
 endpoints:
 - port: solr-metrics
   interval: 15s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因為我不想裝 prometheus operator，所以複製上面安裝的deploy yaml，自己產生一個solr exporter 的deploy跟 service給 prometheus抓資料。&lt;/p&gt;
&lt;p&gt;或許有人會問，為什麼不利用上面的部屬完後去修改service.yaml把&lt;br /&gt;
&lt;a href=&quot;http://prometheus.io/port:&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;prometheus.io/port:&lt;/a&gt; &amp;quot;80&amp;quot;&lt;br /&gt;
改成&lt;br /&gt;
&lt;a href=&quot;http://prometheus.io/port:&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;prometheus.io/port:&lt;/a&gt; &amp;quot;8080&amp;quot;&lt;br /&gt;
就好了。&lt;/p&gt;
&lt;p&gt;因為，改了後他會一直還原成舊的狀態。&lt;br /&gt;
這應該是 solrOperator的關係，會一直覆蓋手動修改的設定，因為我也找不到去修改增加solrOperator的設定，讓80改成8080，所以應該透過上面的  ServiceMonitor 來讓prometheus可以取得資料。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
 namespace: solr
 name: explore-prom-exporter
 annotations:
   deployment.kubernetes.io/revision: &amp;quot;1&amp;quot;
 # generation: 1
 labels:
   controller-tools.k8s.io: &amp;quot;1.0&amp;quot;
   solr-prometheus-exporter: explore-prom-exporter
   technology: solr-prometheus-exporter
spec:
 progressDeadlineSeconds: 600
 replicas: 1
 revisionHistoryLimit: 10
 selector:
   matchLabels:
     solr-prometheus-exporter: explore-prom-exporter
     technology: solr-prometheus-exporter
 strategy:
   rollingUpdate:
     maxSurge: 25%
     maxUnavailable: 25%
   type: RollingUpdate
 template:
   metadata:
     creationTimestamp: null
     labels:
       controller-tools.k8s.io: &amp;quot;1.0&amp;quot;
       solr-prometheus-exporter: explore-prom-exporter
       technology: solr-prometheus-exporter
   spec:
     containers:
     - args:
       - -p
       - &amp;quot;8080&amp;quot;
       - -n
       - &amp;quot;6&amp;quot;
       - -z
       - video-solrcloud-zookeeper-0.video-solrcloud-zookeeper-headless.solr.svc.cluster.local:2181,video-solrcloud-zookeeper-1.video-solrcloud-zookeeper-headless.solr.svc.cluster.local:2181,video-solrcloud-zookeeper-2.video-solrcloud-zookeeper-headless.solr.svc.cluster.local:2181/explore
       - -f
       - /opt/solr/contrib/prometheus-exporter/conf/solr-exporter-config.xml
       command:
       - /opt/solr/contrib/prometheus-exporter/bin/solr-exporter
       image: solr:8.8.2
       imagePullPolicy: IfNotPresent
       livenessProbe:
         failureThreshold: 3
         httpGet:
           path: /metrics
           port: 8080
           scheme: HTTP
         initialDelaySeconds: 20
         periodSeconds: 10
         successThreshold: 1
         timeoutSeconds: 1
       name: solr-prometheus-exporter
       ports:
       - containerPort: 8080
         name: solr-metrics
         protocol: TCP
       resources:
         requests:
           cpu: 300m
           memory: 800Mi
       terminationMessagePath: /dev/termination-log
       terminationMessagePolicy: File
     dnsPolicy: ClusterFirst
     restartPolicy: Always
     schedulerName: default-scheduler
     securityContext:
       fsGroup: 8080
     terminationGracePeriodSeconds: 10    

--- 

apiVersion: v1
kind: Service
metadata:
 namespace: solr
 name: explore-prom-exporter
 annotations:
   prometheus.io/path: /metrics
   prometheus.io/port: &amp;quot;8080&amp;quot;
   prometheus.io/scheme: http
   prometheus.io/scrape: &amp;quot;true&amp;quot;
 creationTimestamp: &amp;quot;2021-09-03T05:52:23Z&amp;quot;
 labels:
   controller-tools.k8s.io: &amp;quot;1.0&amp;quot;
   service-type: metrics
   solr-prometheus-exporter: explore-prom-exporter
spec:
 ports:
 - name: solr-metrics
   port: 80
   protocol: TCP
   targetPort: 8080
 selector:
   solr-prometheus-exporter: explore-prom-exporter
   technology: solr-prometheus-exporter
 sessionAffinity: None
 type: ClusterIP    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最後到prometheus看一下有沒有關於solr的資料(fig.4)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/GKE/37-fig.4.jpg&quot; alt=&quot;37-fig.4.jpg&quot; /&gt;&lt;br /&gt;
(fig.4)&lt;/p&gt;
&lt;p&gt;有資料了，但我們不知道要拿哪些metrics來作爲監控的資料，就先去grafana dashboard找找吧。&lt;br /&gt;
&lt;a href=&quot;https://grafana.com/grafana/dashboards/12456&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Solr Dashboard&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下載，匯入grafana收工。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://apache.github.io/solr-operator/docs/solr-prometheus-exporter/#deploy-prometheus-exporter-for-solr-metrics&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Solr Prometheus Exporter&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;結尾&quot; tabindex=&quot;-1&quot;&gt;結尾&lt;/h1&gt;
&lt;p&gt;再來就是，實際操作 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/GKE/39.solrCloud%E7%9A%84%E5%88%9D%E9%AB%94%E9%A9%97/&quot;&gt;39.solrCloud的初體驗&lt;/a&gt;了&lt;/p&gt;
&lt;p&gt;額外參考，雖然此連結已經不適用，但基本的安裝方式是可以參考。&lt;br /&gt;
&lt;a href=&quot;https://cloud.tencent.com/developer/article/1580031&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Running Solr on Kubernetes&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/GKE/37.SolrCloud on GKE/" />
        </entry>
        <entry>
            <title>
                76. k8s error,The node was low on resource..
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/76. k8s error,The node was low on resource../</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;之前發生過的，&lt;br /&gt;
prometheus會這樣、gitlab最近在弄新版的CI/CD也跑這個出來。&lt;br /&gt;
本來想要之後有空再解決，但最近被DDOS攻擊時，&lt;br /&gt;
發現監控的grafana會卡住，因為他的prometheus ram爆了~~&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/blog.76-fig.1.jpg&quot; alt=&quot;blog.76-fig.1.jpg&quot; /&gt;&lt;br /&gt;
從字面上看來，其實蠻好理解的，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The node was low on resource: memory. Container web was using 4236080Ki, which exceeds its request of 0.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;node的資源不夠了，container 使用量達到上限。&lt;/p&gt;
&lt;p&gt;最直覺的方式就是，資源不夠，那就加開資源阿。&lt;br /&gt;
但開資源前要先想一下，如果我開了，那未來資源就一定夠嗎？&lt;br /&gt;
開的資源又不一定是完全給prometheus用，他供應的是全體的pod。&lt;/p&gt;
&lt;p&gt;所以要先做的是，把 resources request 的加進去 pod裡面。&lt;br /&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;template:
  metadata:
    creationTimestamp: null
    labels:
      app: webhook
      version: v1
  spec:
    containers:
    - image: prom/prometheus:v2.28.0
      imagePullPolicy: Always
      name: prometheus
      ports:
      - containerPort: 80
        protocol: TCP
      resources:
        requests:
          cpu: 30m
          memory: 30Mi
        limits:
          memory: &amp;quot;128Mi&amp;quot;
          cpu: &amp;quot;500m&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊要特別注意 limit，當limit踩到上限時，這個pod就會被終止&lt;br /&gt;
，並引發記憶體不足(OOM)的錯誤。&lt;br /&gt;
所以 limit 要設嗎？？&lt;/p&gt;
&lt;p&gt;這邊要從掛載的服務去決定，&lt;br /&gt;
如果今天掛載的服務 ram的使用量通常不多，&lt;br /&gt;
那突然達到上限，是不是可以判斷這個服務有問題了，必須要重啟。&lt;/p&gt;
&lt;p&gt;但如果是使用prometheus，記憶體的量本來就會隨着metric的量而增加，&lt;br /&gt;
那就不適合加上去了，不然只會一直看到 記憶體不足的錯誤。&lt;/p&gt;
&lt;p&gt;後面的單位，可設定 Ki, Mi ,Gi...&lt;/p&gt;
&lt;p&gt;補充，&lt;/p&gt;
&lt;p&gt;當node資源不足時，刪除pod的先後順序為，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;沒有設定 request 跟 limit的 pod&lt;/li&gt;
&lt;li&gt;只要有pod設定 request 或 limit ，但使用的資源是比在資源上設置的請求還多。&lt;/li&gt;
&lt;li&gt;只要有pod設定 request 或 limit ，但使用的資源是比在資源上設置的請求還少。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h2&gt;
&lt;p&gt;先設定 request ，因node機器的擴展，是根據 request的值，&lt;br /&gt;
來判斷要不要增加node數量，如果沒設定request，&lt;br /&gt;
系統會認爲，沒有擴展的必要。就會導致前面的問題。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.padok.fr/en/blog/kubernetes-pods-evicted&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Why my pods are evicted on Kubernetes?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/scheduling-eviction/node-pressure-eviction/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;節點壓力驅逐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/configuration/manage-resources-containers/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;為容器管理資源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#how-does-scale-up-work&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;How does scale-up work?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/76. k8s error,The node was low on resource../" />
        </entry>
        <entry>
            <title>
                42.k8s PDB（pod中斷預算）
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/42.k8s PDB（pod中斷預算）/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;K8S真是 TXD博大精深......，&lt;/p&gt;
&lt;p&gt;沒想到再追&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/GKE/41.GKE%E7%AF%80%E9%BB%9E%E7%84%A1%E6%B3%95%E8%87%AA%E5%8B%95%E7%B8%AE%E5%B0%8F/&quot;&gt;41.GKE節點無法自動縮小&lt;/a&gt;的時候，會到這邊來。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;簡單來說，這個設定是用來避免pod被無預警的刪除。&lt;br /&gt;
當發生自願中斷的時候，讓此pod不會因為pod的數量過少，&lt;br /&gt;
而導致服務中斷。&lt;/p&gt;
&lt;p&gt;這個跟 HPA有點像，但HPA是根據設定，來決定pod要不要增加或減少。&lt;/p&gt;
&lt;p&gt;自願中斷通常是下面三種：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排空（drain）節點進行修復或升級&lt;/li&gt;
&lt;li&gt;從集群中排空節點以縮小集群（瞭解集群自動擴縮）。&lt;/li&gt;
&lt;li&gt;從節點中移除一個 Pod，以允許其他 Pod 使用該節點。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我們一般直接下指令看有哪些pdb在系統內&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get pdb -A
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/42-fig.1.jpg&quot; alt=&quot;42-fig.1.jpg&quot; /&gt;&lt;br /&gt;
(fig.1)&lt;/p&gt;
&lt;p&gt;建立pdb，主要有兩個參數 看是要設定 minAvailable (最小可用)或 maxUnavailable(最大不可用)。&lt;/p&gt;
&lt;p&gt;建完後，可以看一下ALLOWED DISRUPTIONS 這個欄位，&lt;br /&gt;
這個欄位表示目前該pod可以被中斷的pod數量。&lt;/p&gt;
&lt;p&gt;所以如果為0的話，您的自願中斷那些操作，&lt;br /&gt;
是不會動作的，會一直waiting，直到這個值不為0。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/workloads/pods/disruptions/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;干擾(Disruptions)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh/docs/tasks/run-application/configure-pdb/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;為應用程序設置干擾預算(Disruption Budget)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/10987576.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kubernetes之PDB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.itread01.com/content/1559872864.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kubernetes之PDB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/42.k8s PDB（pod中斷預算）/" />
        </entry>
        <entry>
            <title>
                27.K8s的節點選擇與污染
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/27.K8s的節點選擇與污染/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近碰到的問題，起因是單台的對外連線數過大，導致程式發生問題，無法再連線到外部網路。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;在 GCP網路對外的方式裡面有提到，對外連線時，如果是私有叢集會使用Cloud NAT，&lt;br /&gt;
本次的情形，是因為再該節點內，某一個deploy疑似將連線數吃滿，最近想通了，應該是節點數量的問題。&lt;/p&gt;
&lt;h2 id=&quot;node-selector&quot; tabindex=&quot;-1&quot;&gt;nodeSelector&lt;/h2&gt;
&lt;p&gt;所以要將某一個服務，獨立掛在單一的節點池上面。&lt;br /&gt;
最簡單的用法是  nodeSelector，在 spec.template.spec 的下一層。&lt;/p&gt;
&lt;p&gt;app : websocket  這個是label 在建立nodepool時，一併建立的。&lt;br /&gt;
也可在建立nodepool後，在手動新增label。當然也可以直接指定google賦予的label。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/27-fig.1.jpg&quot; alt=&quot;27-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  查詢label
  kubectl get nodes --show-label
  新增label
  kubectl label node &amp;lt;node name&amp;gt; &amp;lt;label&amp;gt;=&amp;lt;value&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tachingchen.com/tw/blog/kubernetes-assigning-pod-to-nodes/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes 分派 Pod 到指定節點&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;deploy的範例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: deployabc
spec:
  replicas: 10
  template:
    spec:
      .......
      nodeSelector:
        app: websocket
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/node-pools#deploy&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;將 Pod 部署到特定節點池&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/scheduling-eviction/assign-pod-node/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;將 Pod 分配給節點&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;節點污點&quot; tabindex=&quot;-1&quot;&gt;節點污點&lt;/h2&gt;
&lt;p&gt;剛上面有提到，deploy可以指定pod到特定的節點，但是當前面的節點滿了後，其他的deploy還是有可能會到特定的節點上。&lt;br /&gt;
k8s可以設定節點為 污點(Taint)，使此污染的節點，只能接受有容忍度的pod。&lt;/p&gt;
&lt;p&gt;污點的設定不能事後更新，所以要在一開始建立時就設定好。請注意(fig.2)的Taint。&lt;br /&gt;
另外建議統一由GKE的節點污點，從控制台建立或使用指令建立。&lt;br /&gt;
否則當node自動新增時，該節點並不會產生 Taits&lt;br /&gt;
設定時，要指定 key 與 value 以及 效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/27-fig.2.jpg&quot; alt=&quot;27-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;效果有以下三種：&lt;/p&gt;
&lt;p&gt;- NoSchedule：不能容忍此污點的 Pod 不會被調度到節點上；現有 Pod 不會從節點中逐出。&lt;br /&gt;
- PreferNoSchedule：Kubernetes 會避免將不能容忍此污點的 Pod 安排到節點上。&lt;br /&gt;
- NoExecute：如果 Pod 已在節點上運行，則會將該 Pod 從節點中逐出；如果尚未在節點上運行，則不會將其安排到節點上。&lt;/p&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/node-taints?hl=zh-cn#gcloud_1&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;用節點污點控制調度&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之後在deploy上面建立容忍(toleration)污點， 在 spec.template.spec 的下一層&lt;br /&gt;
其中 key 與 value 為自訂，效果請參考上面選擇。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: pod
metadata:
  name: deployabc
spec:
  replicas: 10
  template:
    spec:
		container:
	      .......
		tolerations:
		- key: &amp;quot;visible&amp;quot;
		  operator: &amp;quot;Equal&amp;quot;
		  value: &amp;quot;private&amp;quot;
		  effect: &amp;quot;NoExecute&amp;quot;
		  tolerationSeconds: 3600
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;補充，如果是舊的節點集區，在GKE上面，可以改使用這個label去選擇。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cloud.google.com/gke-nodepool: &amp;lt;節點池的名稱&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;toleration-seconds&quot; tabindex=&quot;-1&quot;&gt;tolerationSeconds不要亂設&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;當設定了以後，此pod就算符合條件，也會在特定時間內被驅逐後重建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在GKE的版本 &lt;code&gt;1.30.5-gke.1443001&lt;/code&gt; ，針對了某個deploy增加此設定，&lt;br /&gt;
然後他會每個小時砍掉pod，重建一次，但還會在相同的node上面。&lt;/p&gt;
&lt;p&gt;ref.&lt;br /&gt;
&lt;a href=&quot;https://kubernetes.io/zh/docs/concepts/scheduling-eviction/taint-and-toleration/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;污點和容忍度&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10221929&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;k8s進階篇（四）：Affinity and Anti-Affinity、Taints and Tolerations&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/27.K8s的節點選擇與污染/" />
        </entry>
        <entry>
            <title>
                254. StatefulSet呼叫pod的方法
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/254. StatefulSet呼叫pod的方法/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;延續上篇 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/252.%20k8s%E4%B8%AD%E7%9A%84pod%E5%91%BC%E5%8F%AB/&quot;&gt;252. k8s中的pod呼叫&lt;/a&gt; ，那篇文章中，&lt;br /&gt;
要直接去call statefulSet的pod，&lt;br /&gt;
透過ip反查，找到DNS，&lt;br /&gt;
但如果IP反查也找不到DNS呢？&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;在建立srs服務時，&lt;br /&gt;
根據之前的測試方式，提供RD 溝通的網址，&lt;br /&gt;
但上線時，一查 這個網址沒有指定，&lt;br /&gt;
IP也沒有對應的FQDN。&lt;/p&gt;
&lt;p&gt;於是，才發現是sts(StatefulSet的縮寫）的設定問題。&lt;br /&gt;
如果要直接跟sts的pod連線時，需要使用&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;headless service&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;無頭 Service 不使用虛擬 IP 地址和代理 組態路由和封包轉發；相反，無頭 Service 通過內部 DNS 記錄報告各個 Pod 的端點 IP 地址，這些 DNS 記錄是由叢集的 DNS 服務所提供的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要使用Headless service的話，則需設定 &lt;code&gt;clusterIP: none&lt;/code&gt;&lt;br /&gt;
但 sts指定的service name要指定是有設定 Headless service的service。&lt;/p&gt;
&lt;p&gt;sts.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: srs-edge
  namespace: srs-qa
spec:
  replicas: 2
  serviceName: srs-edge
  selector:
    matchLabels:
      app: srs-edge

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;service.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: srs-edge
  namespace: srs-qa
spec:
  clusterIP: None
  selector:
    app: srs-edge
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這樣就能夠使用 &lt;code&gt;&amp;lt;podName&amp;gt;.&amp;lt;serviceName&amp;gt;.&amp;lt;nameSpace&amp;gt;.svc.cluster.local&lt;/code&gt; 去呼叫pod了。&lt;/p&gt;
&lt;p&gt;不放心，可以參考上一篇&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/252.%20k8s%E4%B8%AD%E7%9A%84pod%E5%91%BC%E5%8F%AB/&quot;&gt;252. k8s中的pod呼叫&lt;/a&gt;用nslookup驗證FQDN&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;StatefulSet&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/254. StatefulSet呼叫pod的方法/" />
        </entry>
        <entry>
            <title>
                196. http健康度偵測
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/196. http健康度偵測/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近碰到一個怪問題，pod活得好好的，但裏面的服務就掛了。&lt;br /&gt;
因為我還能連進去pod裏面，裝一堆東西，但服務就真的沒辦法了。&lt;br /&gt;
只好，跟開發溝通，不然就弄個健康度偵測吧，&lt;br /&gt;
但要注意，一定要非常確定這個服務隨時重啓沒關係。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;livenessProbe:
  httpGet:
    path: /Info/LivenessCheck
    port: 80
    scheme: HTTP
  initialDelaySeconds: 120
  timeoutSeconds: 1
  periodSeconds: 5
  successThreshold: 1
  failureThreshold: 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;當http 回應的狀態碼是 200~400 的話，默認為正常。&lt;br /&gt;
不是這個以外的，就認爲失敗。&lt;/p&gt;
&lt;p&gt;上面的參數&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;initialDelaySeconds: pod啓動後幾秒才開始執行&lt;/li&gt;
&lt;li&gt;timeoutSeconds: timeout時間&lt;/li&gt;
&lt;li&gt;periodSeconds: 間隔幾秒呼叫一次&lt;/li&gt;
&lt;li&gt;successThreshold: 在檢查失敗後, 接下來要多少次連續判定成功才算成功&lt;/li&gt;
&lt;li&gt;failureThreshold: 失敗次數&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/learn-or-die/kubernetes-%E5%81%A5%E5%BA%B7%E6%AA%A2%E6%9F%A5-59ee2a798115&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes — 健康檢查&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;組態存活、就緒和啟動探針&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/196. http健康度偵測/" />
        </entry>
        <entry>
            <title>
                194. pod debug方式
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/194. pod debug方式/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;這陣子建了一個新環境，&lt;br /&gt;
然後pod在第一次啓動時，都會重啓，&lt;br /&gt;
但一旦重啓就看不到之前的log。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;log&quot; tabindex=&quot;-1&quot;&gt;看上一次的log記錄&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;kubectl logs {PODNAME} --previous
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其他用法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Return snapshot logs from pod nginx with only one container
kubectl logs nginx

# Return snapshot of previous terminated ruby container logs from pod web-1
kubectl logs -p -c ruby web-1

# Begin streaming the logs of the ruby container in pod web-1
kubectl logs -f -c ruby web-1

# Display only the most recent 20 lines of output in pod nginx
kubectl logs --tail=20 nginx

# Show all logs from pod nginx written in the last hour
kubectl logs --since=1h nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref .&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@tasslin/k8s%E5%A6%82%E4%BD%95%E6%96%B9%E4%BE%BF%E6%9F%A5%E6%89%BE%E4%BA%8B%E4%BB%B6%E7%99%BC%E7%94%9F%E6%88%96%E6%98%AF%E5%8F%96%E5%BE%97%E5%B7%B2%E6%B6%88%E9%80%9D%E7%9A%84log%E7%B4%80%E9%8C%84-8bb7ee2505f8&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;K8s如何方便尋找事件發生或是取得已消逝的LOG紀錄&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jamesdefabia.github.io/docs/user-guide/kubectl/kubectl_logs/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kubectl logs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;pod&quot; tabindex=&quot;-1&quot;&gt;連進去pod裏面監控&lt;/h3&gt;
&lt;p&gt;有時會碰到這個pod沒有權限可以安裝htop或 top等等，&lt;br /&gt;
這些看系統效能的東西，&lt;br /&gt;
此時可以透過這種方式，直接外掛一個debug的image，&lt;br /&gt;
就能隨便你亂搞了，還不怕會影響到正在執行的pod。&lt;/p&gt;
&lt;p&gt;下面指令的意思是，連去 filebeat的pod。&lt;br /&gt;
如果要指定container的話，增加 &lt;code&gt;--target=filebeat&lt;/code&gt;的指令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    kubectl debug -it &#92;
    --container=debug-container &#92;
    --image=alpine &#92;
    filebeat-beat-filebeat-bcb666b79-vm6dt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://medium.com/datamindedbe/debugging-running-pods-on-kubernetes-2ba160c47ef5&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Debugging Running Pods on Kubernetes&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/194. pod debug方式/" />
        </entry>
        <entry>
            <title>
                192. 自建的k8s拉取private registry
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/192. 自建的k8s拉取private registry/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;開發環境上，之前拉得都是另一個專案的registry，&lt;br /&gt;
現在有個全新的專案，理所當然image應該拉去另一個地方的GAR。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;首先到IAM裏面，申請一個ServiceAccount，&lt;br /&gt;
然後給權限，可以只給 &lt;code&gt;Artifact Registry讀取者&lt;/code&gt;就好。&lt;br /&gt;
然後產生金鑰，名稱為&lt;code&gt;gar-push-bms.json&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/192-fig.1.jpg&quot; alt=&quot;192-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;建立screct，名稱取名爲&lt;code&gt;gar-pull&lt;/code&gt;&lt;br /&gt;
stackoverflow的說明指出，該email是沒在用的，所以可以隨便打。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubectl create secret docker-registry gar-pull &#92;
  --docker-server &amp;quot;https://asia-east1-docker.pkg.dev&amp;quot; &#92;
  --docker-username _json_key &#92;
  --docker-email gar-pull@.iam.gserviceaccount.com &#92;
  --docker-password=&amp;quot;$(cat gar-push-bms.json)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;deployment的yaml設定&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;  imagePullSecrets:
  - name: gar-pull
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;記得，如果在不同的namespace，需重新建立新的secret。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/36283660/creating-image-pull-secret-for-google-container-registry-that-doesnt-expire&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Creating image pull secret for google container registry that doesn&#39;t expire?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/artifact-registry/docs/docker/authentication?hl=zh-cn#linux-macos&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;為 Docker 設定身份驗證&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/192. 自建的k8s拉取private registry/" />
        </entry>
        <entry>
            <title>
                190. cert-manager安裝
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/190. cert-manager安裝/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;上次開新專案的延伸，&lt;br /&gt;
設定domain時，對於cloudflare不夠熟，&lt;br /&gt;
還好有個前端同事，熟此門路，因爲他也踩過。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h2 id=&quot;cert-manager&quot; tabindex=&quot;-1&quot;&gt;安裝cert-manager&lt;/h2&gt;
&lt;p&gt;參照&lt;a href=&quot;https://cert-manager.io/docs/installation/kubectl/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;官網&lt;/a&gt;說明。&lt;/p&gt;
&lt;p&gt;下面語法不一定是最新的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.3/cert-manager.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再來就是建立  &lt;code&gt;ClusterIssuer&lt;/code&gt; 跟 &lt;code&gt;Certificate&lt;/code&gt;&lt;br /&gt;
在此之前，要先到cloudflare產生一組token，&lt;br /&gt;
才有權限對這個domain做驗證。&lt;/p&gt;
&lt;p&gt;我的domain是在cloud domain購買，然後再cloudflare託管。&lt;br /&gt;
為什麼不直接在google cloud託管，我也不知道，之前就這樣了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;User Profile &amp;gt; API Tokens &amp;gt; API Tokens&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/190-fig.1.jpg&quot; alt=&quot;190-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/190-fig.2.jpg&quot; alt=&quot;190-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;參照官方文件，設定權限，取得token&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/190-fig.3.jpg&quot; alt=&quot;190-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;將token存到 secret&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: Secret
metadata:
  name: cloudflare-api-token-ezio-com
  namespace: cert-manager
type: Opaque
stringData:
  api-token: &amp;lt;token&amp;gt;
---
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: cloudflare-issuer-ezio-com
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    privateKeySecretRef:
      name: cloudflare-issuer-ezio-com
    solvers:
    - dns01:
        cloudflare:
          email: ezio@abc.com
          apiTokenSecretRef:
            name: cloudflare-api-token-ezio-com
            key: api-token
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: ezio-com-tls
  namespace: istio-system
spec:
  secretName: ezio-com-tls
  issuerRef:
    name: cloudflare-issuer-ezio-com
    kind: ClusterIssuer
  commonName: &amp;quot;*.ezio.com&amp;quot;
  dnsNames:
    - &amp;quot;*.ezio.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這邊注意一下，檔案之間的關聯性。&lt;br /&gt;
上面寫的範例domain是 &lt;code&gt;*.ezio.com&lt;/code&gt; ，請改爲自己實際使用的。&lt;/p&gt;
&lt;p&gt;部署上去後，檢查狀態，有沒有Ready，通常不會超過5分鐘。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get certificate -A
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/190-fig.4.jpg&quot; alt=&quot;190-fig.4.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果啓動失敗的話，使用下面指令檢查log&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl describe certificate ezio-com-tls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是下面這個失敗訊息，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Found no Zones for domain _acme-challenge.aplusmanagex.com. (neither in the sub-domain nor in the SLD) please make sure your domain-entries in the config are correct and the API key is correctly setup with Zone.read rights.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;表示你的token沒有相關權限，這個坑我踩完了orz。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cert-manager.io/docs/configuration/acme/dns01/cloudflare/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Cloudflare&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cert-manager.io/docs/installation/kubectl/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kubectl apply&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/190. cert-manager安裝/" />
        </entry>
        <entry>
            <title>
                172. 自建k8s版本升級
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/172. 自建k8s版本升級/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡唸&quot; tabindex=&quot;-1&quot;&gt;睡睡唸&lt;/h1&gt;
&lt;p&gt;有人說他要測試&lt;a href=&quot;https://airensoft.com/ome.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;OME(OverMediaEngine)&lt;/a&gt;，串流直播軟體，說比&lt;a href=&quot;https://github.com/ossrs/srs&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SRS&lt;/a&gt;好一些，但自建的k8s版本不夠，不能上gateway API，所以升級吧。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;更新前請先確認版本更新後，你的服務不會掛掉。&lt;br /&gt;
更新大版本時，會有API棄用的狀況， &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/162.%E6%9F%A5%E8%A9%A2%E5%B7%B2%E6%A3%84%E7%94%A8%E7%9A%84API/&quot;&gt;162.查詢已棄用的API&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;目標&quot; tabindex=&quot;-1&quot;&gt;目標&lt;/h2&gt;
&lt;p&gt;更新k8s的master一臺與node兩臺的版本&lt;/p&gt;
&lt;h2 id=&quot;步驟&quot; tabindex=&quot;-1&quot;&gt;步驟&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;查詢目前的版本&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kuberctl version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（這是目前版本，升級當時的版本為1.22.?)&lt;br /&gt;
server的版本為1.25.14&lt;/p&gt;
&lt;blockquote Major:1,=&quot;&quot; Minor:25,=&quot;&quot; GitVersion:v1.25.14,=&quot;&quot; GitCommit:a5967a3c4d0f33469b7e7798c9ee548f71455222,=&quot;&quot; GitTreeState:clean,=&quot;&quot; BuildDate:2023-09-13T09:04:55Z,=&quot;&quot; GoVersion:go1.20.8,=&quot;&quot; Compiler:gc,=&quot;&quot; Platform:linuxamd64=&quot;&quot;&gt;
&lt;p&gt;Server Version:  &lt;a href=&quot;http://version.info/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;version.Info&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;升級kubeadm&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# 查看所有可用的kubeadm的版本
yum list --showduplicates kubeadm --disableexcludes=kubernetes
# 然後升級kubeadm的版本到1.23.0
yum install -y kubeadm-1.23.0-0 --disableexcludes=kubernetes
# 查看kubeadm版本
kubeadm version
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;升級master控制&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kubeadm upgrade plan
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/172-fig.1.jpg&quot; alt=&quot;172-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;這邊碰到一個問題，我本來只想升級到1.23.0，&lt;br /&gt;
但上面這張圖，他要求直接到1.23.17，&lt;br /&gt;
不照做行不行，『不行』，升級會出錯。&lt;/p&gt;
&lt;p&gt;所以回到第二步，再度更新kubeadm到1.23.17&lt;/p&gt;
&lt;p&gt;再來一次&lt;code&gt;kubeam upgrade plan&lt;/code&gt;&lt;br /&gt;
這次沒出現警告了&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/172-fig.2.jpg&quot; alt=&quot;172-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;執行上面執行完&lt;code&gt;upgrade plan&lt;/code&gt;提供升級指令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kubeadm upgrade apply v1.23.17 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成後會看到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SUCCESS! Your cluster was upgraded to &amp;quot;v1.23.17&amp;quot;. Enjoy!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/172-fig.3.jpg&quot; alt=&quot;172-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;升級kubectl 與 kubelet&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;查看目前節點版本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kubectl get node -o wide
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;驅逐當下節點的pod（這段與參考來源的指令不一樣，這個比較暴力）&lt;br /&gt;
$master為節點的名稱&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kubectl drain --force --ignore-daemonsets --delete-local-data --grace-period=10 &amp;quot;$master&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等驅逐完後，確認node為&lt;code&gt;SchedulingDisabled&lt;/code&gt;狀態，就可已開始升級了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;yum install -y kubelet-1.23.17-0 kubectl-1.23.17-0 --disableexcludes=kubernetes
# 重啓服務
sudo systemctl daemon-reload
sudo systemctl restart kubelet

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查詢node版本是否已經更新，然後解除封鎖。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kubectl uncordon $node
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;升級node的版本&lt;br /&gt;
重複第四步驟，只有更新那一段&lt;code&gt;yum install....&lt;/code&gt;需要到目標的node機器上做。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以指令如下&lt;br /&gt;
$node為要更新的node主機&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# master主機
kubectl drain --force --ignore-daemonsets --delete-local-data --grace-period=10 &amp;quot;$node&amp;quot;
# node主機
yum install -y kubelet-1.23.17-0 kubectl-1.23.17-0 --disableexcludes=kubernetes
# 重啓服務
sudo systemctl daemon-reload
sudo systemctl restart kubelet
# master主機
kubectl uncordon $node
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://tinychen.com/20221224-k8s-12-kubeadm-upgrade-cluster/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;k8s系列12-kubeadm升級k8s叢集 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Upgrading kubeadm clusters&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/172. 自建k8s版本升級/" />
        </entry>
        <entry>
            <title>
                162.查詢已棄用的API
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/162.查詢已棄用的API/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;這件事說來突然，&lt;br /&gt;
某一天我就發現在GKE上面出現了警告訊息，&lt;br /&gt;
說我的GKE仍在使用已棄用的API，&lt;br /&gt;
但我搬到1.25版本已經是一個多月前的事情了，&lt;br /&gt;
也沒聽到有人在說服務掛掉，&lt;br /&gt;
百思不得其解。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/162-fig.1.jpg&quot; alt=&quot;162-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;再來使用了 &lt;a href=&quot;https://github.com/doitintl/kube-no-trouble&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kubent&lt;/a&gt; ，來尋找到底是哪一個服務卡住，&lt;br /&gt;
但很遺憾的都沒有搜尋到。&lt;/p&gt;
&lt;p&gt;過了幾天後，發現之前拿來測試的QA環境，&lt;br /&gt;
也跳出來了已棄用API警告通知。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/162-fig.2.jpg&quot; alt=&quot;162-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;發現GKE就有提示是什麼呼叫的了，&lt;br /&gt;
在QA環境很清楚的寫着kubent，&lt;br /&gt;
但本來的那個呢？&lt;br /&gt;
只有 v2.1.0 ，&lt;br /&gt;
於是根據這個關鍵字去找哪個image有這個版本號。&lt;/p&gt;
&lt;p&gt;在kube-state-metric上面找到了這個關鍵字，&lt;br /&gt;
這也符合為什麼出錯了沒人知道，&lt;br /&gt;
因爲沒人看（？）&lt;br /&gt;
但因爲metric來源有至少三套，所以不好發現。&lt;br /&gt;
不過這個前任建置的也有點奇怪，&lt;br /&gt;
我查了官方的&lt;a href=&quot;https://github.com/kubernetes/kube-state-metrics&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kube-state-metrics&lt;/a&gt;，&lt;br /&gt;
沒找到有用sts建立過的方式，&lt;br /&gt;
有點神奇。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/162-fig.3.jpg&quot; alt=&quot;162-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;先拿QA來驗證改改看了，&lt;br /&gt;
看後續會不會再跳出來警告&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/162.查詢已棄用的API/" />
        </entry>
        <entry>
            <title>
                151. kubeadm重新產生驗證
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/151. kubeadm重新產生驗證/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;事情發生在某一天，&lt;br /&gt;
突然有個人跑來跟我說，他該怎麼連樓上自建的k8s，&lt;br /&gt;
那時在處理其他東西，就說我等等給你。&lt;br /&gt;
再來，突然發現我自己連不上去，一直跳錯誤。&lt;br /&gt;
unable to connect to server: x509: certificate has expired or is not yet valid&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;使用openLen連線時，出現錯誤。當下認爲應該是金鑰有問題，&lt;br /&gt;
但那臺機器應該很久沒動了，當初k8s也不是我架起來的，&lt;br /&gt;
頭痛阿。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;proxy_server.go:147 Error while proxying request: x509: certificate has expired or is not yet valid&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;從這篇&lt;a href=&quot;https://blog.51cto.com/u_13963804/6055113&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;K8S自建叢集更換證書&lt;/a&gt;知道了一件事情&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通過kubeadm自建的叢集，初始化後會生成一年的證書，簽發的CA證書有效期默認是10年，簽發的apiserver證書有效期默認是1年&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再問一下其他單位的同事，那個環境是不是已經架一年了？&lt;br /&gt;
結果出來，差不多一年了，那可以判斷是金鑰過期，但還是必須到機器裏面檢查一下。&lt;/p&gt;
&lt;p&gt;用ssh或任意方式連到master主機上，&lt;br /&gt;
視權限變更使用者，&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;strong&gt;我在執行kubeadm的時候，全程使用root的帳號&lt;/strong&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;檢查憑證到期日&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;kubeadm certs check-expiration
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;發現真的過期了，重建吧。&lt;br /&gt;
參考下面連結發現有點問題，可能是因為版本有更新。&lt;br /&gt;
ref. &lt;a href=&quot;https://juejin.cn/post/7068909995701567501&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;解決kubernetes證書過期問題&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;kubeadm certs renew # 這樣有問題，會發生錯誤
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;kubeadm missing subcommand; &amp;quot;renew&amp;quot; is not meant to be run on its own&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查詢&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/kubeadm-certs/#cmd-certs-renew&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;官方文件&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;kubeadm certs renew all
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行完成後，在檢查一次到期日，是否已經變更。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;kubeadm certs check-expiration
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但此時還是沒辦法連線，需更新kube config，&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;strong&gt;這邊使用一般使用者帳號&lt;/strong&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mv config config.old 
cp -i /etc/kubernetes/admin.conf $HOME/.kube/config 
chown $(id -u):$(id -g) $HOME/.kube/config 
sudo chmod 644 $HOME/.kube/config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;p.s 上面的文章說要重啟kube-apiserver,kube-controller,kube-scheduler,etcd 這四個容器，但我沒重啓，因為我這台master主機根本沒找到docker，這部分我也很疑惑。&lt;br /&gt;
但一切都正常了，就先這樣吧。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;結尾&quot; tabindex=&quot;-1&quot;&gt;結尾&lt;/h3&gt;
&lt;p&gt;如果要從其他地方連到k8s master，檔案就在&lt;code&gt;/etc/kubernetes/admin.conf&lt;/code&gt;裏面了。&lt;br /&gt;
不過官方強烈建議，不要將admin.conf與其他人共享。&lt;br /&gt;
最好是另外開一個使用者，&lt;br /&gt;
這部分我研究下，改天在寫篇文章了吧&lt;/p&gt;
&lt;p&gt;相關資訊：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 kubeadm 進行憑證管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/setup/best-practices/certificates/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; PKI 證書和要求&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/151. kubeadm重新產生驗證/" />
        </entry>
        <entry>
            <title>
                144. k8s 的sercret複製
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/144. k8s 的sercret複製/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;本地的k8s機器，要去google artifact registry pull image ，發現沒權限。&lt;br /&gt;
以前的權限在namespace的 default上面，&lt;br /&gt;
default太肥了，實在不想再往那邊塞，&lt;br /&gt;
要麻自己創個SA再把json丟去驗證，&lt;br /&gt;
不然看能不能把舊的拿來用。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;複製&quot; tabindex=&quot;-1&quot;&gt;複製&lt;/h3&gt;
&lt;p&gt;參考  &lt;a href=&quot;https://fabianlee.org/2021/04/09/kubernetes-copying-a-secret-from-one-namespace-to-another/&quot; title=&quot;Kubernetes: copying a secret from one namespace to another&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes: copying a secret from one namespace to another&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get secret my-tlssecret --namespace=default -o yaml | sed &#39;s/namespace: .*/namespace: gameservice/&#39; | kubectl apply -f -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本來my-tlssecret 在 defaul上 ，要改到gamerservice&lt;/p&gt;
&lt;p&gt;這樣就不用再申請一個sa帳號搞認證了，&lt;br /&gt;
如果要從頭開始的話，&lt;br /&gt;
參考google官方文件&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/artifact-registry/docs/docker/authentication?hl=zh-cn#linux_1&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;為 Docker 設定身份驗證&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;解密&quot; tabindex=&quot;-1&quot;&gt;解密&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;kubectl get secret test-grafana -n monitoring -o jsonpath=&#39;{.data.admin-user}&#39; |base64 --decode; echo
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/144. k8s 的sercret複製/" />
        </entry>
        <entry>
            <title>
                143. k8s取得登入憑證
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/143. k8s取得登入憑證/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;幫同事新建一組drone 自動部署的新專案，&lt;br /&gt;
要發版到自建的k8s上面，&lt;br /&gt;
終於碰到我不想面對的東西了。&lt;br /&gt;
kube_ca ，kube_token  ，我哪知道這兩個東西在哪裏阿&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;從 &lt;a href=&quot;https://github.com/vallard/drone-kube/blob/master/DOCS.md&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Drone Kubernetes&lt;/a&gt;可以知道，一個是使用者，一個是ca認證的key，&lt;br /&gt;
但我還不知道去哪生這兩個東西出來。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;KUBE_TOKEN&lt;/strong&gt; This plugin has one authentication method and that is to use the token to authorize the user.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;KUBE_CA&lt;/strong&gt; This should be the base64 encoding of your certificate authority. You can get this string by running the command:&lt;/p&gt;
&lt;p&gt;跑去問了一下chatGPT，得到答案。&lt;br /&gt;
執行指令前，必須先連到你要取得的cluster上。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep cluster-admin | awk &#39;{print $1}&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我的列出有很多個，就拿第一個看起來也最像的來用了。&lt;br /&gt;
admin-user-token-tm7g4&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/143-fig.1.jpg&quot; alt=&quot;143-fig.1.jpg&quot; /&gt;&lt;br /&gt;
這邊就會看到token。&lt;/p&gt;
&lt;p&gt;再來是ca&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl config view --raw --minify --flatten -o jsonpath=&#39;{.clusters[].cluster.certificate-authority-data}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/143-fig.2.jpg&quot; alt=&quot;143-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;放到drone上面，驗證，收工。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/143-fig.3.jpg&quot; alt=&quot;143-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/authentication/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用者認證&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/143. k8s取得登入憑證/" />
        </entry>
        <entry>
            <title>
                139. openlens add pod shell or logs button
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/139. openlens add pod shell or logs button/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;len在6.X版本後，要登入才能用。&lt;br /&gt;
那個時候也正好跳去openlens，在那之前都可以從pod右上角的按鈕，&lt;br /&gt;
快速進入到pod裏面，或是查pod log，但在6.2.4之後就消失了。&lt;br /&gt;
直到現在6.4.10(寫這篇時的版本)，還是沒有。&lt;br /&gt;
最後得知是因為Lens才把那段移掉。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;安裝方式&quot; tabindex=&quot;-1&quot;&gt;安裝方式&lt;/h3&gt;
&lt;p&gt;到 Extensions  直接貼上下面的來源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@alebcay/openlens-node-pod-menu
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/139-fig.2.jpg&quot; alt=&quot;139-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;來源&quot; tabindex=&quot;-1&quot;&gt;來源&lt;/h3&gt;
&lt;p&gt;主要是框起來的功能，&lt;br /&gt;
對於比較不熟悉的kubectl指令的人來說，非常實用。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/139-fig.1.jpg&quot; alt=&quot;139-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以當初沒有的時候，反而是我同事無法接受。&lt;br /&gt;
至少我還能用指令的方式查我要的東西。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl exec -it pod_name bash
kubectl logs pod_name 
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;今天心血來潮查查看有沒有相關問題，是bug還是已移除。&lt;br /&gt;
才知道了，原來是Lens把它從openLens移除，&lt;br /&gt;
詳細可參考下面連結&lt;br /&gt;
&lt;a href=&quot;https://github.com/lensapp/lens/issues/6819&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://github.com/lensapp/lens/issues/6819&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/lensapp/lens/issues/6823&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;OpenLens 6.3.0 - No Logs or Shell buttons&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之後再試試其他的 &lt;a href=&quot;https://github.com/devtron-labs/devtron&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; devtron&lt;/a&gt; 或 &lt;a href=&quot;https://github.com/kubeshop/monokle&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Monokle&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/139. openlens add pod shell or logs button/" />
        </entry>
        <entry>
            <title>
                137. kubecolor 直觀的kubectl
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/137. kubecolor 直觀的kubectl/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;剛好看到有人的文章說 kubecolor美美的kubectl就來試用了XD&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;mac  or linux 安裝&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;brew install hidetatz/tap/kubecolor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;kubecolor get pod 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/137-fig.1.jpg&quot; alt=&quot;137-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;但我平常打kubectl打習慣了，突然要改用那個覺得好麻煩，&lt;br /&gt;
改別名吧&lt;/p&gt;
&lt;p&gt;新增別名&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;alias kubectl=&amp;quot;kubecolor&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;移除別名&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;unalias kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但這個只有暫時，要永久的話，需要到.bash_profile設定&lt;br /&gt;
mac 是在 個人目錄底下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;沒有的話，就新建檔案，然後輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alias kubectl=&amp;quot;kubecolor&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;p.s mac 的環境變數載入順序為&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/etc/profile -&amp;gt;  /etc/paths -&amp;gt;  ~/.bash_profile -&amp;gt;  ~/.bash_login -&amp;gt;  ~/.profile -&amp;gt;  ~/.bashrc&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ref&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hidetatz/kubecolor&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kubecolor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.796t.com/p/1133106.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;mac 組態環境變數，講的太仔細了，非常棒&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/137. kubecolor 直觀的kubectl/" />
        </entry>
        <entry>
            <title>
                123.Helm 使用方式
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/123.Helm 使用方式/</id>
            <content type="html">
                &lt;h1 id=&quot;睡睡念&quot; tabindex=&quot;-1&quot;&gt;睡睡念&lt;/h1&gt;
&lt;p&gt;最近要用coturn，看到有人用helm 架在k8s上面，就順便來試試了。&lt;br /&gt;
之前剛開始接觸k8s，碰到helm一堆錯誤，無法執行。&lt;br /&gt;
現在想應該是裏面有些設定要修改的關係，&lt;br /&gt;
現在應該會比較好了吧！？&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h2 id=&quot;架構&quot; tabindex=&quot;-1&quot;&gt;架構&lt;/h2&gt;
&lt;p&gt;helm的架構，可先產生一個範例檔，&lt;br /&gt;
看有哪些東西。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm create ezio
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;在Helm裏面，將kubernetes的應用程式稱為Chart&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;tree ezio

ezio
├── Chart.yaml
├── charts
├── templates
│   ├── NOTES.txt
│   ├── _helpers.tpl
│   ├── deployment.yaml
│   ├── hpa.yaml
│   ├── ingress.yaml
│   ├── service.yaml
│   ├── serviceaccount.yaml
│   └── tests
│       └── test-connection.yaml
└── values.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Chart.yaml ：包含了chart的內容描述&lt;/li&gt;
&lt;li&gt;charts(folder) ：此目錄可能包含了其他不同的 chart，也可稱為 &lt;code&gt;subcharts&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;templates(folder)：此目錄為要部署的所有類型範本&lt;/li&gt;
&lt;li&gt;values.yaml ： 參數設定檔，所有的變數都寫在這。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;templates內寫的參數，通常為&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.Values.replicas&lt;/code&gt;：表示values.yaml裏面的replicas參數&lt;/p&gt;
&lt;p&gt;其他非values的取得方式，參考 &lt;a href=&quot;https://godleon.github.io/blog/DevOps/Helm-v3-Chart-Template-Guide/#Built-in-Objects&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Built-in Objects&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;template有一些可能會用到的函數，&lt;br /&gt;
主要有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pipeline ( linux 裏面常見到的 &lt;code&gt;|&lt;/code&gt; )&lt;/li&gt;
&lt;li&gt;if/else&lt;/li&gt;
&lt;li&gt;with（&lt;a href=&quot;http://xn--vb-xm3cq78y.net/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;類似vb.net&lt;/a&gt; 的with）&lt;/li&gt;
&lt;li&gt;range(for loop)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;cheatsheet&quot; tabindex=&quot;-1&quot;&gt;Cheatsheet&lt;/h2&gt;
&lt;h4 id=&quot;dry-run&quot; tabindex=&quot;-1&quot;&gt;dry-run&lt;/h4&gt;
&lt;p&gt;先查看helm所產生的yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;helm install --dry-run coturn ./coturn 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;設定參數&quot; tabindex=&quot;-1&quot;&gt;設定參數&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;helm install coturn ./conturn --set certificate.enabled=false 

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;values-yaml&quot; tabindex=&quot;-1&quot;&gt;指定values.yaml&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;helm install coturn ./conturn -f myval.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;namespace&quot; tabindex=&quot;-1&quot;&gt;指定namespace&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;helm install coturn ./conturn -n tools
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;helm&quot; tabindex=&quot;-1&quot;&gt;看helm列表&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;  helm ls
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;chart&quot; tabindex=&quot;-1&quot;&gt;更新chart&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;helm upgrade coturn ./coturn
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;chart-1&quot; tabindex=&quot;-1&quot;&gt;移除chart&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;helm uninstall coturn
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
- &lt;a href=&quot;https://godleon.github.io/blog/DevOps/Helm-v3-Chart-Template-Guide/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Helm] Helm v3 使用簡介&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10238998&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Helm介紹&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/123.Helm 使用方式/" />
        </entry>
        <entry>
            <title>
                118. kubernetes Dashboard
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/118. kubernetes Dashboard/</id>
            <content type="html">
                &lt;h1 id=&quot;碎碎念&quot; tabindex=&quot;-1&quot;&gt;碎碎念&lt;/h1&gt;
&lt;p&gt;以前GKE用習慣了，現在變成自建的k8s，只能用lens管，&lt;br /&gt;
雖然說不上有哪不足，但總是怪怪的。&lt;br /&gt;
今天查資料看到有這個UI，就架來看看了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;本機訪問&quot; tabindex=&quot;-1&quot;&gt;本機訪問&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/web-ui-dashboard/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;官方文件&lt;/a&gt;，安裝下去就好了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.1/aio/deploy/recommended.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行轉發來連到dashboard&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl proxy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;kubectl 會使得 Dashboard 可以通過 &lt;a href=&quot;http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/&lt;/a&gt; 訪問。&lt;/p&gt;
&lt;p&gt;登入畫面如下&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/118-fig.1.jpg&quot; alt=&quot;118-fig.1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;再來就需要產生一組token來做登入了。&lt;/p&gt;
&lt;p&gt;首先建立一組serviceAccount&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cat &amp;lt;&amp;lt;EOF | kubectl create -f -  
apiVersion: v1  
kind: ServiceAccount  
metadata:  
  name: admin
  namespace: kube-system  
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;綁定serviceAccount 與 角色&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;cat &amp;lt;&amp;lt;EOF | kubectl create -f -  
apiVersion: rbac.authorization.k8s.io/v1 
kind: ClusterRoleBinding  
metadata:  
  name: admin-user  
roleRef:  
  apiGroup: rbac.authorization.k8s.io  
  kind: ClusterRole  
  name: cluster-admin  
subjects:  
- kind: ServiceAccount  
  name: admin
  namespace: kube-system  
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Service Account建立完後，Kubernetes Token Controller 就會自動的為其產生一個 &lt;strong&gt;secret&lt;/strong&gt; resource(名稱為 &lt;code&gt;[SERVICE_ACCOUNT_NAME]-token-[RANDOM_STRING]&lt;/code&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin | awk &#39;{print $1}&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/118-fig.2.jpg&quot; alt=&quot;118-fig.2.jpg&quot; /&gt;&lt;br /&gt;
這邊取得的token即可在  Dashboard 上登入。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://godleon.github.io/blog/Kubernetes/k8s-Deploy-and-Access-Dashboard/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; 佈署 &amp;amp; 存取 Kubernetes Dashboard&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;外部訪問&quot; tabindex=&quot;-1&quot;&gt;外部訪問&lt;/h3&gt;
&lt;p&gt;更改service 內的 kubernetes-dashboard.kubenetes-dashboards&lt;br /&gt;
將cluster改成NodePort ，然後看對應的port多少就能登入了。&lt;br /&gt;
記得用https&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/118-fig.3.jpg&quot; alt=&quot;118-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.  &lt;a href=&quot;https://github.com/kubernetes/dashboard/tree/master/docs/user/accessing-dashboard&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;accessing-dashboard&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/118. kubernetes Dashboard/" />
        </entry>
        <entry>
            <title>
                105. linux系統時間與k8s
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/105. linux系統時間與k8s/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近弄之前的人自建的k8s，&lt;br /&gt;
才碰到一堆問題，&lt;br /&gt;
我的linux果然需要加強orz&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;linux&quot; tabindex=&quot;-1&quot;&gt;一般的linux內的時間顯示&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;timedatectl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/105.fig-1.jpg&quot; alt=&quot;105.fig-1.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Local time  ：本機時間&lt;br /&gt;
Universal time ： UTC時間&lt;br /&gt;
RTC time： 硬體時間&lt;br /&gt;
NTP service : 自動效時&lt;br /&gt;
Time Zone: 時區&lt;/p&gt;
&lt;p&gt;當時間不對時，可以設定時間的自動效正&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;timedatectl set-ntp yes 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;設定完後，等一下（多久不確定，但不會立即），&lt;br /&gt;
UTC的時間應該就會自己效對。&lt;/p&gt;
&lt;p&gt;NTP伺服器（有需要再設定）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://time.google.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;time.google.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查詢各時區&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;timedatectl list-timezones
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;設定時區&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;timedatectl set-timezone Asia/Taipei
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://officeguide.cc/ubuntu-linux-timedatectl-time-synchronization-tutorial/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Ubuntu Linux 使用 timedatectl 校正時間、時區教學與範例&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;pod&quot; tabindex=&quot;-1&quot;&gt;Pod的時區設定&lt;/h3&gt;
&lt;p&gt;pod的時間會跟他所在的node時間一致，&lt;br /&gt;
所以當你的node 主機時間錯時，&lt;br /&gt;
pod的時間也會跟着錯。&lt;/p&gt;
&lt;p&gt;但基本上都是UTC，&lt;br /&gt;
如果要指定時區的話，&lt;br /&gt;
可以用volume掛載成特定地區。&lt;br /&gt;
或是直接在build image時，一併更改。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;pvc 掛載&lt;br /&gt;
時區檔案的位置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: Pod
metadata:
  name: busybox-sleep
spec:
  containers:
  - name: busybox
    image: busybox
    args:
    - sleep
    - &amp;quot;1000000&amp;quot;
    volumeMounts:
    - name: tz-config
      mountPath: /etc/localtime
  volumes:
    - name: tz-config
      hostPath:
        path: /usr/share/zoneinfo/Europe/Prague
        type: File
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Dockerfile更改&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &#92;
		 &amp;amp;&amp;amp; echo &amp;quot;Asia/Shanghai&amp;quot; &amp;gt; /etc/timezone
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gushiciku.cn/pl/gSGc/zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;k8s環境下處理容器時間問題的多種姿勢&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/61947696/date-and-time-synchronization-among-the-pods-and-host-in-kubernetes&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;date and time synchronization among the pods and host in kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/105. linux系統時間與k8s/" />
        </entry>
        <entry>
            <title>
                104. rabbitmq operator安裝
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/104. rabbitmq operator安裝/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;接到同事說要裝rabbitmq，&lt;br /&gt;
說之前在dev有裝過，但在k8s上面沒看到，&lt;br /&gt;
用之前留下的yaml，會裝不起來，只好從頭來了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;本來是想參考他的&lt;a href=&quot;https://github.com/rabbitmq/diy-kubernetes-examples&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;這篇&lt;/a&gt;，結果看到第一段說
&lt;h3 id=&quot;stop-there-is-a-better-way&quot; tabindex=&quot;-1&quot;&gt;Stop! There is a Better Way!&lt;/h3&gt;
才知道rabbitmq有出了operator可供安裝。&lt;/li&gt;
&lt;li&gt;安裝rabbitmq operator&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubectl apply -f &amp;quot;https://github.com/rabbitmq/cluster-operator/releases/latest/download/cluster-operator.yml&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.rabbitmq.com/kubernetes/operator/install-operator.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Installing RabbitMQ Cluster Operator in a Kubernetes Cluster&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;部署yaml&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: rabbitmq.com/v1beta1
kind: RabbitmqCluster
metadata:
  name: dev-rabbitmq
spec:
  replicas: 3
  rabbitmq:
    additionalConfig: |
      default_user=admin
      default_pass=abc123
  service:
    type: NodePort

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因為是自建的k8s，沒有lb，所以就用NodePort了。&lt;br /&gt;
更詳細的參數請參考下面連結。&lt;br /&gt;
ref. &lt;a href=&quot;https://www.rabbitmq.com/kubernetes/operator/using-operator.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Using RabbitMQ Cluster Kubernetes Operator&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;問題排除&quot; tabindex=&quot;-1&quot;&gt;問題排除&lt;/h2&gt;
&lt;p&gt;中間有發生小插曲，k8s內沒有預設的storeageClass&lt;br /&gt;
導致建立pvc時發生錯誤，&lt;br /&gt;
雖然在上面的yaml上面能夠指定，&lt;br /&gt;
但可能是格式沒寫好，導致沒有產生statefuleSet 的pvc。&lt;br /&gt;
最後先指定目前的storageClass為預設的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl patch storageclass &amp;lt;your_storageclass_name&amp;gt; -p &#39;{&amp;quot;metadata&amp;quot;: {&amp;quot;annotations&amp;quot;:{&amp;quot;storageclass.kubernetes.io/is-default-class&amp;quot;:&amp;quot;true&amp;quot;}}}&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://jeff-yen.medium.com/install-rabbitmq-in-kubernetes-8b009c28959f&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;install RabbitMQ in kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zamhuang.medium.com/rabbitmq-%E4%BA%94%E5%88%86%E9%90%98%E8%BC%95%E9%AC%86%E4%BA%86%E8%A7%A3-rabbitmq-%E9%81%8B%E4%BD%9C-fcaecbaa69d4&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;RabbitMQ】五分鐘輕鬆瞭解 RabbitMQ 運作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/104. rabbitmq operator安裝/" />
        </entry>
        <entry>
            <title>
                101. 批次修改hpa
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/101. 批次修改hpa/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;這又是因為懶惰而衍生出來的一篇，&lt;/p&gt;
&lt;p&gt;懶得一個一個點進去改HPA的數量，&lt;/p&gt;
&lt;p&gt;就寫sh搞定吧。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;參考 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/88.%E6%89%B9%E6%AC%A1%E4%BF%AE%E6%94%B9GCP%E7%9A%84label/&quot;&gt;88.批次修改GCP的label&lt;/a&gt;，建立一個文字檔 hpa.txt，&lt;br /&gt;
先用指令，將hpa的name取出存到文字檔內，因為是針對特定幾個修改，所以並沒有全拉。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get hpa;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文字檔內容如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;istio-yabo-api-prod-external
istio-yabo-api-prod-internal
istio-yabo-frontend-external-demo
istio-yabo-frontend-internal-demo
istio-yabo-frontend-prod-external
istio-yabo-frontend-prod-internal
istio-yabo-frontpage-external-prod
istio-yabo-frontpage-internal-prod
istio-yabo-huanggua-external-beta
istio-yabo-huanggua-external-prod
istio-yabo-huanggua-internal-beta
istio-yabo-huanggua-internal-prod
istio-yabo-landingpage-external-demo
istio-yabo-landingpage-external-prod
istio-yabo-landingpage-internal-demo
istio-yabo-landingpage-internal-prod
istio-yabo-pwa-external-prod
istio-yabo-pwa-internal-prod
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要是 kubectl patch hpa 做修改。&lt;br /&gt;
patch這功能看來頗強大，第一次見到，&lt;br /&gt;
改天可研究看看。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while read p; do                                                                                                                                             
  echo &amp;quot;$p&amp;quot;; kubectl patch hpa -p &#39;{&amp;quot;spec&amp;quot;:{&amp;quot;minReplicas&amp;quot;: 2}}&#39; -n istio-system $p; echo &amp;quot;done&amp;quot;;
done &amp;lt;hpa.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;br /&gt;
-  &lt;a href=&quot;https://stackoverflow.com/questions/51808297/kubenetes-change-hpa-min-replica&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubenetes: change hpa min-replica&lt;/a&gt;&lt;br /&gt;
- &lt;a href=&quot;https://kubernetes.io/zh-cn/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 kubectl patch 更新 API 對象&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/101. 批次修改hpa/" />
        </entry>
        <entry>
            <title>
                0.K8s MOC
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/⎈ k8s/0.K8s MOC/</id>
            <content type="html">
                &lt;h1 id=&quot;基本概念&quot; tabindex=&quot;-1&quot;&gt;基本概念&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/27.K8s%E7%9A%84%E7%AF%80%E9%BB%9E%E9%81%B8%E6%93%87%E8%88%87%E6%B1%A1%E6%9F%93/&quot;&gt;27.K8s的節點選擇與污染&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/GKE/41.GKE%E7%AF%80%E9%BB%9E%E7%84%A1%E6%B3%95%E8%87%AA%E5%8B%95%E7%B8%AE%E5%B0%8F/&quot;&gt;41.GKE節點無法自動縮小&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/42.k8s%20PDB%EF%BC%88pod%E4%B8%AD%E6%96%B7%E9%A0%90%E7%AE%97%EF%BC%89/&quot;&gt;42.k8s PDB（pod中斷預算）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/105.%20linux%E7%B3%BB%E7%B5%B1%E6%99%82%E9%96%93%E8%88%87k8s/&quot;&gt;105. linux系統時間與k8s&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/123.Helm%20%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/&quot;&gt;123.Helm 使用方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/172.%20%E8%87%AA%E5%BB%BAk8s%E7%89%88%E6%9C%AC%E5%8D%87%E7%B4%9A/&quot;&gt;172. 自建k8s版本升級&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/192.%20%E8%87%AA%E5%BB%BA%E7%9A%84k8s%E6%8B%89%E5%8F%96private%20registry/&quot;&gt;192. 自建的k8s拉取private registry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/194.%20pod%20debug%E6%96%B9%E5%BC%8F/&quot;&gt;194. pod debug方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/196.%20http%E5%81%A5%E5%BA%B7%E5%BA%A6%E5%81%B5%E6%B8%AC/&quot;&gt;196. http健康度偵測&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;terraform&quot; tabindex=&quot;-1&quot;&gt;Terraform&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Terraform/82.%20Terraform%20vs%20Ansible/&quot;&gt;82. Terraform vs Ansible&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Terraform/147.%20%E7%94%A8chatGPT%E5%AD%B8Terraform/&quot;&gt;147. 用chatGPT學Terraform&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Terraform/148.%20Terraform%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/&quot;&gt;148. Terraform的基本概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Terraform/149.%20terraform%20%E9%83%A8%E7%BD%B2VM%EF%BC%8C%E5%95%93%E5%8B%95docker%E5%AE%89%E8%A3%9Dmetadata_startup_script/&quot;&gt;149. terraform 部署VM，啓動docker安裝metadata_startup_script&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Terraform/189.%20%E5%B0%8E%E5%85%A5Terraform/&quot;&gt;189. 導入Terraform&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;tools&quot; tabindex=&quot;-1&quot;&gt;Tools&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/118.%20kubernetes%20Dashboard/&quot;&gt;118. kubernetes Dashboard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/137.%20kubecolor%20%E7%9B%B4%E8%A7%80%E7%9A%84kubectl/&quot;&gt;137. kubecolor 直觀的kubectl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/139.%20openlens%20add%20pod%20shell%20or%20logs%20button/&quot;&gt;139. openlens add pod shell or logs button&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/162.%E6%9F%A5%E8%A9%A2%E5%B7%B2%E6%A3%84%E7%94%A8%E7%9A%84API/&quot;&gt;162.查詢已棄用的API&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;yaml&quot; tabindex=&quot;-1&quot;&gt;yaml&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Yaml/2.%20k8s%20yaml%E6%92%B0%E5%AF%AB%20volume%20%E8%B8%A9%E5%9D%91%E7%AF%87/&quot;&gt;2. k8s yaml撰寫 volume 踩坑篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Yaml/12.%20k8s%20YAML%20%E5%B0%8F%E7%B4%B0%E7%AF%80/&quot;&gt;12. k8s YAML 小細節&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Yaml/85.%20gke-cronjob%E7%AD%86%E8%A8%98/&quot;&gt;85. gke-cronjob筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Yaml/87.kustomize%20%E5%85%B1%E7%94%A8label(optional%EF%BC%89/&quot;&gt;87.kustomize 共用label(optional）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Yaml/94.%20k8s%20%E7%B4%B0%E7%AF%80%E8%A3%9C%E5%85%85/&quot;&gt;94. k8s 細節補充&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Yaml/98.%20k8s%E4%B8%AD%E7%9A%84command%E8%88%87dockerfile%E7%9A%84%20CMD/&quot;&gt;98. k8s中的command與dockerfile的 CMD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Yaml/136.%20%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%AF%A9%E9%81%B8k8s%E7%9A%84deploy%E5%85%A7%E5%AE%B9/&quot;&gt;136. 一步步篩選k8s的deploy內容&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;gke&quot; tabindex=&quot;-1&quot;&gt;GKE&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/GKE/4.%20GKE%E4%BD%BF%E7%94%A8GPU/&quot;&gt;4. GKE使用GPU&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/GKE/37.SolrCloud%20on%20GKE/&quot;&gt;37.SolrCloud on GKE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/GKE/39.solrCloud%E7%9A%84%E5%88%9D%E9%AB%94%E9%A9%97/&quot;&gt;39.solrCloud的初體驗&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/GKE/44.srs%20%E5%BD%B1%E9%9F%B3%E4%B8%B2%E6%B5%81%20on%20GKE/&quot;&gt;44.srs 影音串流 on GKE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/GKE/50.GKE%20workload%20Identity%20%E5%AF%A6%E5%9C%B0%E6%BC%94%E7%B7%B4/&quot;&gt;50.GKE workload Identity 實地演練&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/GKE/56.%20GKE%E8%A8%98%E9%8C%84%20nginx%20log/&quot;&gt;56. GKE記錄 nginx log&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/GKE/70.%20GKE%20pvc%E9%82%84%E5%8E%9F/&quot;&gt;70. GKE pvc還原&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/GKE/71.gitlab%20on%20GKE%20%E7%81%BD%E5%AE%B3%E9%82%84%E5%8E%9F%E7%AD%86%E8%A8%98/&quot;&gt;71.gitlab on GKE 災害還原筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/101.%20%E6%89%B9%E6%AC%A1%E4%BF%AE%E6%94%B9hpa/&quot;&gt;101. 批次修改hpa&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/104.%20rabbitmq%20operator%E5%AE%89%E8%A3%9D/&quot;&gt;104. rabbitmq operator安裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/43.%E8%87%AA%E5%BB%BAECK%20on%20GKE/&quot;&gt;43.自建ECK on GKE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/190.%20cert-manager%E5%AE%89%E8%A3%9D/&quot;&gt;190. cert-manager安裝&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/Yaml/74.%20kubernetes%20%E6%89%B9%E6%AC%A1%E6%AA%A2%E6%9F%A5yaml%E7%89%B9%E5%AE%9A%E5%AD%97%E5%85%83/&quot;&gt;74. kubernetes 批次檢查yaml特定字元&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/76.%20k8s%20error,The%20node%20was%20low%20on%20resource../&quot;&gt;76. k8s error,The node was low on resource..&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/144.%20k8s%20%E7%9A%84sercret%E8%A4%87%E8%A3%BD/&quot;&gt;144. k8s 的sercret複製&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/151.%20kubeadm%E9%87%8D%E6%96%B0%E7%94%A2%E7%94%9F%E9%A9%97%E8%AD%89/&quot;&gt;151. kubeadm重新產生驗證&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/%E2%8E%88%20k8s/troubleshooting-kubernetes.zh_cn.v2.png&quot; alt=&quot;troubleshooting-kubernetes.zh_cn.v2.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/⎈ k8s/0.K8s MOC/" />
        </entry>
        <entry>
            <title>
                README
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/</id>
            <content type="html">
                &lt;h1 id=&quot;度估記事本&quot; tabindex=&quot;-1&quot;&gt;度估記事本&lt;/h1&gt;
&lt;h2 id=&quot;座右銘&quot; tabindex=&quot;-1&quot;&gt;座右銘&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;懶人，始終相信科技始終來自於人類的惰性。&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;懶是一種方式，卻不是一種態度。&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;你如果想要有更多的時間偷懶，就一定要有最高的效率。&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;最新文章&quot; tabindex=&quot;-1&quot;&gt;最新文章&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/276.%20GKE%E7%A7%81%E6%9C%89%E5%8F%A2%E9%9B%86%E8%A8%AD%E5%AE%9A%20Authorized%20networks%EF%BC%8C%E5%87%BA%E7%8F%BE%E9%8C%AF%E8%AA%A4%20private_endpoint_enforcement_enabled%20cannot%20be%20disabled%20on%20VPC%20peering%20based%20clusters/&quot;&gt;276. GKE私有叢集設定 Authorized networks，出現錯誤 private_endpoint_enforcement_enabled cannot be disabled on VPC peering based clusters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/218.%20Go%20GUI%E5%A5%97%E4%BB%B6%20fyne%E7%AD%86%E8%A8%98/&quot;&gt;218. Go GUI套件 fyne筆記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/277.%20elastic%20%EF%BC%8Cindex%20%E6%B6%88%E5%A4%B1%E7%9B%B8%E9%97%9C%E6%9F%A5%E8%A9%A2%E6%96%B9%E5%BC%8F/&quot;&gt;277. elastic ，index 消失相關查詢方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/278.Golang%E7%B0%A1%E7%95%A5%E7%AD%86%E8%A8%98%EF%BC%88%E4%BA%8C%EF%BC%89/&quot;&gt;278.Golang簡略筆記（二）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;obsidian-github&quot; tabindex=&quot;-1&quot;&gt;用Obsidian發佈到Github&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/193.%20Obsidian%E7%99%BC%E4%BD%88%E5%88%B0github.io%E5%80%8B%E4%BA%BA%E7%B6%B2%E7%AB%99/&quot;&gt;193. Obsidian發佈到github.io個人網站&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;電影評分表&quot; tabindex=&quot;-1&quot;&gt;電影評分表&lt;/h1&gt;
&lt;p&gt;做好玩的 &lt;a href=&quot;https://daimom.github.io/movieRating/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;電影評分表&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;tag&quot; tabindex=&quot;-1&quot;&gt;Tag列表&lt;/h1&gt;
&lt;p&gt;💡：Map Of Content&lt;br /&gt;
💻：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%92%BB%20Code/0.Code%20MOC/&quot;&gt;0.Code MOC&lt;/a&gt;&lt;br /&gt;
🐳：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%B3%20Container/0.Container%20MOC/&quot;&gt;Container MOC&lt;/a&gt;&lt;br /&gt;
🗄：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%84%20Database/0.Database%20MOC/&quot;&gt;0.Database MOC&lt;/a&gt;&lt;br /&gt;
⏱：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8F%B1%20Drone/0.Drone%20MOC/&quot;&gt;0.Drone MOC&lt;/a&gt;&lt;br /&gt;
🗒：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/0.EFK%20MOC/&quot;&gt;EFK MOC&lt;/a&gt;&lt;br /&gt;
☁︎：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/0.GCP%20MOC/&quot;&gt;GCP MOC&lt;/a&gt;&lt;br /&gt;
📥：inbox&lt;br /&gt;
⛵️：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/0.istio%20MOC/&quot;&gt;istio MOC&lt;/a&gt;&lt;br /&gt;
⎈：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%8E%88%20k8s/0.K8s%20MOC/&quot;&gt;k8s MOC&lt;/a&gt;&lt;br /&gt;
🐧：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/0.Linux%20MOC/&quot;&gt;Linux MOC&lt;/a&gt;&lt;br /&gt;
🍎：Apple&lt;br /&gt;
🌐：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%8C%90%20Network/0.Network%20MOC/&quot;&gt;Network MOC&lt;/a&gt;&lt;br /&gt;
👁：&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%91%81%20Observability/0.Observability%20MOC/&quot;&gt;0.Observability MOC&lt;/a&gt;&lt;br /&gt;
🎮：Game&lt;br /&gt;
🆒：Side Project&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;what-is-moc&quot; tabindex=&quot;-1&quot;&gt;What is MOC ?&lt;/h1&gt;
&lt;p&gt;當單一筆記的數量越來越多時，就能夠構成一個MOC(Map of Contens)&lt;br /&gt;
詳細請參考下面連結，&lt;br /&gt;
&lt;a href=&quot;https://medium.com/pm%E7%9A%84%E7%94%9F%E7%94%A2%E5%8A%9B%E5%B7%A5%E5%85%B7%E7%AE%B1/%E6%95%B8%E4%BD%8D%E7%AD%86%E8%A8%98%E5%A4%AA%E5%A4%9A%E5%BE%88%E5%87%8C%E4%BA%82%E6%80%8E%E9%BA%BC%E8%BE%A6-451a6cb4ab17&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;數位筆記太多很凌亂怎麼辦？使用 MOC 架構有系統地管理數百則的數位筆記&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;技術文章寫法要點&quot; tabindex=&quot;-1&quot;&gt;技術文章寫法要點&lt;/h1&gt;
&lt;h4 id=&quot;strong-strong&quot; tabindex=&quot;-1&quot;&gt;&lt;strong&gt;文章採用單線結構&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;一點接着一點，就是一張卡片接着一個卡片，&lt;br /&gt;
把問題拆成多篇文章，&lt;br /&gt;
讓文章一篇就只有一個要點。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.ruanyifeng.com/blog/2024/01/weekly-issue-288.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;# 科技愛好者週刊（第 288 期）：技術寫作的首要訣竅&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;舊筆記&quot; tabindex=&quot;-1&quot;&gt;舊筆記&lt;/h1&gt;
&lt;p&gt;2021年以前文章請至 &lt;a href=&quot;https://daimom3020.blogspot.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;度估記事本&lt;/a&gt; 查詢&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/" />
        </entry>
        <entry>
            <title>
                285. BigQuery 省錢大作戰
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/285. BigQuery 省錢大作戰/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;又來玩新東西了，這次是BigQuery。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;p&gt;BigQuery的費用計算方式，儲存空間+分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BigQuery 採用&lt;a href=&quot;https://en.wikipedia.org/wiki/Column-oriented_DBMS&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;資料欄式資料結構&lt;/a&gt;。系統會根據您所選資料欄中處理的資料總量向您收費，每個資料欄中的資料總量則是按照資料欄中資料的類型計算。如要進一步瞭解資料量的計算方式，請參閱&lt;a href=&quot;https://cloud.google.com/bigquery/docs/best-practices-costs?hl=zh-tw#estimate-query-costs&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;估算查詢費用&lt;/a&gt;一節。&lt;/li&gt;
&lt;li&gt;您只需支付查詢共用資料的費用。資料擁有者不會在資料存取時收費&lt;/li&gt;
&lt;li&gt;如果查詢作業傳回錯誤訊息或是&lt;a href=&quot;https://cloud.google.com/bigquery/docs/cached-results?hl=zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;從快取中擷取結果&lt;/a&gt;，則您不必付費。 以 &lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/standard-sql/procedural-language?hl=zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;程序語言工作&lt;/a&gt;來說，系統會在個別陳述式層級採用這個計價模式。&lt;/li&gt;
&lt;li&gt;資料量會四捨五入至最接近的 MB 數。針對查詢所參照的每個資料表，系統處理的資料量基本額度為 10 MB，每項查詢作業處理的資料量基本額度也同樣是 10 MB。&lt;/li&gt;
&lt;li&gt;即便您取消正在執行的查詢工作，該項作業還是可能產生費用，且價格最高等同於完整執行作業須支付的全額費用。&lt;/li&gt;
&lt;li&gt;當您執行查詢時，系統會根據您所選資料欄中處理的資料量向您收費，即使您已明確對結果設定 &lt;code&gt;LIMIT&lt;/code&gt; 也是如此。&lt;/li&gt;
&lt;li&gt;將資料表&lt;a href=&quot;https://cloud.google.com/bigquery/docs/partitioned-tables?hl=zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;分區&lt;/a&gt;和&lt;a href=&quot;https://cloud.google.com/bigquery/docs/clustered-tables?hl=zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;分群&lt;/a&gt;有助於降低查詢處理的資料量。為達到最佳做法的成效，請盡可能採用分區和分群的做法。&lt;/li&gt;
&lt;li&gt;以量計價 (每 TiB) 的定價是指 &lt;a href=&quot;https://cloud.google.com/skus/?filter=bigquery&amp;amp;hl=zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Google Cloud SKU&lt;/a&gt; 頁面上的分析價格。&lt;/li&gt;
&lt;li&gt;如果您對叢集資料表執行查詢，而且查詢含有叢集資料欄篩選器，則 BigQuery 會使用篩選器運算式來修剪查詢掃描的區塊。這麼做可以減少掃描的位元組數。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/bigquery/pricing?hl=zh-tw#on_demand_pricing&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;以量計價的運算價格&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;注意事項&quot; tabindex=&quot;-1&quot;&gt;注意事項&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;避免反覆覆蓋表： 系統會在時間旅行和故障安全窗口期間保留被替換的資料。如果您經常覆蓋表，則會產生額外的儲存空間費用。&lt;/li&gt;
&lt;li&gt;使用下列方式探索或預覽資料
&lt;ul&gt;
&lt;li&gt;在 Google Cloud 控制台的資料表詳細資料頁面中，按一下「Preview」(預覽) 分頁標籤，即可取樣資料。&lt;/li&gt;
&lt;li&gt;在 bq 指令列工具中，使用 &lt;a href=&quot;https://cloud.google.com/bigquery/docs/managing-table-data?hl=zh-tw#browse-table&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;&lt;code&gt;bq head&lt;/code&gt;&lt;/a&gt; 指令並指定要預覽的資料列數。&lt;/li&gt;
&lt;li&gt;在 API 中，使用 &lt;a href=&quot;https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata/list?hl=zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;&lt;code&gt;tabledata.list&lt;/code&gt;&lt;/a&gt; 從一組指定的資料列擷取資料表資料。&lt;/li&gt;
&lt;li&gt;請避免在非叢集資料表中使用 &lt;code&gt;LIMIT&lt;/code&gt;。如果是未經叢集的資料表，&lt;code&gt;LIMIT&lt;/code&gt; 子句不會降低運算費用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/bigquery/docs/clustered-tables?hl=zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;建立叢集資料表&lt;/a&gt;：在每個修改資料表的作業中，叢集資料表都會保留其排序屬性。依叢集化資料欄篩選或匯總的查詢，只會根據叢集化資料欄掃描相關區塊，而不會掃描整個資料表或資料表分區。感覺上像是index&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/bigquery/docs/partitioned-tables?hl=zh-tw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用分區將大型資料表分割&lt;/a&gt;：分區資料表劃分為多個區段 (稱為分區)，可讓您更容易管理和查詢資料。將大型資料表分成較小的分區，可以提高查詢效能，並且可以透過減少查詢讀取的位元組數來控制費用。&lt;/li&gt;
&lt;li&gt;使用&lt;a href=&quot;https://cloud.google.com/bigquery/pricing?hl=zh-tw#storage&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;長期儲存價格&lt;/a&gt;，降低舊資料的費用：超過90天沒用過的資料，會降低50%的金額&lt;a href=&quot;https://cloud.google.com/bigquery/pricing?hl=zh-tw#storage&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;儲存空間定價&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;為目的地資料表使用資料表到期時間：如果您將大型查詢結果寫入目的地資料表，請使用預設資料表到期時間，等到您不再需要這些資料時，系統便會依照設定的時間來刪除資料&lt;/li&gt;
&lt;li&gt;寫入資料方式：批次不用錢，串流需要。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/285-fig.1.png&quot; alt=&quot;285-fig.1.png&quot; /&gt;&lt;br /&gt;
選擇哪一種方式，參考下圖&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/285-fig.2.png&quot; alt=&quot;285-fig.2.png&quot; /&gt;&lt;br /&gt;
ref. &lt;a href=&quot;https://cloud.google.com/bigquery/docs/write-api?hl=zh-tw#default_stream&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;BigQuery Storage Write API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.github.io/285. BigQuery 省錢大作戰/" />
        </entry>
        <entry>
            <title>
                282. Grafana的label_replace
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/282. Grafana的label_replace/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;在搞Grafana整合時，才發現缺少單個Node的CPU Used，&lt;br /&gt;
從Grafana Dashboard找了個適合的抓下來用，&lt;br /&gt;
有些錯誤更改時，才發現他用了Transformation，&lt;br /&gt;
所以不論我怎改都沒資料。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;p&gt;我使用的dashboard是 &lt;a href=&quot;https://grafana.com/grafana/dashboards/18447-gke-node-dashboard-ssdq/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GKE per Node dashboard&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Transformation功能很多，&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/282-fig.1.png&quot; alt=&quot;282-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;新增功能時，碰到一個問題。&lt;br /&gt;
我有兩個 metrics&lt;/p&gt;
&lt;p&gt;CPU Used&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sum by (kubernetes_io_hostname)(rate(container_cpu_usage_seconds_total{id=&amp;quot;/&amp;quot;}[1m]))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CPU Request&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sum by(node)(kube_node_status_allocatable{resource=&amp;quot;cpu&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;兩邊的值都一樣，但如果要顯示在同一個表格的話，無法顯示！！！&lt;/p&gt;
&lt;p&gt;最快的方式，就是將CPU Request的 node改掉。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sum by (kubernetes_io_hostname)(
  label_replace(
    kube_node_status_allocatable{resource=&amp;quot;cpu&amp;quot;},
    &amp;quot;kubernetes_io_hostname&amp;quot;,
    &amp;quot;$1&amp;quot;,
    &amp;quot;node&amp;quot;,
    &amp;quot;(.*)&amp;quot;
  )
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;將node的值取出來後，再將node的label 改成 kubernetes_io_hostname。&lt;/p&gt;
&lt;p&gt;這樣直接在transformation底下的欄位往上拉就好，&lt;br /&gt;
原本連顯示都沒有。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/282-fig.2.png&quot; alt=&quot;282-fig.2.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/282. Grafana的label_replace/" />
        </entry>
        <entry>
            <title>
                280. Promtail 規則順序
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/280. Promtail 規則順序/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;全面使用istio的時候，&lt;br /&gt;
要將網路入口的log統一丟去loki管理，&lt;br /&gt;
篩選時碰到GPT的幻覺，&lt;br /&gt;
最後丟了測試結果，才更正過來。&lt;br /&gt;
Gemini 倒是一開始就給正確的答案。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;p&gt;本來只有打算抓istio-system的log紀錄，&lt;br /&gt;
但翻了一下，每個pod底下的istio-proxy那些log，&lt;br /&gt;
對於日後判斷感覺也頗重要，就通通一起留著吧。&lt;/p&gt;
&lt;p&gt;所以這次的目標是，抓取 namespace (istio-system)的所有log&lt;br /&gt;
以及 namesapce(default)底下的istio-proxy的container log。&lt;/p&gt;
&lt;p&gt;只保留 ns 為 istio-system的話，沒什麼爭議。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;relabel_configs:
  # Rule 1: 保留 namespace 是 istio-system 
  - source_labels: [__meta_kubernetes_namespace]
    regex: istio-system
    action: keep
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以在上面使用這段。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scrape_configs:
- job_name: pod-logs
  kubernetes_sd_configs:
    - role: pod
      namespaces:
        names:
          - istio-system
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但當有兩個keep時，&lt;br /&gt;
就產生混亂了。&lt;/p&gt;
&lt;p&gt;以下是錯誤的，當兩個一起掛上去，不會有任何log匯出到loki&lt;/p&gt;
&lt;p&gt;GPT一直說，兩個keep規則，只要一個符合就好，&lt;br /&gt;
彼此的關聯是 &lt;code&gt;OR&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/280-fig.1.png&quot; alt=&quot;280-fig.1.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/280-fig.2.png&quot; alt=&quot;280-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;但實際上，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所有規則是依序由上而下套用，目標只有在通過所有 keep規則後，最終才會保留。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要完成or的選項，最好就是寫在同一條。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_pod_container_name]
  separator: &amp;quot;;&amp;quot;
  regex: (istio-system;.+)|(default;istio-proxy)
  action: keep

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Gemini 則有提供另一個思路，&lt;br /&gt;
加上一個虛擬的label ，設定為true，之後再將非true的drop。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;relabel_configs:
  # Rule 1: 如果 namespace 是 istio-system，給目標打上一個暫時標記 __temp_keep
  - source_labels: [__meta_kubernetes_namespace]
    regex: istio-system
    action: replace  # 使用 replace action 來添加/修改 label
    target_label: __temp_keep # 設置一個暫時的 label 名稱
    replacement: &amp;quot;true&amp;quot;      # 給這個 label 一個值

  # Rule 2: 如果 namespace 是 default 且 container 是 istio-proxy，也給目標打上同一個暫時標記 __temp_keep
  - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_pod_container_name]
    regex: default;istio-proxy
    action: replace
    target_label: __temp_keep
    replacement: &amp;quot;true&amp;quot;

  # Rule 3: 最後，只保留帶有 __temp_keep 標記的目標，丟棄沒有此標記的
  - source_labels: [__temp_keep]
    regex: &amp;quot;true&amp;quot; # regex 匹配 __temp_keep 的值
    action: keep  # 只保留匹配的目標 (即帶有 __temp_keep=true 的)

  # (Optional) 清理暫時 label，如果不需要它傳到 Loki
  - source_labels: [__temp_keep]
    action: labeldrop
    regex: __temp_keep
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/280. Promtail 規則順序/" />
        </entry>
        <entry>
            <title>
                278.Golang簡略筆記（二）
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/278.Golang簡略筆記（二）/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;搞 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/218.%20Go%20GUI%E5%A5%97%E4%BB%B6%20fyne%E7%AD%86%E8%A8%98/&quot;&gt;218. Go GUI套件 fyne筆記&lt;/a&gt;，&lt;br /&gt;
是用ChatGPT加上文件搞出來的，&lt;br /&gt;
有些寫法真的是厲害啊，&lt;br /&gt;
值得紀錄一下。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;function 回傳，兩個以上的話需要 &lt;code&gt;()&lt;/code&gt;，一個則不用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;var db *sql.DB
func main() {
	var err error
	db, err = initDatabase(&amp;quot;./stickersInfo.db&amp;quot;)
	if err != nil {
		log.Fatalf(&amp;quot;初始化資料庫失敗: %v&amp;quot;, err)
	}
	// 當main 全部結束後，會關閉db 
	defer db.Close()
}

func initDatabase(dbPath string) (*sql.DB, error) {
	....
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;同一個專案底下，不同文件，不需要另外import，只需下面這行&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;package main
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;變數or 函數，開頭大寫表示是公有。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;var BasePath = &amp;quot;&#92;user&#92;daimom&amp;quot;

var BasePath string
BasePath = &amp;quot;&#92;user&#92;daimom&amp;quot;

BasePath := &amp;quot;&#92;user&#92;daimom&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;slice(動態array)的 &lt;code&gt;...&lt;/code&gt; ，意思是將slice拆開，當作多個參數傳到函式&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;// LoadImages會回傳 []fyne.CanvasObject
grid := container.NewGridWithColumns(3, LoadImages(*imageLists, w)...)

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;字串處理&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;//分割
p := strings.Split(imagePath, &amp;quot;/&amp;quot;)
//結合
alias = (strings.Join(*aliasList, &amp;quot;,&amp;quot;))
//轉string
a = string(number)
//替換文字
folderPath := strings.ReplaceAll(path, &amp;quot;productInfo.meta&amp;quot;, &amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;for range&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;// 迴圈加入,
for i, id := range packageIDs {
  query += &amp;quot;?&amp;quot;
  if i &amp;lt; len(packageIDs)-1 {
    query += &amp;quot;,&amp;quot;
  }
  args[i] = id
}

// 常用取得slice的值。products 型別為 *[]Product。
for _, p := range *products {
  if !existsMap[p.PackageID] {
    filtered = append(filtered, p)
  } else {
    fmt.Printf(&amp;quot;刪除 PackageID: %d, StickerID: %d&#92;n&amp;quot;, p.PackageID, p.stickerId)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;指標&lt;br /&gt;
如果傳入實體的型別為 &lt;code&gt;products []Prouduct&lt;/code&gt;，&lt;br /&gt;
那&lt;code&gt;*products 型別為 []Proudct&lt;/code&gt;，取實體&lt;br /&gt;
而 &lt;code&gt;&amp;amp;products 型別為 *[]Product&lt;/code&gt;，指向這個 slice 的指標&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;func checkDuplicate(products *[]Product){
	// 此處看到products 是個指向[]Product的指標。
	// 要取值的話，變成 *products（型別 []Product)
	// 如果要取指標 &amp;amp;products ，因本來已經是指標了，
	// 會變成 (型別 **[]Product) ，就會出錯
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;map預設回傳&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;map 型別&lt;/th&gt;
&lt;th&gt;不存在時回傳值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;map[int]bool&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;map[string]int&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;map[string]string&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; (空字串)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;map[int]float64&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0.0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&quot;9&quot;&gt;
&lt;li&gt;slice 取值&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;寫法&lt;/th&gt;
&lt;th&gt;意思&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;arr[2:]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;從 index 2 到結尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;arr[:3]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;從開頭到 index 3（不含3）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;arr[1:4]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;從 index 1 到 4（不含4）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;arr[:]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;全部（copy 一份 slice）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&quot;10&quot;&gt;
&lt;li&gt;make用法&lt;br /&gt;
用來建立 slice, map, chan 這三種。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;當用來建立slice時，差異在&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;用法情境&lt;/th&gt;
&lt;th&gt;建議寫法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;要明確是空 slice&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a := []int{}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;要保留 nil 判斷語意&lt;/td&gt;
&lt;td&gt;&lt;code&gt;var a []int&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;要初始化有容量但無資料&lt;/td&gt;
&lt;td&gt;&lt;code&gt;make([]int, 0, 100)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;而三種型別的差異&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;型別&lt;/th&gt;
&lt;th&gt;是否要指定長度？&lt;/th&gt;
&lt;th&gt;備註&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;slice&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;✅ 要指定長度（&lt;code&gt;len&lt;/code&gt;），可選容量（&lt;code&gt;cap&lt;/code&gt;）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;make([]T, len)&lt;/code&gt; 或 &lt;code&gt;make([]T, len, cap)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;map&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;❌ 可省略長度（但可選擇性指定初始容量）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;make(map[K]V)&lt;/code&gt; 或 &lt;code&gt;make(map[K]V, hint)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;chan&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;✅ 要指定 buffer 大小（0 表示無 buffer）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;make(chan T, bufferSize)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;以上都是寫&lt;a href=&quot;https://github.com/daimom/LineStickerMapping&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;LineStickerMapping&lt;/a&gt; ，然後延伸出來的筆記&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://willh.gitbook.io/build-web-application-with-golang-zhtw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用Golang打造Web應用程式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/278.Golang簡略筆記（二）/" />
        </entry>
        <entry>
            <title>
                277. elastic ，index 消失相關查詢方式
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/277. elastic ，index 消失相關查詢方式/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;同事問，為什麼我前五天的index消失了。&lt;br /&gt;
我震驚，不應該啊。&lt;br /&gt;
開始漫長的查詢之路&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;NOTE&lt;/h1&gt;
&lt;h3 id=&quot;filebeat&quot; tabindex=&quot;-1&quot;&gt;filebeat 重新上傳&lt;/h3&gt;
&lt;p&gt;直接看indices的內容，&lt;br /&gt;
真的沒有前幾天的資料，但文件還在，&lt;br /&gt;
那不然先把文件重傳回來好了。&lt;/p&gt;
&lt;p&gt;filebeat靠registry底下的檔案(k8s內的路徑為&lt;code&gt;/usr/share/filebeat/data/registry/filebeat/data.json&lt;/code&gt;，&lt;br /&gt;
來判斷這個文件有沒有讀取過，&lt;br /&gt;
所以將這個資料夾底下的檔案清空，重啟Pod，就會觸發強制重傳了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rm -rvf /usr/share/filebeat/data/registry
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;題外話，然後因為前面的文件太多沒刪除，&lt;br /&gt;
導致elk的硬碟直接塞滿。&lt;/p&gt;
&lt;h3 id=&quot;index-ilm&quot; tabindex=&quot;-1&quot;&gt;檢查index的ILM 有沒有生效&lt;/h3&gt;
&lt;p&gt;先確認ilm的政策正確，下面會列出全部的ilm，看是不是跟你想像的一樣。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET /_ilm/policy?pretty
or
GET _ilm/policy/delete-bms-indices-after-7days?pretty
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;結果如下，&lt;br /&gt;
建立index時，會馬上進入到hot 的phases（根據min_age=0ms)，&lt;br /&gt;
然後14天後，會到delete的phases（min_age=14d)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &amp;quot;delete-bms-indices-after-7days&amp;quot;: {
    &amp;quot;version&amp;quot;: 4,
    &amp;quot;modified_date&amp;quot;: &amp;quot;2024-10-23T08:49:16.681Z&amp;quot;,
    &amp;quot;policy&amp;quot;: {
      &amp;quot;phases&amp;quot;: {
        &amp;quot;hot&amp;quot;: {
          &amp;quot;min_age&amp;quot;: &amp;quot;0ms&amp;quot;,
          &amp;quot;actions&amp;quot;: {
            &amp;quot;set_priority&amp;quot;: {
              &amp;quot;priority&amp;quot;: 100
            }
          }
        },
        &amp;quot;delete&amp;quot;: {
          &amp;quot;min_age&amp;quot;: &amp;quot;14d&amp;quot;,
          &amp;quot;actions&amp;quot;: {
            &amp;quot;delete&amp;quot;: {
              &amp;quot;delete_searchable_snapshot&amp;quot;: true
            }
          }
        }
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再來看index的 ilm&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET /qa-game-cold-back-gamecoldtransdata-2024.12/_ilm/explain
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;內容如下，目前建立了5.23d，要到14d可能還要一陣子，&lt;br /&gt;
先放著之後看結果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;indices&amp;quot;: {
    &amp;quot;qa-game-cold-back-gamecoldtransdata-2024.12&amp;quot;: {
      &amp;quot;index&amp;quot;: &amp;quot;qa-game-cold-back-gamecoldtransdata-2024.12&amp;quot;,
      &amp;quot;managed&amp;quot;: true,
      &amp;quot;policy&amp;quot;: &amp;quot;delete-bms-indices-after-7days&amp;quot;,
      &amp;quot;index_creation_date_millis&amp;quot;: 1743131249510,
      &amp;quot;time_since_index_creation&amp;quot;: &amp;quot;5.23d&amp;quot;,
      &amp;quot;lifecycle_date_millis&amp;quot;: 1743131249510,
      &amp;quot;age&amp;quot;: &amp;quot;5.23d&amp;quot;,
      &amp;quot;phase&amp;quot;: &amp;quot;hot&amp;quot;,
      &amp;quot;phase_time_millis&amp;quot;: 1743131249629,
      &amp;quot;action&amp;quot;: &amp;quot;complete&amp;quot;,
      &amp;quot;action_time_millis&amp;quot;: 1743131249829,
      &amp;quot;step&amp;quot;: &amp;quot;complete&amp;quot;,
      &amp;quot;step_time_millis&amp;quot;: 1743131249829,
      &amp;quot;phase_execution&amp;quot;: {
        &amp;quot;policy&amp;quot;: &amp;quot;delete-bms-indices-after-7days&amp;quot;,
        &amp;quot;phase_definition&amp;quot;: {
          &amp;quot;min_age&amp;quot;: &amp;quot;0ms&amp;quot;,
          &amp;quot;actions&amp;quot;: {
            &amp;quot;set_priority&amp;quot;: {
              &amp;quot;priority&amp;quot;: 100
            }
          }
        },
        &amp;quot;version&amp;quot;: 4,
        &amp;quot;modified_date_in_millis&amp;quot;: 1729673356681
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h3&gt;
&lt;p&gt;突然靈光一閃，猜測有可能是因為index我是以月為單位留存的，&lt;br /&gt;
為什麼index不以天留存呢？因為以前曾經發生過shared數量太多，&lt;br /&gt;
導致機器卡住。&lt;br /&gt;
但刪除的天數是14天，&lt;br /&gt;
所以ilm執行時就直接將這個index刪掉。&lt;/p&gt;
&lt;h3 id=&quot;未驗證&quot; tabindex=&quot;-1&quot;&gt;未驗證&lt;/h3&gt;
&lt;p&gt;如果ILM更改很大，但舊的index沒有進入到新的階段，&lt;br /&gt;
讓ILM重新評估。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST _ilm/run
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果還是沒成功，&lt;br /&gt;
手動將index推到新的phase&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST /&amp;lt;your-index&amp;gt;/_ilm/move
{
  &amp;quot;current_step&amp;quot;: { &amp;quot;phase&amp;quot;: &amp;quot;hot&amp;quot;, &amp;quot;action&amp;quot;: &amp;quot;complete&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;complete&amp;quot; },
  &amp;quot;next_step&amp;quot;: { &amp;quot;phase&amp;quot;: &amp;quot;delete&amp;quot;, &amp;quot;action&amp;quot;: &amp;quot;delete&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;delete&amp;quot; }
}

&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/277. elastic ，index 消失相關查詢方式/" />
        </entry>
        <entry>
            <title>
                276. GKE私有叢集設定 Authorized networks，出現錯誤 private_endpoint_enforcement_enabled cannot be disabled on VPC peering based clusters
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/276. GKE私有叢集設定 Authorized networks，出現錯誤 private_endpoint_enforcement_enabled cannot be disabled on VPC peering based clusters/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;3/25 看到一個文章&lt;a href=&quot;https://www.ithome.com.tw/news/168061&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;用於K8s的Ingress Nginx Controller存在重大漏洞，6,500個叢集恐曝險&lt;/a&gt;，&lt;br /&gt;
然後就炸了。&lt;br /&gt;
後來查了一下攻擊的方式，&lt;br /&gt;
就再把GKE的安全性拉高點吧。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;NOTE&lt;/h1&gt;
&lt;p&gt;如果Cluster有 VPC peering，&lt;br /&gt;
設定完 Authorized networks ，要存檔時會直接噴錯。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/276-fig.1.png&quot; alt=&quot;276-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;記得要把&lt;code&gt;Enforce authorized networks on the control plane&#39;s internal endpoint&lt;/code&gt; 開啟。&lt;/p&gt;
&lt;p&gt;指令的話，則是。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud container clusters update &amp;lt;cluster_name&amp;gt; &#92;
  --project=&amp;lt;project&amp;gt; &#92;
  --enable-master-authorized-networks &#92;
  --master-authorized-networks=&amp;lt;YOUR_IP_RANGE&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/276. GKE私有叢集設定 Authorized networks，出現錯誤 private_endpoint_enforcement_enabled cannot be disabled on VPC peering based clusters/" />
        </entry>
        <entry>
            <title>
                275. VPC network peering
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/275. VPC network peering/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;兩個cluster要用內網互相連線，&lt;br /&gt;
除了share VPC，應該就只剩下network peering了。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;NOTE&lt;/h1&gt;
&lt;p&gt;先看Google文件，&lt;a href=&quot;https://cloud.google.com/vpc/docs/vpc-peering?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;VPC 網路對等互連&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;開頭有明確定義，不能將兩個自動的VPC網路連在一起。&lt;/p&gt;
&lt;p&gt;為什麼？ 因為網段會互相卡到你想哭。&lt;br /&gt;
但其實，一個auto一個Custom我就已經卡到玩不下去了。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/275-fig.1.png&quot; alt=&quot;275-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;而且建議，設定最好在其他服務都還沒用之前設定好。&lt;br /&gt;
因之前有設定redis network peering ，&lt;br /&gt;
導致現在無法設定會出現錯誤。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/275-fig.2.png&quot; alt=&quot;275-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;不然設定還挺簡單的，&lt;br /&gt;
只要先到A project設定。&lt;br /&gt;
再到B project設定就通了。&lt;/p&gt;
&lt;p&gt;前提是沒有碰到網段互咬的情況。&lt;br /&gt;
檢查網段時，記得將網段展開，&lt;br /&gt;
不然可能會有懷疑Google是不是哪裡搞錯了，&lt;br /&gt;
我明明沒這個網段，為什麼會衝突。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/275-fig.3.png&quot; alt=&quot;275-fig.3.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/275. VPC network peering/" />
        </entry>
        <entry>
            <title>
                274. github action建立 self-host runner
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/274. github action建立 self-host runner/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;最近這幾天最大的消息，&lt;br /&gt;
應該算是Nginx-ingress controller 出現重大漏洞。&lt;br /&gt;
不知道的可以看&lt;a href=&quot;https://www.ithome.com.tw/news/168061&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;文章&lt;/a&gt;&lt;br /&gt;
又翻了一下漏洞產生的原因&lt;a href=&quot;https://www.wiz.io/blog/ingress-nginx-kubernetes-vulnerabilities&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;IngressNightmare: 9.8 Critical Unauthenticated Remote Code Execution Vulnerabilities in Ingress NGINX&lt;/a&gt;&lt;br /&gt;
所幸，本來就是Private Cluster，但API那層的Public Endpoints沒檔，&lt;br /&gt;
一檔下去，換前端的Github actions無法部屬，但Github的&lt;a href=&quot;https://api.github.com/meta&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;IP名單&lt;/a&gt;太多了，只好想其他方式。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;本來想了好幾種方式，但不是因為太複雜就是沒辦法做（時間不允許）。&lt;br /&gt;
後來想到github action的自建runner，&lt;br /&gt;
在本地機房建個 runner，部屬時改用這個runner去執行，&lt;br /&gt;
那GKE的allow IP就不用再額外增加了。&lt;/p&gt;
&lt;h3 id=&quot;runner&quot; tabindex=&quot;-1&quot;&gt;建置Runner&lt;/h3&gt;
&lt;p&gt;建立方式，&lt;a href=&quot;https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/adding-self-hosted-runners&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;github 說明文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;簡單流程，就是到設定開啟action 的runner選單，再點選New Runner ，&lt;br /&gt;
選擇 Self-hosted runner，設定好後會看到機器呈現Idle的狀態。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/274-fig.1.png&quot; alt=&quot;274-fig.1.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/274-fig.2.png&quot; alt=&quot;274-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;進去後，照著上面的指令執行即可（記得選對平台及Architecture）。&lt;/p&gt;
&lt;p&gt;設定完後，最後有一行執行的指令&lt;br /&gt;
&lt;code&gt;./run.sh&lt;/code&gt;&lt;br /&gt;
這邊建議修改一下，&lt;br /&gt;
如果你是ssh進去Linux機器，那當你斷掉連線這個指令就會失效了。&lt;/p&gt;
&lt;p&gt;所以要改用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nohup ./run.sh &amp;gt; runner.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;當關閉ssh後指令仍可執行。&lt;/p&gt;
&lt;p&gt;如果要變成系統服務的話，避免重開機後，還要重下指令，&lt;br /&gt;
建議用systemd的方式。&lt;/p&gt;
&lt;h3 id=&quot;github-action&quot; tabindex=&quot;-1&quot;&gt;修改github action&lt;/h3&gt;
&lt;p&gt;開啟.github/workflows的資料夾，看裡面哪些流程要改用自架的機器。&lt;/p&gt;
&lt;p&gt;本來是  &lt;code&gt;runs-on: ubuntu-latest&lt;/code&gt; ，這個是github預設的runner&lt;br /&gt;
改成 &lt;code&gt;runs-on: self-hosted&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/adding-self-hosted-runners&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Adding self-hosted runners&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/monitoring-and-troubleshooting-self-hosted-runners&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Monitoring and troubleshooting self-hosted runners&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Using self-hosted runners in a workflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/274. github action建立 self-host runner/" />
        </entry>
        <entry>
            <title>
                273. GCP搞openTelemetry筆記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/273. GCP搞openTelemetry筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;要開始弄Google Manage Prometheus後面簡稱GMP，&lt;br /&gt;
要用GMP的話，蒐集metric可以用Google的套件，&lt;br /&gt;
也可以用OpenTelemetry ，&lt;br /&gt;
因為OpenTelemetry後面簡稱Otel ，可以適用於未來還要弄的trace，&lt;br /&gt;
早晚都要會的，那不如就一次硬上吧。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;h3 id=&quot;gcp-a-href-https-cloud-google-com-stackdriver-docs-managed-prometheus-setup-otel-hl-zh-cn-target-blank-class-external-link-open-telemetry-a&quot; tabindex=&quot;-1&quot;&gt;先看GCP的文件- &lt;a href=&quot;https://cloud.google.com/stackdriver/docs/managed-prometheus/setup-otel?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;OpenTelemetry 收集器使用入門&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;基本可分成幾個步驟&lt;/p&gt;
&lt;h3 id=&quot;1-workload-identity-service-account-monitoring-metric-writer-namespace-default&quot; tabindex=&quot;-1&quot;&gt;1. 實作workload Identity；建立一個ServiceAccount授予monitoring.metricWriter的權限，並且綁在namespace的default上面。&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;kubectl create ns otel &#92;
&amp;amp;&amp;amp; 
gcloud config set project &amp;lt;project&amp;gt; &#92;
&amp;amp;&amp;amp;
gcloud iam service-accounts create gmp-test-sa &#92;
&amp;amp;&amp;amp;
gcloud iam service-accounts add-iam-policy-binding &#92;
  --role roles/iam.workloadIdentityUser &#92;
  --member &amp;quot;serviceAccount:&amp;lt;project&amp;gt;.svc.id.goog[otel/default]&amp;quot; &#92;
  gmp-test-sa@&amp;lt;project&amp;gt;.iam.gserviceaccount.com &#92;
&amp;amp;&amp;amp;
kubectl annotate serviceaccount &#92;
  --namespace otel &#92;
  default &#92;
  iam.gke.io/gcp-service-account=gmp-test-sa@&amp;lt;project&amp;gt;.iam.gserviceaccount.com &#92;
&amp;amp;&amp;amp;
gcloud projects add-iam-policy-binding &amp;lt;project&amp;gt;&#92;
  --member=serviceAccount:gmp-test-sa@&amp;lt;project&amp;gt;.iam.gserviceaccount.com &#92;
  --role=roles/monitoring.metricWriter
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;2-otel&quot; tabindex=&quot;-1&quot;&gt;2. 設定Otel&lt;/h3&gt;
&lt;p&gt;GCP文件先寫config，也不是不可以。&lt;br /&gt;
但我建議直接先上deploy跟設定吧。&lt;br /&gt;
下方有簡單的說明config設定及修改過的地方。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: otel:prometheus-test
rules:
- apiGroups: [&amp;quot;&amp;quot;]
  resources:
  - pods
  verbs: [&amp;quot;get&amp;quot;, &amp;quot;list&amp;quot;, &amp;quot;watch&amp;quot;]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: otel:prometheus-test
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: otel:prometheus-test
subjects:
- kind: ServiceAccount
  namespace: otel
  name: default
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: otel-collector
  namespace: otel
spec:
  replicas: 1
  selector:
    matchLabels:
      app: otel-collector
      app.kubernetes.io/name: otel-collector
  template:
    metadata:
      labels:
        app: otel-collector
        app.kubernetes.io/name: otel-collector
      annotations:
        prometheus.io/port: &amp;quot;8888&amp;quot;
    spec:
      containers:
      - name: otel-collector
        image: otel/opentelemetry-collector-contrib:0.120.0
        ports:  
            - name: metrics
              containerPort: 8888
              protocol: TCP
            - name: otlp
              containerPort: 4317
              protocol: TCP
            - name: otlp-http
              containerPort: 4318
              protocol: TCP     
        args:
        - --config
        - /etc/otel/config.yaml
        - --feature-gates=exporter.googlemanagedprometheus.intToDouble
        volumeMounts:
        - mountPath: /etc/otel/
          name: otel-config
      volumes:
      - name: otel-config
        configMap:
          name: otel-config
---
apiVersion: v1
kind: Service
metadata:
  name: otel-collector
  namespace: otel
spec:
  selector:
    app: otel-collector
  ports:
    - protocol: TCP
      port: 8888
      targetPort: 8888
      name: metrics
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: otel-config
  namespace: otel
data:
  config.yaml: |-
    receivers:
      prometheus:
        config:
          scrape_configs:
          - job_name: &#39;otel_k8s&#39;
            kubernetes_sd_configs:
            - role: pod
            relabel_configs:
            - source_labels: [__meta_kubernetes_pod_label_app_kubernetes_io_name]
              action: keep
              regex: (prom-example|kube-state-metrics|otel-collector)
            - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
              action: replace
              target_label: __metrics_path__
              regex: (.+)
            - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
              action: replace
              regex: (.+):(?:&#92;d+);(&#92;d+)
              replacement: $$1:$$2
              target_label: __address__
            - action: labelmap
              regex: __meta_kubernetes_pod_label_(.+)

    processors:
      resourcedetection:
        detectors: [gcp]
        timeout: 10s

      transform:
        # &amp;quot;location&amp;quot;, &amp;quot;cluster&amp;quot;, &amp;quot;namespace&amp;quot;, &amp;quot;job&amp;quot;, &amp;quot;instance&amp;quot;, and &amp;quot;project_id&amp;quot; are reserved, and
        # metrics containing these labels will be rejected.  Prefix them with exported_ to prevent this.
        metric_statements:
        - context: datapoint
          statements:
          - set(attributes[&amp;quot;exported_location&amp;quot;], attributes[&amp;quot;location&amp;quot;])
          - delete_key(attributes, &amp;quot;location&amp;quot;)
          - set(attributes[&amp;quot;exported_cluster&amp;quot;], attributes[&amp;quot;cluster&amp;quot;])
          - delete_key(attributes, &amp;quot;cluster&amp;quot;)
          - set(attributes[&amp;quot;exported_namespace&amp;quot;], attributes[&amp;quot;namespace&amp;quot;])
          - delete_key(attributes, &amp;quot;namespace&amp;quot;)
          - set(attributes[&amp;quot;exported_job&amp;quot;], attributes[&amp;quot;job&amp;quot;])
          - delete_key(attributes, &amp;quot;job&amp;quot;)
          - set(attributes[&amp;quot;exported_instance&amp;quot;], attributes[&amp;quot;instance&amp;quot;])
          - delete_key(attributes, &amp;quot;instance&amp;quot;)
          - set(attributes[&amp;quot;exported_project_id&amp;quot;], attributes[&amp;quot;project_id&amp;quot;])
          - delete_key(attributes, &amp;quot;project_id&amp;quot;)

      batch:
        # batch metrics before sending to reduce API usage
        send_batch_max_size: 200
        send_batch_size: 200
        timeout: 5s

      memory_limiter:
        # drop metrics if memory usage gets too high
        check_interval: 1s
        limit_percentage: 65
        spike_limit_percentage: 20

    # Note that the googlemanagedprometheus exporter block is intentionally blank
    exporters:
      googlemanagedprometheus:

    service:
      # 抓log失敗原因
      # telemetry:
      #     logs:
      #         level: DEBUG    
      pipelines:
        metrics:
          receivers: [prometheus]
          processors: [batch, memory_limiter, resourcedetection, transform]
          exporters: [googlemanagedprometheus]
    
      telemetry:
        metrics:
          level: detailed
          readers:
            - pull:
                exporter:
                  prometheus:
                    host: &amp;quot;0.0.0.0&amp;quot;
                    port: 8888 

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;a-deployment&quot; tabindex=&quot;-1&quot;&gt;a. deployment設定&lt;/h4&gt;
&lt;p&gt;annotations中 &lt;code&gt;prometheus.io/port: &amp;quot;8888&amp;quot;&lt;/code&gt; ，&lt;br /&gt;
是由於要抓取otel的metrics，所以特別指定的擷取metrics port，&lt;br /&gt;
不然prometheus預設擷取第一個port 4317。&lt;/p&gt;
&lt;h4 id=&quot;b-config&quot; tabindex=&quot;-1&quot;&gt;b. config設定&lt;/h4&gt;
&lt;p&gt;relabel_configs的source_labels &lt;code&gt;__meta_kubernetes_pod_label_app_kubernetes_io_name&lt;/code&gt;，&lt;br /&gt;
這邊指定要抓的metrics，需額外裝&lt;a href=&quot;https://github.com/kubernetes/kube-state-metrics&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;kube-state-metrics&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;prom-example是prometheus的範例檔，用此命令部屬&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl -n otel apply -f https://raw.githubusercontent.com/GoogleCloudPlatform/prometheus-engine/v0.13.0/examples/example-app.yaml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;收集器開啟LOG紀錄(除錯)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;service:
    telemetry:
        logs:
            level: DEBUG
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://github.com/open-telemetry/opentelemetry-collector-contrib/issues/32976&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Failed to scrape Prometheus endpoint&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;打開otel的port 8888 ，為了接收到metrics。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      telemetry:
        metrics:
          level: detailed
          readers:
            - pull:
                exporter:
                  prometheus:
                    host: &amp;quot;0.0.0.0&amp;quot;
                    port: 8888 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;otel的 config基本架構如下。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;設定&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;receivers&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;接收數據（Prometheus, OTLP, KubeletStats 等）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;processors&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;處理數據（批量處理、轉換、過濾）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;exporters&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;發送數據到不同後端（Prometheus, Loki, OTLP）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;service.pipelines&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定義數據流向（決定哪些數據要送到哪些地方）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;receivers（接收器）&lt;br /&gt;
作用：負責接收來自不同來源的數據，例如指標 (metrics)、日誌 (logs)、追蹤 (traces)。&lt;br /&gt;
ref. &lt;a href=&quot;https://opentelemetry.io/docs/collector/configuration/#receivers&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Receivers&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;processors（處理器）&lt;br /&gt;
對數據進行處理，如過濾、增強、聚合。&lt;br /&gt;
ref.&lt;a href=&quot;https://opentelemetry.io/docs/collector/configuration/#processors&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;processors&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;exporters（導出器）&lt;br /&gt;
作用：將數據導出到指定後端，例如 Prometheus、Loki、OTLP 服務等。&lt;br /&gt;
ref. &lt;a href=&quot;https://opentelemetry.io/docs/collector/configuration/#exporters&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;exporters&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;service（管道組合）&lt;br /&gt;
作用：定義不同類型的數據應該如何流動，設定接收器、處理器、導出器的組合方式。&lt;br /&gt;
ref.&lt;a href=&quot;https://opentelemetry.io/docs/collector/configuration/#service&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;service&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;p.s. 附上Otel demo的&lt;a href=&quot;https://raw.githubusercontent.com/open-telemetry/opentelemetry-demo/main/kubernetes/opentelemetry-demo.yaml&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;yaml&lt;/a&gt;，有一些基本的設定可以在這參考。&lt;/p&gt;
&lt;h3 id=&quot;3-otel&quot; tabindex=&quot;-1&quot;&gt;3. 驗證Otel資料&lt;/h3&gt;
&lt;p&gt;確認Otel-collector沒有錯誤。&lt;/p&gt;
&lt;p&gt;在 cloud Metrics Exporer輸入 &lt;code&gt;up&lt;/code&gt; 沒看到目標叢集&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/273-fig.1.png&quot; alt=&quot;273-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;打開 cluster，將&lt;code&gt;Cloud Monitoring&lt;/code&gt;的選項打開，只設定system。&lt;/p&gt;
&lt;p&gt;之後就會看到對應的metrics&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/273-fig.2.png&quot; alt=&quot;273-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-grafana-gmp&quot; tabindex=&quot;-1&quot;&gt;4. 用Grafana查看GMP&lt;/h3&gt;
&lt;p&gt;這不算是Otel的相關流程，&lt;br /&gt;
但追根究底，用了Otel統整資料，最後還是要給Grafana使用。&lt;/p&gt;
&lt;h4 id=&quot;grafana-gmp-a-href-https-cloud-google-com-stackdriver-docs-managed-prometheus-query-target-blank-class-external-link-grafana-a&quot; tabindex=&quot;-1&quot;&gt;使用Grafana查詢GMP的方法，文件-&lt;a href=&quot;https://cloud.google.com/stackdriver/docs/managed-prometheus/query&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用 Grafana 進行查詢&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Otel 的grafana流程圖&lt;a href=&quot;https://opentelemetry.io/docs/demo/collector-data-flow-dashboard/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;說明&lt;/a&gt;，Grafana dashboard可至&lt;br /&gt;
&lt;a href=&quot;https://grafana.com/grafana/dashboards/18309-opentelemetry-collector-data-flow/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;grafana dashboard&lt;/a&gt;下載。&lt;/p&gt;
&lt;p&gt;在2025/03/20時，我使用上面的dashboard，預設有很多chart是錯誤的，&lt;br /&gt;
追查是因為很多metrics的名稱被改掉，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;otelcol_receiver_accepted_spans&lt;/code&gt;被改成 &lt;code&gt;otelcol_receiver_accepted_metric_points_total&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;otelcol_receiver_refused_spans&lt;/code&gt;改 &lt;code&gt;otelcol_receiver_refused_metric_points_total&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;otelcol_receiver_accepted_metric_points&lt;/code&gt;改&lt;code&gt;otelcol_receiver_accepted_metric_points_total&lt;/code&gt;&lt;br /&gt;
..&lt;br /&gt;
類似的還有不少，當有錯誤時，可以確認一下內容。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面都是我搜尋otel metrics猜的metrics，&lt;br /&gt;
也不知道是不是正確，但看起來很像一回事。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/273-fig.3.png&quot; alt=&quot;273-fig.3.png&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;題外話&quot; tabindex=&quot;-1&quot;&gt;題外話&lt;/h3&gt;
&lt;p&gt;利用GPT問答時，&lt;br /&gt;
也有看到另一種架構，&lt;br /&gt;
當receivers過多時，在DaemonSet建立Otel-collector，&lt;br /&gt;
再匯入到一個Otel ，之後再由這個Otel決定要到哪個Exporter。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/273. GCP搞openTelemetry筆記/" />
        </entry>
        <entry>
            <title>
                272. istio將401的錯誤，自動轉成503
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/272. istio將401的錯誤，自動轉成503/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;這其實是蠻弔詭的狀況，&lt;br /&gt;
後端程式，在本地測試是回401 (Unauthorized)，&lt;br /&gt;
但到了QA就變成了502。&lt;br /&gt;
這件事我也只能吞了，開始查吧。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;首先查一下，什麼情況下會自動轉成503。&lt;br /&gt;
服務放在GKE上，並且將目標Pod的sidecar關閉。&lt;br /&gt;
目標的Pod為A，同Namespcae不同的Pod為B。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;從哪裡呼叫&lt;/th&gt;
&lt;th&gt;目標位置&lt;/th&gt;
&lt;th&gt;Status Code&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;外部&lt;/td&gt;
&lt;td&gt;網址，istio 轉到A Service&lt;/td&gt;
&lt;td&gt;502&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;Pod A ip&lt;/td&gt;
&lt;td&gt;502&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;Service A ip&lt;/td&gt;
&lt;td&gt;502&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;Pod A ip&lt;/td&gt;
&lt;td&gt;401&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;Service A ip&lt;/td&gt;
&lt;td&gt;401&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;但如果將B的sidecar也關閉， 則在B呼叫Pod 或 Service 都會回傳401。&lt;br /&gt;
這邊就不由得猜想是istio本身的問題。&lt;/p&gt;
&lt;p&gt;於是自己寫了個Golang的小程式，自訂回傳狀態碼401。&lt;br /&gt;
一測試發現，我從外部呼叫，Status code是正常的回傳401。&lt;/p&gt;
&lt;p&gt;看來istio沒問題，那就只剩下程式問題（甩鍋大成功）。&lt;br /&gt;
用curl -v 查看 401的錯誤訊息發現header有下面訊息。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/272-fig.1.png&quot; alt=&quot;272-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;轉交給RD，請他們確認這邊的訊息。&lt;br /&gt;
後來改完程式後就正常了。&lt;/p&gt;
&lt;p&gt;初步研判應該是istio判斷到 header有不明的訊息（見上圖），&lt;br /&gt;
觸發Retry機制，但觸發太多次，istio就直接回傳502的錯誤。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/272. istio將401的錯誤，自動轉成503/" />
        </entry>
        <entry>
            <title>
                271. IOT設備裝Prometheus搞Remote write
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/271. IOT設備裝Prometheus搞Remote write/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;監控IOT設備的一些基礎效能，&lt;br /&gt;
node_exporter裝好了，&lt;br /&gt;
但是怎麼把metrics丟出去..？？&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;SOLUTION&lt;/h1&gt;
&lt;h3 id=&quot;前置作業&quot; tabindex=&quot;-1&quot;&gt;前置作業&lt;/h3&gt;
&lt;h4 id=&quot;node-exporter&quot; tabindex=&quot;-1&quot;&gt;執行node_exporter&lt;/h4&gt;
&lt;p&gt;讓node_exporter背景執行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nohup ./node_exporter &amp;gt; node_exporter.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;prometheus-server&quot; tabindex=&quot;-1&quot;&gt;Prometheus Server設定&lt;/h4&gt;
&lt;p&gt;需開啟 &lt;code&gt;remote-write-receiver&lt;/code&gt;，&lt;br /&gt;
在參數的地方加上 &lt;code&gt;--web.enable-remote-write-receiver&lt;/code&gt;，&lt;br /&gt;
然後由於要對外，看你是使用哪種方式，就設定對外。&lt;br /&gt;
記得安全要做好，看是檔IP或是要用&lt;a href=&quot;https://prometheus.io/docs/prometheus/latest/configuration/https/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;基本驗證&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- name: prometheus-server
  image: &amp;quot;prom/prometheus:v2.48.0&amp;quot;
  imagePullPolicy: &amp;quot;IfNotPresent&amp;quot;
  args:
    - --web.enable-remote-write-receiver
    - --storage.tsdb.retention.time=95d
    - --config.file=/etc/config/prometheus.yml
    - --storage.tsdb.path=/data
    - --web.console.libraries=/etc/prometheus/console_libraries
    - --web.console.templates=/etc/prometheus/consoles
    - --web.enable-lifecycle
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;iot&quot; tabindex=&quot;-1&quot;&gt;IOT設備&lt;/h3&gt;
&lt;h4 id=&quot;step-1-prometheus&quot; tabindex=&quot;-1&quot;&gt;Step 1.  安裝Prometheus&lt;/h4&gt;
&lt;p&gt;由於這個IOT裝置，本身是busybox，很多東西不能用，&lt;br /&gt;
(apt,yum,apk這些通通不支援)&lt;br /&gt;
所以是先把壓縮包放到ftp，&lt;br /&gt;
(下載時建議先用&lt;code&gt;uname -a&lt;/code&gt;檢查一下OS版本，我這都是裝arm的版本)&lt;br /&gt;
再用sftp的指令下載。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sftp -P 222  abc@123.123.13.13
get prometheus.tar.gz
tar -zxvf prometheus.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;step-2-remote-write&quot; tabindex=&quot;-1&quot;&gt;Step 2. remote write設定檔&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;global:
  scrape_interval: 15s  # 每 15 秒抓取一次數據
  evaluation_interval: 15s  # 每 15 秒執行規則評估

scrape_configs:
  - job_name: &#39;node_exporter&#39;
    static_configs:
      - targets: [&#39;localhost:9100&#39;]

remote_write:
  - url: &amp;quot;https://remotewrite.test.com/api/v1/write&amp;quot;
    remote_timeout: 30s
    queue_config:
      batch_send_deadline: 5s
      max_samples_per_send: 100
      max_shards: 1
    write_relabel_configs:
      - source_labels: [__name__]
        regex: &amp;quot;.*&amp;quot;
        action: replace
        target_label: &amp;quot;iot&amp;quot;
        replacement: &amp;quot;shining_iot&amp;quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://prometheus.io/docs/prometheus/latest/configuration/configuration/#remote_write&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Remote_write config&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;step-3-prometheus&quot; tabindex=&quot;-1&quot;&gt;Step 3. 執行Prometheus&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;./prometheus --config.file ../prometheus.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&quot;step-3-1&quot; tabindex=&quot;-1&quot;&gt;Step 3-1. 除錯&lt;/h5&gt;
&lt;p&gt;然後，Prometheus Client 就出錯了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;tls: failed to verify certificate: x509: certificate signed by unknown authority&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看錯誤是憑證錯誤，所以先用curl驗證一下，&lt;br /&gt;
這台機器也沒辦法裝curl，所以還是只能去下載curl到ftp後，&lt;br /&gt;
再去ftp下載。&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;curl -v&lt;/code&gt; 在IOT設備，驗證promtheus server後出現錯誤&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -v https://remotewrite.test.com/api/v1/write
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;error setting certificate file: /etc/ssl/certs/ca-certificates.crt&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這樣看起來應該都是IOT設備沒有裝憑證導致。&lt;br /&gt;
透過curl下載letsencrypt憑證&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -o /etc/ssl/certs/ISRG_Root_X1.pem https://letsencrypt.org/certs/isrgrootx1.pem
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，上面有提到&lt;code&gt;curl -v&lt;/code&gt; 驗證https會發生錯誤，&lt;br /&gt;
所以，無法下載。&lt;br /&gt;
此時，回歸老方法，下載後丟去ftp，在傳到IOT設備。&lt;/p&gt;
&lt;p&gt;下載後，根據上面的錯誤訊息，建立資料夾&lt;br /&gt;
將&lt;code&gt;isrgrootx1.pem&lt;/code&gt; 改名成 &lt;code&gt;ca-certificates.crt&lt;/code&gt;放到 &lt;code&gt;/etc/ssl/certs&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p /etc/ssl/certs
cp isrgrootx1.pem /etc/ssl/certs/ca-certificates.crt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再驗證一次 ，正常。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -v https://remotewrite.test.com/api/v1/write
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;step-4-prometheus&quot; tabindex=&quot;-1&quot;&gt;Step 4. 再度執行Prometheus&lt;/h4&gt;
&lt;p&gt;這次執行後，出現另一個錯誤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;level=ERROR source=db.go:1109 msg=&amp;quot;compaction failed&amp;quot; component=tsdb err=&amp;quot;preallocate: no space left on device&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;檢查硬碟空間與inode都有足夠的空間，&lt;br /&gt;
發生這種情況是由於Prometheus的WAL(預寫日誌)的機制，&lt;br /&gt;
為了保證數據可靠性，所以會根據公式推出需要儲存的容量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;needed_disk_space = retention_time_seconds * ingested_samples_per_second * bytes_per_sample
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://prometheus.io/docs/prometheus/latest/storage/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Prometheus Storage&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但IOT設備空間本來就小，&lt;br /&gt;
所以只好縮！！！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./prometheus --storage.tsdb.retention.time=10m --storage.tsdb.retention.size=1MB --config.file ../prometheus.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最後到Prometheus Server看看有沒有資料傳上去就好了。&lt;br /&gt;
傳不上去的話就是看上傳的地方是否有地方要更改。&lt;/p&gt;
&lt;h4 id=&quot;題外話&quot; tabindex=&quot;-1&quot;&gt;題外話&lt;/h4&gt;
&lt;p&gt;看到有人說，開啟Remote Write的話，&lt;br /&gt;
會導致Server記憶體使用量上升。&lt;br /&gt;
目前還沒大量使用，也只能等到時再看看。&lt;br /&gt;
ref. &lt;a href=&quot;https://tsunejui.github.io/posts/prometheus-remote-write-performance-issue/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Prometheus Remote Write Performance Issue&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/271. IOT設備裝Prometheus搞Remote write/" />
        </entry>
        <entry>
            <title>
                269. PVC backup and restore
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/269. PVC backup and restore/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;又來個問題，PVC有辦法備份嗎？&lt;br /&gt;
本來是想用第二個掛載volume的方式，&lt;br /&gt;
將資料備份出來，但GKE的volume只支援ReadWriteOnce。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;h4 id=&quot;step-1-a-href-https-kubernetes-io-zh-cn-docs-concepts-storage-volume-snapshots-target-blank-class-external-link-volumesnapshot-a&quot; tabindex=&quot;-1&quot;&gt;Step 1. 檢查有沒有支援 &lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;volumesnapshot&lt;/a&gt;&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;kubectl api-resources | grep volumesnapshot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有的話，應該會看到類似這樣的訊息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/269-fig.1.png&quot; alt=&quot;269-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;step-2-pvc-csi-driver&quot; tabindex=&quot;-1&quot;&gt;Step 2. 確認要備份pvc的CSI driver&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;顯示全部的CSI driver
kubectl get csidrivers

根據storageclass查詢（Provisioner欄位）
kubectl get sc -o wide

查pv的CSI driver(CSI.driver欄位)
kubectl get pv &amp;lt;volume-name&amp;gt; -o yaml

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;step-3-volume-snapshot-class&quot; tabindex=&quot;-1&quot;&gt;Step 3. 建立VolumeSnapshotClass&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;kind: VolumeSnapshotClass
apiVersion: snapshot.storage.k8s.io/v1
metadata:
  name: volume-snapshot-class
  annotations:
    snapshot.storage.kubernetes.io/is-default-class: &amp;quot;true&amp;quot;
driver: pd.csi.storage.gke.io
deletionPolicy: Delete
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建完後，使用下面指令查看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get vsclass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;p.s. 可用 &lt;code&gt;kubectl api-resources&lt;/code&gt; 查詢縮寫&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/volume-snapshot-classes/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Volume Snapshot Classes&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;step-4-volume-snapshot&quot; tabindex=&quot;-1&quot;&gt;Step 4. 建立VolumeSnapshot&lt;/h4&gt;
&lt;p&gt;指定要備份的pvc&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshot
metadata:
  name: postgres-snapshot
  namespace: database
spec:
  volumeSnapshotClassName: volume-snapshot-class # change your vsclass
  source:
    persistentVolumeClaimName: postgres-pvc # change your pvc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建完後使用下面指令查看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get volumesnapshots -n database
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原本是可以直接使用vs作為縮寫代替，&lt;br /&gt;
但跟我的virtualservice衝突。&lt;/p&gt;
&lt;p&gt;VolumeSnapshot執行完後，會自動建立一個VolumeSnapshotContent。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kc get vsc -n database
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/269-fig.2.png&quot; alt=&quot;269-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;step-5&quot; tabindex=&quot;-1&quot;&gt;Step 5. 還原&lt;/h4&gt;
&lt;p&gt;建立一個pvc使用dataSource的方式還原，&lt;br /&gt;
底下的 storageClassName、&lt;a href=&quot;http://datasource.name/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;dataSource.name&lt;/a&gt; 根據情況修改。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: restore-pvc
  namespace: database
spec:
  storageClassName: standard-rwo
  dataSource:
    name: postgres-snapshot
    kind: VolumeSnapshot
    apiGroup: snapshot.storage.k8s.io
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;單純執行建立pvc時，如出現錯誤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;waiting for first consumer to be created before binding&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這是由於storageClass的volumeBindingMode是 &lt;code&gt;WaitForFirstConsumer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以需要將deploy與pvc綁定，才能創建PV。&lt;/p&gt;
&lt;p&gt;但這個只能備份一次，&lt;br /&gt;
還必須手動，&lt;br /&gt;
所以要全自動的話，&lt;br /&gt;
再看看要怎麼搞了。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;卷快照&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ibrahimhkoyuncu.medium.com/kubernetes-complete-guide-to-kubernetes-volumesnapshot-pvc-backup-and-restore-and-automated-2aade2a3a90a&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kubernetes — Complete Guide to Kubernetes VolumeSnapshot, PVC Backup and Restore, and Automated PVC Backup for Data Management&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/269. PVC backup and restore/" />
        </entry>
        <entry>
            <title>
                268. DNS檔廣告伺服器-AdguardHome
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/268. DNS檔廣告伺服器-AdguardHome/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;有天看文章時，看到有人介紹  &lt;a href=&quot;https://pi-hole.net/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Pi-Hole&lt;/a&gt;，&lt;br /&gt;
這是一款 DNS Sinkhole，簡單說就是直接在DNS過濾廣告。&lt;br /&gt;
然後查了一下相關訊息，發現另一套 &lt;a href=&quot;https://adguard.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Adguard&lt;/a&gt;，&lt;br /&gt;
這套以前就有看過，但要付費。&lt;br /&gt;
但是！！！他有提供免費版本，可以替代Pi-Hole。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;p&gt;隨便找一台機器，使用docker安裝。&lt;br /&gt;
下面提供docker-compose版本。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version: &#39;3.8&#39;

services:
  adguardhome:
    image: adguard/adguardhome
    container_name: adguardhome
    restart: unless-stopped
    volumes:
      - ./data/workdir:/opt/adguardhome/work
      - ./date/confdir:/opt/adguardhome/conf
    ports:
      - &amp;quot;53:53/tcp&amp;quot;
      - &amp;quot;53:53/udp&amp;quot;
      - &amp;quot;3000:3000/tcp&amp;quot;
      - &amp;quot;3310:3310/tcp&amp;quot;
      - &amp;quot;784:784/udp&amp;quot;  # run AdGuard Home as a DNS-over-QUIC⁠ server. 
      - &amp;quot;853:853/udp&amp;quot;   # run AdGuard Home as a DNS-over-QUIC⁠ server. 
      - &amp;quot;8853:8853/udp&amp;quot;  # run AdGuard Home as a DNS-over-QUIC⁠ server. 
    networks:
      - adguard_network

networks:
  adguard_network:
    driver: bridge

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由於我是使用docker對映port轉發，&lt;br /&gt;
所以使用機器的ip後面加上port 3000，&lt;br /&gt;
此時會到設定畫面。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/268-fig.1.png&quot; alt=&quot;268-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;將上面的port，由預設的80改為3310。&lt;br /&gt;
(因為我機器的80被用走了)，&lt;br /&gt;
再來設定帳密，之後都直接下一步即可。&lt;/p&gt;
&lt;p&gt;但到了開啟儀表板的按鈕時，需手動更改位置。&lt;br /&gt;
因為預設開啟的位置是 &lt;code&gt;172.31.0.2:3310&lt;/code&gt; ，&lt;br /&gt;
這是adguard的container ip。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/268-fig.2.png&quot; alt=&quot;268-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;改成上面開啟設定頁面的ip 加上剛剛設定的port 3310, &lt;code&gt;192.168.103.224:3310&lt;/code&gt;&lt;br /&gt;
就能開啟登入頁了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/268-fig.3.png&quot; alt=&quot;268-fig.3.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;詳情參考&lt;a href=&quot;https://adguard-dns.io/kb/zh-CN/adguard-home/getting-started/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;入門&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果不想使用docker compose，&lt;br /&gt;
&lt;a href=&quot;https://hub.docker.com/r/adguard/adguardhome&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;dockerhub&lt;/a&gt;上面有指令。&lt;br /&gt;
如果用docker run的話，可能要看一下打算用哪個port去開啟儀表板。&lt;br /&gt;
下面的圖就不太適合了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run --name adguardhome&#92;
    --restart unless-stopped&#92;
    -v /my/own/workdir:/opt/adguardhome/work&#92;
    -v /my/own/confdir:/opt/adguardhome/conf&#92;
    -p 53:53/tcp -p 53:53/udp&#92;
    -p 67:67/udp -p 68:68/udp&#92;
    -p 80:80/tcp -p 443:443/tcp -p 443:443/udp -p 3000:3000/tcp&#92;
    -p 853:853/tcp&#92;
    -p 784:784/udp -p 853:853/udp -p 8853:8853/udp&#92;
    -p 5443:5443/tcp -p 5443:5443/udp&#92;
    -d adguard/adguardhome

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之後記得到要使用的裝置上面更改dns。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://hub.docker.com/r/adguard/adguardhome&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;docker hub adguard/adguardhome&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/AdguardTeam/AdGuardHome&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;github AdGuardHome&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://adguard-dns.io/kb/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;manual&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/268. DNS檔廣告伺服器-AdguardHome/" />
        </entry>
        <entry>
            <title>
                267. cloudflare  308-ERR_TOO_MANY_REDIRECTS
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/267. cloudflare  308-ERR_TOO_MANY_REDIRECTS/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;過年前發生的事情，&lt;br /&gt;
只要經過cloudflare的CDN，就會有某些檔案抓不到，&lt;br /&gt;
網站就直接卡住，就算清了cloudflare的快取，&lt;br /&gt;
過一陣子還是在其他圖片上卡住。&lt;/p&gt;
&lt;h1 id=&quot;troubleshoting&quot; tabindex=&quot;-1&quot;&gt;Troubleshoting&lt;/h1&gt;
&lt;p&gt;那時懷疑是CDN的問題，&lt;br /&gt;
所以直接在網址後面接上 &lt;code&gt;cdn-cgi/trace&lt;/code&gt;，&lt;br /&gt;
完整網址：&lt;code&gt;domain.com/cdn-cgi/trace&lt;/code&gt;&lt;br /&gt;
這樣就能看到這個是走去哪邊取快取資料。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fl=447f46
h=domain.com
ip=123.123.123.123
ts=1738566177.011
visit_scheme=https
uag=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36
colo=LAX
sliver=none
http=http/3
loc=TW
tls=TLSv1.3
sni=plaintext
warp=off
gateway=off
rbi=off
kex=X25519MLKEM768
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://developers.cloudflare.com/fundamentals/reference/cdn-cgi-endpoint/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;/cdn-cgi/ endpoint&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;緊急修復，開啟開發者模式&lt;br /&gt;
只能撐三小時，切記、切記、切記，&lt;br /&gt;
除非你要特地寫個api，不斷去點開關。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/267-fig.1.png&quot; alt=&quot;267-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;關閉CDN&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSL/TLS加密(待驗證)&lt;br /&gt;
之後查了一些&lt;a href=&quot;https://developers.cloudflare.com/ssl/troubleshooting/too-many-redirects/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;資料&lt;/a&gt;，這個錯誤都是因為ssl憑證發生問題，&lt;br /&gt;
例如原本為https要轉到http就會發生此錯誤，&lt;br /&gt;
很剛好，之前的ssl憑證這一塊都是採用靈活。&lt;br /&gt;
只有一邊有鎖頭，但另一邊沒有。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/267-fig.2.png&quot; alt=&quot;267-fig.2.png&quot; /&gt;&lt;br /&gt;
但這個又不能馬上說改就改，&lt;br /&gt;
有些東西要提前作業(cloudstorage的LB要改成https)。&lt;br /&gt;
年後測試下去，就正常了正常了，&lt;br /&gt;
所以我也不知道是不是SSL的問題。&lt;br /&gt;
但全都SSL憑證還是比較好。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.github.io/267. cloudflare  308-ERR_TOO_MANY_REDIRECTS/" />
        </entry>
        <entry>
            <title>
                266. Promtail 擷取docker log
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/266. Promtail 擷取docker log/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;之前是用filebeat將log丟到EFK裡面&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/244.%20%E5%9C%A8GCE%E4%BD%BF%E7%94%A8filebeat%E5%82%B3%E5%88%B0GKE%E7%9A%84ECK/&quot;&gt;244. 在GCE使用filebeat傳到GKE的ECK&lt;/a&gt;&lt;br /&gt;
最近有些案子開始改用loki了，&lt;br /&gt;
所以GCE這邊也要跟著改一下。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;專案越來越多，&lt;br /&gt;
也開始思考要不要那麼多grafana了。&lt;br /&gt;
所以loki統一丟到同一台上面，&lt;br /&gt;
雖然說Loki對於全文檢索不太適合，&lt;br /&gt;
但如果是針對時間戳記的話是還蠻好用的。&lt;/p&gt;
&lt;p&gt;Docker-compose.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version: &#39;3.8&#39;

services:
  promtail:
    image: grafana/promtail:3.2.1
    container_name: promtail
    command: --config.file=/mnt/config/promtail-config.yaml
    volumes:
      - ./promtail.yaml:/mnt/config/promtail-config.yaml
      - /var/lib/docker/containers:/var/lib/docker/containers
    networks:
      - zlm_network


networks:
  zlm_network:
    driver: bridge
    name: zlm_network

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;簡單掛載promtail，雖然官方文章也有提到使用&lt;a href=&quot;https://grafana.com/docs/loki/latest/send-data/docker-driver/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;docker driver&lt;/a&gt; 。&lt;br /&gt;
但有點懶得再弄其他套了。&lt;/p&gt;
&lt;p&gt;promtail.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server:
  http_listen_port: 9080
  grpc_listen_port: 0

clients:
- url: http://10.60.16.12:3100/loki/api/v1/push

positions:
  filename: /tmp/positions.yaml
target_config:
  sync_period: 10s
scrape_configs:
  - job_name: container_scrape # Job Name
    pipeline_stages:
        - docker: {}
        - static_labels: 
            project: &amp;quot;gr-video-qa&amp;quot;  
    docker_sd_configs: # 使用 Docker Service Discovery
      - host: unix:///var/run/docker.sock # Docker Socket 的位置
        refresh_interval: 5s # 每 5 秒重新掃描一次 Docker Socket
    relabel_configs: # 將 Docker 相關的資訊轉換成 Label
      - source_labels: [&#39;__meta_docker_container_name&#39;] # 將 __meta_docker_container_name 轉為新的名為 container 的 Label
        regex: &#39;/(.*)&#39; # 使用正規表達式取出 Container Name
        target_label: &#39;container&#39;
      - source_labels: [&#39;__meta_docker_container_log_stream&#39;] # 將 __meta_docker_container_log_stream 轉為新的名為 logstream 的 Label
        target_label: &#39;logstream&#39;        

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;promtail的設定檔，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://grafana.com/docs/loki/latest/send-data/promtail/configuration/#pipeline_stages&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;pipeline_stages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://grafana.com/docs/loki/latest/send-data/promtail/stages/static_labels/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;static_labels&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://grafana.com/docs/loki/latest/send-data/promtail/configuration/#docker_sd_configs&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;docker_sd_configs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他部分，參考&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10331661&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Promtail — Loki 御用 Log 收集器&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/266. Promtail 擷取docker log/" />
        </entry>
        <entry>
            <title>
                265. Golang簡略筆記（二）
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/265. Golang簡略筆記（二）/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;懶是工程師的原動力，&lt;br /&gt;
起因是我不想要手動比對兩份GCP價格的金額有哪些差距。&lt;br /&gt;
用excel vlookup 應該也是能處理，但可能需要重複的剪剪貼貼，&lt;br /&gt;
或是寫成vba，都要寫code的話，就直接寫吧。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;回傳時，可以用 &lt;code&gt;_&lt;/code&gt; 省略回傳的參數&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;只取得row值，備忘一下&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;cell&lt;/th&gt;
&lt;th&gt;col&lt;/th&gt;
&lt;th&gt;row&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A8&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;_, lastEndRow := parseCell(merge.GetEndAxis())

// parseCell: 將 Excel 的儲存格名稱 (如 &amp;quot;A1&amp;quot;) 解析為列號與行號
func parseCell(cell string) (col int, row int) {
	col, row, err := excelize.CellNameToCoordinates(cell)
	if err != nil {
		log.Fatalf(&amp;quot;解析儲存格名稱失敗: %v&amp;quot;, err)
	}
	return col, row
}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;拆func時，傳送指標&lt;br /&gt;
解析excel，不可避免的就是開檔，&lt;br /&gt;
用指標的話&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;避免複製大型結構體&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;excelize.File&lt;/code&gt; 內部可能包含大量資料，例如工作表、儲存格的值和格式等。如果傳遞整個結構體，而不是指標，Go 會將整個物件複製一份，這會浪費記憶體和處理時間。&lt;/li&gt;
&lt;li&gt;使用指標可以直接操作原始資料，避免不必要的複製。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;允許修改原始資料&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你需要對 &lt;code&gt;excelize.File&lt;/code&gt; 做修改（例如更新儲存格的值或新增工作表），指標讓你能夠直接操作原始物件，而不需要傳回新的副本。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;資源管理&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;excelize.File&lt;/code&gt; 可能會開啟檔案並佔用系統資源。使用指標可以確保同一份資源不會被複製，方便正確關閉或釋放資源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上述原話來自chatGPT&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
func insertData(f *excelize.File, sheetName string, db *sql.DB) {
....
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;數字轉字串&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;moneyCell := &amp;quot;H&amp;quot; + strconv.Itoa(lastEndRow)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;
&lt;p&gt;output的差異&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能設計不同&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;- &lt;code&gt;fmt&lt;/code&gt;：用於普通的輸出和格式化，更多的是用來處理程序正常運行時的輸出。&lt;br /&gt;
- &lt;code&gt;log&lt;/code&gt;：專門用於記錄事件、錯誤和診斷程序問題，通常會自動添加時間戳，讓記錄更方便檢索。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用場景不同&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fmt&lt;/code&gt; 適合用於格式化和打印普通的輸出內容（如程序的正常輸出或輸入提示）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;log&lt;/code&gt; 適合用於記錄關鍵事件（如錯誤日誌、調試資訊），特別是需要包含時間戳的情況。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;錯誤處理的需求&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fmt&lt;/code&gt; 更偏向於簡單的輸出，不關注程序的運行狀態。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;log&lt;/code&gt; 提供專門的方法（如 &lt;code&gt;log.Fatal&lt;/code&gt; 和 &lt;code&gt;log.Panic&lt;/code&gt;），可以快速輸出錯誤並中止程序執行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上來自ChatGPT&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;兩者都有Print,Printf,Println&lt;br /&gt;
分別代表 列印，格式化列印(%s,%d)，換行列印。&lt;/p&gt;
&lt;p&gt;錯誤訊息  fmt.Errorf 與 log.Fatalf ，&lt;br /&gt;
前者是回傳error，後者則輸出錯誤訊息並結束程式&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;
&lt;p&gt;查SQLite的軟體&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sqlitebrowser.org/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;DB Browser for SQLite&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;brew install db-browser-for-sqlite
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;conclusion&quot; tabindex=&quot;-1&quot;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;ChatGPT很好用沒錯，&lt;br /&gt;
不然這個程式花的時間可能要更久，&lt;br /&gt;
需要先查要用哪個套件，判斷哪些儲存格是合併的，&lt;br /&gt;
再取他後面欄位的值，建立sqlite、table，insert，update。&lt;br /&gt;
因為不只一個sheet要做，所以將原本func main底下的程式重構。&lt;br /&gt;
讓程式簡潔點。&lt;/p&gt;
&lt;p&gt;但是，GPT也是有幻覺，我要計算SQL A跟B 欄位的差距(C)，&lt;br /&gt;
A已經有值，B是update後才有值，&lt;br /&gt;
同時計算C的話，會變成NULL。&lt;br /&gt;
GPT跟我說能同時計算，跟我印象中的不一樣，&lt;br /&gt;
我一再確認，GPT還是說可以(暈)。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/265. Golang簡略筆記（二）/" />
        </entry>
        <entry>
            <title>
                264. use golang debug on mac m3
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/264. use golang debug on mac m3/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;之前的筆電是mbp ，那時還是intel的筆電。&lt;br /&gt;
換來mba之後，變成m3的記憶體了。&lt;br /&gt;
執行go 的程式都沒問題，&lt;br /&gt;
只要用vscode debug就直接噴錯。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Failed to launch: could not launch process: can not run under Rosetta, check that the installed build of Go is right for your CPU architecture.
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;p&gt;先確認 go的版本&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;go version
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果顯示的是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;go version go1.23.4 darwin/amd64&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需改安裝 arm64版本。&lt;/p&gt;
&lt;p&gt;如果用&lt;code&gt;brew install go&lt;/code&gt; ，會自動判斷你的golang版本，&lt;br /&gt;
所以不需額外修改。&lt;/p&gt;
&lt;p&gt;但是，如果你之前是用pkg安裝的話，&lt;br /&gt;
你會發現用brew怎樣安裝，版本都改不過去。&lt;br /&gt;
就算安裝後移除再重裝，也是一樣。&lt;/p&gt;
&lt;p&gt;所以，直接到&lt;a href=&quot;https://go.dev/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;官網&lt;/a&gt;下載正確版本吧。&lt;/p&gt;
&lt;h1 id=&quot;toubleshooting&quot; tabindex=&quot;-1&quot;&gt;Toubleshooting&lt;/h1&gt;
&lt;p&gt;使用 &lt;code&gt;go env&lt;/code&gt; 會看到GOPATH 是建立在 &lt;code&gt;/home/user/go&lt;/code&gt;，&lt;br /&gt;
但&lt;code&gt;.zshrc&lt;/code&gt;裡面並沒有這個設定檔，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;是由於 在 Go 1.11 版本之后，Go 引入了 &lt;strong&gt;Go Modules&lt;/strong&gt;，並默認不在依賴 &lt;code&gt;GOPATH&lt;/code&gt; by ChatGPT&lt;/p&gt;
&lt;/blockquote&gt;

            </content>
            <link href="https://daimom.github.io/264. use golang debug on mac m3/" />
        </entry>
        <entry>
            <title>
                263. Linux 查看文件內容
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/263. Linux 查看文件內容/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;其實很少用到，&lt;br /&gt;
但新服務剛架起來的時候，&lt;br /&gt;
就真的很需要他。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;h4 id=&quot;cat&quot; tabindex=&quot;-1&quot;&gt;Cat&lt;/h4&gt;
&lt;p&gt;最基礎的用法&lt;br /&gt;
缺點是，當內容太多時，會很難看，&lt;br /&gt;
此時能搭配&lt;code&gt;grep&lt;/code&gt;做內容搜尋。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat 123.log
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;head&quot; tabindex=&quot;-1&quot;&gt;head&lt;/h4&gt;
&lt;p&gt;取文字檔的最上面幾行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;head -n 10 123.log
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;tail&quot; tabindex=&quot;-1&quot;&gt;tail&lt;/h4&gt;
&lt;p&gt;取文字檔的最後面幾行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tail -n 10 123.log
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;man&quot; tabindex=&quot;-1&quot;&gt;man&lt;/h4&gt;
&lt;p&gt;查詢指令用法，&lt;br /&gt;
有時用 &lt;code&gt;&amp;lt;command&amp;gt; -h&lt;/code&gt; 會找不到使用方式，&lt;br /&gt;
此時可用 &lt;code&gt;man &amp;lt;command&amp;gt;&lt;/code&gt; 去搜尋&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;man find
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要做到後續的處理，寫shellscript，&lt;br /&gt;
&lt;code&gt;awk&lt;/code&gt; 與 &lt;code&gt;xargs&lt;/code&gt; 都是常用的指令。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.trevorlasn.com/blog/10-essential-terminal-commands-every-developer-should-know&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;10 Essential Terminal Commands Every Developer Should Know&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/263. Linux 查看文件內容/" />
        </entry>
        <entry>
            <title>
                262. PostgreSQL on k8s
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/262. PostgreSQL on k8s/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;RD說他的資料庫用量應該是很小、非常小，&lt;br /&gt;
所以用不到GCP的Cloud SQL，&lt;br /&gt;
加上他的資料，根據他本人說法，不重要，隨時可以刪除。&lt;br /&gt;
所以就自己建了。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;h3 id=&quot;安裝&quot; tabindex=&quot;-1&quot;&gt;安裝&lt;/h3&gt;
&lt;p&gt;查了一個上午，&lt;br /&gt;
還是一整個混亂，看起來大部分的人都是用Helm架設的。&lt;br /&gt;
然後都是朝高可用性下去執行。&lt;br /&gt;
但我應該是用不到，要到達高可用性就用GCP原生方案了。&lt;/p&gt;
&lt;p&gt;最後問了GPT，歷經了一些錯誤。&lt;br /&gt;
搞出了下面的yaml。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Namespace
metadata:
  name: database
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgresql
  namespace: database
  labels:
    app: postgresql
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgresql
  template:
    metadata:
      labels:
        app: postgresql
    spec:
      containers:
      - name: postgres
        image: postgres:17
        ports:
        - containerPort: 5432
        env:
        - name: POSTGRES_USER
          value: admin
        - name: POSTGRES_PASSWORD
          value: ifQiD
        - name: POSTGRES_DB
          value: main
        - name: PGDATA
          value: /var/lib/postgresql/data/pgdata
        volumeMounts:
        - name: postgres-data
          mountPath: /var/lib/postgresql/data
      volumes:
      - name: postgres-data
        persistentVolumeClaim:
          claimName: postgres-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: postgresql
  namespace: database
  labels:
    app: postgresql
spec:
  type: ClusterIP
  ports:
  - port: 5432
    targetPort: 5432
  selector:
    app: postgresql
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
  namespace: database
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;驗證連線&quot; tabindex=&quot;-1&quot;&gt;驗證連線&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;apt update
apt install postgresql-client

&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#驗證版本&quot;&gt;#驗證版本&lt;/a&gt;
psql --version

# connection
psql -h postgresql.database.svc.cluster.local -p 5432 -U admin -d main


# 確認目前連接的資料庫
SELECT current_database();

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h3&gt;
&lt;p&gt;如果要改用高可用性的話，GCP文件有教學，&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/tutorials/stateful-workloads/postgresql?hl=zh-cn#deploy-postgresql&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;在 GKE 上部署高可用性 PostgreSQL 資料庫&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也有&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/tutorials/stateful-workloads/mysql?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;在 GKE 上部署有狀態 MySQL 叢集&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;補充說明&quot; tabindex=&quot;-1&quot;&gt;補充說明&lt;/h3&gt;
&lt;p&gt;Artifact Hub ： CNCF基金會孵化專門用來尋找雲端軟體的網頁。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cncf.io/blog/2024/09/17/artifact-hub-becomes-a-cncf-incubating-project/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Artifact Hub becomes a CNCF incubating project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://artifacthub.io/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Artifact Hub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/262. PostgreSQL on k8s/" />
        </entry>
        <entry>
            <title>
                261. Loki筆記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/261. Loki筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;好記性，不如爛筆頭。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;
&lt;p&gt;Grafana  Observerbility家族&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Grafana：提供強大可視化和監控功能的開源平台，支援多種數據來源和外掛，適用於構建各類儀表板。&lt;/li&gt;
&lt;li&gt;Prometheus：一個開源系統監控和警報工具，專門設計用來收集時序數據，並與 Grafana 整合，適合用於微服務架構的監控。&lt;/li&gt;
&lt;li&gt;AlertManager：Prometheus 的告警管理元件，負責處理告警的路由和通知，確保及時響應系統異常。&lt;/li&gt;
&lt;li&gt;Grafana Loki：專為日誌聚合設計的系統，能夠高效地收集和查詢日誌數據，並與 Grafana 無縫整合，適合用於微服務環境的日誌監控。&lt;/li&gt;
&lt;li&gt;Grafana Tempo：分佈式追蹤系統，專門設計用來追蹤和分析微服務之間的請求路徑，幫助識別性能瓶頸。&lt;/li&gt;
&lt;li&gt;Grafana Mimir：高可擴展的時序數據存儲系統，適合處理大規模監控數據的存儲需求，提供高效的查詢性能。&lt;/li&gt;
&lt;li&gt;Grafana Alloy：強化可觀測性的解決方案，專注於提供統一的數據聚合和分析能力，幫助使用者更好地理解和優化其應用性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10354224&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;後 Grafana 時代的第五天 - 探討 Grafana 大規模中心化架構的演變&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Loki主要分成兩種檔案類型，一種是index，另一種是chunk。&lt;br /&gt;
前者作為索引目錄表，後者是儲存log。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;a href=&quot;https://grafana.com/docs/loki/latest/get-started/architecture/#index-format&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;&lt;strong&gt;index&lt;/strong&gt;&lt;/a&gt; is a table of contents of where to find logs for a specific set of labels.&lt;br /&gt;
The &lt;a href=&quot;https://grafana.com/docs/loki/latest/get-started/architecture/#chunk-format&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;&lt;strong&gt;chunk&lt;/strong&gt;&lt;/a&gt; is a container for log entries for a specific set of labels&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在schema_config裡面代表的欄位為 &lt;code&gt;store&lt;/code&gt; 與 &lt;code&gt;object_store&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The simple scalable deployment mode can scale up to a few TBs of logs per day&lt;br /&gt;
helm部屬loki是採用簡單部屬，但簡單部屬已可達到每天TB等級的資料。&lt;br /&gt;
超過需要改用microservices。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://grafana.com/docs/loki/latest/get-started/deployment-modes/#simple-scalable&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;simple-scalable&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Promtail&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Promtail is feature complete. All future feature development will occur in Grafana Alloy.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;傳送資料時，&lt;br /&gt;
可先用dry-run驗證&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat my.log | promtail --stdin --dry-run --inspect --client.url http://127.0.0.1:3100/loki/api/v1/push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://grafana.com/docs/loki/latest/send-data/promtail/troubleshooting/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Troubleshooting Promtail&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10331661&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Promtail — Loki 御用 Log 收集器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;loki語法查詢&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;|=&lt;/code&gt; (contains string) and&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!=&lt;/code&gt; (does not contain string) over the regular expression filter operators:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|~&lt;/code&gt; (matches the regular expression)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!~&lt;/code&gt; (does not match the regular expression)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Explorer Logs&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;配合Loki好用的套件，可直接看到所有的Log。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/261-fig.1.png&quot; alt=&quot;261-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;要使用&lt;a href=&quot;https://grafana.com/docs/loki/latest/visualize/grafana/#explore-logs&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Explore Logs&lt;/a&gt;](&lt;a href=&quot;https://grafana.com/docs/loki/latest/visualize/grafana/#explore-logs&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://grafana.com/docs/loki/latest/visualize/grafana/#explore-logs&lt;/a&gt;)，需更新到 Grafana 11.3。&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;Loki可以無縫銜接使用新的儲存系統&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下是節錄自 &lt;a href=&quot;https://grafana.com/docs/loki/latest/operations/storage/tsdb/#single-store-tsdb-tsdb&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Single Store TSDB (tsdb)&lt;/a&gt;&lt;br /&gt;
有兩個store的版本，假設今天是 2023-01-04 ，&lt;br /&gt;
可以指定 2023-01-05後，改使用另一個store。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;schema_config:
  configs:
    # Old boltdb-shipper schema. Included in example for reference but does not need changing.
    - from: &amp;quot;2023-01-03&amp;quot; # &amp;lt;---- A date in the past
      index:
        period: 24h
        prefix: index_
      object_store: gcs
      schema: v12
      store: boltdb-shipper
    # New TSDB schema below
    - from: &amp;quot;2023-01-05&amp;quot; # &amp;lt;---- A date in the future
      index:
        period: 24h
        prefix: index_
      object_store: gcs
      schema: v13
      store: tsdb
...

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;loki vs elastic search&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;loki的架構比較適合Low-cardinality。&lt;br /&gt;
elk則可以支援到 High-cardinality。&lt;/p&gt;
&lt;p&gt;Low-cardinality表示一列有很多重複的值. 性別/姓名都算是低基數.&lt;br /&gt;
High-cardinality意味著該列包含很大比例的唯一值. 所以像UniqueID, UUID這樣的值在該列則能稱為高基數.&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://ithelp.ithome.com.tw/articles/10287270&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;## 淺談Observability(上)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Loki 不對Log內容進行索引，僅索引Log的label。&lt;br /&gt;
ELK則會針對每個字段做索引，故可以用全文檢索。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ELK（Elasticsearch）適合場景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要對High-cardinality字段（如唯一 ID、IP 地址、用戶名等）進行查詢和分析。&lt;/li&gt;
&lt;li&gt;支持複雜的全文檢索、聚合和篩選需求。&lt;/li&gt;
&lt;li&gt;願意接受更高的存儲和運行成本。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Loki 適合場景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重點是時間序列日志分析，標籤數量有限（Low-cardinality）。&lt;/li&gt;
&lt;li&gt;不需要對日志的詳細字段進行高卡諾性查詢，而是更多關注基於時間範圍的日志搜索。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;Loki日誌保存&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;主要是下面這些。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;limits_config:
  max_label_names_per_series: 20
  max_cache_freshness_per_query: 10m
  query_timeout: 300s
  reject_old_samples: true
  reject_old_samples_max_age: 168h
  split_queries_by_interval: 15m
  volume_enabled: true
  retention_period: 750h
compactor:
  working_directory: /var/loki/data/retention
  retention_enabled: true
  delete_request_store: filesystem
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;retention_enabled： 一定要設&lt;br /&gt;
delete_request_store：看是要刪除那邊的檔案，我的object_store使用filesystem。&lt;br /&gt;
retention_period：就看要保留多久了。&lt;/p&gt;
&lt;p&gt;然後，loki的使用量真的低，prometheue使用量還比他高！？&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://grafana.com/docs/loki/latest/operations/storage/retention/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Log retention&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;9&quot;&gt;
&lt;li&gt;大小寫忽略&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在dashboard的時候，增加一個textbox供使用者查詢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/261-fig.2.png&quot; alt=&quot;261-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果要搜尋多個字串的話，不能用 &lt;code&gt;|=&lt;/code&gt; 要使用 &lt;code&gt;|~&lt;/code&gt; 正則表示。&lt;br /&gt;
忽略大小寫則是 &lt;code&gt;(?i)&lt;/code&gt;&lt;br /&gt;
整合起來就是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{service_name=`control`} | json |~ &amp;quot;(?i)$search&amp;quot; | logfmt | drop __error__, __error_details__
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/261. Loki筆記/" />
        </entry>
        <entry>
            <title>
                260. Grafana 變數連動
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/260. Grafana 變數連動/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;延續上一篇 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/259.%20Loki%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E9%AB%94%E9%A9%97/&quot;&gt;259. Loki快速上手體驗&lt;/a&gt; 的效果。&lt;br /&gt;
要讓log更好用的話，需要幾個變數，&lt;br /&gt;
原本是想做到當按下Label時，可以直接連動變數，&lt;br /&gt;
可惜還沒有找到相關資料，只好先用下拉選單做連動變數。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;連動變數，首先針對的都是有第一個來源，&lt;br /&gt;
第二個才能根據第一個的選擇去作查詢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/260-fig.1.png&quot; alt=&quot;260-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;第一個是namespace，第二個deployment就是filter namespace的值。&lt;/p&gt;
&lt;p&gt;來源是Prometheus，&lt;br /&gt;
因為如果選Loki的話，沒有辦法用Query Result去做，&lt;br /&gt;
只能用label name或 label value。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/260-fig.2.png&quot; alt=&quot;260-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;圖片中間的Regex的意思是，&lt;br /&gt;
取得 kube_deployment_labels底下 deployment的值。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/260-fig.3.png&quot; alt=&quot;260-fig.3.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;第三層同樣的方法。&lt;/p&gt;
&lt;p&gt;至於為什麼會到三層，因為實務上有碰到，當多個pod的時候，&lt;br /&gt;
你會需要看特定pod的log。&lt;/p&gt;
&lt;p&gt;最後 dashboard的metrics，Panel選擇Logs。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{namespace=&amp;quot;$namespace&amp;quot;, pod=~&amp;quot;.*$Deploy.*&amp;quot;, pod=~&amp;quot;$Pod&amp;quot;} |= ``
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/260-fig.4.png&quot; alt=&quot;260-fig.4.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;選擇Loki與Grafana的好處在於，&lt;br /&gt;
當你看到異常高峰的metrics時，&lt;br /&gt;
可以直接看到log，不用再跑去另一個地方查，&lt;br /&gt;
也可以說是 &lt;s&gt;懶人的作法&lt;/s&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/260. Grafana 變數連動/" />
        </entry>
        <entry>
            <title>
                259. Loki快速上手體驗
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/259. Loki快速上手體驗/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;新的服務又掛上去了，&lt;br /&gt;
本來想繼續掛EFK給人用，&lt;br /&gt;
但看了一下，如果監控的同時可以順便看Log好像也不錯。&lt;br /&gt;
監控是grafana，那log只能是 loki了。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;p&gt;先來看一下成果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/259-fig.1.png&quot; alt=&quot;259-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-loki&quot; tabindex=&quot;-1&quot;&gt;1. 部屬 Loki&lt;/h3&gt;
&lt;p&gt;我是直接從istio(1.21.1)，將loki.yaml直接拿出來部屬。&lt;br /&gt;
路徑在&lt;code&gt;istio-1.21.1/samples/addons/loki.yaml&lt;/code&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/istio/istio/blob/1.21.1/samples/addons/loki.yaml&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;github&lt;/a&gt;&lt;br /&gt;
原本的沒有namespace，需要的自行增加，&lt;br /&gt;
否則直接部屬即可。&lt;/p&gt;
&lt;h3 id=&quot;2-promtail&quot; tabindex=&quot;-1&quot;&gt;2. 部屬 Promtail&lt;/h3&gt;
&lt;p&gt;再來，部屬Promtail將 pod log丟到loki裡面。&lt;br /&gt;
k8s的話建議使用 DaemonSet的方法建。&lt;br /&gt;
如果想用其他方式，請洽&lt;a href=&quot;https://grafana.com/docs/loki/latest/send-data/promtail/installation/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;install-promtail&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這邊唯一要改的是Loki的位置，&lt;br /&gt;
Configmap：promtail-config&lt;br /&gt;
底下的 &lt;code&gt;data.clients.url&lt;/code&gt; 改為你的loki ip。&lt;br /&gt;
建立loki svc時的port為3100，&lt;br /&gt;
於是 &lt;code&gt;http://loki.istio-system.svc.cluster.local/loki/api/v1/push&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一開始測試時，可以先到任一pod裡面，呼叫 ready的api，&lt;br /&gt;
正常的話會回復一個ready的字串。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl http://loki.istio-system.svc.cluster.local/ready
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://grafana.com/docs/loki/latest/reference/loki-http-api/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Loki HTTP API&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--- # Daemonset.yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: promtail-daemonset
spec:
  selector:
    matchLabels:
      name: promtail
  template:
    metadata:
      labels:
        name: promtail
    spec:
      serviceAccount: promtail-serviceaccount
      containers:
      - name: promtail-container
        image: grafana/promtail
        args:
        - -config.file=/etc/promtail/promtail.yaml
        env: 
        - name: &#39;HOSTNAME&#39; # needed when using kubernetes_sd_configs
          valueFrom:
            fieldRef:
              fieldPath: &#39;spec.nodeName&#39;
        volumeMounts:
        - name: logs
          mountPath: /var/log
        - name: promtail-config
          mountPath: /etc/promtail
        - mountPath: /var/lib/docker/containers
          name: varlibdockercontainers
          readOnly: true
      volumes:
      - name: logs
        hostPath:
          path: /var/log
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
      - name: promtail-config
        configMap:
          name: promtail-config
--- # configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: promtail-config
data:
  promtail.yaml: |
    server:
      http_listen_port: 9080
      grpc_listen_port: 0

    clients:
    - url: https://{YOUR_LOKI_ENDPOINT}/loki/api/v1/push

    positions:
      filename: /tmp/positions.yaml
    target_config:
      sync_period: 10s
    scrape_configs:
    - job_name: pod-logs
      kubernetes_sd_configs:
        - role: pod
      pipeline_stages:
        - docker: {}
      relabel_configs:
        - source_labels:
            - __meta_kubernetes_pod_node_name
          target_label: __host__
        - action: labelmap
          regex: __meta_kubernetes_pod_label_(.+)
        - action: replace
          replacement: $1
          separator: /
          source_labels:
            - __meta_kubernetes_namespace
            - __meta_kubernetes_pod_name
          target_label: job
        - action: replace
          source_labels:
            - __meta_kubernetes_namespace
          target_label: namespace
        - action: replace
          source_labels:
            - __meta_kubernetes_pod_name
          target_label: pod
        - action: replace
          source_labels:
            - __meta_kubernetes_pod_container_name
          target_label: container
        - replacement: /var/log/pods/*$1/*.log
          separator: /
          source_labels:
            - __meta_kubernetes_pod_uid
            - __meta_kubernetes_pod_container_name
          target_label: __path__

--- # Clusterrole.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: promtail-clusterrole
rules:
  - apiGroups: [&amp;quot;&amp;quot;]
    resources:
    - nodes
    - services
    - pods
    verbs:
    - get
    - watch
    - list

--- # ServiceAccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: promtail-serviceaccount

--- # Rolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: promtail-clusterrolebinding
subjects:
    - kind: ServiceAccount
      name: promtail-serviceaccount
      namespace: default
roleRef:
    kind: ClusterRole
    name: promtail-clusterrole
    apiGroup: rbac.authorization.k8s.io
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;3-log&quot; tabindex=&quot;-1&quot;&gt;3. 看Log&lt;/h3&gt;
&lt;p&gt;先到Promtail的pod看有沒有錯誤，&lt;br /&gt;
沒有的話到grafana裡面，&lt;br /&gt;
如果你的grafana也是istio裡面的yaml安裝起來的話，&lt;br /&gt;
預設就會有loki的datasource，&lt;br /&gt;
不用再額外設定。&lt;/p&gt;
&lt;p&gt;開啟grafana，開啟選單的explorer。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/259-fig.2.png&quot; alt=&quot;259-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;datasource選 Loki&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/259-fig.3.png&quot; alt=&quot;259-fig.3.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;一開始可以用label選擇，這邊的app是我建立服務時所用的label。&lt;br /&gt;
也可以用deploy或namespace選擇。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/259-fig.4.png&quot; alt=&quot;259-fig.4.png&quot; /&gt;&lt;br /&gt;
最後按下右上的Run Query。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/259-fig.5.png&quot; alt=&quot;259-fig.5.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;這樣就表示有資料了。&lt;br /&gt;
此時，也可以按右上的Add dashboard，&lt;br /&gt;
套用到現有的dashboard或是建立一個都可以。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/259. Loki快速上手體驗/" />
        </entry>
        <entry>
            <title>
                258. GCP費用試算
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/258. GCP費用試算/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;之前聽上面的說，他們有買GCP的費用折扣。&lt;br /&gt;
直到最近我開始申請費用表單，&lt;br /&gt;
才發現申請的金額與GCP上面的費用一致，&lt;br /&gt;
搞不懂怎麼一回事。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;p&gt;首先，要先到 Billing裡面的Pricing，查看SKU的折扣。&lt;br /&gt;
這邊很多選項，&lt;br /&gt;
建議是先到Report裡面直接拿SKU ID搜尋，Group by選擇 SKU。&lt;br /&gt;
或是到 &lt;a href=&quot;https://cloud.google.com/skus/?currency=USD&amp;amp;hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Google Cloud Platform SKUs&lt;/a&gt; 搜尋 SKU ID。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/258-fig.1.png&quot; alt=&quot;258-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;最後，到pricing貼上 SKU ID&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/258-fig.2.png&quot; alt=&quot;258-fig.2.png&quot; /&gt;&lt;br /&gt;
就能查到 Effective discount。&lt;/p&gt;
&lt;p&gt;再來以前三高的金額試算&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以網路費用(Network Inter Region Data Transfer Out from Americas to APAC):12587.22G，&lt;br /&gt;
以&lt;a href=&quot;https://cloud.google.com/products/calculator?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GCP 計算機&lt;/a&gt;計算為 $1006.9，折扣 22% ，故 785.382，與費用明細一致。&lt;/p&gt;
&lt;p&gt;計算機計算時，要分清楚是哪一邊。&lt;br /&gt;
以費用名稱來看是屬於 Inter Region 的資料輸出，&lt;br /&gt;
故選擇下面的 Inter-Region。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/258-fig.5.png&quot; alt=&quot;258-fig.5.png&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GCP網站上，以CPU：C2D 使用時間 36248.56，每小時 0.034231，為1240.82 ，折扣 26% 故金額為 918 。&lt;br /&gt;
與費用明細上使用時間為 35281 hours ，金額為 893。視為一致。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;以CPU:E2 Custom 計算，使用時間為 30550.16， 每小時 0.02651815，為810.133，折扣 31.33% 故金額為 556.3188，&lt;br /&gt;
與費用明細拆成兩筆，使用時間為11567.12+18983.043，費用為 345.66+210.63 = 556.29，視為一致。&lt;br /&gt;
(E2 的網站費用有分成 Custom與一般的，每小時費用不一樣。)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/258-fig.3.png&quot; alt=&quot;258-fig.3.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/258-fig.4.png&quot; alt=&quot;258-fig.4.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/258. GCP費用試算/" />
        </entry>
        <entry>
            <title>
                257. istio-proxy Readiness probe failed
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/257. istio-proxy Readiness probe failed/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;最近同事在壓測服務，&lt;br /&gt;
然後發現他的pod常常無故重啟，&lt;br /&gt;
不是restart，而是整個pod重建。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;h3 id=&quot;2024-12-13&quot; tabindex=&quot;-1&quot;&gt;2024/12/13更新&lt;/h3&gt;
&lt;p&gt;&lt;mark&gt;找的方向錯誤，目前是這個NodePool只要掛上Taint後，&lt;br /&gt;
壓測時，就會導致Istio-proxy的readines 每小時重開一次。&lt;/mark&gt;&lt;/p&gt;
&lt;p&gt;看event事件，發現這個錯誤。&lt;br /&gt;
看來是istio-proxy本身的Readiness導致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/257-fig.1.png&quot; alt=&quot;257-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然後檢查istio-proxy本身的resource 也有設定limit。&lt;/p&gt;
&lt;p&gt;先改個limit設定試試。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spec:
  replicas: 1
  selector:
    matchLabels:
      app: gameservice
      group: gameservice
  template:
    metadata:
      annotations:
        sidecar.istio.io/proxyCPU: 200m
        sidecar.istio.io/proxyCPULimit: 2000m
        sidecar.istio.io/proxyMemory: 128Mi
        sidecar.istio.io/proxyMemoryLimit: 2Gi
    spec:
      containers: 
        .... 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這個可以指定單個pod使用此設定，&lt;br /&gt;
如果要設成全域，參考&lt;a href=&quot;https://discuss.istio.io/t/setting-global-resource-requests-for-sidecar-proxy/12066&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;setting-global-resource-requests-for-sidecar-proxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是，這情況仍然會發生。&lt;br /&gt;
猜測可能是壓策時，大量的請求塞到istio-proxy裡面導致無法負荷。&lt;br /&gt;
另一種是直接 &lt;s&gt;停用readiness&lt;/s&gt;了 。&lt;br /&gt;
下面的方法，是改寫不是停用，&lt;br /&gt;
目前還沒找到停用的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spec:
  replicas: 1
  selector:
    matchLabels:
      app: gameservice
      group: gameservice
  template:
    metadata:
      annotations:
		sidecar.istio.io/rewriteAppHTTPProbers: &amp;quot;false&amp;quot;
    spec:
      containers: 
        .... 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://istio.io/latest/zh/docs/ops/configuration/mesh/app-health-check/#disable-the-http-probe-rewrite-for-a-pod&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; Istio 服務的健康檢查&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://istio.io/latest/docs/reference/config/annotations/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Resource Annotations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://istio.io/latest/docs/reference/config/networking/workload-group/#ReadinessProbe&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Workload Group&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/257. istio-proxy Readiness probe failed/" />
        </entry>
        <entry>
            <title>
                256. httpbin取得request的header
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/256. httpbin取得request的header/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;這幾天在GKE幫人架srs origin+edge +zlm ，&lt;br /&gt;
然後到有沒有來源IP的header可供使用，&lt;br /&gt;
我記得有，但忘記名稱，&lt;br /&gt;
現在只有兩條路 ，一條是自己寫個後端回傳header的服務。&lt;br /&gt;
另一個就是找別人寫好的，還好有找到（我就記得我看過），&lt;br /&gt;
不然真的要自己寫了。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;有請， &lt;a href=&quot;https://httpbin.org/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Httpbin&lt;/a&gt; ，&lt;br /&gt;
要參考用哪些path的話，可以先到官方文件看一下。&lt;/p&gt;
&lt;p&gt;我就直接掛載成deploy和service了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Namespace
metadata:
  name: xff
  labels:
    istio-injection: enabled
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: httpbin
  namespace: xff
  labels:
    group: srs
    app: httpbin
spec:
  replicas: 1
  revisionHistoryLimit: 5
  progressDeadlineSeconds: 30
  selector:
    matchLabels:
      group: srs
      app: httpbin
  strategy:
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
    type: RollingUpdate
  template:
    metadata:
      labels:
        group: srs
        app: httpbin
    spec:
      containers:
        - name: srs
          image: kennethreitz/httpbin
          imagePullPolicy: IfNotPresent # IfNotPresent, Always, Never
          ports:
            - name: http-web
              containerPort: 80
              protocol: TCP
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      terminationGracePeriodSeconds: 30
---
apiVersion: v1
kind: Service
metadata:
  name: httpbin
  namespace: xff
spec:
  type: LoadBalancer
  selector:
    group: srs
    app: httpbin
  ports:
    - name: http-web
      protocol: TCP
      port: 80
      targetPort: 80
    - name: https
      protocol: TCP
      port: 443
      targetPort: 80  

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後，cloudflare掛ip，開啟proxy。&lt;br /&gt;
用自己的電腦呼叫自己設定的domain。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -X Get https://video-httpbin.abc.com/get
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/256-fig.1.png&quot; alt=&quot;256-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;這樣就看得到headers裡面的 &lt;code&gt;Cf-Connecting-Ip&lt;/code&gt; 就是來源IP。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/256. httpbin取得request的header/" />
        </entry>
        <entry>
            <title>
                253. docker內監控服務狀態
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/253. docker內監控服務狀態/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;上一篇 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/251.%20%20GCE%E4%B8%8A%E7%9A%84docker%E7%9B%A3%E6%8E%A7/&quot;&gt;251.  GCE上的docker監控&lt;/a&gt; ，&lt;br /&gt;
能取得服務本身的CPU、Memory..等，&lt;br /&gt;
但如果要判斷服務有沒有正常，&lt;br /&gt;
還真的不知從何著手。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;使用  container_last_seen 配上 absent取絕對值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;absent(container_last_seen{name=~&amp;quot;filebeat&amp;quot;}) OR vector(0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;為什麼要加上 &lt;code&gt;or vector(0)&lt;/code&gt;的原因是&lt;br /&gt;
當promQL判斷服務 &lt;code&gt;filebeat&lt;/code&gt;還活著的話，&lt;br /&gt;
不會有任何資料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/253-fig.1.png&quot; alt=&quot;253-fig.1.png&quot; /&gt;&lt;br /&gt;
當服務沒啟動時，才會顯示 &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;於是加上後面 &lt;code&gt;OR vector(0)&lt;/code&gt;&lt;br /&gt;
當沒有查詢結果時，預設會顯示 0 ，方便告警復歸。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://github.com/google/cadvisor/issues/2305&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;What container_last_seen use for&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/253. docker內監控服務狀態/" />
        </entry>
        <entry>
            <title>
                252. k8s中的pod呼叫
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/252. k8s中的pod呼叫/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;其實如果架構可以，&lt;br /&gt;
應該是不需要用到這個功能。&lt;br /&gt;
用這個也有前提，必須要是statefulset。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;pod本身的name是隨機的，&lt;br /&gt;
所以不太可能用程式寫死去呼叫他，&lt;br /&gt;
當然，真的要硬幹還是可以。&lt;/p&gt;
&lt;p&gt;statefulSet，他的pod是從0開始往後，&lt;br /&gt;
從k8s的文件看，呼叫單個pod的方式，&lt;br /&gt;
&lt;code&gt;&amp;lt;podname&amp;gt;.&amp;lt;servicename&amp;gt;.&amp;lt;namespace&amp;gt;.svc.cluster.local&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-network-id&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Stable Network ID&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是！！！我在測試時，就莫名其妙一直卡關。&lt;br /&gt;
到最後還直接去查kube-dns的值，看是怎麼解析的。&lt;/p&gt;
&lt;p&gt;測試的statefulset是rabbitMQ，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/252-fig.1.png&quot; alt=&quot;252-fig.1.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/252-fig.2.png&quot; alt=&quot;252-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;從上圖可以組成下面的網址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl http://qa-rabbitmq-server-1.qa-rabbitmq.rabbitmq-system.svc.cluster.local:15692/metrics
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;測試時，一直出現錯誤，找不到服務。&lt;br /&gt;
但用pod IP可以找到資料。&lt;/p&gt;
&lt;p&gt;最後氣到，直接裝了nslookup，反查dns名稱了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt-get install dnsutils

or

yum install bind-utils
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要查詢之前，最好先找到你的kube-dns 的pod ip，&lt;/p&gt;
&lt;p&gt;不過其實預設的dns應該就是kube-dns的ip了&lt;br /&gt;
但為了萬一，我還是強制指定一下，如果有多個pod，隨便抓一個就好，&lt;br /&gt;
kube-dns的ip &lt;code&gt;192.168.24.157&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/252-fig.3.png&quot; alt=&quot;252-fig.3.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;利用rabbitMQ的ip 反查domain&lt;/p&gt;
&lt;p&gt;結果..ip註冊的domain是&lt;br /&gt;
&lt;code&gt;qa-rabbitmq-server-1.qa-rabbitmq-nodes.rabbitmq-system.svc.cluster.local&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;照格式來講沒錯，但他用的是另一個service name，&lt;br /&gt;
為什麼我到現在還是不清楚。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/252. k8s中的pod呼叫/" />
        </entry>
        <entry>
            <title>
                251.  GCE上的docker監控
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/251.  GCE上的docker監控/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;之前因為架構關係，建了幾個在GCE上的docker服務。&lt;br /&gt;
外層主機可以透過GCP的metric監控，&lt;br /&gt;
但裡面的docker就不知道了。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;查了一下，&lt;br /&gt;
把&lt;a href=&quot;https://github.com/google/cadvisor&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;cAdvisor&lt;/a&gt;裝起來就好了。&lt;br /&gt;
這是一個專門用在監控VM主機上的docker。&lt;/p&gt;
&lt;h3 id=&quot;c-advisor&quot; tabindex=&quot;-1&quot;&gt;cAdvisor&lt;/h3&gt;
&lt;p&gt;docker-compose.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;services:
  cadvisor:
    container_name: cadvisor
    image: gcr.io/cadvisor/cadvisor:latest
    pull_policy: if_not_present
    restart: always
    privileged: true
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:ro
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
      - /dev/disk/:/dev/disk:ro
    ports:
      - 8888:8080
    networks:
      - zlm_network
networks:
  zlm_network:
    name: zlm_network
    driver: bridge
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;記得改用 &lt;code&gt;gcr.io/cadvisor/cadvisor:latest&lt;/code&gt;&lt;br /&gt;
如果你查到的文章有人用 &lt;code&gt;google/cadvisor:latest&lt;/code&gt;&lt;br /&gt;
這種在建制時會發生錯誤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Failed to create a Container Manager: mountpoint for cpu not found&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;架好後，可使用下面方法測試&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl http://127.0.0.1:8888/metrics
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;prometheus&quot; tabindex=&quot;-1&quot;&gt;prometheus&lt;/h3&gt;
&lt;p&gt;要建一個新的或是拿舊的套用都可以。&lt;br /&gt;
重點是config，&lt;br /&gt;
因我的prometheus掛在GKE上面，&lt;br /&gt;
所以直接讓prometheus去取得GCE的metrics。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- job_name: &#39;game-result-stage&#39;
  scrape_interval: 15s
  static_configs:
    - targets:
      - &#39;&amp;lt;ip&amp;gt;:8888&#39; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;grafana&quot; tabindex=&quot;-1&quot;&gt;Grafana&lt;/h3&gt;
&lt;p&gt;可直接匯入 &lt;a href=&quot;https://grafana.com/grafana/dashboards/11600-docker-container/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;11600&lt;/a&gt; 這個dashboard。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/cypik/monitoring-servers-and-docker-containers-using-prometheus-with-grafana-2f8bce8b5d84&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Monitoring Servers and Docker Containers using Prometheus with Grafana&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/251.  GCE上的docker監控/" />
        </entry>
        <entry>
            <title>
                250. find指令筆記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/250. find指令筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;最近在弄crontab的問題，&lt;br /&gt;
結果才發現find 加上 delete滿滿的細節。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;搜尋時間&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這邊要先知道一件事，atime, mtime , ctime 都是用&lt;code&gt;n*24 hour&lt;/code&gt;&lt;br /&gt;
作為時間比對的依據，&lt;br /&gt;
判斷文件距離上次修改時間已經過了幾個24個小時時段。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;find . -mtime -1 # 找到最後修改時間為「少於 1 天前」的檔案。
find . -mtime 1  # 找到最後修改時間為「剛好 1 天前」的檔案。
find . -mtime +1 # 找到最後修改時間為「超過 1 天前」的檔案。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假設現在時間 星期四 14:55&lt;br /&gt;
-mtime -1 最後修改時間 是 星期三的14:55到星期四的14:55之間的檔案&lt;br /&gt;
-mtime 1 最後修改時間是 星期二14:55到 星期三的14:55的檔案&lt;br /&gt;
-mtime +1 最後修改時間是 星期二14:55之前的檔案&lt;/p&gt;
&lt;p&gt;其他還有這兩個參數可供使用&lt;br /&gt;
-atime  最近訪問時間&lt;br /&gt;
-ctime  最近狀態改動時間&lt;/p&gt;
&lt;p&gt;這幾個時間都可用stat查看&lt;/p&gt;
&lt;p&gt;這張圖表示 -5,5,+5的差別&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/250-fig.1.png&quot; alt=&quot;250-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果要查詢分鐘的話，&lt;br /&gt;
則是使用 -amin,-mmin,-cmin 用法跟上面差不多。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://blog.csdn.net/db_murphy/article/details/107053545&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;徹底搞明白find命令mtime含義和用法&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;查看說明文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;man find
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;搜尋類型&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;find . -type f # 搜尋檔案
find . -type d # 搜尋資料夾
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;搜尋檔案名稱&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;find . -iname &amp;quot;docker&amp;quot; # 不區分大小寫
find . -name &amp;quot;*.mp4&amp;quot;  # 副檔名為mp4
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;執行後再其他指令&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;   find . -iname &amp;quot;docker&amp;quot; -exec rm -f {} +
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;{}&lt;/code&gt; 代表將前面搜尋的結果傳到後面的參數，&lt;br /&gt;
&lt;code&gt;+&lt;/code&gt; 表示將結果一次傳進去給rm，另一種作法是 &lt;code&gt;&#92;;&lt;/code&gt;，針對每個資料夾都執行一次rm的指令&lt;br /&gt;
記得&lt;code&gt;&#92;&lt;/code&gt;前面的空格。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;排除特定資料夾&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;find . -iname &amp;quot;docker&amp;quot; -mindepth 1 -path /home/user/docker -prune -o -print
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-o&lt;/code&gt;  在find中，代表OR的邏輯，其中一個為true才執行，&lt;br /&gt;
基本語法為&lt;code&gt;find &amp;lt;path&amp;gt; &amp;lt;condition1&amp;gt; -o &amp;lt;condition2&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;所以 -o -print的用意識，如果不是 &lt;code&gt;/home/user/docker&lt;/code&gt;的資料夾就print&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.miniasp.com/post/2010/08/27/Linux-find-command-tips-and-notice&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;在 Linux 下使用 find 指令查詢目錄與檔案的速查筆記&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.gtwang.org/linux/unix-linux-find-command-examples/&quot; title=&quot;Unix/Linux 的 find 指令使用教學、技巧與範例整理&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Unix/Linux 的 find 指令使用教學、技巧與範例整理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;單純紀錄一下麻煩的要死的cp功能，&lt;br /&gt;
後面還是用glcoud storage rsync處理掉，cp真的太慢了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
total=$(find /home/user/MP4Final -type f -cmin -1 | wc -l)
find /home/user/MP4Final -type f -cmin -5 | while read file; do

    # 提取檔案名稱
    filename=$(basename &amp;quot;$file&amp;quot;)

    # 提取最後兩個資料夾名稱
    last_two_dirs=$(echo &amp;quot;$file&amp;quot; | awk -F/ &#39;{print $(NF-2) &amp;quot;/&amp;quot; $(NF-1)}&#39;)

    # 目標位置
    target_dir=&amp;quot;video/$last_two_dirs&amp;quot;

    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#echo&quot;&gt;#echo&lt;/a&gt; &amp;quot;source:$file&amp;quot;
    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#echo&quot;&gt;#echo&lt;/a&gt; &amp;quot;$target_dir/$filename&amp;quot;
    gcloud storage cp -n &amp;quot;$file&amp;quot; &amp;quot;gs://$target_dir/$filename&amp;quot; --quiet
done
echo &amp;quot;total: $total&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/250. find指令筆記/" />
        </entry>
        <entry>
            <title>
                247. MSSQL指令賦予權限
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/247. MSSQL指令賦予權限/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;因為之前RD組長真的幹了從刪庫到跑路的過程，&lt;br /&gt;
重點刪了還沒跑路。&lt;br /&gt;
於是每個RD的資料庫權限直接縮減。&lt;br /&gt;
但由於程式是使用ORM ，會自建資料庫。&lt;br /&gt;
導致RD沒有權限可以連到新建的DB，&lt;br /&gt;
我只能手動賦予權限，但每次新增好煩，&lt;br /&gt;
我又沒window，只能用VM開SSMS出來用。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;用指令直接解決&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
create USER bmsrd for login bmsrd
EXEC sp_addrolemember &#39;db_datareader&#39;,&#39;bmsrd&#39;
EXEC sp_addrolemember &#39;db_datawriter&#39;,&#39;bmsrd&#39;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以後直接到 Google的 Cloud SQL Studio 執行指令就好。&lt;br /&gt;
或是使用 Azure Data Studio就好了。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/247. MSSQL指令賦予權限/" />
        </entry>
        <entry>
            <title>
                246. GCP網路費用粗估計算
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/246. GCP網路費用粗估計算/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;昨天突然說要叫我算一下影音串流，如果每秒2MB的話，一個月多少。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;Q: 現在的題目，每秒有 2Mb的串流，每月會有多少費用。&lt;br /&gt;
先計算每月流量&lt;br /&gt;
&lt;code&gt;2*60*60*24*30=5184000(Mb)&lt;/code&gt;&lt;br /&gt;
再轉成MB&lt;br /&gt;
&lt;code&gt;51840000/8=648000&lt;/code&gt;&lt;br /&gt;
因Google的費用單位都是 GiB (1GB 約0.93GiB)，&lt;br /&gt;
所以 648 GB = 602GiB&lt;/p&gt;
&lt;p&gt;p.s GB是十進制，GiB是二進制&lt;/p&gt;
&lt;h3 id=&quot;組成&quot; tabindex=&quot;-1&quot;&gt;組成&lt;/h3&gt;
&lt;p&gt;網路的費用分成兩塊，&lt;br /&gt;
Data transfer(資料傳輸) +  data processes(資料處理)&lt;/p&gt;
&lt;p&gt;入站不收 data transfer的費用，但會收  data processes的費用。&lt;br /&gt;
出站，兩邊的費用都會收。&lt;/p&gt;
&lt;h3 id=&quot;inbound&quot; tabindex=&quot;-1&quot;&gt;Inbound&lt;/h3&gt;
&lt;p&gt;processes data的服務 有 Load Balancer 、Cloud NAT 、 Protocol forward&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/246-fig.1.png&quot; alt=&quot;246-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;從LB 進入的data processes費用為 &lt;code&gt;602*0.008=4.816&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;LB的轉發規則前五條，每小時  0.025  ，於是 &lt;code&gt;0.025*24*30=18&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;於是，inbound的 LB 資料處理費用為 22.816 USD&lt;/p&gt;
&lt;h3 id=&quot;outbound&quot; tabindex=&quot;-1&quot;&gt;Outbound&lt;/h3&gt;
&lt;p&gt;這邊計算時，務必搞清楚 哪一邊是client 哪一邊是 server。&lt;/p&gt;
&lt;p&gt;GKE Private Cluster 的網路入跟出的IP不一樣，&lt;br /&gt;
所以計算方式也不一樣。&lt;/p&gt;
&lt;h3 id=&quot;第一種&quot; tabindex=&quot;-1&quot;&gt;第一種&lt;/h3&gt;
&lt;p&gt;客戶直接連線到server抓取串流&lt;br /&gt;
所以GKE是server，是從Load Balancer出。&lt;/p&gt;
&lt;p&gt;Data processes 費用&lt;br /&gt;
跟上面inbound的費用一樣，都是 每GiB 0.008 ，所以是 22.816&lt;/p&gt;
&lt;p&gt;Data Transfer 費用&lt;/p&gt;
&lt;p&gt;&amp;gt; &lt;code&gt; 602*0.23 = 138.46&lt;/code&gt;&lt;br /&gt;
 &lt;br /&gt;
 0.23是台灣到中國的每GB費用，&lt;br /&gt;
 到其他地方的價格不一樣。&lt;br /&gt;
 &lt;br /&gt;
 ref. &lt;a href=&quot;https://cloud.google.com/vpc/network-pricing?hl=zh-tw#vpc-pricing&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;虛擬私人雲端&lt;/a&gt; 網際網路資料移轉速率-&amp;gt; 進階級計價模式&lt;/p&gt;
&lt;p&gt;所以總金額約為 138.46+22.816 = 161.276&lt;/p&gt;
&lt;h3 id=&quot;第二種&quot; tabindex=&quot;-1&quot;&gt;第二種&lt;/h3&gt;
&lt;p&gt;服務直接將串流打到對方的伺服器上&lt;br /&gt;
所以GKE是client，是吃Cloud NAT的流量。&lt;/p&gt;
&lt;p&gt;Data processes 費用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;(0.044*720) + (0.005*1*720)+(5184*0.045)=43.056&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(0.044＊720 ) :  超過32個VM ，NAT 閘道的每小時價格 0.044 ，一個月有720個小時&lt;br /&gt;
(0.005＊1＊720)：NAT閘道的IP，1個每小時0.005&lt;br /&gt;
(172.8＊0.045)： 每處理 GiB 資料、傳入與傳出資料移轉的價格 0.045 ，172.8G&lt;/p&gt;
&lt;p&gt;Data Transfer 費用&lt;/p&gt;
&lt;p&gt;&amp;gt; &lt;code&gt; 602*0.23 = 138.46&lt;/code&gt;&lt;br /&gt;
 &lt;br /&gt;
 0.23是台灣到中國的每GB費用，&lt;br /&gt;
 到其他地方的價格不一樣。&lt;/p&gt;
&lt;p&gt;所以總金額約為 138.46+43.056 = 181.516&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/vpc/network-pricing?hl=zh-tw#nat-pricing&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Cloud NAT&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;補充&quot; tabindex=&quot;-1&quot;&gt;補充&lt;/h3&gt;
&lt;p&gt;Inter-region data transfer&lt;/p&gt;
&lt;p&gt;如果是跨region的話，也是要算錢的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/246-fig.2.png&quot; alt=&quot;246-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;參考 &lt;a href=&quot;https://cloud.google.com/vpc/network-pricing#vpc-pricing&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Inter-region data transfer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Inter-zone data transfer&lt;br /&gt;
如果是相同region，不同zone的話，每 GiB 0.01&lt;br /&gt;
相同region，相同zone的話則不算錢。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/246. GCP網路費用粗估計算/" />
        </entry>
        <entry>
            <title>
                245. gcloud storage取代gsutil
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/245. gcloud storage取代gsutil/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;剛好想要查一下gsutil的 rsync指令，&lt;br /&gt;
結果官方文件一直跑不出來，&lt;br /&gt;
細看才發現&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通常，您應該使用 &lt;code&gt;gcloud storage&lt;/code&gt; 命令)而不是 &lt;code&gt;gsutil&lt;/code&gt; 命令：&lt;br /&gt;
gsutil 工具是一個舊版 Cloud Storage CLI，僅進行最低程度的維護。&lt;br /&gt;
gsutil 工具不支援使用較新的 Cloud Storage 功能，例如軟刪除和託管式資料夾&lt;br /&gt;
&lt;code&gt;gcloud storage&lt;/code&gt; 命令需要較少的手動最佳化即可實現最快的上傳和下載速率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看來我該改程式了。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.google.com/storage/docs/gsutil?hl=zh-cn#builtinhelp&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Gsutil&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;rsync 同步&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;gsutil -m rsync -r /home/user/docker-compose/VideoSokoban/MP4Final gs://abc

change 

gcloud storage rsync -r /home/user/docker-compose-yaml/VideoSokoban/MP4Final gs://abc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/storage/rsync&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud storage rsync&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;signurl  下載權限&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;gsutil signurl -d 30m gcs-download.json gs://backup/downloadbak/24-4-17.bak

change

gcloud storage sign-url  -d=30m --private-key-file=gcs-download.json gs://backup/downloadbak/24-4-17.bak

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但第一次執行時，可能會發生錯誤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ERROR: (gcloud.storage.sign-url) This command requires the pyOpenSSL library. Please install it and set the environment variable CLOUDSDK_PYTHON_SITEPACKAGES to 1 before re-running this command&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;執行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export CLOUDSDK_PYTHON_SITEPACKAGES=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/storage/sign-url&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud storage sign-url&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;du 查bucket大小&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;gcloud storage du gs://abc --summarize --readable-sizes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/storage/du&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud storage du&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或是在Metrics Explorer ，查詢 &lt;code&gt;Total bytes (v2)&lt;/code&gt; 選擇 GCS Bucket。&lt;br /&gt;
這邊也有 &lt;code&gt;Total count (v2)&lt;/code&gt; 可以查詢加總。&lt;br /&gt;
filter可指定bucket name。&lt;/p&gt;
&lt;p&gt;完整 api &lt;code&gt;storage.googleapis.com/storage/v2/total_bytes&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/245-fig.1.png&quot; alt=&quot;245-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;cors&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;gsutil cors set example_cors_file.json gs://example_bucket
改
gcloud storage buckets update gs://example_bucket --cors-file=example_cors_file.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/142.gcs%20cors%E8%A8%AD%E5%AE%9A/&quot;&gt;142.gcs cors設定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/storage/docs/using-cors#command-line&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Set up and view CORS configurations&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;cp 複製&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;gsutil cp -n gs://abc/57d51e14-6ea2-409a-9bee-07a832456cf6.jpg .


gcloud storage cp -n  gs://abc/57d51e14-6ea2-409a-9bee-07a832456cf6.jpg .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/storage/cp&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud storage cp&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/245. gcloud storage取代gsutil/" />
        </entry>
        <entry>
            <title>
                244. 在GCE使用filebeat傳到GKE的ECK
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/244. 在GCE使用filebeat傳到GKE的ECK/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;RD說他要搞一台自動錄影的服務，&lt;br /&gt;
本來以為只有一個服務，那就掛在GKE上就好了。&lt;br /&gt;
但是，他有兩個服務A跟B，兩邊的資料要互通。&lt;br /&gt;
真要用GKE硬作也是可以，但如果這個服務本身效能就吃很大，&lt;br /&gt;
那用k8s也是要多開一台機器，那不如就用GCE吧。&lt;br /&gt;
然後，問題就來了，LOG咧！？&lt;br /&gt;
Log出問題時要查，最好也是傳去共同的ECK上面，但ECK在GKE上面。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;抓取log的流程也跟一般的filebeat差不多。&lt;br /&gt;
filebeat會從主機上的 &lt;code&gt;/var/lib/docker/containers/*/*.log&lt;/code&gt; 抓取。&lt;br /&gt;
這邊文字檔的log是docker logs的資料，也就是程式的stdout。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/running-on-docker.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;官方簡單說明&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;docker-compose-yaml&quot; tabindex=&quot;-1&quot;&gt;Docker-compose.yaml&lt;/h2&gt;
&lt;p&gt;我是用docker compose ，比較好管理。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; services:
  filebeat:
    image: docker.elastic.co/beats/filebeat:8.15.3
    build: filebeat
    container_name: filebeat
    user: root
    restart: unless-stopped
    environment:
      - ELASTICSEARCH_HOSTS=https://10.60.7.192:9200
      - ELASTICSEARCH_USERNAME=elastic
      - ELASTICSEARCH_PASSWORD=PASSWORD
    labels:
      co.elastic.logs/enabled: &amp;quot;false&amp;quot;
    volumes:
      - ./filebeat.yml:/usr/share/filebeat/filebeat.yml
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./ca.crt:/etc/pki/client/ca.crt
      - ./tls.crt:/etc/pki/client/cert.pem
      - ./tls.key:/etc/pki/client/cert.key
    logging:
      driver: &amp;quot;json-file&amp;quot;
      options:
        max-size: &amp;quot;10m&amp;quot;
        max-file: &amp;quot;2&amp;quot;
    networks:
       - zlm_network
networks:
  zlm_network:
    driver: bridge
    name: zlm_network        
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要會著重於volume的部分。&lt;br /&gt;
其他地方可能有點差異會抓幾個講。&lt;/p&gt;
&lt;h3 id=&quot;general&quot; tabindex=&quot;-1&quot;&gt;General&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;user: root
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不設定的話，在&lt;code&gt;filebeat.yml&lt;/code&gt; 的logging 會出現權限不足的錯誤。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;network 的設定，讓他跟要抓取log的服務放在一起，故同一個網路名稱。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;volume&quot; tabindex=&quot;-1&quot;&gt;Volume&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;filebeat.yml的設定檔連結，這部份沒什麼問題。&lt;br /&gt;
裡面內容會在下面說。&lt;/li&gt;
&lt;li&gt;抓取log的路徑 &lt;code&gt;/var/lib/docker/containers&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;掛載SSL憑證&lt;br /&gt;
為什麼要掛載呢？因為ECK在安裝的時候，預設都走ssl，&lt;br /&gt;
但ECK安裝時在GKE上面，而目前filebeat在GCE，&lt;br /&gt;
所以要拿ECK在GKE上面的憑證來用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重點來了，你怎麼知道要抓哪個憑證來用，&lt;br /&gt;
此時我們可以先去看一下GKE的ECK裡面的設定檔。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;volumes:
   - name: elastic-internal-http-certificates
     secret:
       secretName: prod-es-http-certs-internal
       defaultMode: 420
       optional: false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此時，就能去decode secret了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get secret prod-es-http-certs-internal -n elastic-system  -o=jsonpath=&#39;{.data.ca&#92;.crt}&#39; | base64 -d;echo

kubectl get secret prod-es-http-certs-internal -n elastic-system  -o=jsonpath=&#39;{.data.tls&#92;.crt}&#39; | base64 -d;echo

kubectl get secret prod-es-http-certs-internal -n elastic-system  -o=jsonpath=&#39;{.data.tls&#92;.key}&#39; | base64 -d;echo

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之後將key ，掛載讓filebeat能夠讀取即可。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/running-on-docker.html#_configure_filebeat_on_docker&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Run Filebeat on Docker&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;filebeat-yml&quot; tabindex=&quot;-1&quot;&gt;Filebeat.yml&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;filebeat.inputs:
 - type: container
   enabled: true
   paths:
     - &#39;/var/lib/docker/containers/*/*.log&#39;
   tags: [&amp;quot;videosokoban-qa&amp;quot;]

 processors:
   - add_docker_metadata: ~
   - drop_event:
       when:
         not:
           equals:
             container.name: &amp;quot;zlm-server&amp;quot;
 output.elasticsearch:
   hosts:  https://prod-es-http:9200 &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#https&quot;&gt;#https&lt;/a&gt;://10.60.7.192:9200
   username: &amp;quot;elastic&amp;quot;
   password: &amp;quot;PASSWORD&amp;quot;
   ssl:
     certificate_authorities:
       - &amp;quot;/etc/pki/client/ca.crt&amp;quot;
     certificate: &amp;quot;/etc/pki/client/cert.pem&amp;quot;
     key: &amp;quot;/etc/pki/client/cert.key&amp;quot;      
   indices:
     - index: &amp;quot;videosokoban-qa-%{+yyyy.MM}&amp;quot;
       when.contains:
         tags: &amp;quot;videosokoban-qa&amp;quot;
 logging:
   metrics.enabled: false
   level: debug
   to_stderr: true
   to_files: true
   files:
     path: /var/log/filebeat
     name: filebeat
     keepfiles: 7
     permissions: 0644      
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;filebeat-input&quot; tabindex=&quot;-1&quot;&gt;filebeat.input&lt;/h3&gt;
&lt;p&gt;要擷取的log來源，&lt;br /&gt;
已將本機的路徑掛到docker上面的路徑的。&lt;br /&gt;
&lt;code&gt;/var/lib/docker/containers/*/*.log&lt;/code&gt;&lt;br /&gt;
這個路徑擁有所有的docker logs&lt;/p&gt;
&lt;p&gt;type 有分成 container與 docker。&lt;/p&gt;
&lt;p&gt;據說是docker只能用在docker上面，&lt;br /&gt;
但container可以用在任何的容器服務上面。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;type: docker&lt;/code&gt;的設定我沒搞出來，有興趣的可以自己試一試。&lt;/p&gt;
&lt;h3 id=&quot;processors&quot; tabindex=&quot;-1&quot;&gt;processors&lt;/h3&gt;
&lt;p&gt;這邊牽扯到的部分比較多&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;add_docker_metadata&lt;br /&gt;
增加一些欄位到log裡面，詳細內容可參考 &lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/add-docker-metadata.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Add Docker metadata&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;drop_event ，判斷當container_name是 zlm-server的時候，&lt;br /&gt;
就不要紀錄，這個值是先塞資料進去到ECK後，再篩選出來的。&lt;br /&gt;
條件判斷可參考&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/defining-processors.html#conditions&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;conditions&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前還有用過  &lt;code&gt;drop_fileds&lt;/code&gt; ,&lt;code&gt;add_cloud_metadata&lt;/code&gt;，&lt;br /&gt;
其他更多請參考&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/defining-processors.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Define processors&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;output-elasticsearch&quot; tabindex=&quot;-1&quot;&gt;output.elasticsearch&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;host &amp;amp; ssl&lt;br /&gt;
要將log丟去的ECK伺服器位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;hosts這邊，本來是用GKE的內部負載平衡的ip位置，&lt;br /&gt;
但是直接使用ip位置的話，會出現錯誤。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cannot validate certificate for 10.60.7.192 because it doesn&#39;t contain any IP SANs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這是因為伺服器的憑證沒有加過IP地址，&lt;br /&gt;
看一下 &lt;code&gt;tls.crt&lt;/code&gt;，裡面的這段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/244-fig.1.png&quot; alt=&quot;244-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;這裡並沒有ip位置，所以沒辦法通過驗證。&lt;br /&gt;
但這個憑證是ECK自動產生的，&lt;br /&gt;
所以換個想法，直接讓服務去呼叫 &lt;code&gt;https://prod-es-http:9200&lt;/code&gt;&lt;br /&gt;
此時，就是到主機設定一下&lt;code&gt;/etc/hosts&lt;/code&gt;，&lt;br /&gt;
新增&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10.60.7.192 prod-es-http
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/8.15/securing-communication-elasticsearch.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Secure communication with Elasticsearch&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;indices&lt;br /&gt;
將特定的tag綁定到指定的indices上&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/8.15/elasticsearch-output.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Configure the Elasticsearch output&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;logging&quot; tabindex=&quot;-1&quot;&gt;logging&lt;/h3&gt;
&lt;p&gt;除錯時，&lt;br /&gt;
可以先將&lt;code&gt;to_stderr: true &lt;/code&gt; 開啟。&lt;br /&gt;
可直接用&lt;code&gt;docker logs filebeat&lt;/code&gt; 看 log。&lt;/p&gt;
&lt;p&gt;注意，如果要用 &lt;code&gt;to_files&lt;/code&gt;, docker-compose.yaml 記得加上 &lt;code&gt;user: root&lt;/code&gt;，&lt;br /&gt;
否則會發生權限不足的情況。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/configuration-logging.html#_logging_to_stderr&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Configure logging&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方的filebeat.yaml ，請參考 &lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-reference-yml.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;filebeat.reference.yml&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/244. 在GCE使用filebeat傳到GKE的ECK/" />
        </entry>
        <entry>
            <title>
                243. GCP 全域負載平衡器進階路由設定
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/243. GCP 全域負載平衡器進階路由設定/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;新的服務，就順便改一下新的負載平衡器去掛載bucket吧。&lt;br /&gt;
然後滿滿的坑，GCP的說明範例不知道在寫啥。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/243-fig.1.png&quot; alt=&quot;243-fig.1.png&quot; /&gt;&lt;br /&gt;
以前都是選擇傳統版，&lt;br /&gt;
設定也頗簡單。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/243-fig.2.png&quot; alt=&quot;243-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;不要看他新版上面寫建議，&lt;br /&gt;
就真的用，至少先弄個傳統的把你要的東西設定好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/243-fig.3.png&quot; alt=&quot;243-fig.3.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/243-fig.4.png&quot; alt=&quot;243-fig.4.png&quot; /&gt;&lt;br /&gt;
上面的設定是將 domain/files/123.jpg，轉到 bucket底下的123.jpg&lt;/p&gt;
&lt;p&gt;這邊提供一個最快的解法。&lt;/p&gt;
&lt;p&gt;假設已經在傳統的負載平衡器上面已經建立好了規則，名稱為 abc-qa。&lt;br /&gt;
使用指令查詢&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute url-maps describe abc-qa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;將 &lt;code&gt;pathMatchers&lt;/code&gt;底下的東西抄出來，改一下，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/243-fig.6.png&quot; alt=&quot;243-fig.6.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;貼到『進階型主機與路徑規則』上面就好了（不要太相信程式碼指南）。&lt;br /&gt;
真的要參考，請看底下連結。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/243-fig.5.png&quot; alt=&quot;243-fig.5.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;service的部分，利用指令查詢你的服務或bucket。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute backend-buckets list --uri
or
gcloud compute backend-services list --uri
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這指令會得到類似下面的網址。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://www.googleapis.com/compute/v1/projects/&amp;lt;project_name&amp;gt;/global/backendBuckets/&amp;lt;bucket_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;service 可以為 &lt;code&gt;projects/&amp;lt;project_name&amp;gt;/global/backendBuckets/&amp;lt;bucket_name&amp;gt;&lt;/code&gt;&lt;br /&gt;
或是&lt;br /&gt;
&lt;code&gt;global/backendBuckets/&amp;lt;bucket_name&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;出現錯誤 &lt;code&gt;Operation type [update] failed with message &amp;quot;Invalid resource: URL_MAP/513614964978.game-result-video-qa&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;錯誤的設定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;defaultService: global/backendBuckets/abc-qa
name: matcher1
routeRules:
  - matchRules:
      - prefixMatch: /videos
    priority: 100
    routeAction:
      weightedBackendServices:
        - backendService: global/backendBuckets/abc-qa
          weight: 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;問顧問，說不要用 &lt;code&gt;weightedBackendServices&lt;/code&gt; 直接指定service。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;defaultService: global/backendBuckets/abc-qa
name: matcher1
routeRules:
  - matchRules:
      - prefixMatch: /videos
    priority: 100
    service: global/backendBuckets/abc-qa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.  &lt;a href=&quot;https://stackoverflow.com/questions/76006293/gcp-https-load-balancer-l7-backend-bucket-issue&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GCP - HTTP(S) Load Balancer L7 Backend Bucket Issue&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;程式碼指南的 &lt;code&gt;$[DEFAULT_SERVICE_URL]&lt;/code&gt;是什麼&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用指令查詢&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud compute backend-buckets list --uri
or
gcloud compute backend-services list --uri
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.  &lt;a href=&quot;https://stackoverflow.com/questions/74024072/what-does-default-service-url-refer-to-when-setting-google-load-balancer-to&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;What does &amp;quot;$[DEFAULT_SERVICE_URL]&amp;quot; refer to when setting Google Load Balancer towards a GCP Storage Bucket?&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;conclusion&quot; tabindex=&quot;-1&quot;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;沒事不要用新版的應用程式負載平衡器。&lt;br /&gt;
官方文件要看的話，請看下面兩個連結。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/load-balancing/docs/https/traffic-management-global#advanced_host_path_and_route_rule&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Advanced host, path, and route rule&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/load-balancing/docs/url-map-concepts&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;URL maps overview&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.github.io/243. GCP 全域負載平衡器進階路由設定/" />
        </entry>
        <entry>
            <title>
                242.  .Net core 8 使用apt install 權限不足
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/242.  .Net core 8 使用apt install 權限不足/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;今天早上又被人抓住說要開新服務，&lt;br /&gt;
看這個架構要怎麼調。&lt;br /&gt;
測試時來到Docker build，然後就掛了。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;SOLUTION&lt;/h1&gt;
&lt;p&gt;在使用apt update的時候，出現了&lt;code&gt;Permission denied&lt;/code&gt;&lt;br /&gt;
在Dockerfile的上層加上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;USER root
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就能執行了，&lt;br /&gt;
但不知道為什麼，我沒辦法復現錯誤狀況，&lt;br /&gt;
使用 &lt;code&gt;docker system prune -a&lt;/code&gt; 全部清除了也是一樣。&lt;/p&gt;
&lt;p&gt;但當時確實有碰到這個問題。&lt;/p&gt;
&lt;p&gt;附上完整Dockerfile&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base

USER root
WORKDIR /app

RUN  apt update &amp;amp;&amp;amp; apt install -y curl python3
RUN curl -O https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-cli-443.0.0-linux-x86_64.tar.gz &#92;
&amp;amp;&amp;amp; tar -xf google-cloud-cli-443.0.0-linux-x86_64.tar.gz &amp;amp;&amp;amp; ./google-cloud-sdk/install.sh --command-completion=true --path-update=true --quiet
COPY gcs-download.json .
RUN /app/google-cloud-sdk/bin/gcloud auth activate-service-account abc@abc.com  --key-file=gcs-download.json
EXPOSE 8080
EXPOSE 8081
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其實應該用workload Identity會比較好，但這程式預計要放的位置，&lt;br /&gt;
要改的話變動太大。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://learn.microsoft.com/en-us/dotnet/core/compatibility/containers/8.0/app-user&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;# New non-root &#39;app&#39; user in Linux images&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2024-12-06&quot; tabindex=&quot;-1&quot;&gt;2024/12/06更新&lt;/h3&gt;
&lt;p&gt;還有另一個方法，&lt;br /&gt;
在deploy上面加上下面指令，&lt;br /&gt;
讓pod以root的身分執行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
securityContext:
	runAsUser: 0
	runAsNonRoot: false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/security-context/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;為 Pod 或容器組態安全上下文&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/242.  .Net core 8 使用apt install 權限不足/" />
        </entry>
        <entry>
            <title>
                241. MSSQL紀錄log，使用QUERY_STORE
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/241. MSSQL紀錄log，使用QUERY_STORE/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;線上出了問題，&lt;br /&gt;
但沒有作Tracer，所以就只能先追Slow Query看看了。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;p&gt;本來以為只能寫Trigger，當觸發動作時，記錄當下的Query&lt;br /&gt;
後來問了一下GPT，才發現原來現在的SQL server有一個查詢存放區，&lt;br /&gt;
是專門拿來放SQL指令。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;查詢存放區會收集 DML 陳述式，例如 &lt;code&gt;SELECT&lt;/code&gt;、&lt;code&gt;INSERT&lt;/code&gt;、&lt;code&gt;UPDATE&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt;、&lt;code&gt;MERGE&lt;/code&gt; 和 &lt;code&gt;BULK INSERT&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但這也不是很新的東西，從SQL 2016就有了。&lt;br /&gt;
但從SQL 2022開始，這個設定就會預設打開。&lt;/p&gt;
&lt;p&gt;開啟方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ALTER DATABASE &amp;lt;database_name&amp;gt;
SET QUERY_STORE = ON (OPERATION_MODE = READ_WRITE);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後，就可以查看看所有執行過的SQL了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT Txt.query_text_id, Txt.query_sql_text, Pln.plan_id, Qry.*, RtSt.*
FROM sys.query_store_plan AS Pln
INNER JOIN sys.query_store_query AS Qry
    ON Pln.query_id = Qry.query_id
INNER JOIN sys.query_store_query_text AS Txt
    ON Qry.query_text_id = Txt.query_text_id
INNER JOIN sys.query_store_runtime_stats RtSt
ON Pln.plan_id = RtSt.plan_id;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/zh-tw/sql/relational-databases/system-catalog-views/sys-query-store-query-transact-sql?view=sql-server-ver16&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;sys.query_store_query欄位說明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/zh-tw/sql/relational-databases/system-catalog-views/sys-query-store-runtime-stats-transact-sql?view=sql-server-ver16&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;sys.query_store_runtime_stats欄位說明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;計劃存放區中可為查詢儲存的不重複計劃數目，受限於 &lt;strong&gt;max_plans_per_query&lt;/strong&gt; 組態選項。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查詢 max_plans_per_query的值及其他參數&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select *
from sys.database_query_store_options
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/zh-tw/sql/relational-databases/system-catalog-views/sys-database-query-store-options-transact-sql?view=sql-server-ver16&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;sys.database_query_store_options欄位說明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;雖然說他的最大值預設是200，&lt;br /&gt;
但我實際看起來，我的plan_id已經超過200了還在存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/241-fig.1.png&quot; alt=&quot;241-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/zh-tw/sql/relational-databases/performance/monitoring-performance-by-using-the-query-store?view=sql-server-ver16&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用查詢存放區監視效能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/zh-tw/sql/relational-databases/performance/manage-the-query-store?view=sql-server-ver16&amp;amp;source=recommendations&amp;amp;tabs=ssms&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;管理查詢存放區的最佳做法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/241. MSSQL紀錄log，使用QUERY_STORE/" />
        </entry>
        <entry>
            <title>
                240. git log 除錯指令
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/240. git log 除錯指令/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;前陣子，RD同仁找來，說為什麼這樣的CI不會過。&lt;br /&gt;
查了一連串的LOG，發現是fast-forward的問題。&lt;br /&gt;
過程中用了一堆git 指令...&lt;br /&gt;
紀錄吧&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;只顯示merge的log&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git log --merges
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;顯示全部Log&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git log
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;顯示單一提交的詳細訊息&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git show &amp;lt;commit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;查詢某個特定提交的tag&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git tag --points-at &amp;lt;commit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;列出所有tag及對應的commit值&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git show-ref --tags
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;以圖形化顯示log&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git log --graph
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;取得git的tag資料&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;# 取開頭第一個
git tag --points-at &amp;lt;commit&amp;gt; | head -1
# 取結尾第一個
git tag --points-at &amp;lt;commit&amp;gt; | tail -1
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;Log Merge欄位的意思&lt;br /&gt;
假設顯示的資訊如下&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;commit a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t
Merge: 1a2b3c4 5d6e7f8
Author: John Doe &amp;lt;john.doe@example.com&amp;gt;
Date:   Tue Sep 11 14:30:00 2024 +0800

    Merge branch &#39;feature-branch&#39; into &#39;develop&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;develop的 commit值是 &lt;code&gt;1a2b3c4&lt;/code&gt;&lt;br /&gt;
feature-branch的commit值是&lt;code&gt;5d6e7f8&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;這兩個是 non-fast-forward合併，因為看得到Parents commit。&lt;br /&gt;
如果是Fast-Forward合併，只會顯示單個提交，不會有&lt;code&gt;Merge&lt;/code&gt;標記。&lt;/p&gt;
&lt;ol start=&quot;9&quot;&gt;
&lt;li&gt;pull時不使用rebase，而是使用merge&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git pull --no-rebase
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/240. git log 除錯指令/" />
        </entry>
        <entry>
            <title>
                239. Cloudflare白名單及擷取國別設定
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/239. Cloudflare白名單及擷取國別設定/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;每當要再設定一次時，&lt;br /&gt;
都要找一陣子，才會發現在哪裡，&lt;br /&gt;
於是才發現，我沒筆記啊...&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;h2 id=&quot;白名單設定&quot; tabindex=&quot;-1&quot;&gt;白名單設定&lt;/h2&gt;
&lt;p&gt;網路安全-&amp;gt;WAF-&amp;gt;自訂規則&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/239-fig.1.png&quot; alt=&quot;239-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;新增規則&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/239-fig.2.png&quot; alt=&quot;239-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;這邊可選擇要篩選哪個欄位。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/239-fig.3.png&quot; alt=&quot;239-fig.3.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;再來要允許還是阻擋。&lt;/p&gt;
&lt;p&gt;最後記得『佈署』。&lt;/p&gt;
&lt;h2 id=&quot;header&quot; tabindex=&quot;-1&quot;&gt;國別header&lt;/h2&gt;
&lt;p&gt;網路-&amp;gt; IP 地理位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/239-fig.4.png&quot; alt=&quot;239-fig.4.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;之後就能從header裡面取得這個使用者是哪個國家。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloudflare.zendesk.com/hc/en-us/articles/200168236-Configuring-IP-geolocation&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Configuring IP geolocation&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/239. Cloudflare白名單及擷取國別設定/" />
        </entry>
        <entry>
            <title>
                238. Steam Deck安裝Cheat Engine
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/238. Steam Deck安裝Cheat Engine/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;有些遊戲用簡易版的搜尋軟體 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/206.%20steamDeck%20%E7%9A%84%20Cheat%20Engine%E6%9B%BF%E4%BB%A3%E5%93%81/&quot;&gt;206. steamDeck 的 Cheat Engine替代品&lt;/a&gt;，&lt;br /&gt;
就是搜不到，&lt;br /&gt;
想說是不是還是該用CE來試試看了。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;主要是參考這個影片&lt;a href=&quot;https://www.youtube.com/watch?v=ISWTA5Cj1zs&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Cheat Tables (.CT) for Steam Deck SteamOS Cheat Engine Guide Setup Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要幾個步驟，備忘一下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下載軟體&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到桌面模式下，安裝 ProtonUP-Qt 以及 Protontricks&lt;br /&gt;
如果沒有外接滑鼠的話，&lt;br /&gt;
右邊的觸控版是滑鼠， RT(R2) 是滑鼠左鍵， LT(L2)是滑鼠右鍵&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;新增SteamTinkerLaunch&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;開啟ProtonUP-Qt&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/238-fig.1.png&quot; alt=&quot;238-fig.1.png&quot; /&gt;&lt;br /&gt;
Add version&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/238-fig.2.png&quot; alt=&quot;238-fig.2.png&quot; /&gt;&lt;br /&gt;
在Compatibility tool選擇 &lt;code&gt;SteamTinkerLaunch&lt;/code&gt;&lt;br /&gt;
然後 install&lt;/p&gt;
&lt;p&gt;完成後重新啟動Steam&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;新增CE到收藏庫&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;桌面模式下，開啟Steam。&lt;br /&gt;
到『收藏庫』，左下方有一個新增遊戲的按鈕，&lt;br /&gt;
選擇 『新增非Steam遊戲』。&lt;br /&gt;
找到你剛剛下載的CheatEngine.exe。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;安裝CE&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;新增完成後，會出現下圖，&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/238-fig.3.png&quot; alt=&quot;238-fig.3.png&quot; /&gt;&lt;br /&gt;
選擇右邊的內容，&lt;br /&gt;
開啟相容性。&lt;br /&gt;
『強制使用特定Steam Play 相容性工具』打勾。&lt;br /&gt;
選擇『Proton Experimental』&lt;/p&gt;
&lt;p&gt;設定完後，啟動。&lt;br /&gt;
會看到安裝畫面，就安裝吧。&lt;/p&gt;
&lt;h3 id=&quot;skip-all&quot; tabindex=&quot;-1&quot;&gt;注意，中途會問你要不要裝其他軟體，選擇Skip All&lt;/h3&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;複製資料夾&lt;br /&gt;
找到CE的資料夾，記得先開啟『顯示隱藏檔』&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;/home/.steam/steam/steamapps/compatdata&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;這邊有兩種方式，&lt;br /&gt;
一種是找到建立日期是剛剛的。&lt;br /&gt;
另一種是打開&lt;code&gt;Protontricks&lt;/code&gt; 看CheatEngine的編號是哪一個。&lt;/p&gt;
&lt;p&gt;像我的是&lt;code&gt;3262966842&lt;/code&gt; 就再進去&lt;br /&gt;
&lt;code&gt;3262966842/pfx/drive_c/Program FIles&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;完整路徑會像這樣&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/home/.steam/steam/steamapps/compatdata/3262966842/pfx/drive_c/Program files&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;將&lt;code&gt;Cheat Engine 7.5&lt;/code&gt;資料夾整個複製，&lt;br /&gt;
貼到你想要修改的遊戲資料夾上面。&lt;/p&gt;
&lt;p&gt;假設我要修Brotato，編號是 1942280（開&lt;code&gt;Protontricks&lt;/code&gt;查）。&lt;br /&gt;
就參考上面的路徑&lt;br /&gt;
&lt;code&gt;/home/.steam/steam/steamapps/compatdata/1942280/pfx/drive_c/Program files&lt;/code&gt;&lt;br /&gt;
到這邊將&lt;code&gt;Cheat Engine 7.5&lt;/code&gt;資料夾 貼上。&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;設定Brotato用&lt;code&gt;SteamTinkerLaunch&lt;/code&gt;開啟&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;桌面模式&lt;br /&gt;
&lt;code&gt;內容-&amp;gt;相容性-&amp;gt;強制使用特定Steam Play相容性工具-&amp;gt;Steam Tinker Launch&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;設定Game Menu&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;桌面模式&lt;br /&gt;
照上面的設定完後，執行遊戲，會跳出一個視窗，&lt;br /&gt;
選擇下方的Main Menu-&amp;gt; Game Menu&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Use custom command 打勾
Custom command 選擇剛剛複製過來資料夾裡面的CheatEngine.exe
Fork custom command 打勾
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;啟用開發者模式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以回到遊戲模式，&lt;br /&gt;
先按下&lt;code&gt;Steam&lt;/code&gt;按鈕，系統-&amp;gt; 啟用開發者模式。&lt;/p&gt;
&lt;ol start=&quot;9&quot;&gt;
&lt;li&gt;開始修改&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;執行你的遊戲，此時按下 &lt;code&gt;Steam&lt;/code&gt; 按鈕，&lt;br /&gt;
會看到同時有兩個檔案在執行，&lt;br /&gt;
一個是你玩得遊戲，&lt;br /&gt;
另一個則是CheatEngine。&lt;br /&gt;
需要注意的是，如果你有選擇開啟其他視窗的話，&lt;br /&gt;
需要從&lt;code&gt;Steam&lt;/code&gt;按鈕去選擇你開啟的其他視窗。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;抓圖的話使用內建的Spectacle&lt;/li&gt;
&lt;li&gt;複製圖片的話，使用ssh&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;SteamDeck&lt;/p&gt;
&lt;p&gt;如果沒設過密碼，需使用&lt;code&gt;passwd&lt;/code&gt;先行設定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;systemctl enable sshd  # 啟用sshd
systemctl restart sshd  # 重新啟動sshd
systemctl status sshd # 查詢狀態

ip -4 addr # 查詢ip位置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PC&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scp -r deck@192.168.1.2:/home/deck/Pictures/ .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=ISWTA5Cj1zs&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Cheat Tables (.CT) for Steam Deck SteamOS Cheat Engine Guide Setup Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://fearlessrevolution.com/index.php&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;FearLess Cheat Engine&lt;/a&gt; 下載CT檔案的網站&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/238. Steam Deck安裝Cheat Engine/" />
        </entry>
        <entry>
            <title>
                237. GCP IAM綁GKE的RBAC
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/237. GCP IAM綁GKE的RBAC/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;要弄個小程式定時撈secret的資料出來，&lt;br /&gt;
但叢集是舊的沒有開啟workload Identity，&lt;br /&gt;
也只能掛IAM的service account了。&lt;br /&gt;
只給予&lt;code&gt;Kubernetes Engine Viewer&lt;/code&gt;的權限，&lt;br /&gt;
但要撈secret時，會通知缺乏&lt;code&gt;container.secrets.get&lt;/code&gt;的權限。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;檢查Kubernetes Engine Viewer有哪些權限&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/237-fig.1.png&quot; alt=&quot;237-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.google.com/iam/docs/understanding-roles#container.viewer&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;網頁查詢&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另一種透過指令的方式，參考上圖中的role將值帶入到下面指令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud iam roles describe roles/container.viewer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;s&gt;(我很想吐槽，我怎麼知道這個名稱要用哪個role去查啊，還不是要去網頁看)&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/iam?hl=zh-cn#permissions&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;查看 IAM 角色授予的權限&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查完的結果是真的缺乏 &lt;code&gt;container.secrets.get&lt;/code&gt;的權限。&lt;br /&gt;
那現在的問題是，要怎麼加權限？&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;釐清認證方式&lt;br /&gt;
Google 文件說明&lt;br /&gt;
您可以使用 IAM 和 Kubernetes RBAC 來控制對 GKE 叢集的存取權：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;IAM 並非特定於 Kubernetes；它為多種 Google Cloud 產品提供身份管理，並且主要在 Google Cloud 項目級層運行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kubernetes RBAC 是 Kubernetes 的核心組成部分，可讓您針對叢集內的任何對象或對象類型建立和授予角色（一組權限）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;為了授權操作，GKE 首先會檢查是否存在 RBAC 政策。如果不存在 RBAC 政策，GKE 會檢查 IAM 權限。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 GKE 中，IAM 和 Kubernetes RBAC 整合在一起，您可以通過任一工具向使用者授權，使其有足夠的權限執行操作。這對於 GKE 叢集的引導過程至關重要，因為默認情況下，Google Cloud 使用者不具有任何 Kubernetes RBAC RoleBindings。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/role-based-access-control?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;使用基於角色的存取權控制向叢集中的操作授權&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以說預設的角色權限就是那些，要針對角色加權限的話只能自己新增了。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;新增RBAC權限&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ClusterRoleBinding 使用 kind: user，綁定IAM的帳號。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: secret-reader
rules:
  - apiGroups: [&amp;quot;&amp;quot;]
    resources: [&amp;quot;secrets&amp;quot;]
    verbs: [&amp;quot;get&amp;quot;, &amp;quot;list&amp;quot;, &amp;quot;watch&amp;quot;]
--- 
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: secret-reader-binding
subjects:
  - kind: User  # 或者 ServiceAccount 根據具體的需求
    name: get-api@project.iam.gserviceaccount.com  # 替換成具體的使用者或服務帳號名稱
    apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: secret-reader
  apiGroup: rbac.authorization.k8s.io
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;驗證方式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;綁完後，可使用指令看看能不能正常讀取。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kc auth can-i get secret iplc-test-com-tls &#92;
-o=jsonpath=&#39;{.data.tls&#92;.crt}&#39; &#92;
--as get-api@project.iam.gserviceaccount.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可讀取會顯示 Yes，否則就是 No&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/authorization/#checking-api-access&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Checking API access&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/237. GCP IAM綁GKE的RBAC/" />
        </entry>
        <entry>
            <title>
                236. Telegram傳送檔案
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/236. Telegram傳送檔案/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;Why&lt;/h1&gt;
&lt;p&gt;突然想要懶一下，&lt;br /&gt;
定時送個檔案到TG上面，&lt;br /&gt;
怎麼傳文字我很清楚，但檔案還真的沒想法。&lt;br /&gt;
只打算弄個sh，不想寫code。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;問了GPT很簡單，&lt;br /&gt;
就一行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;987654321&lt;/code&gt; 是 chat_id&lt;br /&gt;
&lt;code&gt;bot123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11&lt;/code&gt;是TG的機器人token&lt;br /&gt;
&lt;code&gt;backup.zip&lt;/code&gt;是檔案&lt;br /&gt;
&lt;code&gt;samplefile&lt;/code&gt;是附註&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -F chat_id=987654321 &#92;
     -F document=@/path/to/backup.zip &#92;
     -F caption=samplefile &#92;
     https://api.telegram.org/bot123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11/sendDocument

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://core.telegram.org/bots/api#senddocument&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;sendDocument&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;小補充，想在caption上面標注日期，方便尋找。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;today=$(date +%F)
curl -F chat_id=987654321 &#92;
     -F document=@/path/to/backup.zip &#92;
     -F caption=samplefile-${today} &#92;
     https://api.telegram.org/bot123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11/sendDocument

&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/236. Telegram傳送檔案/" />
        </entry>
        <entry>
            <title>
                235. Grafana Alert Template
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/235. Grafana Alert Template/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;Why&lt;/h1&gt;
&lt;p&gt;新服務要上線了，&lt;br /&gt;
要趕緊把 Observability做一做，&lt;br /&gt;
之前的版本都會有一長串資訊，&lt;br /&gt;
看了就很煩，不能很直觀的知道是哪邊出問題。&lt;br /&gt;
訊息又都要一個一個打，&lt;br /&gt;
所以，我能不能弄成一個範本，減少我人工的作業？&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，因有特殊符號，導致編譯出問題。&lt;br /&gt;
故將裡面的所有{ } 改為全形，請自行改為半形&lt;br /&gt;
故將裡面的所有{ } 改為全形，請自行改為半形&lt;br /&gt;
故將裡面的所有{ } 改為全形，請自行改為半形&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;很重要，說三次&quot; tabindex=&quot;-1&quot;&gt;很重要，說三次&lt;/h2&gt;
&lt;p&gt;原始的範本，通常長成這樣。&lt;br /&gt;
有很多資訊，但有些是用不到的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[FIRING:1] (cpu-dealer GKE Cluster normal backend)

Firing  

Value: B=2.632  
Labels:  
- alertname = cpu-abc  
- grafana_folder = GKE Cluster  
- level = normal  
- service-type = backend  
Annotations:  
- summary = 環境：Prod  
機器名稱：dealer  
告警訊息：CPU使用量1core  
Source: http://localhost:3000/alerting/grafana/uRU7sCEnz/view?orgId=1  
Silence: http://localhost:3000/alerting/silence/new?alertmanager=grafana&amp;amp;matcher=alertname%3Dcpu-dealer&amp;amp;matcher=grafana_folder%3DGKE+Cluster&amp;amp;matcher=level%3Dnormal&amp;amp;matcher=service-type%3Dbackend  
Dashboard: http://localhost:3000/d/2-jy90-nk?orgId=1  
Panel: http://localhost:3000/d/2-jy90-nk?orgId=1&amp;amp;viewPanel=13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最後的成果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[FIRING:1] sftp-qa Disk Space alarm-GCE (normal sftp-qa value_percent_used_mean_aggregate)


Annotations:  
- summary: 環境：alarm-GCE  
機器名稱：sftp-qa  
告警項目：sftp-qa Disk Space  
告警訊息：硬碟空間目前 46.22% ，已達上限 70%  
Dashboard URL:  

[View Dashboard](http://&amp;lt;ip&amp;gt;/grafana/d/f649857c-4763-442f-9919-b41c3832d5b8?orgId=1)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;step-1&quot; tabindex=&quot;-1&quot;&gt;Step 1. 確認版本&lt;/h3&gt;
&lt;p&gt;首先確認Grafana的版本，目前我使用的是&lt;code&gt;Grafana v11.2.0&lt;/code&gt;。&lt;br /&gt;
版本不一樣，指令可能會不一樣，需要再去查文件。&lt;/p&gt;
&lt;h3 id=&quot;step-2-notification-template&quot; tabindex=&quot;-1&quot;&gt;Step 2. 設定Notification Template&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/235-fig.1.png&quot; alt=&quot;235-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;開啟 Home &amp;gt; Alerting &amp;gt; Cotact points&lt;br /&gt;
切換到分頁 Notification Templates ，選擇 Add Notification Template&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/235-fig.2.png&quot; alt=&quot;235-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在左上的Template框框，輸入下面程式碼。&lt;br /&gt;
如果指令沒錯，可以在右邊的preview看到結果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;｛｛ define &amp;quot;alert_message&amp;quot; ｝｝
  ｛｛ range .Alerts ｝｝
    ｛｛ if gt (len .Annotations) 0 ｝｝
      Annotations:
      ｛｛ range $key, $value := .Annotations ｝｝
        - **｛｛ $key ｝｝**:   
        ｛｛ $value ｝｝
      ｛｛ end ｝｝
    ｛｛ else ｝｝
      No Annotations found.
    ｛｛ end ｝｝

    Dashboard URL:
    [View Dashboard](｛｛ .DashboardURL ｝｝)
  ｛｛ end ｝｝
｛｛ end ｝｝
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這程式我是叫GPT寫的，再稍微小改一下。&lt;br /&gt;
如果想自己開發，請參考&lt;a href=&quot;https://grafana.com/docs/grafana/latest/alerting/configure-notifications/template-notifications/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Configure notification messages&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;p.s. 注意版本，版本不一樣從網頁的版本號調整&lt;/p&gt;
&lt;h3 id=&quot;step-3-notification-policy&quot; tabindex=&quot;-1&quot;&gt;Step 3. 綁定notification policy&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/235-fig.4.png&quot; alt=&quot;235-fig.4.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;回到Contact Points，&lt;br /&gt;
選擇你的notification policy&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/235-fig.3.png&quot; alt=&quot;235-fig.3.png&quot; /&gt;&lt;br /&gt;
選擇剛剛新增的Template&lt;/p&gt;
&lt;p&gt;可以按一下Test驗證一下有沒有通。&lt;/p&gt;
&lt;h3 id=&quot;step-4-alert-rules&quot; tabindex=&quot;-1&quot;&gt;Step 4. 設定 Alert Rules&lt;/h3&gt;
&lt;p&gt;基本的設定就參考&lt;a href=&quot;https://grafana.com/docs/grafana/latest/alerting/fundamentals/alert-rules/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Alert rules&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在Summary則是輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;環境：｛｛ index $labels &amp;quot;grafana_folder&amp;quot; ｝｝
機器名稱：｛｛ index $labels &amp;quot;metadata.label.system.name&amp;quot; ｝｝
告警項目：｛｛ index $labels &amp;quot;alertname&amp;quot; ｝｝
告警訊息：硬碟空間目前 ｛｛ humanize (index $values &amp;quot;B&amp;quot;).Value  ｝｝% ，已達閥值 70%
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;index是用來顯示標籤中的內容，&lt;br /&gt;
可以更方便得到你想要的數值。&lt;br /&gt;
可以在測試時用 &lt;code&gt;｛｛ $labels ｝｝&lt;/code&gt; 看有哪些標籤可用。&lt;/p&gt;
&lt;p&gt;p.s 版本不一樣，取值的方式也不一樣。&lt;/p&gt;
&lt;p&gt;同樣可以使用的是 &lt;code&gt;｛｛ $value ｝｝&lt;/code&gt; ，這邊注意只有value沒有s。&lt;br /&gt;
但在使用index時，需要加上 s。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://grafana.com/docs/grafana/latest/alerting/fundamentals/notifications/templates/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Notification.Templates&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;code&gt;humanize&lt;/code&gt; 是比較人性化的format函數。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;humanize&lt;/code&gt; 會將多餘的小數點位數移除或改為比較易讀的方式。&lt;br /&gt;
&lt;code&gt;humanizePercentage&lt;/code&gt; 將小數點轉為百分比&lt;br /&gt;
&lt;code&gt;humanizeDuration&lt;/code&gt; 將時間轉為可讀的時間&lt;/p&gt;
&lt;p&gt;更多可參考下面連結，裡面也有其他function的用法。&lt;br /&gt;
ref. &lt;a href=&quot;https://grafana.com/docs/grafana/latest/alerting/alerting-rules/templating-labels-annotations/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;humanize&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;troubleshooting&quot; tabindex=&quot;-1&quot;&gt;Troubleshooting&lt;/h4&gt;
&lt;p&gt;當有一個變數寫錯時，發送告警時，全部的變數都不會顯示。&lt;br /&gt;
會變成下面的情況。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- summary:  
｛｛ $value ｝｝  
環境：｛｛ index $labels &amp;quot;grafana_folder&amp;quot; ｝｝  
機器名稱：｛｛ (index $values &amp;quot;B&amp;quot;).persistentvolumeclaim ｝｝  
告警項目：｛｛ index $labels &amp;quot;alertname&amp;quot; ｝｝  
告警訊息：硬碟空間目前 ｛｛ humanizePercentage (index $values &amp;quot;B&amp;quot;).Value ｝｝ ，已達閥值 70%  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此時就看一下是不是那邊要加空格沒空格，&lt;br /&gt;
或是指定的values的欄位有錯誤。&lt;br /&gt;
像上面的錯誤，機器名稱的部分應該要改成這樣。&lt;br /&gt;
&lt;code&gt;機器名稱：｛｛ (index $values &amp;quot;B&amp;quot;).Labels.persistentvolumeclaim  ｝｝&lt;/code&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/235. Grafana Alert Template/" />
        </entry>
        <entry>
            <title>
                234. Debian新增軟體源
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/234. Debian新增軟體源/</id>
            <content type="html">
                &lt;h1 id=&quot;cause&quot; tabindex=&quot;-1&quot;&gt;Cause&lt;/h1&gt;
&lt;p&gt;客戶那邊要新增一臺機器，&lt;br /&gt;
連過去裝時，才發現他沒有software  repositories&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;OS： Debian 10&lt;/p&gt;
&lt;p&gt;編輯 &lt;code&gt;/etc/apt/sources.list&lt;/code&gt; ，&lt;br /&gt;
新增&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;deb http://ftp.debian.org/debian stable main contrib non-free
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然後開啓terminal，執行下面指令，收工&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.  &lt;a href=&quot;https://wiki.debian.org/DebianRepository&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;DebianRepository&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/234. Debian新增軟體源/" />
        </entry>
        <entry>
            <title>
                233. 不同區域 GCE與GKE LB連線
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/233. 不同區域 GCE與GKE LB連線/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;Why&lt;/h1&gt;
&lt;p&gt;突然來了個要求，要從美東的GCE 連到臺灣的GKE。&lt;br /&gt;
GKE的機器，我建了內部 LB 。&lt;br /&gt;
但只有同一個區域的GCE機器能夠連。&lt;br /&gt;
連去GCE 直接ping各個區域的機器，都正常。&lt;br /&gt;
但連GKE的LB 就不通。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;諮詢了顧問公司，&lt;br /&gt;
他們的回答是VPC內部的子網路都是互通的（沒錯，測試有通），&lt;br /&gt;
但要連到GKE的internal LB，&lt;br /&gt;
LB要開啓 &lt;code&gt;Global access&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/233-fig.1.png&quot; alt=&quot;233-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/load-balancing/docs/internal?hl=zh-cn#client-access&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;客戶端訪問&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;troubleshoot&quot; tabindex=&quot;-1&quot;&gt;Troubleshoot&lt;/h3&gt;
&lt;p&gt;這幾天發現個問題，&lt;br /&gt;
手動更改Global access後，會自動變成Disable。&lt;br /&gt;
通報給Google了，後續看狀況。&lt;br /&gt;
但有建議說直接在server上面加 annotations&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  annotations:
    # add globle access
    networking.gke.io/internal-load-balancer-allow-global-access: &amp;quot;true&amp;quot;
    networking.gke.io/load-balancer-type: &amp;quot;Internal&amp;quot;
  name: srs-source-internal
  namespace: srs-prod  
spec:
  type: LoadBalancer
  selector:
    app: srs-source
  ports:
    - protocol: TCP
      port: 1935
      targetPort: 1935
      name: rtmp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/concepts/service-load-balancer-parameters#global_access_internal_lb&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Global access&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/233. 不同區域 GCE與GKE LB連線/" />
        </entry>
        <entry>
            <title>
                232. GCE Observability 安裝agent失敗
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/232. GCE Observability 安裝agent失敗/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;利用terraform裝好GCE後，&lt;br /&gt;
要來裝一下監控，才能把資料丟去grafana裏面統一管。&lt;br /&gt;
結果一直卡在pending。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/232-fig.1.png&quot; alt=&quot;232-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;以爲只是單純安裝失敗，先強制關閉更新後再看看。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 關閉安裝
sudo bash add-monitoring-agent-repo.sh --remove-repo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重新啓用後還會卡在pending，&lt;br /&gt;
還是只能查 log ，到 &lt;code&gt;/var/log/google-cloud-ops-agent&lt;/code&gt; 底下，&lt;br /&gt;
查看&lt;code&gt;health-checks.log&lt;/code&gt; 。發現原因出現permission denied&lt;/p&gt;
&lt;p&gt;後來才發現原因，&lt;br /&gt;
我用terraform建立GCE時，沒有設定的service account。&lt;br /&gt;
導致他要安裝時會卡在那邊。&lt;/p&gt;
&lt;p&gt;所以，只要把機器停機，&lt;br /&gt;
再到  API and identity management 選擇 Service account即可。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/232-fig.2.png&quot; alt=&quot;232-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/stackdriver/docs/solutions/agents/ops-agent/troubleshoot-install-startup?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;排查 Ops Agent 安裝和啟動問題&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/232. GCE Observability 安裝agent失敗/" />
        </entry>
        <entry>
            <title>
                231. GKE node cpu limit 計算
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/231. GKE node cpu limit 計算/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;線上服務的pod，CPU飆高，&lt;br /&gt;
導致所屬的node，CPU也跟著衝高，合理。&lt;br /&gt;
但同仁問了一句那個limit是啥。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/231-fig.1.png&quot; alt=&quot;231-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;那條紅色的線，&lt;br /&gt;
原本以為那是某個node的cpu最大值，&lt;br /&gt;
但我這個node的最大cpu只有4而已。&lt;/p&gt;
&lt;p&gt;所以排除了CPU的上限，檢視 Metrics Explorer&lt;br /&gt;
指標上面寫Limit cores&lt;br /&gt;
再根據 &lt;a href=&quot;https://cloud.google.com/monitoring/api/metrics_kubernetes&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GKE system metrics&lt;/a&gt;，得知這個metrics是指 CPU cores limit of the container。&lt;/p&gt;
&lt;p&gt;但我又懶得一個一個查這個node有多少limit。&lt;br /&gt;
於是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get pods --all-namespaces -o wide --field-selector spec.nodeName=&amp;lt;node name&amp;gt; -o custom-columns=:metadata.name,:metadata.namespace --no-headers | while read -r name ns; do
  echo &amp;quot;$name and $ns&amp;quot;
  kubectl get pod $name -n $ns -o jsonpath=&#39;{.spec.containers[*].resources.limits.cpu}&#39; | xargs -n1 echo &amp;quot;  CPU Limit: &amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本來是用for，但在切割name 與 namespace出了點問題。&lt;br /&gt;
最後才改用while。&lt;/p&gt;
&lt;p&gt;這邊將值總和計算出來後是6.2，數值一樣，謎底解開了。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://kubernetes.io/docs/reference/kubectl/#output-options&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Command line tool (kubectl)&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/231. GKE node cpu limit 計算/" />
        </entry>
        <entry>
            <title>
                228. Cloudsql PITR還原
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/228. Cloudsql PITR還原/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;Why&lt;/h1&gt;
&lt;p&gt;為了之後的服務，要來驗證一下有哪些的還原方式。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;目前看到的是PITR，看說明文件，可以還原到秒的時間。&lt;br /&gt;
開啓方式可以參考&lt;a href=&quot;https://cloud.google.com/sql/docs/sqlserver/backup-recovery/pitr&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;官方文件&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但有一點文件沒提到，&lt;br /&gt;
你只能選取五分鐘前的時間。&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;p&gt;現在時間是 15:30 ，你還原的時間點，只能選擇15:25以前。&lt;br /&gt;
當然還有秒數的問題，&lt;br /&gt;
如果選擇的時間是 15:25~15:30的話，會出現這個錯誤。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/228-fig.1.png&quot; alt=&quot;228-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果要確認可以退的時間點，&lt;br /&gt;
可以執行下面指令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud sql instances get-latest-recovery-time &amp;lt;instanceName&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;會顯示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kind: sql#getLatestRecoveryTime
latestRecoveryTime: &#39;2024-08-15T06:48:48Z&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面就是你能夠還原的最早時間。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/sql/instances/get-latest-recovery-time&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud sql instances get-latest-recovery-time&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/228. Cloudsql PITR還原/" />
        </entry>
        <entry>
            <title>
                225.  Debian安裝後設定
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/225.  Debian安裝後設定/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;被要求寫個SOP安裝服務的手冊，&lt;br /&gt;
從作業系統開始。&lt;/p&gt;
&lt;h1 id=&quot;note&quot; tabindex=&quot;-1&quot;&gt;Note&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;*** is not in the sudoers file.  This incident will be reported.”&lt;br /&gt;
修改sudoers檔案&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;su root
chmod 777 /etc/sudoers
vi /etc/sudoers

# 在 root    ALL=(ALL:ALL) ALL 下面加上
 &amp;lt;user&amp;gt;    ALL=(ALL)ALL

chmod 440 /etc/sudoers
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;關閉休眠模式&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo systemctl mask sleep.target suspend.target hibernate.target hybrid-sleep.target

執行完後，需重開機
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;
&lt;p&gt;關閉安裝來源&lt;br /&gt;
最快的方法是直接從桌面模式關掉。&lt;br /&gt;
程式介面搜尋 update，找到software &amp;amp; update ，&lt;br /&gt;
進去後切到Other software的頁籤，將選項拿掉。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝deb&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;apt install ./anydesk_6.3.2-1_amd64.deb
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/225.  Debian安裝後設定/" />
        </entry>
        <entry>
            <title>
                224. GKE的節點上限採坑記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/224. GKE的節點上限採坑記/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;WHY&lt;/h1&gt;
&lt;p&gt;最近同事在搞壓力測試，&lt;br /&gt;
然後他就突然跟我說，欸，我的pod起不來。&lt;br /&gt;
看了一下，發現ip 應該是還夠的啊，怎麼會噴 &lt;code&gt;scale.up.error.ip.space.exhausted&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;how&quot; tabindex=&quot;-1&quot;&gt;How&lt;/h1&gt;
&lt;p&gt;因為GKE會根據每個node上，所設定的最大pod數量，&lt;br /&gt;
以及pod的CIDR範圍，來計算你這個cluster可以開到幾個node。&lt;/p&gt;
&lt;p&gt;ref.&lt;a href=&quot;https://cloud.google.com/kubernetes-engine/docs/how-to/flexible-pod-cidr?hl=zh-cn#configuring_maximum_pods_per_node&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;組態每個節點的 Pod 數上限&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章的最後有寫到，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果您將默認最大 Pod 數設定為 &lt;code&gt;110&lt;/code&gt; 並將 Pod 的次要 IP 地址範圍設定為 &lt;code&gt;/21&lt;/code&gt;，Kubernetes 會為叢集中的節點分配 &lt;code&gt;/24&lt;/code&gt; CIDR 範圍。這允許叢集中最多有&lt;mjx-container class=&quot;MathJax&quot; jax=&quot;SVG&quot; style=&quot;direction: ltr; position: relative;&quot;&gt;&lt;svg style=&quot;overflow: visible; min-height: 1px; min-width: 1px; vertical-align: 0;&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;7.008ex&quot; height=&quot;2.021ex&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewBox=&quot;0 -893.3 3097.5 893.3&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;scale(1,-1)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msup&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(533,363) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(389,0)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;path data-c=&quot;34&quot; d=&quot;M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z&quot; transform=&quot;translate(500,0)&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1389,0)&quot;&gt;&lt;path data-c=&quot;2212&quot; d=&quot;M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(2167,0)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot; transform=&quot;translate(500,0)&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3167,0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;mjx-assistive-mml unselectable=&quot;on&quot; display=&quot;inline&quot; style=&quot;top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; position: absolute; padding: 1px 0px 0px 0px; border: 0px; display: block; width: auto; overflow: hidden;&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow data-mjx-texclass=&quot;ORD&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mn&gt;24&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;21&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/math&gt;&lt;/mjx-assistive-mml&gt;&lt;/mjx-container&gt; = &lt;mjx-container class=&quot;MathJax&quot; jax=&quot;SVG&quot; style=&quot;direction: ltr; position: relative;&quot;&gt;&lt;svg style=&quot;overflow: visible; min-height: 1px; min-width: 1px; vertical-align: 0;&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;2.119ex&quot; height=&quot;1.885ex&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewBox=&quot;0 -833.2 936.6 833.2&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;scale(1,-1)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msup&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(533,363) scale(0.707)&quot;&gt;&lt;path data-c=&quot;33&quot; d=&quot;M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;mjx-assistive-mml unselectable=&quot;on&quot; display=&quot;inline&quot; style=&quot;top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; position: absolute; padding: 1px 0px 0px 0px; border: 0px; display: block; width: auto; overflow: hidden;&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;/math&gt;&lt;/mjx-assistive-mml&gt;&lt;/mjx-container&gt; =  8 個節點。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的最大pod數為&lt;code&gt;110&lt;/code&gt;，次要IP範圍也是&lt;code&gt;/21&lt;/code&gt;，&lt;br /&gt;
所以node開到8個，就達到上限了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/224-fig.1.png&quot; alt=&quot;224-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然後，為什麼kubernetes替叢集的節點分配的範圍是 &lt;code&gt;/24&lt;/code&gt;。&lt;br /&gt;
要往下看表格。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;每個節點的最大 Pod 數量&lt;/th&gt;
&lt;th&gt;每個節點的 CIDR 範圍&lt;/th&gt;
&lt;th&gt;IP 地址數量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;/28&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9 - 16&lt;/td&gt;
&lt;td&gt;/27&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;17 - 32&lt;/td&gt;
&lt;td&gt;/26&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;33 - 64&lt;/td&gt;
&lt;td&gt;/25&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;65 - 128&lt;/td&gt;
&lt;td&gt;/24&lt;/td&gt;
&lt;td&gt;256&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;129 - 256&lt;/td&gt;
&lt;td&gt;/23&lt;/td&gt;
&lt;td&gt;512&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;假設最大pod數是64，那最大節點數則是 &lt;mjx-container class=&quot;MathJax&quot; jax=&quot;SVG&quot; style=&quot;direction: ltr; position: relative;&quot;&gt;&lt;svg style=&quot;overflow: visible; min-height: 1px; min-width: 1px; vertical-align: 0;&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;7.008ex&quot; height=&quot;2.021ex&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewBox=&quot;0 -893.3 3097.5 893.3&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;scale(1,-1)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msup&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(533,363) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(389,0)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;path data-c=&quot;35&quot; d=&quot;M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z&quot; transform=&quot;translate(500,0)&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1389,0)&quot;&gt;&lt;path data-c=&quot;2212&quot; d=&quot;M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(2167,0)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot; transform=&quot;translate(500,0)&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3167,0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;mjx-assistive-mml unselectable=&quot;on&quot; display=&quot;inline&quot; style=&quot;top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; position: absolute; padding: 1px 0px 0px 0px; border: 0px; display: block; width: auto; overflow: hidden;&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow data-mjx-texclass=&quot;ORD&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mn&gt;25&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;21&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/math&gt;&lt;/mjx-assistive-mml&gt;&lt;/mjx-container&gt; = &lt;mjx-container class=&quot;MathJax&quot; jax=&quot;SVG&quot; style=&quot;direction: ltr; position: relative;&quot;&gt;&lt;svg style=&quot;overflow: visible; min-height: 1px; min-width: 1px; vertical-align: 0;&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;2.119ex&quot; height=&quot;1.904ex&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewBox=&quot;0 -841.7 936.6 841.7&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;scale(1,-1)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msup&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(533,363) scale(0.707)&quot;&gt;&lt;path data-c=&quot;34&quot; d=&quot;M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z&quot; style=&quot;stroke-width: 3;&quot;&gt;&lt;/path&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;mjx-assistive-mml unselectable=&quot;on&quot; display=&quot;inline&quot; style=&quot;top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; position: absolute; padding: 1px 0px 0px 0px; border: 0px; display: block; width: auto; overflow: hidden;&quot;&gt;&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/msup&gt;&lt;/math&gt;&lt;/mjx-assistive-mml&gt;&lt;/mjx-container&gt; = 16&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;後來才知道原因，當時有其他案子在手中，沒空查原因。&lt;br /&gt;
但當下直接加大機器規格，減少node的數量。&lt;br /&gt;
或者直接在vpc上面增加新的pod range，應該也是可以的。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/224. GKE的節點上限採坑記/" />
        </entry>
        <entry>
            <title>
                223. 檢查TCP or UDP是否有通
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/223. 檢查TCP or UDP是否有通/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;Why&lt;/h1&gt;
&lt;p&gt;搞SRS的時候，&lt;br /&gt;
要測試webRTC的功能，&lt;br /&gt;
開了UDP但不知道到底有沒有通。&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;h3 id=&quot;udp&quot; tabindex=&quot;-1&quot;&gt;UDP&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;nc -u YOUR_PUBLIC_IP 30000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通的話，應該是會發現你可以在底下打字，然後不會結束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/223-fig.1.png&quot; alt=&quot;223-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果有另一台伺服器可以玩的話，&lt;br /&gt;
可以做server&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nc -ulvp 30000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.wildfirechat.cn/webrtc/udp_connectivity.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;UDP連接埠連通性檢查&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;netcat&quot; tabindex=&quot;-1&quot;&gt;Netcat&lt;/h3&gt;
&lt;p&gt;安裝方式&lt;/p&gt;
&lt;p&gt;Mac&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew install netcat
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Linux&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt install netcat
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CentOS&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yum install nc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alpine Linux&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apk add netcat-openbsd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Docker&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt install netcat-traditional
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;檢查特定的port 是否開啟&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;nc -v 192.168.0.175 5000
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;掃描對方機器的port&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;nc -vnz -w 1 192.168.233.208 1-1000 2000-3000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再來還有送出http請求、寄信、簡易網頁伺服器...&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://blog.gtwang.org/linux/linux-utility-netcat-examples/&quot; title=&quot;Netcat（Linux nc 指令）網路管理者工具實用範例&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Netcat（Linux nc 指令）網路管理者工具實用範例&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/223. 檢查TCP or UDP是否有通/" />
        </entry>
        <entry>
            <title>
                222. elastic 整批刪除indics
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/222. elastic 整批刪除indics/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;Why&lt;/h1&gt;
&lt;p&gt;不知道為什麼，ILM沒有動作，沒將舊的indics刪除。&lt;br /&gt;
導致elastic直接報錯。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this action would add [2] shards, but this cluster currently has [1000]/[1000] maximum normal shards open;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;緊急處理先將node的 shared開成1500&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PUT /_cluster/settings
{
  &amp;quot;persistent&amp;quot;: {
    &amp;quot;cluster.max_shards_per_node&amp;quot;: 1500
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;再來是檢查為什麼有那麼多shared沒刪除，&lt;br /&gt;
但一整批，一個一個刪除會瘋掉。&lt;br /&gt;
用wildcard卻會發生錯誤。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DELETE /qa-backend-2024.02.*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;錯誤&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;error&amp;quot;: {
    &amp;quot;root_cause&amp;quot;: [
      {
        &amp;quot;type&amp;quot;: &amp;quot;illegal_argument_exception&amp;quot;,
        &amp;quot;reason&amp;quot;: &amp;quot;Wildcard expressions or all indices are not allowed&amp;quot;
      }
    ],
    &amp;quot;type&amp;quot;: &amp;quot;illegal_argument_exception&amp;quot;,
    &amp;quot;reason&amp;quot;: &amp;quot;Wildcard expressions or all indices are not allowed&amp;quot;
  },
  &amp;quot;status&amp;quot;: 400
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不想寫shellscript，一個一個撈index去刪除，&lt;br /&gt;
於是先開放wildcard吧。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PUT _cluster/settings
{
    &amp;quot;transient&amp;quot;: {
        &amp;quot;action.destructive_requires_name&amp;quot;: false // allow wildcards
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再來執行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DELETE /qa-backend-2024.02.*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;結束。&lt;/p&gt;
&lt;p&gt;ref.  &lt;a href=&quot;https://stackoverflow.com/questions/63388937/elasticsearch-how-to-delete-multiple-indexes-with-wildcard&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;elasticsearch, how to delete multiple indexes with wildcard&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/222. elastic 整批刪除indics/" />
        </entry>
        <entry>
            <title>
                221. L7mp stunner監控
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/221. L7mp stunner監控/</id>
            <content type="html">
                &lt;h1 id=&quot;why&quot; tabindex=&quot;-1&quot;&gt;Why&lt;/h1&gt;
&lt;p&gt;有人搞了一個webRTC for k8s用的即時媒體串流方案，&lt;br /&gt;
然後我要來接監控了。&lt;br /&gt;
&lt;a href=&quot;https://l7mp.io/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;L7mp&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;solution&quot; tabindex=&quot;-1&quot;&gt;Solution&lt;/h1&gt;
&lt;p&gt;參考&lt;a href=&quot;https://docs.l7mp.io/en/stable/MONITORING/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;文件&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加 &lt;code&gt;enableMetricsEndpoint&lt;/code&gt; 參數加到Dataplane裡面&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;...
spec:
  args:
    - &#39;-w&#39;
    - &#39;--udp-thread-num=16&#39;
  command:
    - stunnerd
  enableMetricsEndpoint: true
  hostNetwork: false
  image: docker.io/l7mp/stunnerd:0.18.0
  imagePullPolicy: Always
  replicas: 1
  resources:
    limits:
      cpu: 2
      memory: 512Mi
    requests:
      cpu: 500m
      memory: 128Mi
  terminationGracePeriodSeconds: 3600
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;弄個暫時的pod測試看看metrics有沒有資料&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;kubectl run alpine-pod -n istio-system --image=alpine --restart=Never -- /bin/sleep 600
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先取得stunner的pod ip，再來就看有沒有資料了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl http://192.168.1.25:8080/metrics
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有資料後再來下一步。&lt;br /&gt;
這邊要注意一下，剛開後，&lt;code&gt;stunner&lt;/code&gt;開頭的指標通通找不到，&lt;br /&gt;
像是&lt;code&gt;stunner_listener_connections_total&lt;/code&gt;、&lt;code&gt;stunner_listener_bytes_total&lt;/code&gt;...等。&lt;/p&gt;
&lt;p&gt;我放了一陣子(一兩個小時？)，就突然跑出來了，&lt;br /&gt;
我不確定為什麼，等之後再測試看看。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;prometheus 設定 discover&lt;br /&gt;
詳細說明，參考&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/209.%20k8s%E4%B8%ADsrs%E7%9A%84%E5%90%84%E5%80%8Bpod%20%20metrics%E5%8F%96%E5%BE%97/&quot;&gt;209. k8s中srs的各個pod  metrics取得&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;scrape_configs:
- job_name: &#39;ome&#39;
  scrape_interval: 10s
  kubernetes_sd_configs:
    - role: pod  
  relabel_configs:
    - source_labels: [__meta_kubernetes_pod_name]
      action: keep
      regex: tcp-gateway.*
    - source_labels: [__meta_kubernetes_pod_container_port_name]
      action: replace
      target_label: portname
      replacement: 8080  
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;建立Grafana&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;annotations&amp;quot;: {
    &amp;quot;list&amp;quot;: [
      {
        &amp;quot;builtIn&amp;quot;: 1,
        &amp;quot;datasource&amp;quot;: {
          &amp;quot;type&amp;quot;: &amp;quot;grafana&amp;quot;,
          &amp;quot;uid&amp;quot;: &amp;quot;-- Grafana --&amp;quot;
        },
        &amp;quot;enable&amp;quot;: true,
        &amp;quot;hide&amp;quot;: true,
        &amp;quot;iconColor&amp;quot;: &amp;quot;rgba(0, 211, 255, 1)&amp;quot;,
        &amp;quot;name&amp;quot;: &amp;quot;Annotations &amp;amp; Alerts&amp;quot;,
        &amp;quot;type&amp;quot;: &amp;quot;dashboard&amp;quot;
      }
    ]
  },
  &amp;quot;editable&amp;quot;: true,
  &amp;quot;fiscalYearStartMonth&amp;quot;: 0,
  &amp;quot;graphTooltip&amp;quot;: 0,
  &amp;quot;id&amp;quot;: 14,
  &amp;quot;links&amp;quot;: [],
  &amp;quot;liveNow&amp;quot;: false,
  &amp;quot;panels&amp;quot;: [
    {
      &amp;quot;datasource&amp;quot;: {
        &amp;quot;type&amp;quot;: &amp;quot;prometheus&amp;quot;,
        &amp;quot;uid&amp;quot;: &amp;quot;PBFA97CFB590B2093&amp;quot;
      },
      &amp;quot;fieldConfig&amp;quot;: {
        &amp;quot;defaults&amp;quot;: {
          &amp;quot;color&amp;quot;: {
            &amp;quot;mode&amp;quot;: &amp;quot;palette-classic&amp;quot;
          },
          &amp;quot;custom&amp;quot;: {
            &amp;quot;axisCenteredZero&amp;quot;: false,
            &amp;quot;axisColorMode&amp;quot;: &amp;quot;text&amp;quot;,
            &amp;quot;axisLabel&amp;quot;: &amp;quot;&amp;quot;,
            &amp;quot;axisPlacement&amp;quot;: &amp;quot;auto&amp;quot;,
            &amp;quot;barAlignment&amp;quot;: 0,
            &amp;quot;drawStyle&amp;quot;: &amp;quot;line&amp;quot;,
            &amp;quot;fillOpacity&amp;quot;: 0,
            &amp;quot;gradientMode&amp;quot;: &amp;quot;none&amp;quot;,
            &amp;quot;hideFrom&amp;quot;: {
              &amp;quot;legend&amp;quot;: false,
              &amp;quot;tooltip&amp;quot;: false,
              &amp;quot;viz&amp;quot;: false
            },
            &amp;quot;lineInterpolation&amp;quot;: &amp;quot;linear&amp;quot;,
            &amp;quot;lineWidth&amp;quot;: 1,
            &amp;quot;pointSize&amp;quot;: 5,
            &amp;quot;scaleDistribution&amp;quot;: {
              &amp;quot;type&amp;quot;: &amp;quot;linear&amp;quot;
            },
            &amp;quot;showPoints&amp;quot;: &amp;quot;auto&amp;quot;,
            &amp;quot;spanNulls&amp;quot;: false,
            &amp;quot;stacking&amp;quot;: {
              &amp;quot;group&amp;quot;: &amp;quot;A&amp;quot;,
              &amp;quot;mode&amp;quot;: &amp;quot;none&amp;quot;
            },
            &amp;quot;thresholdsStyle&amp;quot;: {
              &amp;quot;mode&amp;quot;: &amp;quot;off&amp;quot;
            }
          },
          &amp;quot;mappings&amp;quot;: [],
          &amp;quot;thresholds&amp;quot;: {
            &amp;quot;mode&amp;quot;: &amp;quot;absolute&amp;quot;,
            &amp;quot;steps&amp;quot;: [
              {
                &amp;quot;color&amp;quot;: &amp;quot;green&amp;quot;,
                &amp;quot;value&amp;quot;: null
              },
              {
                &amp;quot;color&amp;quot;: &amp;quot;red&amp;quot;,
                &amp;quot;value&amp;quot;: 80
              }
            ]
          }
        },
        &amp;quot;overrides&amp;quot;: []
      },
      &amp;quot;gridPos&amp;quot;: {
        &amp;quot;h&amp;quot;: 8,
        &amp;quot;w&amp;quot;: 12,
        &amp;quot;x&amp;quot;: 0,
        &amp;quot;y&amp;quot;: 0
      },
      &amp;quot;id&amp;quot;: 3,
      &amp;quot;options&amp;quot;: {
        &amp;quot;legend&amp;quot;: {
          &amp;quot;calcs&amp;quot;: [],
          &amp;quot;displayMode&amp;quot;: &amp;quot;list&amp;quot;,
          &amp;quot;placement&amp;quot;: &amp;quot;bottom&amp;quot;,
          &amp;quot;showLegend&amp;quot;: true
        },
        &amp;quot;tooltip&amp;quot;: {
          &amp;quot;mode&amp;quot;: &amp;quot;single&amp;quot;,
          &amp;quot;sort&amp;quot;: &amp;quot;none&amp;quot;
        }
      },
      &amp;quot;targets&amp;quot;: [
        {
          &amp;quot;datasource&amp;quot;: {
            &amp;quot;type&amp;quot;: &amp;quot;prometheus&amp;quot;,
            &amp;quot;uid&amp;quot;: &amp;quot;PBFA97CFB590B2093&amp;quot;
          },
          &amp;quot;editorMode&amp;quot;: &amp;quot;code&amp;quot;,
          &amp;quot;expr&amp;quot;: &amp;quot;stunner_listener_connections&amp;quot;,
          &amp;quot;legendFormat&amp;quot;: &amp;quot;__auto&amp;quot;,
          &amp;quot;range&amp;quot;: true,
          &amp;quot;refId&amp;quot;: &amp;quot;A&amp;quot;
        }
      ],
      &amp;quot;title&amp;quot;: &amp;quot;stunner_listener_connections&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;timeseries&amp;quot;
    },
    {
      &amp;quot;datasource&amp;quot;: {
        &amp;quot;type&amp;quot;: &amp;quot;prometheus&amp;quot;,
        &amp;quot;uid&amp;quot;: &amp;quot;PBFA97CFB590B2093&amp;quot;
      },
      &amp;quot;fieldConfig&amp;quot;: {
        &amp;quot;defaults&amp;quot;: {
          &amp;quot;color&amp;quot;: {
            &amp;quot;mode&amp;quot;: &amp;quot;palette-classic&amp;quot;
          },
          &amp;quot;custom&amp;quot;: {
            &amp;quot;axisCenteredZero&amp;quot;: false,
            &amp;quot;axisColorMode&amp;quot;: &amp;quot;text&amp;quot;,
            &amp;quot;axisLabel&amp;quot;: &amp;quot;&amp;quot;,
            &amp;quot;axisPlacement&amp;quot;: &amp;quot;auto&amp;quot;,
            &amp;quot;barAlignment&amp;quot;: 0,
            &amp;quot;drawStyle&amp;quot;: &amp;quot;line&amp;quot;,
            &amp;quot;fillOpacity&amp;quot;: 0,
            &amp;quot;gradientMode&amp;quot;: &amp;quot;none&amp;quot;,
            &amp;quot;hideFrom&amp;quot;: {
              &amp;quot;legend&amp;quot;: false,
              &amp;quot;tooltip&amp;quot;: false,
              &amp;quot;viz&amp;quot;: false
            },
            &amp;quot;lineInterpolation&amp;quot;: &amp;quot;linear&amp;quot;,
            &amp;quot;lineWidth&amp;quot;: 1,
            &amp;quot;pointSize&amp;quot;: 5,
            &amp;quot;scaleDistribution&amp;quot;: {
              &amp;quot;type&amp;quot;: &amp;quot;linear&amp;quot;
            },
            &amp;quot;showPoints&amp;quot;: &amp;quot;auto&amp;quot;,
            &amp;quot;spanNulls&amp;quot;: false,
            &amp;quot;stacking&amp;quot;: {
              &amp;quot;group&amp;quot;: &amp;quot;A&amp;quot;,
              &amp;quot;mode&amp;quot;: &amp;quot;none&amp;quot;
            },
            &amp;quot;thresholdsStyle&amp;quot;: {
              &amp;quot;mode&amp;quot;: &amp;quot;off&amp;quot;
            }
          },
          &amp;quot;mappings&amp;quot;: [],
          &amp;quot;thresholds&amp;quot;: {
            &amp;quot;mode&amp;quot;: &amp;quot;absolute&amp;quot;,
            &amp;quot;steps&amp;quot;: [
              {
                &amp;quot;color&amp;quot;: &amp;quot;green&amp;quot;,
                &amp;quot;value&amp;quot;: null
              },
              {
                &amp;quot;color&amp;quot;: &amp;quot;red&amp;quot;,
                &amp;quot;value&amp;quot;: 80
              }
            ]
          }
        },
        &amp;quot;overrides&amp;quot;: [
          {
            &amp;quot;matcher&amp;quot;: {
              &amp;quot;id&amp;quot;: &amp;quot;byName&amp;quot;,
              &amp;quot;options&amp;quot;: &amp;quot;{__name__=&#92;&amp;quot;stunner_listener_connections_total&#92;&amp;quot;, instance=&#92;&amp;quot;192.168.58.102:8080&#92;&amp;quot;, job=&#92;&amp;quot;ome&#92;&amp;quot;, name=&#92;&amp;quot;stunner/tcp-gateway/tcp-listener&#92;&amp;quot;, portname=&#92;&amp;quot;8080&#92;&amp;quot;}&amp;quot;
            },
            &amp;quot;properties&amp;quot;: [
              {
                &amp;quot;id&amp;quot;: &amp;quot;color&amp;quot;,
                &amp;quot;value&amp;quot;: {
                  &amp;quot;fixedColor&amp;quot;: &amp;quot;dark-yellow&amp;quot;,
                  &amp;quot;mode&amp;quot;: &amp;quot;fixed&amp;quot;
                }
              }
            ]
          }
        ]
      },
      &amp;quot;gridPos&amp;quot;: {
        &amp;quot;h&amp;quot;: 8,
        &amp;quot;w&amp;quot;: 12,
        &amp;quot;x&amp;quot;: 12,
        &amp;quot;y&amp;quot;: 0
      },
      &amp;quot;id&amp;quot;: 1,
      &amp;quot;options&amp;quot;: {
        &amp;quot;legend&amp;quot;: {
          &amp;quot;calcs&amp;quot;: [],
          &amp;quot;displayMode&amp;quot;: &amp;quot;list&amp;quot;,
          &amp;quot;placement&amp;quot;: &amp;quot;bottom&amp;quot;,
          &amp;quot;showLegend&amp;quot;: true
        },
        &amp;quot;tooltip&amp;quot;: {
          &amp;quot;mode&amp;quot;: &amp;quot;single&amp;quot;,
          &amp;quot;sort&amp;quot;: &amp;quot;none&amp;quot;
        }
      },
      &amp;quot;targets&amp;quot;: [
        {
          &amp;quot;datasource&amp;quot;: {
            &amp;quot;type&amp;quot;: &amp;quot;prometheus&amp;quot;,
            &amp;quot;uid&amp;quot;: &amp;quot;PBFA97CFB590B2093&amp;quot;
          },
          &amp;quot;editorMode&amp;quot;: &amp;quot;code&amp;quot;,
          &amp;quot;expr&amp;quot;: &amp;quot;rate(stunner_listener_connections_total[1m])&amp;quot;,
          &amp;quot;legendFormat&amp;quot;: &amp;quot;__auto&amp;quot;,
          &amp;quot;range&amp;quot;: true,
          &amp;quot;refId&amp;quot;: &amp;quot;A&amp;quot;
        }
      ],
      &amp;quot;title&amp;quot;: &amp;quot;listener_connections_total&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;timeseries&amp;quot;
    },
    {
      &amp;quot;datasource&amp;quot;: {
        &amp;quot;type&amp;quot;: &amp;quot;prometheus&amp;quot;,
        &amp;quot;uid&amp;quot;: &amp;quot;PBFA97CFB590B2093&amp;quot;
      },
      &amp;quot;description&amp;quot;: &amp;quot;監聽器上發送或接收的字節總數。&amp;quot;,
      &amp;quot;fieldConfig&amp;quot;: {
        &amp;quot;defaults&amp;quot;: {
          &amp;quot;color&amp;quot;: {
            &amp;quot;mode&amp;quot;: &amp;quot;palette-classic&amp;quot;
          },
          &amp;quot;custom&amp;quot;: {
            &amp;quot;axisCenteredZero&amp;quot;: false,
            &amp;quot;axisColorMode&amp;quot;: &amp;quot;text&amp;quot;,
            &amp;quot;axisLabel&amp;quot;: &amp;quot;&amp;quot;,
            &amp;quot;axisPlacement&amp;quot;: &amp;quot;auto&amp;quot;,
            &amp;quot;barAlignment&amp;quot;: 0,
            &amp;quot;drawStyle&amp;quot;: &amp;quot;line&amp;quot;,
            &amp;quot;fillOpacity&amp;quot;: 0,
            &amp;quot;gradientMode&amp;quot;: &amp;quot;none&amp;quot;,
            &amp;quot;hideFrom&amp;quot;: {
              &amp;quot;legend&amp;quot;: false,
              &amp;quot;tooltip&amp;quot;: false,
              &amp;quot;viz&amp;quot;: false
            },
            &amp;quot;lineInterpolation&amp;quot;: &amp;quot;linear&amp;quot;,
            &amp;quot;lineWidth&amp;quot;: 1,
            &amp;quot;pointSize&amp;quot;: 5,
            &amp;quot;scaleDistribution&amp;quot;: {
              &amp;quot;type&amp;quot;: &amp;quot;linear&amp;quot;
            },
            &amp;quot;showPoints&amp;quot;: &amp;quot;auto&amp;quot;,
            &amp;quot;spanNulls&amp;quot;: false,
            &amp;quot;stacking&amp;quot;: {
              &amp;quot;group&amp;quot;: &amp;quot;A&amp;quot;,
              &amp;quot;mode&amp;quot;: &amp;quot;none&amp;quot;
            },
            &amp;quot;thresholdsStyle&amp;quot;: {
              &amp;quot;mode&amp;quot;: &amp;quot;off&amp;quot;
            }
          },
          &amp;quot;mappings&amp;quot;: [],
          &amp;quot;thresholds&amp;quot;: {
            &amp;quot;mode&amp;quot;: &amp;quot;absolute&amp;quot;,
            &amp;quot;steps&amp;quot;: [
              {
                &amp;quot;color&amp;quot;: &amp;quot;green&amp;quot;,
                &amp;quot;value&amp;quot;: null
              },
              {
                &amp;quot;color&amp;quot;: &amp;quot;red&amp;quot;,
                &amp;quot;value&amp;quot;: 80
              }
            ]
          },
          &amp;quot;unit&amp;quot;: &amp;quot;bytes&amp;quot;
        },
        &amp;quot;overrides&amp;quot;: [
          {
            &amp;quot;matcher&amp;quot;: {
              &amp;quot;id&amp;quot;: &amp;quot;byName&amp;quot;,
              &amp;quot;options&amp;quot;: &amp;quot;{__name__=&#92;&amp;quot;stunner_listener_bytes_total&#92;&amp;quot;, direction=&#92;&amp;quot;rx&#92;&amp;quot;, instance=&#92;&amp;quot;192.168.58.102:8080&#92;&amp;quot;, job=&#92;&amp;quot;ome&#92;&amp;quot;, name=&#92;&amp;quot;stunner/tcp-gateway/tcp-listener&#92;&amp;quot;, portname=&#92;&amp;quot;8080&#92;&amp;quot;}&amp;quot;
            },
            &amp;quot;properties&amp;quot;: [
              {
                &amp;quot;id&amp;quot;: &amp;quot;color&amp;quot;,
                &amp;quot;value&amp;quot;: {
                  &amp;quot;fixedColor&amp;quot;: &amp;quot;purple&amp;quot;,
                  &amp;quot;mode&amp;quot;: &amp;quot;fixed&amp;quot;
                }
              }
            ]
          },
          {
            &amp;quot;matcher&amp;quot;: {
              &amp;quot;id&amp;quot;: &amp;quot;byName&amp;quot;,
              &amp;quot;options&amp;quot;: &amp;quot;rx&amp;quot;
            },
            &amp;quot;properties&amp;quot;: [
              {
                &amp;quot;id&amp;quot;: &amp;quot;color&amp;quot;,
                &amp;quot;value&amp;quot;: {
                  &amp;quot;fixedColor&amp;quot;: &amp;quot;dark-red&amp;quot;,
                  &amp;quot;mode&amp;quot;: &amp;quot;fixed&amp;quot;
                }
              }
            ]
          }
        ]
      },
      &amp;quot;gridPos&amp;quot;: {
        &amp;quot;h&amp;quot;: 9,
        &amp;quot;w&amp;quot;: 24,
        &amp;quot;x&amp;quot;: 0,
        &amp;quot;y&amp;quot;: 8
      },
      &amp;quot;id&amp;quot;: 2,
      &amp;quot;options&amp;quot;: {
        &amp;quot;legend&amp;quot;: {
          &amp;quot;calcs&amp;quot;: [],
          &amp;quot;displayMode&amp;quot;: &amp;quot;list&amp;quot;,
          &amp;quot;placement&amp;quot;: &amp;quot;bottom&amp;quot;,
          &amp;quot;showLegend&amp;quot;: true
        },
        &amp;quot;tooltip&amp;quot;: {
          &amp;quot;mode&amp;quot;: &amp;quot;single&amp;quot;,
          &amp;quot;sort&amp;quot;: &amp;quot;none&amp;quot;
        }
      },
      &amp;quot;targets&amp;quot;: [
        {
          &amp;quot;datasource&amp;quot;: {
            &amp;quot;type&amp;quot;: &amp;quot;prometheus&amp;quot;,
            &amp;quot;uid&amp;quot;: &amp;quot;PBFA97CFB590B2093&amp;quot;
          },
          &amp;quot;editorMode&amp;quot;: &amp;quot;code&amp;quot;,
          &amp;quot;expr&amp;quot;: &amp;quot;sum(irate(stunner_listener_bytes_total[1m])) by (direction)&amp;quot;,
          &amp;quot;hide&amp;quot;: false,
          &amp;quot;legendFormat&amp;quot;: &amp;quot;__auto&amp;quot;,
          &amp;quot;range&amp;quot;: true,
          &amp;quot;refId&amp;quot;: &amp;quot;A&amp;quot;
        }
      ],
      &amp;quot;title&amp;quot;: &amp;quot;stunner_listener_bytes_total&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;timeseries&amp;quot;
    },
    {
      &amp;quot;datasource&amp;quot;: {
        &amp;quot;type&amp;quot;: &amp;quot;prometheus&amp;quot;,
        &amp;quot;uid&amp;quot;: &amp;quot;PBFA97CFB590B2093&amp;quot;
      },
      &amp;quot;description&amp;quot;: &amp;quot;發送到後端或從後端接收的字節總數。&amp;quot;,
      &amp;quot;fieldConfig&amp;quot;: {
        &amp;quot;defaults&amp;quot;: {
          &amp;quot;color&amp;quot;: {
            &amp;quot;mode&amp;quot;: &amp;quot;palette-classic&amp;quot;
          },
          &amp;quot;custom&amp;quot;: {
            &amp;quot;axisCenteredZero&amp;quot;: false,
            &amp;quot;axisColorMode&amp;quot;: &amp;quot;text&amp;quot;,
            &amp;quot;axisLabel&amp;quot;: &amp;quot;&amp;quot;,
            &amp;quot;axisPlacement&amp;quot;: &amp;quot;auto&amp;quot;,
            &amp;quot;barAlignment&amp;quot;: 0,
            &amp;quot;drawStyle&amp;quot;: &amp;quot;line&amp;quot;,
            &amp;quot;fillOpacity&amp;quot;: 0,
            &amp;quot;gradientMode&amp;quot;: &amp;quot;none&amp;quot;,
            &amp;quot;hideFrom&amp;quot;: {
              &amp;quot;legend&amp;quot;: false,
              &amp;quot;tooltip&amp;quot;: false,
              &amp;quot;viz&amp;quot;: false
            },
            &amp;quot;lineInterpolation&amp;quot;: &amp;quot;linear&amp;quot;,
            &amp;quot;lineWidth&amp;quot;: 1,
            &amp;quot;pointSize&amp;quot;: 5,
            &amp;quot;scaleDistribution&amp;quot;: {
              &amp;quot;type&amp;quot;: &amp;quot;linear&amp;quot;
            },
            &amp;quot;showPoints&amp;quot;: &amp;quot;auto&amp;quot;,
            &amp;quot;spanNulls&amp;quot;: false,
            &amp;quot;stacking&amp;quot;: {
              &amp;quot;group&amp;quot;: &amp;quot;A&amp;quot;,
              &amp;quot;mode&amp;quot;: &amp;quot;none&amp;quot;
            },
            &amp;quot;thresholdsStyle&amp;quot;: {
              &amp;quot;mode&amp;quot;: &amp;quot;off&amp;quot;
            }
          },
          &amp;quot;mappings&amp;quot;: [],
          &amp;quot;thresholds&amp;quot;: {
            &amp;quot;mode&amp;quot;: &amp;quot;absolute&amp;quot;,
            &amp;quot;steps&amp;quot;: [
              {
                &amp;quot;color&amp;quot;: &amp;quot;green&amp;quot;,
                &amp;quot;value&amp;quot;: null
              },
              {
                &amp;quot;color&amp;quot;: &amp;quot;red&amp;quot;,
                &amp;quot;value&amp;quot;: 80
              }
            ]
          },
          &amp;quot;unit&amp;quot;: &amp;quot;bytes&amp;quot;
        },
        &amp;quot;overrides&amp;quot;: [
          {
            &amp;quot;matcher&amp;quot;: {
              &amp;quot;id&amp;quot;: &amp;quot;byName&amp;quot;,
              &amp;quot;options&amp;quot;: &amp;quot;rx&amp;quot;
            },
            &amp;quot;properties&amp;quot;: [
              {
                &amp;quot;id&amp;quot;: &amp;quot;color&amp;quot;,
                &amp;quot;value&amp;quot;: {
                  &amp;quot;fixedColor&amp;quot;: &amp;quot;dark-red&amp;quot;,
                  &amp;quot;mode&amp;quot;: &amp;quot;fixed&amp;quot;
                }
              }
            ]
          }
        ]
      },
      &amp;quot;gridPos&amp;quot;: {
        &amp;quot;h&amp;quot;: 8,
        &amp;quot;w&amp;quot;: 24,
        &amp;quot;x&amp;quot;: 0,
        &amp;quot;y&amp;quot;: 17
      },
      &amp;quot;id&amp;quot;: 4,
      &amp;quot;options&amp;quot;: {
        &amp;quot;legend&amp;quot;: {
          &amp;quot;calcs&amp;quot;: [],
          &amp;quot;displayMode&amp;quot;: &amp;quot;list&amp;quot;,
          &amp;quot;placement&amp;quot;: &amp;quot;bottom&amp;quot;,
          &amp;quot;showLegend&amp;quot;: true
        },
        &amp;quot;tooltip&amp;quot;: {
          &amp;quot;mode&amp;quot;: &amp;quot;single&amp;quot;,
          &amp;quot;sort&amp;quot;: &amp;quot;none&amp;quot;
        }
      },
      &amp;quot;targets&amp;quot;: [
        {
          &amp;quot;datasource&amp;quot;: {
            &amp;quot;type&amp;quot;: &amp;quot;prometheus&amp;quot;,
            &amp;quot;uid&amp;quot;: &amp;quot;PBFA97CFB590B2093&amp;quot;
          },
          &amp;quot;editorMode&amp;quot;: &amp;quot;code&amp;quot;,
          &amp;quot;expr&amp;quot;: &amp;quot;sum(irate(stunner_cluster_bytes_total[1m])) by (direction)&amp;quot;,
          &amp;quot;legendFormat&amp;quot;: &amp;quot;__auto&amp;quot;,
          &amp;quot;range&amp;quot;: true,
          &amp;quot;refId&amp;quot;: &amp;quot;A&amp;quot;
        }
      ],
      &amp;quot;title&amp;quot;: &amp;quot;stunner_cluster_bytes_total&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;timeseries&amp;quot;
    }
  ],
  &amp;quot;refresh&amp;quot;: false,
  &amp;quot;schemaVersion&amp;quot;: 38,
  &amp;quot;style&amp;quot;: &amp;quot;dark&amp;quot;,
  &amp;quot;tags&amp;quot;: [],
  &amp;quot;templating&amp;quot;: {
    &amp;quot;list&amp;quot;: []
  },
  &amp;quot;time&amp;quot;: {
    &amp;quot;from&amp;quot;: &amp;quot;2024-06-21T01:25:08.227Z&amp;quot;,
    &amp;quot;to&amp;quot;: &amp;quot;2024-06-21T04:12:21.776Z&amp;quot;
  },
  &amp;quot;timepicker&amp;quot;: {},
  &amp;quot;timezone&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;title&amp;quot;: &amp;quot;stunner&amp;quot;,
  &amp;quot;uid&amp;quot;: &amp;quot;cbd52e5c-df69-45e6-b2ba-84433a4cd6ec&amp;quot;,
  &amp;quot;version&amp;quot;: 5,
  &amp;quot;weekStart&amp;quot;: &amp;quot;&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql/prometheus-aggr-ops&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;PromQL聚合操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/l7mp/stunner&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;stunner Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.l7mp.io/en/stable/MONITORING/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;stunner Document&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/221. L7mp stunner監控/" />
        </entry>
        <entry>
            <title>
                220. windows將程式變成服務的好東西-winSW
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/220. windows將程式變成服務的好東西-winSW/</id>
            <content type="html">
                &lt;h1 id=&quot;緣由&quot; tabindex=&quot;-1&quot;&gt;緣由&lt;/h1&gt;
&lt;p&gt;本來在Linux上面跑的docker環境，&lt;br /&gt;
這次在客戶那邊突然要變成用windows，&lt;br /&gt;
非常好，之前弄的架構完全不一樣。&lt;/p&gt;
&lt;h1 id=&quot;主題&quot; tabindex=&quot;-1&quot;&gt;主題&lt;/h1&gt;
&lt;p&gt;今天有一個程式，你想讓他開機時自己啟動，&lt;br /&gt;
不是到msconfig設定開機啟動，就是弄成服務。&lt;br /&gt;
但開機啟動，如果沒有開機就沒用了，&lt;br /&gt;
所以弄成服務，一般是最穩定的方式。&lt;/p&gt;
&lt;p&gt;用nginx為範例說明，&lt;br /&gt;
我也是找nginx啟動時，才發現這個好東西。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先，先下載&lt;a href=&quot;https://github.com/winsw/winsw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;winSW&lt;/a&gt;，&lt;br /&gt;
下載回來的程式，改名成&lt;code&gt;nginx-server.exe&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一層目錄下，建立nginx-server.xml&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- nginx-service.xml --&amp;gt;
&amp;lt;service&amp;gt;
    &amp;lt;id&amp;gt;nginx&amp;lt;/id&amp;gt;
    &amp;lt;name&amp;gt;nginx&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;nginx&amp;lt;/description&amp;gt;
    &amp;lt;logpath&amp;gt;C:&#92;nginx-1.26.1&#92;server-logs&#92;&amp;lt;/logpath&amp;gt;
    &amp;lt;logmode&amp;gt;roll&amp;lt;/logmode&amp;gt;
    &amp;lt;depend&amp;gt;&amp;lt;/depend&amp;gt;
    &amp;lt;executable&amp;gt;C:&#92;nginx-1.26.1&#92;nginx.exe&amp;lt;/executable&amp;gt;
    &amp;lt;stopexecutable&amp;gt;C:&#92;nginx-1.26.1&#92;nginx.exe -s stop&amp;lt;/stopexecutable&amp;gt;
&amp;lt;/service&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;安裝&lt;br /&gt;
command執行 &lt;code&gt;nginx-server.exe install&lt;/code&gt;&lt;br /&gt;
如果要刪除則是 &lt;code&gt;nginx-server.exe uninstall&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;除錯&quot; tabindex=&quot;-1&quot;&gt;除錯&lt;/h3&gt;
&lt;p&gt;nginx.conf如果寫錯，導致服務無法啟動時，&lt;br /&gt;
可到上面的&lt;code&gt;&amp;lt;logpaht&amp;gt;&lt;/code&gt;位置查看錯誤訊息，&lt;br /&gt;
照上面的範例，是&lt;code&gt;C:&#92;nginx-1.26.1&#92;server-logs&#92;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;以上是最簡單的用法。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/winsw/winsw&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;github文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://book.king011.com/view/en-US/view/ms-os-tools/WinSW&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;WinSW&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/220. windows將程式變成服務的好東西-winSW/" />
        </entry>
        <entry>
            <title>
                219. Google Cloud Managed Service for Prometheus  費用
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/219. Google Cloud Managed Service for Prometheus  費用/</id>
            <content type="html">
                &lt;h1 id=&quot;緣由&quot; tabindex=&quot;-1&quot;&gt;緣由&lt;/h1&gt;
&lt;p&gt;由於GKE預設惠啟用 Google Cloud Managed Service for Prometheus，&lt;br /&gt;
來比較一下，看之後是不是能夠一個網站看到全部的圖表。&lt;br /&gt;
不過也要先看下價格，如果太貴，那也只能分開了。&lt;/p&gt;
&lt;h1 id=&quot;主題&quot; tabindex=&quot;-1&quot;&gt;主題&lt;/h1&gt;
&lt;h3 id=&quot;2024-06-07&quot; tabindex=&quot;-1&quot;&gt;2024/06/07&lt;/h3&gt;
&lt;p&gt;價格&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$0.06/百萬個&lt;a href=&quot;https://cloud.google.com/stackdriver/pricing?hl=zh-cn#metrics-charged-by-samples&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;樣本&lt;/a&gt;†：注入的前 0-50 億個樣本†&lt;/li&gt;
&lt;li&gt;$0.048/百萬樣本：接下來的 50-2500 億個樣本&lt;/li&gt;
&lt;li&gt;$0.036/百萬樣本：接下來注入的 250-5,000 億個樣本&lt;/li&gt;
&lt;li&gt;注入的每百萬個樣本 $0.024：超過 5000 億個樣本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這數字以百萬計。&lt;/p&gt;
&lt;p&gt;一下子真的不知道該怎麼算，&lt;br /&gt;
那就先算出 每10秒一個metric，那一個月會有多少資料。&lt;br /&gt;
ans: 259,200筆。所以一個月 $0.06USD&lt;/p&gt;
&lt;p&gt;加減算一下50億個樣本，要多少錢。&lt;br /&gt;
ans: $300 USD&lt;/p&gt;
&lt;p&gt;現在來算一下，一般建pvc要多少，&lt;br /&gt;
建立一個PVC，預設使用 Balanced persistent disk。&lt;br /&gt;
pvc通常掛個100G，每個月約$10 USD。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Price (monthly in USD)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Standard provisioned space&lt;/td&gt;
&lt;td&gt;$0.04 per GiB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SSD provisioned space&lt;/td&gt;
&lt;td&gt;$0.17 per GiB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Balanced provisioned space&lt;/td&gt;
&lt;td&gt;$0.1 per GiB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h1&gt;
&lt;p&gt;這價格看起來還頗有吸引力的，來試試看吧。&lt;/p&gt;
&lt;p&gt;日後如果要從帳單看有多少筆資料的話，&lt;/p&gt;
&lt;p&gt;Service -&amp;gt; &lt;strong&gt;Cloud Monitoring&lt;/strong&gt;&lt;br /&gt;
SKUs -&amp;gt; Prometheus Samples Ingested &amp;amp;  Monitoring API Requests&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/stackdriver/pricing?hl=zh-cn#mgd-prometheus-pricing-summary&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Cloud Monitoring 價格摘要&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/stackdriver/docs/managed-prometheus/cost-controls?hl=zh-cn&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;費用控制和歸因&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/compute/disks-image-pricing#disk&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;硬碟價格&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/219. Google Cloud Managed Service for Prometheus  費用/" />
        </entry>
        <entry>
            <title>
                218. Go GUI套件 fyne筆記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/218. Go GUI套件 fyne筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;緣由&quot; tabindex=&quot;-1&quot;&gt;緣由&lt;/h1&gt;
&lt;p&gt;因為Line的貼圖太多了，&lt;br /&gt;
關鍵字跑出來的貼圖，常常又不是自己想要的。&lt;br /&gt;
所以我就想要搞像MSN那樣的自訂關鍵字，&lt;br /&gt;
至少能夠比較快找到我要的貼圖。&lt;/p&gt;
&lt;h1 id=&quot;主題&quot; tabindex=&quot;-1&quot;&gt;主題&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Demo&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;go install fyne.io/fyne/v2/cmd/fyne_demo@latest
fyne_demo
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;基本觀念&lt;br /&gt;
參考  &lt;a href=&quot;https://www.cnblogs.com/yjf512/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;軒脈刃de刀光劍影&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主視窗&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;func main() {
	myApp := app.New()
	myWindow := myApp.NewWindow(&amp;quot;Line Sticker Alias&amp;quot;)
	// 設定視窗的初始大小
	myWindow.Resize(fyne.NewSize(800, 600))
	// 設定視窗的內容
	myWindow.SetContent(CreateUI(myWindow))
	// 顯示視窗
	myWindow.ShowAndRun()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;傳入型態&lt;br /&gt;
傳入建議使用 &lt;code&gt;fyne.Window&lt;/code&gt;，因很多UI行為需要的都是window。&lt;br /&gt;
如果要開新視窗的話，可以採用下面的程式&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;func ShowAliasWindow(filePath string, parent fyne.Window) {
	w := fyne.CurrentApp().NewWindow(&amp;quot;新增別名&amp;quot;)
	....
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;常用選項，按鈕(紅色)、文字方塊(紫色)、圖片(綠色)&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/218-fig.1.png&quot; alt=&quot;218-fig.1.png&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;// 延遲200ms，啟動按鈕（看起來比較流暢）
aliasButton := widget.NewButton(alias, func() {
  time.AfterFunc(200*time.Millisecond, func() {
    ShowAliasWindow(fulPath, parent)
  })
})

// 文字框
textbox := widget.NewEntry()
textbox.SetPlaceHolder(&amp;quot;Enter Keyword...&amp;quot;)

// 圖片
img := canvas.NewImageFromFile(fulPath)
img.FillMode = canvas.ImageFillOriginal

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;物件合併&lt;br /&gt;
V：vertical&lt;br /&gt;
H：horizontal&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;// 上面 4. 的 aliasButton 跟 img 合併在一起
images = append(images, container.NewVBox(img, aliasButton))
// 將圖片按鈕物件，切成三個一行
grid := container.NewGridWithColumns(3, images...)

//塞入window，顯示。w 為 上面 3 的宣告
w.SetContent(container.NewVScroll(grid))
w.Resize(fyne.NewSize(400, 400))
w.Show()
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;dialog&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;
// w 為 fyne.window

// 錯誤對話方塊
err := deleteAlias(stickerId)
if err != nil {
  dialog.NewError(err, w).Show()
  return // 錯誤發生後，直接返回，停止繼續執行下面的程式碼
}
//訊息對話方塊
dialog.NewInformation(&amp;quot;提示&amp;quot;, &amp;quot;新增完成！&amp;quot;, w).Show()

//開啟資料夾對話方塊
dialog.NewFolderOpen(func(folder fyne.ListableURI, err error) {
  if err != nil {
    dialog.ShowError(err, w)
    return
  }
  if folder == nil {
    return // 使用者按取消
  }
  inputFolder.SetText(folder.Path())
}, w).Show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/yjf512/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;軒脈刃de刀光劍影&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://go-circle.cn/fyne-press/v1.0/1-getting-started/introduction.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Fyne開發文件(中)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.fyne.io/started/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Fyne官網文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/fyne-io/fyne&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Fyne Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/218. Go GUI套件 fyne筆記/" />
        </entry>
        <entry>
            <title>
                217. iptables 筆記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/217. iptables 筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;緣由&quot; tabindex=&quot;-1&quot;&gt;緣由&lt;/h1&gt;
&lt;p&gt;istio重新複習概念的時候，&lt;br /&gt;
又碰到了iptable，然後，我又忘了。&lt;br /&gt;
沒有用自己理解過的作法，&lt;br /&gt;
果然很容易忘記啊。&lt;/p&gt;
&lt;h1 id=&quot;主題&quot; tabindex=&quot;-1&quot;&gt;主題&lt;/h1&gt;
&lt;p&gt;iptables簡單說是個管高速公路大門的。&lt;/p&gt;
&lt;p&gt;基本有三條路(chain)，&lt;br /&gt;
分別是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;filter：這條路會直接到管高速公路大門的管理單位大樓裡面。&lt;/li&gt;
&lt;li&gt;nat：要去這條高速公路的其他地方，就往這邊。&lt;/li&gt;
&lt;li&gt;mangle：特權道路，有高官要過時，就走這條。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;鳥哥的說明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;filter (過濾器)：主要跟進入 Linux 本機的封包有關，這個是預設的 table 喔！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;INPUT：主要與想要進入我們 Linux 本機的封包有關；&lt;/li&gt;
&lt;li&gt;OUTPUT：主要與我們 Linux 本機所要送出的封包有關；&lt;/li&gt;
&lt;li&gt;FORWARD：這個咚咚與 Linux 本機比較沒有關係， 他可以『轉遞封包』到後端的電腦中，與下列 nat table 相關性較高。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nat (位址轉換)：是 Network Address Translation 的縮寫， 這個表格主要在進行來源與目的之 IP 或 port 的轉換，與 Linux 本機較無關，主要與 Linux 主機後的區域網路內電腦較有相關。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PREROUTING：在進行路由判斷之前所要進行的規則(DNAT/REDIRECT)&lt;/li&gt;
&lt;li&gt;POSTROUTING：在進行路由判斷之後所要進行的規則(SNAT/MASQUERADE)&lt;/li&gt;
&lt;li&gt;OUTPUT：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;mangle (破壞者)：這個表格主要是與特殊的封包的路由旗標有關， 早期僅有 PREROUTING 及 OUTPUT 鏈，不過從 kernel 2.4.18 之後加入了 INPUT 及 FORWARD 鏈。 由於這個表格與特殊旗標相關性較高，所以像咱們這種單純的環境當中，較少使用 mangle 這個表格。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://linux.vbird.org/linux_server/centos6/0250simple_firewall.php#netfilter&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;iptables 的表格 (table) 與鏈 (chain)&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;每個chain裡面都有自己rule，&lt;br /&gt;
rule 1 是去彰化，&lt;br /&gt;
rule 2 是去員林，&lt;br /&gt;
rule 3是去嘉義。&lt;/p&gt;
&lt;p&gt;從台中南下要去彰化的話，rule 1 符合就直接去彰化了。&lt;br /&gt;
但如果是要去嘉義，前面不符合，就跳過，直到rule 3判斷符合才會執行。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://jimmysong.io/blog/sidecar-injection-iptables-and-traffic-routing/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Istio 中的 Sidecar 注入、透明流量劫持及流量路由過程詳解&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/217. iptables 筆記/" />
        </entry>
        <entry>
            <title>
                216. GKE掛載ReadWrite Many的PVC
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/216. GKE掛載ReadWrite Many的PVC/</id>
            <content type="html">
                &lt;h1 id=&quot;緣由&quot; tabindex=&quot;-1&quot;&gt;緣由&lt;/h1&gt;
&lt;p&gt;GKE上面的pvc是不支援ReadWrite Many的。&lt;br /&gt;
用途是全部的Log寫到同一個資料夾，&lt;br /&gt;
然後再用filebeat擷取到EFK。&lt;/p&gt;
&lt;h1 id=&quot;主題&quot; tabindex=&quot;-1&quot;&gt;主題&lt;/h1&gt;
&lt;p&gt;這邊要做的是自建一個NFS server。&lt;/p&gt;
&lt;p&gt;deploy裡面，也可以直接在GCE上面建立一個硬碟，&lt;br /&gt;
然後在deploy上面指定。就是下面這段，&lt;br /&gt;
這原本是前任的方式，我直接改掉了。&lt;br /&gt;
直接在一個yaml裡面全部弄好。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcePersistentDisk:
    pdName: gke-log-nfs-disk
    fsType: ext4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NFS-server.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;---
apiVersion: v1
kind: Namespace
metadata:
  name: nfs
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: nfs-pvc
  namespace: nfs
spec:
  storageClassName: &amp;quot;standard&amp;quot;
  resources:
    requests:
      storage: 100Gi
  accessModes:
    - ReadWriteOnce
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nfs-server
  namespace: nfs
spec:
  replicas: 1
  selector:
    matchLabels:
      role: nfs-server
  template:
    metadata:
      labels:
        role: nfs-server
    spec:
      containers:
      - name: nfs-server
        image: gcr.io/google_containers/volume-nfs:0.8
        ports:
          - name: nfs
            containerPort: 2049
          - name: mountd
            containerPort: 20048
          - name: rpcbind
            containerPort: 111
        securityContext:
          privileged: true
        volumeMounts:
          - mountPath: /exports
            name: nfs-pvc
      volumes:
      - name: nfs-pvc
        persistentVolumeClaim:
          claimName: nfs-pvc
        # gcePersistentDisk:
        #     pdName: gke-log-nfs-disk
        #     fsType: ext4
---
apiVersion: v1
kind: Service
metadata:
  name: nfs-server
  namespace: nfs
spec:
  ports:
    - name: nfs
      port: 2049
    - name: mountd
      port: 20048
    - name: rpcbind
      port: 111
  selector:
    role: nfs-server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再來是掛載一個provisioner&lt;/p&gt;
&lt;p&gt;nfs-provisioner.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: nfs-client-provisioner
  namespace: nfs
  labels:
    app: nfs-client-provisioner  
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nfs-client-provisioner
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: nfs-client-provisioner
    spec:
      serviceAccountName: nfs-client-provisioner
      containers:
        - name: nfs-client-provisioner
          image: gcr.io/k8s-staging-sig-storage/nfs-subdir-external-provisioner:v4.0.2
          # image: registry.k8s.io/sig-storage/nfs-subdir-external-provisioner:v4.0.2
          volumeMounts:
            - name: nfs-client-root
              mountPath: /persistentvolumes
          env:
            - name: PROVISIONER_NAME
              value: nfs-log
            - name: NFS_SERVER
              value: nfs-server.nfs.svc.cluster.local
            - name: NFS_PATH
              value: /
      volumes:
        - name: nfs-client-root
          nfs:
            server: nfs-server.nfs.svc.cluster.local
            path: /
---
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: nfs-log
provisioner: nfs-log
parameters:
  archiveOnDelete: &amp;quot;false&amp;quot;

---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: nfs-client-provisioner-runner
rules:
  - apiGroups: [&amp;quot;&amp;quot;]
    resources: [&amp;quot;nodes&amp;quot;]
    verbs: [&amp;quot;get&amp;quot;, &amp;quot;list&amp;quot;, &amp;quot;watch&amp;quot;]
  - apiGroups: [&amp;quot;&amp;quot;]
    resources: [&amp;quot;persistentvolumes&amp;quot;]
    verbs: [&amp;quot;get&amp;quot;, &amp;quot;list&amp;quot;, &amp;quot;watch&amp;quot;, &amp;quot;create&amp;quot;, &amp;quot;delete&amp;quot;]
  - apiGroups: [&amp;quot;&amp;quot;]
    resources: [&amp;quot;persistentvolumeclaims&amp;quot;]
    verbs: [&amp;quot;get&amp;quot;, &amp;quot;list&amp;quot;, &amp;quot;watch&amp;quot;, &amp;quot;update&amp;quot;]
  - apiGroups: [&amp;quot;storage.k8s.io&amp;quot;]
    resources: [&amp;quot;storageclasses&amp;quot;]
    verbs: [&amp;quot;get&amp;quot;, &amp;quot;list&amp;quot;, &amp;quot;watch&amp;quot;]
  - apiGroups: [&amp;quot;&amp;quot;]
    resources: [&amp;quot;events&amp;quot;]
    verbs: [&amp;quot;create&amp;quot;, &amp;quot;update&amp;quot;, &amp;quot;patch&amp;quot;]
---
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: run-nfs-client-provisioner
subjects:
  - kind: ServiceAccount
    name: nfs-client-provisioner
    namespace: nfs
roleRef:
  kind: ClusterRole
  name: nfs-client-provisioner-runner
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: nfs-client-provisioner
  namespace: nfs
---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: leader-locking-nfs-client-provisioner
  namespace: nfs
rules:
  - apiGroups: [&amp;quot;&amp;quot;]
    resources: [&amp;quot;endpoints&amp;quot;]
    verbs: [&amp;quot;get&amp;quot;, &amp;quot;list&amp;quot;, &amp;quot;watch&amp;quot;, &amp;quot;create&amp;quot;, &amp;quot;update&amp;quot;, &amp;quot;patch&amp;quot;]
---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: leader-locking-nfs-client-provisioner
  namespace: nfs
subjects:
  - kind: ServiceAccount
    name: nfs-client-provisioner
roleRef:
  kind: Role
  name: leader-locking-nfs-client-provisioner
  apiGroup: rbac.authorization.k8s.io
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要使用的話，&lt;br /&gt;
建立一個pvc, storageClassName改成上面建立的storageClass&lt;br /&gt;
其他deploy掛載方式，跟掛pvc一樣。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: logs-nfs-pvc
  namespace: default
spec:
  accessModes:
    - ReadWriteMany
  storageClassName: nfs-log
  resources:
    requests:
      storage: 100Gi

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/%E8%BC%95%E9%AC%86%E5%B0%8F%E5%93%81-pks%E8%88%87k8s%E7%9A%84%E9%BB%9E%E6%BB%B4/%E5%9C%A8gke%E4%B8%8A%E4%BD%BF%E7%94%A8readwrite-many%E7%9A%84disk-9945ff67a4d&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;在GKE上使用ReadWrite Many的Disk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;nfs-subdir-external-provisioner&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/216. GKE掛載ReadWrite Many的PVC/" />
        </entry>
        <entry>
            <title>
                214. Elastic API建立 Index_template
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/214. Elastic API建立 Index_template/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;幫同事測試不同LOG的刪除時間，&lt;br /&gt;
每次要去點一點又怕忘記，&lt;br /&gt;
弄個API了，&lt;br /&gt;
不知道之後能不能在部屬時直接掛上去，再研究看看。&lt;br /&gt;
這次就先簡單建立個 index template跟life cycle了&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;filebeat-elastic-efk-57-filebeat-57-filebeat&quot; tabindex=&quot;-1&quot;&gt;首先要先確定你的filebeat有將資料丟到elastic裡面，可參考&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%97%92%20EFK/57.filebeat%20%E8%A3%9C%E5%85%85%E8%AA%AA%E6%98%8E/&quot;&gt;57.filebeat 補充說明&lt;/a&gt;。&lt;/h3&gt;
&lt;p&gt;再來根據你建的是indices還是datastream，來決定你的index_template。&lt;br /&gt;
下面的指令，都在dev tools中執行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;API後面的最後一個路徑為名稱&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;indices&quot; tabindex=&quot;-1&quot;&gt;indices&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;API建立 Index Lifecycle Policies&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;PUT _ilm/policy/worker
{
  &amp;quot;policy&amp;quot;: {
    &amp;quot;_meta&amp;quot;: {
      &amp;quot;description&amp;quot;: &amp;quot;used for worker log&amp;quot;,
      &amp;quot;author&amp;quot;: &amp;quot;Ezio&amp;quot;,
      &amp;quot;project&amp;quot;: {
        &amp;quot;name&amp;quot;: &amp;quot;srs&amp;quot;,
        &amp;quot;department&amp;quot;: &amp;quot;lerouge&amp;quot;
      }
    },
    &amp;quot;phases&amp;quot;: {
      &amp;quot;hot&amp;quot;: {
        &amp;quot;min_age&amp;quot;: &amp;quot;0ms&amp;quot;,
        &amp;quot;actions&amp;quot;: {
          &amp;quot;set_priority&amp;quot;: {
            &amp;quot;priority&amp;quot;: 100
          },
          &amp;quot;rollover&amp;quot;: {
            &amp;quot;max_age&amp;quot;: &amp;quot;3d&amp;quot;,
            &amp;quot;max_primary_shard_size&amp;quot;: &amp;quot;50gb&amp;quot;
          }
        }
      },
      &amp;quot;delete&amp;quot;: {
        &amp;quot;min_age&amp;quot;: &amp;quot;3d&amp;quot;,
        &amp;quot;actions&amp;quot;: {
          &amp;quot;delete&amp;quot;: {
            &amp;quot;delete_searchable_snapshot&amp;quot;: true
          }
        }
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;建立 index_template&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;PUT _index_template/worker
{
  &amp;quot;index_patterns&amp;quot; : [&amp;quot;worker-*&amp;quot;],
  &amp;quot;template&amp;quot;: {
    &amp;quot;settings&amp;quot;: {
      &amp;quot;index&amp;quot;: {
        &amp;quot;lifecycle&amp;quot;: {
          &amp;quot;name&amp;quot;: &amp;quot;videoworker&amp;quot;
        }
      }
    }
  },
  &amp;quot;composed_of&amp;quot;: [&amp;quot;ecs@mappings&amp;quot;, &amp;quot;logs@mappings&amp;quot;,&amp;quot;logs@settings&amp;quot;],
  &amp;quot;priority&amp;quot; : 200,
  &amp;quot;version&amp;quot;: 1,
  &amp;quot;_meta&amp;quot;: {
    &amp;quot;description&amp;quot;: &amp;quot;test by Ezio&amp;quot;,
    &amp;quot;latest_modify_date&amp;quot;: &amp;quot;2024-05-28&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;檢查  Index Lifecycle Policies 及 index template&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;GET _ilm/policy/worker  #  Index Lifecycle Policies
GET _index_template/worker # index template
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-put-lifecycle.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Create or update lifecycle policy API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/index-templates.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Index templates&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;data-stream&quot; tabindex=&quot;-1&quot;&gt;data stream&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;建立 index template&lt;br /&gt;
與上面的差異點在於，有沒有增加&lt;code&gt;data_stream&lt;/code&gt;與 &lt;code&gt;template.lifecycle.data_retention&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;PUT _index_template/videowork
{
  &amp;quot;index_patterns&amp;quot; : [&amp;quot;videoworker-*&amp;quot;],
  &amp;quot;template&amp;quot;: {
    &amp;quot;lifecycle&amp;quot;: {
      &amp;quot;data_retention&amp;quot;: &amp;quot;3d&amp;quot;
    }
  },
  &amp;quot;data_stream&amp;quot;: { },
  &amp;quot;composed_of&amp;quot;: [&amp;quot;ecs@mappings&amp;quot;, &amp;quot;logs@mappings&amp;quot;,&amp;quot;logs@settings&amp;quot;],
  &amp;quot;priority&amp;quot; : 200,
  &amp;quot;version&amp;quot;: 1,
  &amp;quot;_meta&amp;quot;: {
    &amp;quot;description&amp;quot;: &amp;quot;test by Ezio&amp;quot;,
    &amp;quot;latest_modify_date&amp;quot;: &amp;quot;2024-05-28&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/tutorial-manage-new-data-stream.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Create a data stream with a lifecycle&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;indices-vs-data-stream&quot; tabindex=&quot;-1&quot;&gt;indices vs data stream&lt;/h3&gt;
&lt;p&gt;下面資料是用gpt-4o提供的&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;Indices&lt;/th&gt;
&lt;th&gt;Data Streams&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;管理方式&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;手動管理或使用 ILM&lt;/td&gt;
&lt;td&gt;自動管理滾動和索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;數據存儲&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;適合任意結構數據&lt;/td&gt;
&lt;td&gt;專為時間序列數據設計&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;對應組態&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;每個索引獨立組態&lt;/td&gt;
&lt;td&gt;透過索引範本自動組態&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;滾動策略&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;需手動或 ILM 組態&lt;/td&gt;
&lt;td&gt;自動滾動&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;查詢性能&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;基於標準索引&lt;/td&gt;
&lt;td&gt;優化時間序列數據查詢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;索引創建&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;使用 &lt;code&gt;PUT /index_name&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;透過索引範本自動創建&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;適用數據&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;任意數據，包括非時間序列數據&lt;/td&gt;
&lt;td&gt;主要為日誌、指標等時間序列數據&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;學習曲線&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;需要學習和管理索引的細節&lt;/td&gt;
&lt;td&gt;簡化，特別適合大規模時間序列數據&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;生命週期管理&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;需要組態 ILM&lt;/td&gt;
&lt;td&gt;自動管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;存儲效率&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;依賴手動優化&lt;/td&gt;
&lt;td&gt;為時間序列數據設計，具備存儲效率&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;優缺點&quot; tabindex=&quot;-1&quot;&gt;優缺點&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;項目&lt;/th&gt;
&lt;th&gt;Indices&lt;/th&gt;
&lt;th&gt;Data Streams&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;優點&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- 更靈活，可用於任意類型數據&lt;/td&gt;
&lt;td&gt;- 自動管理滾動和索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;- 完全自定義對應和設置&lt;/td&gt;
&lt;td&gt;- 簡化組態和管理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;- 支援複雜的查詢和聚合&lt;/td&gt;
&lt;td&gt;- 優化時間序列數據查詢和存儲&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;- 適合大規模日誌和指標數據&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;缺點&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;- 需手動管理索引和滾動策略&lt;/td&gt;
&lt;td&gt;- 主要針對時間序列數據&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;- 組態和管理相對複雜&lt;/td&gt;
&lt;td&gt;- 不適合非時間序列數據&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;- 需要組態和維護 ILM&lt;/td&gt;
&lt;td&gt;- 對應和設置相對不靈活&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;推薦使用場景&quot; tabindex=&quot;-1&quot;&gt;推薦使用場景&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;使用場景&lt;/th&gt;
&lt;th&gt;Indices&lt;/th&gt;
&lt;th&gt;Data Streams&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;日誌管理&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;可以使用，但需要手動組態滾動和管理&lt;/td&gt;
&lt;td&gt;最佳選擇，自動管理，簡化運維&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;應用監控&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;可以使用，但需自定義索引和對應&lt;/td&gt;
&lt;td&gt;最佳選擇，專為時間序列數據設計&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;定期報表&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;適合任何類型報表&lt;/td&gt;
&lt;td&gt;適合時間序列報表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;歷史數據查詢&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;最佳選擇，可針對具體需求優化查詢&lt;/td&gt;
&lt;td&gt;適合基於時間範圍的歷史數據查詢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;複雜數據分析&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;最佳選擇，支援靈活的對應和查詢&lt;/td&gt;
&lt;td&gt;適合時間序列數據的快速查詢和聚合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;非時間序列數據存儲&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;最佳選擇，適合所有類型數據&lt;/td&gt;
&lt;td&gt;不推薦，僅適合時間序列數據&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h3&gt;
&lt;p&gt;其實從API來看的話，直接用data stream比較快，也比較省事。&lt;br /&gt;
加上目前用的是ECK，&lt;br /&gt;
我根本沒去設計 warm phase 或 cold phase的硬碟。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://training.onedoggo.com/tech-sharing/uncle-joe-teach-es-elasticsearch/index-jian-li-qian-ni-gai-zhi-dao-de/es-de-chao-qian-bu-shu-index-template&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ES 的超前佈署 - Index Template&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/214. Elastic API建立 Index_template/" />
        </entry>
        <entry>
            <title>
                212. k8s的親和性與反親和性
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/212. k8s的親和性與反親和性/</id>
            <content type="html">
                &lt;h1 id=&quot;緣由&quot; tabindex=&quot;-1&quot;&gt;緣由&lt;/h1&gt;
&lt;p&gt;後端的服務，沒有HPA，所以目前都單Pod在執行。&lt;br /&gt;
但很不巧的，都在同一個Node裡面。&lt;br /&gt;
所以當一個Node出問題時，其他服務會一起陣亡。&lt;br /&gt;
但只有一個NodePool，也沒辦法用nodeSelector。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;GKE版本：1.27&lt;/p&gt;
&lt;p&gt;先上範例，詳細說明在下面(格式有點跑掉，複製使用時要注意）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: bms
  labels:
    group: svc
    app: backend
spec:
  replicas: 1
  selector:
    matchLabels:
      group: svc
      app: backend
  template:
    metadata:
      labels:
        group: svc
        app: backend
    spec:
      containers:
        - name: service
          image: my-image:v1.0.6
          ports:
            - name: http
              containerPort: 80
              protocol: TCP
      affinity:
        podAntiAffinity:
			preferredDuringSchedulingIgnoredDuringExecution:
	        - weight: 100
		        podAffinityTerm:
	              labelSelector:
	                matchExpressions:
	                - key: app
	                  operator: In
	                  values:
	                  - gcp
	              topologyKey: kubernetes.io/hostname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這個的用途，主要是讓pod決定要跟哪個服務在一起，或不在一起。&lt;/p&gt;
&lt;p&gt;其中比較重要的參數，&lt;/p&gt;
&lt;h3 id=&quot;反親和性與親和性&quot; tabindex=&quot;-1&quot;&gt;反親和性與親和性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;podAntiAffinity&lt;/li&gt;
&lt;li&gt;podAffinity&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前者是反親和性，不要跟哪個服務在一起&lt;br /&gt;
後者是親和性，要跟哪個服務在一起&lt;/p&gt;
&lt;h3 id=&quot;必要與最好可以&quot; tabindex=&quot;-1&quot;&gt;必要與最好可以&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;requiredDuringSchedulingIgnoredDuringExecution&lt;/li&gt;
&lt;li&gt;preferredDuringSchedulingIgnoredDuringExecution&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前者是一定要達成下面的條件，&lt;br /&gt;
後者是最好是達成這樣的條件，並設成比重分數&lt;/p&gt;
&lt;h3 id=&quot;選擇條件&quot; tabindex=&quot;-1&quot;&gt;選擇條件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;requiredDuringSchedulingIgnoredDuringExecution:
- labelSelector:
    matchExpressions:
    - key: app
      operator: In
      values:
      - gcp
  topologyKey: kubernetes.io/hostname  
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;preferredDuringSchedulingIgnoredDuringExecution:
- weight: 100
  podAffinityTerm:
    labelSelector:
      matchExpressions:
      - key: app
        operator: In
        values:
        - gcp
    topologyKey: kubernetes.io/hostname
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大致上的邏輯一樣，&lt;br /&gt;
&lt;code&gt;但preferredDuringSchedulingIgnoredDuringExecution&lt;/code&gt; ，&lt;br /&gt;
必須加上&lt;code&gt;podAffinityTerm&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;簡單說明規則，&lt;br /&gt;
選擇這個服務要跟哪個label當比較值。&lt;br /&gt;
然後，&lt;code&gt;topologyKey&lt;/code&gt; 有點類似SQL group的概念，你要根據哪個來分群。&lt;/p&gt;
&lt;p&gt;上面的例子是根據 node name來區分，&lt;br /&gt;
還有根據區域 &lt;code&gt;kind.zone&lt;/code&gt; 來分。&lt;/p&gt;
&lt;p&gt;如果想知道有哪些的話，可以下指令看一下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl get nodes --show-labels
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面是簡單的寫法，&lt;br /&gt;
詳細過程可以參考 矽谷牛大大的文章，連結在下方。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hwchiu.com/docs/2023/k8s-assigning-pod-2&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;矽谷牛-解密 Assigning Pod To Nodes(下)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#operators&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;K8s文件-將 Pod 指派給節點&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://godleon.github.io/blog/Kubernetes/k8s-Assigning-Pod-to-Nodes/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Kubernetes] Assigning Pods to Nodes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/212. k8s的親和性與反親和性/" />
        </entry>
        <entry>
            <title>
                211. k8s service與 endpoint無法連結
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/211. k8s service與 endpoint無法連結/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;某天在建立新的叢集，&lt;br /&gt;
服務都已經架好準備給RD了，&lt;br /&gt;
最後才發現，平常用的連線方式連不到GCP的Memorystore.Redis。&lt;br /&gt;
這個問題卡了整整一週，&lt;br /&gt;
不斷的刪除重建、比對、找差異。&lt;/p&gt;
&lt;h1 id=&quot;故事展開&quot; tabindex=&quot;-1&quot;&gt;故事展開&lt;/h1&gt;
&lt;p&gt;GKE 版本： 1.28.7-gke.1026000&lt;/p&gt;
&lt;p&gt;先簡單說一下架構，&lt;br /&gt;
istio增加6379 的port ，&lt;br /&gt;
新增redis的svc以及endpoint，&lt;br /&gt;
由於redis是GCP的服務，故本身沒有pod，&lt;br /&gt;
讓istio能夠透過virtusalService連到這個service，&lt;br /&gt;
然後RD透過這個ip以及port連到 GCP的Redis。&lt;/p&gt;
&lt;p&gt;先來看錯誤的使用方式，&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/211-fig.1.jpg&quot; alt=&quot;211-fig.1.jpg&quot; /&gt;&lt;br /&gt;
在port name上面設定redis的名稱，&lt;br /&gt;
導致svc的endpoints上面無法綁定。&lt;/p&gt;
&lt;p&gt;不設定port name的話&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/211-fig.2.jpg&quot; alt=&quot;211-fig.2.jpg&quot; /&gt;&lt;br /&gt;
則可以正常綁定。&lt;/p&gt;
&lt;p&gt;目前猜測，可能跟 IANA的port name有關係。&lt;br /&gt;
但為什麼會這樣，&lt;br /&gt;
就不清楚了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;# Service Name and Transport Protocol Port Number Registry&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前測試出來，只要有設定Name就會綁不到endpoints。&lt;/p&gt;
&lt;h4 id=&quot;endpoint-slice-2024-05-20&quot; tabindex=&quot;-1&quot;&gt;另外，EndpointSlice目前(2024/05/20)仍會無法綁定，&lt;/h4&gt;
&lt;p&gt;請先改用Endpoint的api。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/211-fig.3.jpg&quot; alt=&quot;211-fig.3.jpg&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: discovery.k8s.io/v1
kind: EndpointSlice
metadata:
  name: redis # must be the same as service name
  namespace: istio-system
  labels:
    # You should set the &amp;quot;kubernetes.io/service-name&amp;quot; label.
    # Set its value to match the name of the Service
    kubernetes.io/service-name: redis
addressType: IPv4
ports:
  - name: redis # should match with the name of the service port defined above
    appProtocol: redis
    protocol: TCP
    port: 6379
endpoints:
  - addresses:
      - &amp;quot;10.1.11.43&amp;quot;

---
apiVersion: v1
kind: Service
metadata:
  name: redis
  namespace: istio-system
spec:
  ports:
    - protocol: TCP
      port: 6379
      targetPort: 6379
      name: redis    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;參照官方文件的作法也不會綁定。&lt;br /&gt;
&lt;a href=&quot;https://kubernetes.io/docs/concepts/services-networking/service/#services-without-selectors&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Services without selectors&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2024/05/8&lt;/p&gt;
&lt;p&gt;有另一個工程師告知，&lt;br /&gt;
endpoint那邊的Port Name也加上去的話，&lt;br /&gt;
就好了。&lt;/p&gt;
&lt;h1 id=&quot;結論&quot; tabindex=&quot;-1&quot;&gt;結論&lt;/h1&gt;
&lt;p&gt;頂多改改 Endpoints的address就好了，&lt;br /&gt;
port name那些，別亂加。&lt;br /&gt;
要加就要一起加，且名稱也要一樣。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
apiVersion: v1
kind: Endpoints
metadata:
  name: redis # must be the same as service name
  namespace: istio-system
subsets:
  - addresses:
      - ip: 10.122.11.43
    ports:
      - port: 6379
	    name: redis
---
apiVersion: v1
kind: Service
metadata:
  name: redis
  namespace: istio-system
spec:
  ports:
    - protocol: TCP
      port: 6379
      targetPort: 6379
      name: redis
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/211. k8s service與 endpoint無法連結/" />
        </entry>
        <entry>
            <title>
                210. Arc Browser筆記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/210. Arc Browser筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近看到一個頗神的瀏覽器，&lt;a href=&quot;https://arc.net/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Arc from The Browser Company&lt;/a&gt;&lt;br /&gt;
最近剛出了win11版本，mac則要12版本以上才能使用。&lt;br /&gt;
我的mac是2015年的可以安裝。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;可以先看一下這個&lt;a href=&quot;https://www.youtube.com/watch?v=nlNsCB4SbVc&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Arc 真香！腦洞大開的功能讓超多 Chrome 死忠粉決定把 Arc 當作預設瀏覽器了！&lt;/a&gt;  裡面有簡單的教學。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要注意的是，現在的版本已經把內建Note砍掉了，&lt;br /&gt;
如果要使用只能用線上的。&lt;/p&gt;
&lt;p&gt;打開 Preferences &amp;gt; Profiles &amp;gt; New documents&lt;br /&gt;
選擇你要設定的線上服務&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/210-fig.1.png&quot; alt=&quot;210-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;瀏覽器設定檔&lt;br /&gt;
ARC 本身也是用chrome的核心去做的，&lt;br /&gt;
所以除了Arc本身的設定以外，還有chromium的設定。&lt;br /&gt;
進去的方式 Preferences &amp;gt; Profiles  &amp;gt; Search Settings..&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/210-fig.2.png&quot; alt=&quot;210-fig.2.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/210-fig.3.png&quot; alt=&quot;210-fig.3.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/210-fig.4.png&quot; alt=&quot;210-fig.4.png&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前會常用到的快速鍵&lt;br /&gt;
⌘+S：開關左邊的SideBar&lt;br /&gt;
⌘+T：開啟新分頁&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，開啟的分頁預設只會維持12hour，&lt;br /&gt;
更改可到 圖1 的&lt;code&gt;Archive tabs after&lt;/code&gt;修改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;⌘＋⌥(options)＋G：快速開啟chatGPT&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Archive的歷史紀錄&lt;br /&gt;
在sidebar 往左滑即可。&lt;br /&gt;
或直接點選&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/210-fig.5.png&quot; alt=&quot;210-fig.5.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/210. Arc Browser筆記/" />
        </entry>
        <entry>
            <title>
                209. k8s中srs的各個pod  metrics取得
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/209. k8s中srs的各個pod  metrics取得/</id>
            <content type="html">
                &lt;h1 id=&quot;事由&quot; tabindex=&quot;-1&quot;&gt;事由&lt;/h1&gt;
&lt;p&gt;同事正在弄SRS串流，照我以前的寫法，&lt;br /&gt;
是透過service去取得單一個pod的metrics，&lt;br /&gt;
這樣只會有一個pod的資料，&lt;br /&gt;
所以要想辦法取得所有pod的資料。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;由於我有套用istio，&lt;br /&gt;
於是有套istio-proxy的pod通通會預設塞&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;prometheus.io/path: /stats/prometheus
prometheus.io/port: &#39;15020&#39;
prometheus.io/scrape: &#39;true&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以直接在deploy加參數進去時，也會被改寫。&lt;/p&gt;
&lt;p&gt;於是只好額外寫job 如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- job_name: &#39;srs&#39;
  scrape_interval: 10s
  static_configs:
    - targets:
      - &#39;srs.default.svc.cluster.local:9972&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;呼叫 service 的 srs ，然後去取得metrics的metrics。&lt;br /&gt;
但當有多個pod的時候，這就會出問題了。&lt;br /&gt;
因為service到pod的流量平均分配，你不會知道他連去哪個pod。&lt;br /&gt;
但今天我要抓全部metrics，這種寫法就會出問題。&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;static_configs&lt;/code&gt; 這個只適用於 固定字串，&lt;br /&gt;
所以對於會變來變去的pod ip沒有用。&lt;/p&gt;
&lt;p&gt;於是要改成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- job_name: &#39;srs&#39;
  scrape_interval: 10s
  kubernetes_sd_configs:
    - role: pod  
  relabel_configs:
    - source_labels: [__meta_kubernetes_pod_name]
      action: keep
      regex: srs-.*
    - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
      action: replace
      target_label: __metrics_path__
      replacement: /metrics   # 強制指定路徑為 /metrics
    - source_labels: [__meta_kubernetes_pod_container_port_name]
      action: replace
      target_label: portname
      replacement: 9972 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;規則由上往下依序執行，有符合才會往下。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kubernetes_sd_configs&lt;/code&gt; 有這5種方式(GPT抄來的)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;role: endpoints：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;這個組態項告訴 Prometheus 去發現 Kubernetes 中的端點對象。端點對象代表了服務的後端 Pod 的 IP 地址和連接埠。&lt;/li&gt;
&lt;li&gt;通過此組態項，Prometheus 可以直接與後端 Pod 進行通訊，收集指標資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;role: service：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;這個組態項告訴 Prometheus 去發現 Kubernetes 中的服務對象。&lt;/li&gt;
&lt;li&gt;Prometheus 將會為每個服務發現服務的所有後端 Pod，並從每個 Pod 中抓取指標資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;role: pod：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;這個組態項告訴 Prometheus 去發現 Kubernetes 中的 Pod 對象。&lt;/li&gt;
&lt;li&gt;Prometheus 將會為每個發現的 Pod 收集指標資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;role: ingress：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;這個組態項告訴 Prometheus 去發現 Kubernetes 中的 Ingress 對象。&lt;/li&gt;
&lt;li&gt;Prometheus 將會監視 Ingress 對象，並收集與之相關的指標資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;role: node：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;這個組態項告訴 Prometheus 去發現 Kubernetes 中的節點對象。&lt;/li&gt;
&lt;li&gt;Prometheus 將會為每個節點收集相關的指標資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;再來是重點 &lt;code&gt;relabel_configs&lt;/code&gt;&lt;br /&gt;
分別有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;source_labels：來源標籤，可以參考prometheus的UI，上面有顯示很多label&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/209-fig.1.png&quot; alt=&quot;209-fig.1.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;action：四種動作（keep,drop,replace,labelmap）。&lt;br /&gt;
決定你要將值保留、終止、取代或標籤對應&lt;/li&gt;
&lt;li&gt;target_label：目的標籤，&lt;br /&gt;
抓資料的url，由下面三種特殊標籤組成&lt;code&gt;__scheme__&lt;/code&gt; + &lt;code&gt;__address__&lt;/code&gt; + &lt;code&gt;__metrics_path__&lt;/code&gt;。&lt;br /&gt;
範例： &lt;code&gt;https://192.168.103.224:9527/metrics&lt;/code&gt;&lt;br /&gt;
主要是決定特殊標籤要用什麼，不然隨便取名都可以。&lt;/li&gt;
&lt;li&gt;regex，當作是條件判斷這裡面的值要符合規則能往下。&lt;br /&gt;
下面regex意思是，pod name要符合&lt;code&gt;srs-.*&lt;/code&gt;的才保留。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;    - source_labels: [__meta_kubernetes_pod_name]
      action: keep
      regex: srs-.*
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;replacement：變更的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ossrs.io/lts/zh-cn/docs/v5/doc/exporter&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;SRS-Prometheus Exporter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://p8s.io/docs/service-discovery/relabel/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Relabeling 重新標記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://godleon.github.io/blog/Prometheus/Prometheus-Relabel/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt; [Prometheus] Service Discovery &amp;amp; Relabel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/209. k8s中srs的各個pod  metrics取得/" />
        </entry>
        <entry>
            <title>
                208. 架設 sftp
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/208. 架設 sftp/</id>
            <content type="html">
                &lt;h1 id=&quot;事由&quot; tabindex=&quot;-1&quot;&gt;事由&lt;/h1&gt;
&lt;p&gt;需要一個地方放大量的資料，日後提供給客戶下載，&lt;br /&gt;
本來想說用GCS就好，但如果要一次下載好幾個檔案就沒辦法了。&lt;br /&gt;
只好乖乖弄FTP。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;一開始用vsftp，搞個docker 大概沒10分鐘就好了。&lt;br /&gt;
有一半的時間在找image上面，&lt;br /&gt;
但如果要達成『一個使用者，可以看到所有使用者的目錄，其他使用者需要獨立』就懵了。&lt;/p&gt;
&lt;p&gt;後續找資料時，看到鳥哥說了一句話，『所以，建議您，除非必要，否則的話，使用 SSH 提供的 sftp-server 功能即可』&lt;br /&gt;
ref. &lt;a href=&quot;https://linux.vbird.org/linux_server/redhat9/0400wuftp.php&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;FTP 的安全性問題與替代方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以我就轉往sftp了。&lt;/p&gt;
&lt;p&gt;先來釐清目標，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一個最高權限的帳號，&lt;br /&gt;
可以在所有使用者的目錄新增檔案，&lt;br /&gt;
然後所有使用者間是不能互相看到彼此的檔案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;docker image 使用 &lt;a href=&quot;https://hub.docker.com/r/corilus/sftp&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;corilus/sftp&lt;/a&gt;，&lt;br /&gt;
下載量已達1M。&lt;/p&gt;
&lt;p&gt;如果只是簡單的ftp功能，直接架起來就好了。&lt;/p&gt;
&lt;p&gt;但要做成上面的目標，要用mount的方式，將資料夾掛載到主目錄底下。&lt;br /&gt;
詳細作法參考下面。&lt;/p&gt;
&lt;p&gt;docker-compose.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version: &#39;3&#39;
services:
  sftp:
    container_name: sftp
    image: corilus/sftp
    privileged: true
    volumes:
        - ./mount.sh:/etc/sftp.d/bindmount.sh
        - ./userlist.conf:/etc/sftp/users.conf:ro
        - ./upload:/home
    ports:
        - &amp;quot;2222:22&amp;quot;
    restart: always
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指令說明，可參考 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%90%A7%20Linux/108.%20linux%20shell%20%E9%80%B2%E9%9A%8E%E6%8C%87%E4%BB%A4/#bdeaee&quot;&gt;108. linux shell 進階指令#^bdeaee&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mount.sh/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;mount.sh&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# File mounted as: /etc/sftp.d/bindmount.sh
# Just an example (make your own)

function bindmount() {
    if [[ !  -d &amp;quot;$1&amp;quot; ]]; then
        mkdir -p &amp;quot;$1&amp;quot;
    fi

    if [[ ! -d &amp;quot;$2&amp;quot; ]]; then
	     mkdir -p &amp;quot;$2&amp;quot;
    fi

    chown -R :100 &amp;quot;$1&amp;quot; &amp;quot;$2&amp;quot;
    chmod 775 &amp;quot;$1&amp;quot; &amp;quot;$2&amp;quot;
    mount --bind &amp;quot;$1&amp;quot; &amp;quot;$2&amp;quot;
}

# Remember permissions, you may have to fix them:
# chown -R :users /data/common
bindmount &amp;quot;/home/mike/upload&amp;quot; &amp;quot;/home/ms/mike&amp;quot;
bindmount &amp;quot;/home/aaron/upload&amp;quot; &amp;quot;/home/ms/aaron&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;userlist.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ms:ms:1001:100
mike:mike:1002:100
aaron:aaron:1003:100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本來想用ln的方式去操作，&lt;br /&gt;
從terminal 能夠進去資料夾，但用FTP登入就是說 &lt;code&gt;no such file or dirctory&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;問了老半天GPT也都是失敗，&lt;br /&gt;
從一開始說要加個不存在的參數 FollowSymlinks ，&lt;br /&gt;
到後面的一連串重複回答。&lt;/p&gt;
&lt;p&gt;最後看到 &lt;a href=&quot;https://serverfault.com/questions/448647/symbolic-link-and-filezilla-over-sftp&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Symbolic link and filezilla over sftp&lt;/a&gt;&lt;br /&gt;
看來是ln的先天限制，所以改用mount後，調個權限，好了。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Corilus/sftp&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Corilus/sftp Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/208. 架設 sftp/" />
        </entry>
        <entry>
            <title>
                207. mapgenie整批unfound
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/207. mapgenie整批unfound/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;前陣子玩遊戲時發現一個網站，&lt;a href=&quot;http://mapgenie.io/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;mapgenie.io&lt;/a&gt;&lt;br /&gt;
裡面有很多遊戲的地圖，&lt;br /&gt;
按下found以後，不想一個一個把勾拿掉。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;有餘力的話，應該是買VIP會員才對，&lt;br /&gt;
但我覺得我用不到那麼多功能，&lt;br /&gt;
可能這個功能也是VIP專用。&lt;/p&gt;
&lt;p&gt;畢竟花錢就是要省時間，不想花錢又想省時間的話，&lt;br /&gt;
洗洗睡吧。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;打開網頁的開發者工具，&lt;br /&gt;
找到 &lt;code&gt;body &amp;gt; div#app&lt;/code&gt;&lt;br /&gt;
底下的scripts，會長的像這樣&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/207-fig.1.png&quot; alt=&quot;207-fig.1.png&quot; /&gt;&lt;br /&gt;
最上面有一些數字，那些數字就是我們要的。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;選擇網路頁籤&lt;br /&gt;
再來將一個found關掉，會看到底下的Fetch/XHR，新增一筆。&lt;br /&gt;
點選後，注意看箭頭是不是寫DELETE&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/207-fig.2.png&quot; alt=&quot;207-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;複製成CURL&lt;br /&gt;
對著剛剛的58673按右鍵，選擇複製成CURL&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/207-fig.3.png&quot; alt=&quot;207-fig.3.png&quot; /&gt;&lt;br /&gt;
然後找個記事本貼上，你會發現一長串的東西。&lt;br /&gt;
我測試過，可以把 &lt;code&gt;-H &#39;cookie:&#39;&lt;/code&gt; 整段拿掉，&lt;br /&gt;
其他東西應該就不好刪了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/207-fig.4.png&quot; alt=&quot;207-fig.4.png&quot; /&gt;&lt;br /&gt;
再來就是更換最上面的數字，就不用一個一個點標誌，然後把勾拿掉了。&lt;br /&gt;
上面的圖片，我只節錄了三行，完整的不只這樣。&lt;br /&gt;
然後將curl丟去 命令提是字元執行就好了。&lt;/p&gt;
&lt;p&gt;更懶一點，弄個for迴圈，把數字自動帶進去網址。&lt;br /&gt;
可以參考 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%98%81%EF%B8%8E%20GCP/135.%20gsutil%E6%95%B4%E6%89%B9%E8%A4%87%E8%A3%BD/&quot;&gt;135. gsutil整批複製&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;還有另一種就是去找newman去搞自動化帶入參數應該也能做到。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/207. mapgenie整批unfound/" />
        </entry>
        <entry>
            <title>
                206. steamDeck 的 Cheat Engine替代品
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/206. steamDeck 的 Cheat Engine替代品/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;春特入手了幾款 跟弟弟一起玩的遊戲，&lt;/p&gt;
&lt;p&gt;但有些時候重複刷的有點煩，&lt;/p&gt;
&lt;p&gt;就想說改一下省點時間，&lt;/p&gt;
&lt;p&gt;查了一些資訊，發現CheatEngine不是不能裝，&lt;/p&gt;
&lt;p&gt;但有夠&lt;strong&gt;麻煩&lt;/strong&gt;！！！！！&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;鎮重聲明，修改有一定風險。&quot; tabindex=&quot;-1&quot;&gt;鎮重聲明，修改有一定風險。&lt;/h3&gt;
&lt;h4 id=&quot;c-c-memory-deck&quot; tabindex=&quot;-1&quot;&gt;感謝巴友C.C告知另一套軟體『memory deck』&lt;/h4&gt;
&lt;p&gt;直接在Decky loader 搜尋，安裝即可。&lt;br /&gt;
搜尋方式也很簡單，直接按掌機右下的 &lt;code&gt;...&lt;/code&gt; 就能搜尋。&lt;br /&gt;
缺點是每次要改就要重新搜尋一次。&lt;/p&gt;
&lt;p&gt;最後在&lt;a href=&quot;https://ref.gamer.com.tw/redir.php?url=https%3A%2F%2Fwww.reddit.com%2Fr%2FSteamDeck%2Fcomments%2F10dslcm%2Fcheat_engine_or_some_equivalent_on_steam_deck%2F&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;reddit&lt;/a&gt;找到了 &lt;a href=&quot;https://ref.gamer.com.tw/redir.php?url=https%3A%2F%2Fgithub.com%2Fprimetime00%2Fmemory_hack&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;memory_hack&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這款的好處在於，steam deck(桌面模式)開啟遊戲後，&lt;/p&gt;
&lt;p&gt;用手機或電腦在同一個wifi底下，開啟網頁即可修改。&lt;/p&gt;
&lt;p&gt;安裝方式也很簡單，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;建立一個資料夾，要放安裝檔&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;python3 &amp;lt;(wget -qO- https://github.com/primetime00/memory_hack/raw/master/app/patches/install.py)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;安裝完後，會問你要不要當成預設程式，我是選n ，當有需要時再到剛剛的資料夾啟動就好。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;啟動指令，到該資料夾底下執行   &lt;code&gt;./run.sh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ref.gamer.com.tw/redir.php?url=https%3A%2F%2Fgithub.com%2Fprimetime00%2Fmemory_hack%3Ftab%3Dreadme-ov-file%23steam-deck&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;安裝說明連結&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然後就可以先在steam deck上面開網頁，&lt;a href=&quot;http://localhost:5000/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;http://localhost:5000&lt;/a&gt; 看有沒有資料。&lt;/p&gt;
&lt;p&gt;如果要用手機或電腦連的話，&lt;/p&gt;
&lt;p&gt;可以另外開啟konsole ，執行 &lt;code&gt;ip -4 addr&lt;/code&gt;  就會看到你的ip，假設是192.168.0.125，&lt;/p&gt;
&lt;p&gt;在手機上開啟 &lt;a href=&quot;http://192.168.0.125:5000/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;http://192.168.0.125:5000&lt;/a&gt; ，就會看到畫面了。&lt;/p&gt;
&lt;p&gt;簡易操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;到 Search 的頁籤上，選擇 Process的 遊戲名稱&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;輸入數值查詢，通常要兩次查詢，第一次有很多資料，當數值變動時，再搜尋一次，就會有了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;複製記憶體位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到 Code的頁籤，選擇 Process的遊戲名稱&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;輸入數值，旁邊的方格，打勾表示鎖定數值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;p.s 改完後，數值可能不會馬上重現，讓遊戲的數值變動一下。&lt;/p&gt;
&lt;p&gt;完整操作說明，請參考 &lt;a href=&quot;https://ref.gamer.com.tw/redir.php?url=https%3A%2F%2Fgithub.com%2Fprimetime00%2Fmemory_hack%2Fblob%2Fmaster%2Fdocs%2Ftutorial%2FTUTORIAL.md&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Memory Hack Beginner Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前有人介紹另一款，&lt;br /&gt;
Memory Deck ，直接在掌機模式下的Decky loader 商店搜尋，&lt;br /&gt;
裝起來就好了。&lt;/p&gt;

            </content>
            <link href="https://daimom.github.io/206. steamDeck 的 Cheat Engine替代品/" />
        </entry>
        <entry>
            <title>
                205. Grafana 筆記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/205. Grafana 筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前文&quot; tabindex=&quot;-1&quot;&gt;前文&lt;/h1&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;單位換算&quot; tabindex=&quot;-1&quot;&gt;單位換算&lt;/h3&gt;
&lt;p&gt;byte(IEC)：以1024轉換計算。2MB = 2042 kb&lt;br /&gt;
byte(SI) ： 以十進位計算。 2MB= 2000kb&lt;/p&gt;
&lt;h3 id=&quot;更換線條顏色&quot; tabindex=&quot;-1&quot;&gt;更換線條顏色&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;先把Legend  打開&lt;/li&gt;
&lt;li&gt;點選Legend的顏色&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/205-fig.1.png&quot; alt=&quot;205-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;隱藏&quot; tabindex=&quot;-1&quot;&gt;隱藏&lt;/h3&gt;
&lt;p&gt;Overrides裡面的選項，有時會被打勾，導致線圖不會出現&lt;/p&gt;
&lt;h3 id=&quot;匯出&quot; tabindex=&quot;-1&quot;&gt;匯出&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;點選標題的右邊分享按鈕&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/205-fig.2.png&quot; alt=&quot;205-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;選擇Export ，再來看要存檔或檢視Json&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/205-fig.3.png&quot; alt=&quot;205-fig.3.png&quot; /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.github.io/205. Grafana 筆記/" />
        </entry>
        <entry>
            <title>
                203. istio Authorization 拒絕指定檔案瀏覽
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/203. istio Authorization 拒絕指定檔案瀏覽/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;接到個需求，要限定網站的某個副檔名不能被瀏覽。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;Authorization-policy的yaml&lt;/p&gt;
&lt;p&gt;Rule規則分成三大塊&lt;/p&gt;
&lt;p&gt;From&lt;br /&gt;
請求來源&lt;br /&gt;
To&lt;br /&gt;
請求目的&lt;br /&gt;
When&lt;br /&gt;
指定的請求附加條件&lt;/p&gt;
&lt;h3 id=&quot;to&quot; tabindex=&quot;-1&quot;&gt;To&lt;/h3&gt;
&lt;p&gt;nginx查一下，是有類似的東西。&lt;br /&gt;
但istio我看了官方文件，&lt;br /&gt;
寫法是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- to:
  - operation:
      paths: [&amp;quot;/user/profile/*&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;目前只有支援單個 &lt;code&gt;*&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exact match: &lt;code&gt;abc&lt;/code&gt; will match on value &lt;code&gt;abc&lt;/code&gt;.&lt;br /&gt;
完全匹配： &lt;code&gt;abc&lt;/code&gt; 將匹配值 &lt;code&gt;abc&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;Prefix match: &lt;code&gt;abc*&lt;/code&gt; will match on value &lt;code&gt;abc&lt;/code&gt; and &lt;code&gt;abcd&lt;/code&gt;.&lt;br /&gt;
前綴匹配： &lt;code&gt;abc*&lt;/code&gt; 將匹配值 &lt;code&gt;abc&lt;/code&gt; 和 &lt;code&gt;abcd&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;Suffix match: &lt;code&gt;*abc&lt;/code&gt; will match on value &lt;code&gt;abc&lt;/code&gt; and &lt;code&gt;xabc&lt;/code&gt;.&lt;br /&gt;
後綴匹配： &lt;code&gt;*abc&lt;/code&gt; 將匹配值 &lt;code&gt;abc&lt;/code&gt; 和 &lt;code&gt;xabc&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;Presence match: &lt;code&gt;*&lt;/code&gt; will match when value is not empty.&lt;br /&gt;
存在匹配：當值不為空時， &lt;code&gt;*&lt;/code&gt; 將匹配。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;現在的目標是要阻擋 index-erscvs.js.map ，禁止任何人觀看。&lt;br /&gt;
但 index-erscvs.js 不能被deny&lt;/p&gt;
&lt;p&gt;於是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kind: AuthorizationPolicy
metadata:
  name: frontend-map-policy
spec:
  selector:
    matchLabels:
      group: frontend
  action: DENY
  rules:
    - to:
      - operation:
          hosts: [&amp;quot;abc.def.com&amp;quot;]
          ports: [&amp;quot;80&amp;quot;]
          paths: [&amp;quot;*.js.map&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;優先順序評估表 &lt;code&gt;Custom &amp;gt; Deny &amp;gt; Allow&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://istio.io/latest/docs/reference/config/security/authorization-policy&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Authorization Policy&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;when&quot; tabindex=&quot;-1&quot;&gt;When&lt;/h3&gt;
&lt;h5 id=&quot;values-cidr&quot; tabindex=&quot;-1&quot;&gt;注意，values不支援CIDR，需用* 代替私有網段&lt;/h5&gt;
&lt;p&gt;這邊沿用 &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%E2%9B%B5%EF%B8%8F%20istio/186.%20istio%E7%9A%84Authorization%20policy(%E7%99%BD%E5%90%8D%E5%96%AE)/&quot;&gt;186. istio的Authorization policy(白名單)&lt;/a&gt; 的方式，&lt;br /&gt;
設定白名單。&lt;/p&gt;
&lt;p&gt;於是，下面的設定方式，label 是 group=frontend的deploy，&lt;br /&gt;
不允許訪問&lt;code&gt;*.js.map&lt;/code&gt;的檔案，除了來源是 &lt;code&gt;123.123.123.123&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: frontend-map-policy
spec:
  selector:
    matchLabels:
      group: frontend
  action: DENY
  rules:
    - to:
      - operation:
          hosts: [&amp;quot;abc.def.com&amp;quot;]
          ports: [&amp;quot;80&amp;quot;]
          paths: [&amp;quot;*.js.map&amp;quot;]
      when:      
      - key: request.headers[X-Envoy-External-Address]
        notValues:
          - &amp;quot;123.123.123.123&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;驗證時，可以用下面的指令協助查詢，&lt;br /&gt;
要注意是不是被其他的policy影響了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 先開啟debug模式，資訊比較多，查完後將deploy重啟即可
istioctl proxy-config log deploy/httpbin --level &amp;quot;rbac:debug&amp;quot; | grep rbac

for i in {1..20}; do curl -H &#39;Cache-Control: no-cache, no-store&#39; https://abc.def.com/assets/index-d74bceac.js -s -o /dev/null -w &amp;quot;%{http_code}&#92;n&amp;quot;; done

kubectl logs &amp;lt;pod name&amp;gt; -c istio-proxy
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;注意&quot; tabindex=&quot;-1&quot;&gt;注意&lt;/h2&gt;
&lt;p&gt;when 跟 to 如果用 下面方式的話，表示是兩條規則&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
	- to:
		...
	- when:
		...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這樣才是同一條規則，&lt;br /&gt;
我犯了這個蠢錯誤&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	- to:
		...
	  when:
		...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://istio.io/latest/docs/reference/config/security/authorization-policy&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Authorization Policy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://istio.io/latest/docs/reference/config/security/conditions/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Authorization Policy Conditions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/hxpjava1/article/details/117330067&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;authorizationPolicy詳解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/203. istio Authorization 拒絕指定檔案瀏覽/" />
        </entry>
        <entry>
            <title>
                202. GCP多帳號切換
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/202. GCP多帳號切換/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近適逢專案搬家時期，帳號要切來切去，&lt;br /&gt;
結果一切過去就不能用了。&lt;br /&gt;
錯誤寫，你的B帳號無法在A專案使用。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;OS是 MacOS，window會不會有相同錯誤不清楚&lt;/p&gt;
&lt;p&gt;試了幾次，切換GCP帳號的指令都沒用，&lt;br /&gt;
最後摸出一套可行的步驟&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先確定目前使用的gcp帳號是哪一個，* 代表使用中的帳號&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;gcloud auth list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/202-fig.1.png&quot; alt=&quot;202-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然後確認config設定有沒有錯&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud config list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果帳號或project有錯誤，就修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 修改帳號
gcloud config set account abc@abc.com
# 修改project
gcloud config set project project_id
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;確認要使用專案的context設定&lt;br /&gt;
指令&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;# 取得所有cluster設定
kubectl config get-contexts
# 切換要使用的cluster
kubectl config use-context [NAME]
# 檢查目前使用中的cluster
kubectl config current-context
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Docker 切換&lt;br /&gt;
選擇環境後滑鼠點一下&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/202-fig.2.png&quot; alt=&quot;202-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;完成後，重開 Terminal&lt;br /&gt;
一定要重開！！！！不然會像鬼打牆一樣，一直跳錯誤。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/202-fig.3.png&quot; alt=&quot;202-fig.3.png&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;差點都想直接用 &lt;code&gt;gcloud auth revoke &amp;lt;account&amp;gt;&lt;/code&gt; 把帳號強制登出了。&lt;/p&gt;
&lt;h4 id=&quot;2024-04-11&quot; tabindex=&quot;-1&quot;&gt;2024/04/11&lt;/h4&gt;
&lt;p&gt;要切帳號時，terraform又掛了，一直提示我用另一個帳號。&lt;br /&gt;
但用kubectl 指令時，都正常。&lt;/p&gt;
&lt;p&gt;後來執行這行，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud auth application-default login
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重新登入後正常。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.kmp.tw/post/gcloudchangeaccountandproject/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[GCP]gcloud切換帳號、專案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/sdk/gcloud/reference/auth&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;gcloud auth&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/202. GCP多帳號切換/" />
        </entry>
        <entry>
            <title>
                201. kustomize patch
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/201. kustomize patch/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;懶癌發作，要部署新環境時，&lt;br /&gt;
想到每個deployment要一個一個改，就好懶。&lt;br /&gt;
該換擬出來了 kustomize，&lt;br /&gt;
kubectl 現在預設就有支援，以前還要單獨裝指令。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;查看kustomize的結果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl kustomize ./
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;執行方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kubectl apply -k &amp;lt;folder path&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;修改映像檔&quot; tabindex=&quot;-1&quot;&gt;修改映像檔&lt;/h4&gt;
&lt;p&gt;要注意得點是， deployment.yaml 的image裏面的映像檔名稱，&lt;br /&gt;
要對應到kustomize.yaml 的 &lt;a href=&quot;http://images.name/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;images.name&lt;/a&gt;。&lt;br /&gt;
以下面的範例來說， my-image:1.2.3  其中my-image就是映像檔名稱，&lt;br /&gt;
所以在kustomize.yaml裏面的image name要寫 my-image&lt;/p&gt;
&lt;p&gt;deployment.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  template:
    spec:
      containers:
      - name: my-container
        image: my-image:1.2.3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;kustomize.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;resources:
- ../../../base
images:
- name: my-image
  newName: my.image.registry/nginx
  newTag: 1.4.0

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/201-fig.1.png&quot; alt=&quot;201-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;修改其他欄位&quot; tabindex=&quot;-1&quot;&gt;修改其他欄位&lt;/h4&gt;
&lt;p&gt;除了一般能修改的東西，能用 cross-cutting field 修改以外，&lt;br /&gt;
其他要修改只能透過patch的方式。&lt;br /&gt;
其中 patchesJson6902跟 patchesStrategicMerge，&lt;br /&gt;
目前已經被patches取代，也將於後續版本deprecated.&lt;/p&gt;
&lt;p&gt;且 patches能夠在 name以及namespace上使用regex。&lt;/p&gt;
&lt;p&gt;ref.  &lt;a href=&quot;https://stackoverflow.com/questions/63604579/what-is-the-difference-between-patches-vs-patchesjson6902-in-kustomize&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;What is the difference between patches vs patchesJson6902 in Kustomize&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;cross-cutting 基本有這些&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/201-fig.1.png&quot; alt=&quot;201-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果上面有用到 cross-cutting 的參數，下面的原始檔，&lt;br /&gt;
只要寫原始的就好，不用寫修改過的參數。&lt;br /&gt;
例如 namespace 在原始的deployment.yaml是default，&lt;br /&gt;
然後在 kustomize.yaml 裏面 修改成 game，&lt;br /&gt;
那Patches還是寫原本的default。&lt;/p&gt;
&lt;p&gt;Patches底下的patch，只要有以下資訊即可，&lt;br /&gt;
然後就是要修改的設定了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: systemmanageservice
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面範例是，修改container底下的env變數。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;patches:
- target:
    kind: Deployment
    name: systemmanageservice
  patch: |-
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: systemmanageservice
    spec:
      template:
        spec:
          containers:
          - name: systemmanageservice
            env:
            - name: ASPNETCORE_ENVIRONMENT
              value: QA
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/tasks/manage-kubernetes-objects/kustomization/#kustomize-feature-list&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Kustomize 功能特性列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubectl.docs.kubernetes.io/zh/api-reference/kustomization/patches/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;patches&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;patches-json6902&quot; tabindex=&quot;-1&quot;&gt;patchesJson6902&lt;/h2&gt;
&lt;p&gt;上面有提到patches是  patchesJson6902 與&lt;br /&gt;
patchesStrategicMerge的結合。&lt;/p&gt;
&lt;p&gt;於是 patches也支援下面這種用法。&lt;br /&gt;
使用 op 來作新增或取代。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

patchesJson6902:
- target:
    version: v1
    kind: Deployment
    name: my-deployment
  patch: |-
    - op: add
      path: /some/new/path
      value: value
    - op: replace
      path: /some/existing/path
      value: &amp;quot;new value&amp;quot;    
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://daimom.github.io/201. kustomize patch/" />
        </entry>
        <entry>
            <title>
                200. Net core SDK安裝至container
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/200. Net core SDK安裝至container/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;後端之前發了一個版本上去後，&lt;br /&gt;
記憶體就一路往上飆，&lt;br /&gt;
他們也查不出個所以，&lt;br /&gt;
後來幫他們查，有請他們加個程式碼試試，看來也成功了。&lt;br /&gt;
但為了以後，還是知道一下要怎麼抓記憶體的用量比較好，&lt;br /&gt;
就交給他去看了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;PropertyGroup&amp;gt; 
    &amp;lt;ServerGarbageCollection&amp;gt;false&amp;lt;/ServerGarbageCollection&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://www.zendei.com/article/38158.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;【譯】Asp.net core應用在 Kubernetes上記憶體使用率過高問題分析&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;以下為同事執行的指令，&lt;br /&gt;
可能需要先安裝wget之類的東西。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;裝 dotnet SDK&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;wget https://dot.net/v1/dotnet-install.sh -O dotnet-install.sh
chmod +x ./dotnet-install.sh
./dotnet-install.sh --version latest
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;執行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;裝完後，最好先用 &lt;code&gt;find / -iname dotnet&lt;/code&gt; ，&lt;br /&gt;
查一下安裝後的dotnet在哪。&lt;br /&gt;
執行的時候，記得用 &lt;code&gt;./dotnet --version&lt;/code&gt; ，的方式執行。&lt;br /&gt;
不然，預設是用&lt;code&gt;/usr/bin&lt;/code&gt; 裏面的dotnet執行的。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;
&lt;p&gt;除錯&lt;/p&gt;
&lt;p&gt;沒研究，但同事是參考下面這篇去實作。&lt;br /&gt;
參考連結 &lt;a href=&quot;https://developer.samsung.com/tizen/blog/en/2020/07/31/identifying-memory-leaks-with-dotnet-dump-and-dotnet-gcdump&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Identifying Memory Leaks with dotnet-dump and dotnet-gcdump&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.microsoft.com/zh-tw/dotnet/core/install/linux-scripted-manual#scripted-install&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;已編寫指令碼的安裝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.samsung.com/tizen/blog/en/2020/07/31/identifying-memory-leaks-with-dotnet-dump-and-dotnet-gcdump&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Identifying Memory Leaks with dotnet-dump and dotnet-gcdump&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://daimom.github.io/200. Net core SDK安裝至container/" />
        </entry>
        <entry>
            <title>
                193. Obsidian發佈到github.io個人網站
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/193. Obsidian發佈到github.io個人網站/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;前陣子弄好了Obsidian自動發佈到&lt;a href=&quot;https://daimom.vercel.app/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;vercel&lt;/a&gt;，&lt;br /&gt;
成果也還不錯，但就是偶爾有點問題，&lt;br /&gt;
因為是免費用戶，所以會碰到無法更新。&lt;br /&gt;
有天一怒之下，就自己改成用github了。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;首先前面還是一樣&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%86%92%20SideProject/160.Obsidian%E7%99%BC%E4%BD%88%E7%B6%B2%E7%AB%99/&quot;&gt;160.Obsidian發佈網站&lt;/a&gt;，&lt;br /&gt;
步驟要先設定好從Obsidiant傳到你的github。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/193-fig.1.png&quot; alt=&quot;193-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;當你在Obsidian選擇publish時，會將內容傳到public_vercel 這個repository。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/193-fig.2.jpg&quot; alt=&quot;193-fig.2.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;所以，接下來的流程是，在public_vercel 使用github action，&lt;br /&gt;
將obsidian的內容編譯成html，再轉到github的網站上面。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;到github建立個人網頁&lt;br /&gt;
到github，建立一個自己使用者的子網域，&lt;br /&gt;
repository的名稱會是 &lt;code&gt;user.github.io&lt;/code&gt; 這種名稱，&lt;br /&gt;
只有&lt;code&gt;user&lt;/code&gt;這個字可以改。&lt;br /&gt;
建立完後，可以先弄個index.html到github裏面，&lt;br /&gt;
然後訪問剛剛建立的網址，&lt;br /&gt;
我建立的名稱為&lt;code&gt;daimom.github.io&lt;/code&gt;&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/193-fig.3.jpg&quot; alt=&quot;193-fig.3.jpg&quot; /&gt;&lt;br /&gt;
所以網址就是 &lt;a href=&quot;https://daimom.github.io/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;daimom.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;github_page&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;將npm轉成pnpm&lt;br /&gt;
其實這一步也可以不做，&lt;br /&gt;
那就是寫github action的時候，不能用pnpm只能用npm，&lt;br /&gt;
程式應該也要小改一下，&lt;br /&gt;
但pnpm會比較快，我就順便改一改了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;到 public_vercel的資料夾底下，執行下面三行，參考&lt;a href=&quot;https://booop.net/migrate-from-npm-to-pnpm/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;從 npm 遷移到 pnpm&lt;/a&gt;，&lt;br /&gt;
有些步驟我測試是不需要，&lt;br /&gt;
重點是 &lt;code&gt;pnpm import&lt;/code&gt;，要將&lt;code&gt;package-lock.json&lt;/code&gt; 轉成 &lt;code&gt;pnpm-lock.yaml&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 刪除npm package
rm -rf node_modules 
# 安裝pnpm
npm install -g pnpm
# 轉換相關檔案
pnpm import
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;完成後，上傳到github。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;建立github action&lt;br /&gt;
資料夾結構如下&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/193-fig.4.jpg&quot; alt=&quot;193-fig.4.jpg&quot; /&gt;&lt;br /&gt;
能改檔案名稱的只有&lt;code&gt;build-site.yaml&lt;/code&gt;以及 &lt;code&gt;install-pnpm&lt;/code&gt;，&lt;br /&gt;
但後者要改的話，程式內容也需要改，不熟的話不建議更改。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;build-site.yaml的程式如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;name: &#39;Build Sites&#39;

on:
  workflow_dispatch:
    inputs:
      deployment-version:
        description: 指定版本
        required: false
  schedule:
    - cron: &#39;0 10 * * *&#39;
jobs:
  build-site-test:
    runs-on: ubuntu-latest
    steps:
      # [Checkout]
      - name: Checkout code repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # [執行腳本] 構建 pnpm 及 Node 環境
      - name: &#39;[Macro] Prepare environment&#39;
        uses: ./.github/actions/install-pnpm

      # [執行腳本] 構建html
      - name: &#39;[Macro] Build sites &#39;
        shell: bash
        run: pnpm build

      - name: Push to HTML Repository
        run: |
          git config --global user.email $
          git config --global user.name &amp;quot;daimom&amp;quot;
          git config --list
          git clone https://$@github.com/daimom/daimom.github.io.git temp-html-repo
          cp -r dist/. temp-html-repo/
          
          cd temp-html-repo
          git add .
          git commit -m &amp;quot;Update from Build Repository&amp;quot;
          git remote -v
          git push origin main

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;install-pnpm/action.yaml的程式如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;name: &#39;prepare&#39;
description: &#39;Prepare environment&#39;

runs:
  using: &#39;composite&#39;
  steps:
    - name: Setup pnpm
      uses: pnpm/action-setup@v2
      with:
        version: 8
    - name: Setup node.js
      uses: actions/setup-node@v4
      with:
        node-version: 20
        cache: &#39;pnpm&#39;

    - name: Install dependencies
      shell: bash
      run: pnpm install

&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&quot;簡易說明&quot; tabindex=&quot;-1&quot;&gt;簡易說明&lt;/h5&gt;
&lt;p&gt;這邊的設定是每天的UTC 10:00 執行一次，&lt;br /&gt;
如果要自定時間的話，可以參考&lt;a href=&quot;https://crontab.informaship.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Crontab 中文線上 編輯器&lt;/a&gt;&lt;br /&gt;
測試的時候可以先把&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  schedule:
    - cron: &#39;0 10 * * *&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push:
  branches:
	- &#39;main&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這樣只要推上去main就會觸發動作了(注意排版)。&lt;/p&gt;
&lt;p&gt;ref. &lt;a href=&quot;https://gugod.org/2021/02/run-twitter-bot-with-github-actions/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;以 GitHub Action 來發推文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或者是直接手動部署，&lt;br /&gt;
在public_vercel的github action選擇你的Action ，再選 Run workflow&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/193-fig.6.jpg&quot; alt=&quot;193-fig.6.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;程式裏面的 &lt;code&gt;$ &lt;/code&gt; 是要到repository裏面設定。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/193-fig.5.jpg&quot; alt=&quot;193-fig.5.jpg&quot; /&gt;&lt;br /&gt;
也可以直接輸入你的email，反正email這東西應該已經...。&lt;br /&gt;
但重點是底下的 &lt;code&gt;$&lt;/code&gt; ，&lt;br /&gt;
這個一定要用secret隱藏，而且不能外流。&lt;br /&gt;
產生的方式，詳閱， &lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%86%92%20SideProject/160.Obsidian%E7%99%BC%E4%BD%88%E7%B6%B2%E7%AB%99/#github-token&quot;&gt;160.Obsidian發佈網站#建立github token&lt;/a&gt;&lt;br /&gt;
再來將產生的token，新增到sercret裏面。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.github.com/zh/actions&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;GitHub Actions 文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&quot;internal-link&quot; data-note-icon=&quot;&quot; href=&quot;https://daimom.github.io/%F0%9F%92%BB%20Code/110.github%20action%20pipeline%E7%AD%86%E8%A8%98/&quot;&gt;110.github action pipeline筆記&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/193. Obsidian發佈到github.io個人網站/" />
        </entry>
        <entry>
            <title>
                191. Steam deck安裝除錯記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/191. Steam deck安裝除錯記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;好久沒買聖誕禮物了，&lt;br /&gt;
前陣子又有人說steam deck oled很推，&lt;br /&gt;
看了幾次都沒現貨，&lt;br /&gt;
上週五，剛好喵到pchome有貨，下訂隔天到。&lt;br /&gt;
禮拜六吃喜酒，又逛了一下lalaport，&lt;br /&gt;
禮拜天中午跟朋友吃飯，才開始動工，&lt;br /&gt;
然後就是一整個踩坑記。&lt;/p&gt;
&lt;p&gt;禮拜天開始安裝，第一次搞steam一堆問題。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;h3 id=&quot;1&quot; tabindex=&quot;-1&quot;&gt;安裝時，一直卡在安裝剩餘1秒&lt;/h3&gt;
&lt;p&gt;我試了幾種方法，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;重開機（沒用），重開了五六次，還是卡住&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;看&lt;a href=&quot;https://www.reddit.com/r/SteamDeck/comments/t4x2q6/steamdeck_setup_stuck_at_1_second_remaining_for/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;redit&lt;/a&gt;說 不要連2.4g的wifi，重開機安裝，一樣卡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不斷關閉wifi後，重連我也試過，沒用(設定開關在右下方的那三個點）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最後改連手機的熱點分享，終於過了&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;外掛推薦(不裝也可以）&quot; tabindex=&quot;-1&quot;&gt;外掛推薦(不裝也可以）&lt;/h3&gt;
&lt;p&gt;目前看到的都是一些比較個人化的東西，&lt;/p&gt;
&lt;p&gt;也可能我遊戲玩不多，&lt;/p&gt;
&lt;p&gt;之前主要都在玩p4&lt;/p&gt;
&lt;p&gt;第一步先安裝 &lt;a href=&quot;https://github.com/SteamDeckHomebrew/decky-loader&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Decky loader&lt;/a&gt;，可以參考 版上的 &lt;a href=&quot;https://forum.gamer.com.tw/C.php?bsn=60599&amp;amp;snA=39936&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;這篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（桌面模式，按左下的steam按鈕-&amp;gt;電源-&amp;gt;切換至桌面）&lt;/p&gt;
&lt;p&gt;（沒外接鍵盤的話，需按下 steam按鈕+X ，開啓螢幕小鍵盤)&lt;/p&gt;
&lt;p&gt;前面的設定先改好，後面安裝不需要輸入指令，在&lt;a href=&quot;https://github.com/SteamDeckHomebrew/decky-loader&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;網站&lt;/a&gt;上點擊即可下載，&lt;/p&gt;
&lt;p&gt;然後對着下載下來的檔案，點兩下安裝，&lt;/p&gt;
&lt;p&gt;最後從桌面上的 圖示，回到掌機畫面。&lt;/p&gt;
&lt;p&gt;目前我裝的有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Bluetooth ： 據說是能讓藍牙耳機自動連線&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Animation Changer：關機(長按電源）、暫停（短按電源）的畫面修改&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ProtonDB Badges：判斷遊戲在裝置上的可玩性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SteamGridDB：修改掌機模式下遊戲的圖片，裝這個是掌機模式下的Chrome沒圖案真的太醜了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CSS-Loader：桌面佈景，可以到&lt;a href=&quot;https://deckthemes.com/themes?filters=&amp;amp;order=Most+Downloaded&amp;amp;type=CSS&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;官網&lt;/a&gt;看有哪些&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;animation-changer&quot; tabindex=&quot;-1&quot;&gt;Animation Changer ，影片放大&lt;/h4&gt;
&lt;p&gt;安裝CSS-Loader，然後搜尋  Full Suspend ，安裝完後即可。&lt;/p&gt;
&lt;h4 id=&quot;補丁安裝&quot; tabindex=&quot;-1&quot;&gt;補丁安裝&lt;/h4&gt;
&lt;p&gt;前面步驟，請看這一篇&lt;a href=&quot;https://forum.gamer.com.tw/C.php?bsn=60599&amp;amp;snA=40118&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;steam deck夏日狂想曲中文18+補丁&lt;/a&gt;，如果你bottle無法建立的話再回來。&lt;/p&gt;
&lt;p&gt;同事一直推坑我夏日狂想曲，然後bottle的bottles無法建立，一直卡在Arial font的字體安裝失敗，&lt;/p&gt;
&lt;p&gt;查&lt;a href=&quot;https://steamcommunity.com/sharedfiles/filedetails/?id=2802396237&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;原文&lt;/a&gt;有人推薦用Q4wine，就試試看了。&lt;/p&gt;
&lt;p&gt;但在flatsel需將Q4wine底下的Filesystem中的All system files打開，&lt;/p&gt;
&lt;p&gt;安裝時才能夠讀取到&lt;a href=&quot;https://forum.gamer.com.tw/C.php?bsn=60599&amp;amp;snA=40118&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;steam deck夏日狂想曲中文18+補丁&lt;/a&gt; 這邊說的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Z:&#92;home&#92;deck&#92;Summer Memories
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;額外補充&quot; tabindex=&quot;-1&quot;&gt;額外補充&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.protondb.com/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;protonDB&lt;/a&gt; ：查遊戲相容性的網站，不同獎牌代表的意思&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;白金：完美執行。&lt;br /&gt;
金：調整後完美執行。&lt;br /&gt;
銀：有小問題，但可玩。&lt;br /&gt;
銅：可玩，但經常遇到遊戲崩潰等問題。&lt;br /&gt;
無法執行：如題。&lt;/p&gt;
&lt;h4 id=&quot;oled&quot; tabindex=&quot;-1&quot;&gt;Oled燈號閃爍意思&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;狀態&lt;/th&gt;
&lt;th&gt;說明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;三閃紅燈&lt;/td&gt;
&lt;td&gt;電池電力不足無法開機&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;啟動中(綠燈)&lt;/td&gt;
&lt;td&gt;主機在PSU連接狀態且電池已經充滿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;啟動中(白燈)&lt;/td&gt;
&lt;td&gt;主機在PSU連接狀態且充電功率與PD協定有成功辨識並在電量達到觸發閾值後進入旁路充電&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;啟動中(橘燈)&lt;/td&gt;
&lt;td&gt;主機在PSU連接狀態且充電功率不足或PD協定無法辨識,簡單說就是以低功率充電&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;啟動中(紅燈)&lt;/td&gt;
&lt;td&gt;偵測到主機溫度高於95度C,無法開機&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;呼吸白燈&lt;/td&gt;
&lt;td&gt;主機開機中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;呼吸藍燈&lt;/td&gt;
&lt;td&gt;主機更新韌體或系統中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;無亮燈&lt;/td&gt;
&lt;td&gt;主機關機,且沒有偵測到PSU連接&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href=&quot;https://steamdb.info/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;steamdb&lt;/a&gt;：查遊戲特價歷史價格&lt;/p&gt;
&lt;h4 id=&quot;sudo&quot; tabindex=&quot;-1&quot;&gt;重置sudo 密碼&lt;/h4&gt;
&lt;p&gt;如果你忘記密碼（因爲我就忘了），&lt;/p&gt;
&lt;p&gt;只剩下重刷這一條路了。&lt;/p&gt;
&lt;p&gt;將steam deck關機，按住右下方的『...』與開機按鈕開機，&lt;/p&gt;
&lt;p&gt;然後清除資料吧。&lt;/p&gt;
&lt;h3 id=&quot;組合鍵&quot; tabindex=&quot;-1&quot;&gt;組合鍵&lt;/h3&gt;
&lt;p&gt;長按Steam按鈕，有快速鍵列表&lt;/p&gt;
&lt;p&gt;steam + R1 ： 截圖&lt;/p&gt;
&lt;p&gt;steam +X ： 開啓螢幕鍵盤&lt;/p&gt;
&lt;p&gt;『 ... 』+類比上下：調整螢幕亮度&lt;/p&gt;
&lt;p&gt;『 ... 』+電源： Recovery Manager&lt;/p&gt;
&lt;p&gt;音量『 - 』+電源 ：Boot Manager&lt;/p&gt;
&lt;p&gt;音量『 + 』+電源  ：BiOS&lt;/p&gt;
&lt;h3 id=&quot;配件&quot; tabindex=&quot;-1&quot;&gt;配件&lt;/h3&gt;
&lt;p&gt;未來應該再來下面幾個東西，再觀察看看需不需要了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tomtoc  Steam Deck硬殼收納包 ：看起來跟steam deck很合&lt;/li&gt;
&lt;li&gt;Innergie C6 Duo 63瓦 USB-C 雙孔：臺達的充電器，現在有一個單孔的，但有時要拔來拔去不方便。&lt;/li&gt;
&lt;li&gt;type c hub：感覺還是頗需要，如果要用桌面模式接鍵盤、滑鼠或外接螢幕的話，這個要再找找看了。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;目前應該就這樣，&lt;/p&gt;
&lt;p&gt;剩下的等有碰到再研究。&lt;/p&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://forum.gamer.com.tw/C.php?page=1&amp;amp;bsn=60599&amp;amp;snA=39919&amp;amp;tnum=460&amp;amp;bPage=2&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Steam Deck 大樓！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/SteamDeck/comments/yb96pf/suspend_animations_are_extremely_small_using_deck/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Suspend animations are extremely small using Deck Loader&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ptt.cc/bbs/Steam/M.1672478420.A.6FC.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[閒聊] SteamDeck兩周心得(配件、調校、套件)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/191. Steam deck安裝除錯記/" />
        </entry>
        <entry>
            <title>
                159. RBAC筆記
                
            </title>
            <updated>2025-07-08T10:28:05Z</updated>
            <id>https://daimom.github.io/159. RBAC筆記/</id>
            <content type="html">
                &lt;h1 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;RBAC這東西很久前就知道了，但一直沒實際去驗證過。&lt;br /&gt;
最近看istio ambient，看到他用L4的方式管理SA角色誰可以呼叫誰，&lt;br /&gt;
才又跑去認真看了一次。&lt;/p&gt;
&lt;h1 id=&quot;正文&quot; tabindex=&quot;-1&quot;&gt;正文&lt;/h1&gt;
&lt;p&gt;一個標準的Role通常長得像這樣&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: pod-reader
rules:
- apiGroups: [&amp;quot;&amp;quot;] # &amp;quot;&amp;quot; 標明 core API 組
  resources: [&amp;quot;volumesnapshots&amp;quot;]
  verbs: [&amp;quot;get&amp;quot;, &amp;quot;watch&amp;quot;, &amp;quot;list&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;rules 分成下面三個部分&lt;/p&gt;
&lt;p&gt;如果要最高權限的話就是用 &lt;code&gt;*&lt;/code&gt; 代替，&lt;br /&gt;
但切記勿亂用。&lt;/p&gt;
&lt;h3 id=&quot;api-groups&quot; tabindex=&quot;-1&quot;&gt;apiGroups&lt;/h3&gt;
&lt;p&gt;apiGroups每個資源名稱所代表的apiGroups都不一樣。&lt;br /&gt;
執行 &lt;code&gt;kubectl api-resources&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/159-fig.2.png&quot; alt=&quot;159-fig.2.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;觀察APIVERSION的欄位，&lt;br /&gt;
像 &lt;code&gt;bindings&lt;/code&gt;的APIVERSION 是 &lt;code&gt;v1&lt;/code&gt; 的話代表是核心，所以 &lt;code&gt;apiGroups: [&amp;quot;&amp;quot;]&lt;/code&gt;&lt;br /&gt;
而&lt;code&gt;allowlistedworkloads&lt;/code&gt;的APIVERSION是&lt;code&gt;auto.gke.io/v1&lt;/code&gt;，所以&lt;code&gt;apiGroups: [&amp;quot;auto.gke.io&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;p.s namespace代表這個resource是不是全域資源，需不需要指定namespace來使用&lt;/p&gt;
&lt;h3 id=&quot;resources&quot; tabindex=&quot;-1&quot;&gt;resources&lt;/h3&gt;
&lt;p&gt;上面有提到每個resource有指定的APIGroups，&lt;br /&gt;
這邊就比較簡單，只要將上面指令查到的NAME拿來用就好。&lt;br /&gt;
注意，不是後面的kind。&lt;/p&gt;
&lt;h3 id=&quot;verb&quot; tabindex=&quot;-1&quot;&gt;verb&lt;/h3&gt;
&lt;p&gt;查詢所有的resouce&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;kubectl api-resources --sort-by name -o wide
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在你要選擇的資源內，用&lt;code&gt;[ ]&lt;/code&gt; 包起來的表示為此resouce的可以接受哪些動作。&lt;br /&gt;
&lt;img src=&quot;https://daimom.github.io/img/user/159-fig.0.jpg&quot; alt=&quot;159-fig.0.jpg&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在K8s裏面透過RBAC管理這個角色可以對這個resouce做什麼，&lt;br /&gt;
對照表，參考&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;動作&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;verb&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;說明&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;讀取&lt;/td&gt;
&lt;td&gt;&lt;code&gt;get&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;取得單一資源的詳細資訊&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;讀取&lt;/td&gt;
&lt;td&gt;&lt;code&gt;list&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;列出資源清單&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;讀取&lt;/td&gt;
&lt;td&gt;&lt;code&gt;watch&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;持續監聽資源變化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;寫入&lt;/td&gt;
&lt;td&gt;&lt;code&gt;create&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;創建新資源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;修改&lt;/td&gt;
&lt;td&gt;&lt;code&gt;update&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;修改現有資源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;修改&lt;/td&gt;
&lt;td&gt;&lt;code&gt;patch&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;局部修改 (使用 &lt;code&gt;kubectl patch&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;刪除&lt;/td&gt;
&lt;td&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;刪除資源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;刪除&lt;/td&gt;
&lt;td&gt;&lt;code&gt;deletecollection&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;批量刪除資源&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;put 與 patch的差別在於，如果只有單一個資料要更新的話，使用patch ，所有資料都要更新的話用put&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ChatGPT&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;統整&quot; tabindex=&quot;-1&quot;&gt;統整&lt;/h3&gt;
&lt;p&gt;設定的流程，會先指定role 可以對哪些資源做些什麼操作。&lt;br /&gt;
然後使用rolebinding，來指定這個role與user/group&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://daimom.github.io/img/user/159-fig.1.png&quot; alt=&quot;159-fig.1.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;設定完使用者後，要綁到deploy上面 ，&lt;br /&gt;
要在template.spec底下寫 serviceAccountName&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;template:
  metadata:
    labels:
      app: filebeat
  spec:
    serviceAccountName: filebeat
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pod有使用這個sa的話，那token會在下面的這個位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/var/run/secrets/kubernetes.io/serviceaccount/token
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ref.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://godleon.github.io/blog/Kubernetes/k8s-How-to-access-resource-legally/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;[Kubernetes] 如何取得合法可用的權限，讓 pod 與 API server 溝通&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[ &lt;a href=&quot;https://www.cnblogs.com/fanfanfanlichun/p/15005427.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;一文讀懂k8s rbac 權限驗證&lt;/a&gt;]&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://daimom.github.io/159. RBAC筆記/" />
        </entry>
</feed>
